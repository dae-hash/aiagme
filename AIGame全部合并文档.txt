# Node - 节点信息

- 更新时间:2025-12-13 11:58:42

> 节点信息
> 
> 该节点信息由本应用进行封装，提供了大量便捷的操作，例如可以直接绘制出节点在屏幕上的位置、可以直接调用点击、滑动、输入文字等操作。



```javascript
//首先创建节点选择器
let selector = $act.selector();
//接下来可以通过selector进行界面ui的选择，不过要先进行条件筛选和过滤，因此可以先调用一些筛选类的方法：
selector = selector
.text("登录") //筛选控件文本必须是"登录"的节点
.cls("android.widget.Button");//筛选控件类必须是"android.widget.Button"的节点
//接下来可以调用一些选择类的方法选择节点
let node = selector.waitLast();//在筛选完毕的列表中选择最后一个节点
//接下来就可以使用{Node}中封装的函数了，例如绘制出节点在屏幕的位置：
if(node!=null){
    node.draw();
}
```




### const {Integer} x;

> x坐标


### const {Integer} y;

> y坐标


### const {Integer} w;

> 宽度


### const {Integer} h;

> 高度


### const {Integer} cx;

> 中心点x坐标


### const {Integer} cy;

> 中心点y坐标


### const {Boolean} clickable;

> 是否可点击


### const {Boolean} longClickable;

> 是否可长按


### const {Boolean} enabled;

> 是否可用


### const {Boolean} selected;

> 是否选中


### const {Boolean} scrollable;

> 是否可滚动


### const {Boolean} checkable;

> 是否可勾选


### const {Boolean} checked;

> 是否勾选


### const {Boolean} visible;

> 是否可见


### const {int[]} region;

> 区域
> 格式为[left, top, width, height]


### const {Boolean} multiLine;

> 是否多行


### const {Integer} drawOrder;

> 绘制顺序


### const {String} desc;

> 描述信息


### const {String} tip;

> 提示信息
> 仅Android 9.0+支持


### const {String} id;

> 资源id


### const {String} pkg;

> 包名


### const {String} cls;

> 类名


### const {String} text;

> 文本


### const {Integer} windowId;

> 窗口id


### const {AccessibilityNodeInfo} node;

> 安卓原生节点信息
> 
> 类名：android.view.accessibility.AccessibilityNodeInfo


### parent()

> 获取父节点

- 返回 : {Node} 父节点
- 版本 : 1.3.6


### childNum()

> 获取子节点数

- 返回 : {int} 子节点数量
- 版本 : 1.4.3


### childs()

> 获取所有子节点

- 返回 : {Node[]} 子节点列表
- 版本 : 1.4.3


### child(index)

> 获取子节点

- 参数 : index {int} 下标
- 返回 : {Node} 子节点
- 版本 : 1.4.3


### getX()

> 获取x坐标

- 返回 : {int} x坐标
- 版本 : 1.3.6


### getY()

> 获取y坐标

- 返回 : {int} y坐标
- 版本 : 1.3.6


### getW()

> 获取宽度

- 返回 : {int} 宽度
- 版本 : 1.3.6


### getH()

> 获取高度

- 返回 : {int} 高度
- 版本 : 1.3.6


### getCx()

> 获取中心点x坐标

- 返回 : {int} 中心点x坐标
- 版本 : 1.3.6


### getCy()

> 获取中心点y坐标

- 返回 : {int} 中心点y坐标
- 版本 : 1.3.6


### getClickable()

> 获取是否可点击

- 返回 : {boolean} 是否可点击
- 版本 : 1.3.6


### getLongClickable()

> 获取是否可长按

- 返回 : {boolean} 是否可长按
- 版本 : 1.3.6


### getEnabled()

> 获取是否可用

- 返回 : {boolean} 是否可用
- 版本 : 1.3.6


### getSelected()

> 获取是否选中

- 返回 : {boolean} 是否选中
- 版本 : 1.3.6


### getScrollable()

> 获取是否可滚动

- 返回 : {boolean} 是否可滚动
- 版本 : 1.3.6


### getCheckable()

> 获取是否可勾选

- 返回 : {boolean} 是否可勾选
- 版本 : 1.3.6


### getChecked()

> 获取是否勾选

- 返回 : {boolean} 是否勾选
- 版本 : 1.3.6


### getRegion()

> 获取区域

- 返回 : {int[]} 区域
- 版本 : 1.3.6


### getMultiLine()

> 获取是否多行

- 返回 : {boolean} 是否多行
- 版本 : 1.3.6


### getDrawOrder()

> 获取绘制顺序

- 返回 : {int} 绘制顺序
- 版本 : 1.3.6


### getTip()

> 获取提示信息

- 返回 : {String} 提示信息
- 版本 : 1.3.6


### getDesc()

> 获取描述信息

- 返回 : {String} 描述信息
- 版本 : 1.3.6


### getId()

> 获取资源id

- 返回 : {String} 资源id
- 版本 : 1.3.6


### getPkg()

> 获取包名

- 返回 : {String} 包名
- 版本 : 1.3.6


### getCls()

> 获取类名

- 返回 : {String} 类名
- 版本 : 1.3.6


### getText()

> 获取文本

- 返回 : {String} 文本
- 版本 : 1.3.6


### getWindowId()

> 获取窗口id

- 返回 : {int} 窗口id
- 版本 : 1.3.6


### getNode()

> 获取安卓原生节点信息
> 
> 获取安卓原本的对象{AccessibilityNodeInfo}之后就可以调用它本身就具有的API了

- 返回 : {AccessibilityNodeInfo} 安卓原生节点信息
- 版本 : 1.3.6


```javascript
//获得安卓原生类
let andNodeInfo = node.getNode();
//调用安卓API:获取子节点个数
let count = andNodeInfo.getChildCount();//参考{AccessibilityNodeInfo}类中的方法
alert("子节点个数",""+count);
```


### click()

> 点击
> 
> 默认不使用坐标手势:click(false)，而是使用节点手势执行点击动作。

- 版本 : 1.3.6


### click(useAct)

> 点击
> 
> 节点执行的手势有时候没有效果，此时可以使用坐标来进行点击:click(true);

- 参数 : useAct {boolean} 是否使用act点击
- 版本 : 1.3.6


### click(px, py)

> 点击
> 
> 偏移点击，会相对于当前节点的坐标进行偏移x或y的距离，可传入正负数。

- 参数 : px {int} x的偏移量
- 参数 : py {int} y的偏移量
- 版本 : 1.3.6


### press()

> 长按
> 
> 默认不使用坐标手势:press(false)，而是使用节点手势执行长按动作。

- 版本 : 1.3.6


### press(dur)

> 长按

- 参数 : dur {int} 长按时间
- 版本 : 1.3.6


### press(px, py)

> 长按

- 参数 : px {int} x的偏移量
- 参数 : py {int} y的偏移量
- 版本 : 1.3.6


### press(px, py, dur)

> 长按

- 参数 : px {int} x的偏移量
- 参数 : py {int} y的偏移量
- 参数 : dur {int} 长按时间
- 版本 : 1.3.6


### press(useAct)

> 长按
> 
> 节点执行的手势有时候没有效果，此时可以使用坐标来进行长按:press(true);

- 参数 : useAct {boolean} 是否使用坐标长按
- 版本 : 1.3.6


### move(dir)

> 滑动

- 参数 : dir {string} 方向:up,down,left,right
- 版本 : 1.3.6


### move(x2, y2, dur)

> 滑动

- 参数 : x2 {int} 目标x坐标
- 参数 : y2 {int} 目标y坐标
- 参数 : dur {int} 滑动时间
- 版本 : 1.3.6


### move(x2, y2, dur, delay)

> 滑动

- 参数 : x2 {int} 目标x坐标
- 参数 : y2 {int} 目标y坐标
- 参数 : dur {int} 滑动时间
- 参数 : delay {int} 滑动延迟
- 版本 : 1.3.6


### move(px, py, x2, y2, dur, delay)

> 滑动

- 参数 : px {int} x的偏移量
- 参数 : py {int} y的偏移量
- 参数 : x2 {int} 目标x坐标
- 参数 : y2 {int} 目标y坐标
- 参数 : dur {int} 滑动时间
- 参数 : delay {int} 滑动延迟
- 版本 : 1.3.6


### draw()

> 全屏绘制节点方框
> 
> 需要悬浮窗权限

- 版本 : 1.3.6


### input(text)

> 输入内容
> 
> 对于使用网页开发的输入框，需要指定本应用的输入法才可以输入文字，此函数可以判断输入法是否可用，如果可用就优先使用输入法输入，否则就用无障碍输入。

- 版本 : 1.3.6


### input(text, useAcc)

> 输入内容
> 
> 对于使用网页开发的输入框，需要指定本应用的输入法才可以输入文字

- 参数 : text {boolean} 是否只用无障碍输入，为true时，只会使用无障碍输入，如果为false则会判断输入法是否可用,可用就用输入法输入，否则就用无障碍输入
- 版本 : 1.3.6


### findFirst(selector)

> 查找子孙节点

- 参数 : selector {uiSelector} 筛选器 
- 返回 : {node} 符合条件的节点


```javascript
let node = $act.selector() //创建选择器
.pkg("com.taobao.idlefish") //为选择器添加过滤条件
.cls("android.view.View") //为选择器添加过滤条件
.desc("看对眼就留言，问问更多细节~") //为选择器添加过滤条件
.waitFirst(); //通过过滤条件找到符合要求的节点
if (node != null) {
    //如果想要查找node的子孙节点，也可以通过选择器来查找
    let mSelector = $act.selector() //创建选择器
    .pkg("com.taobao.idlefish") //为选择器添加过滤条件
    .cls("android.view.Button"); //为选择器添加过滤条件
    //然后把选择器传入进去即可过滤找到node的子孙节点
    let childNode = node.findFirst(mSelector);
    if(childNode!=null){
        log("找到子孙节点了");
        childNode.draw();//绘制位置
    }
}
```


### findLast(selector)

> 查找子孙节点

- 参数 : selector {uiSelector} 筛选器 
- 返回 : {node} 符合条件的节点


### find(selector, index)

> 查找子孙节点
> 
> 指定过滤器以及子孙节点的下标，当下标超过列表范围的时候，会返回列表最后一个node节点

- 参数 : selector {uiSelector} 筛选器 
- 参数 : index {num} 下标
- 返回 : {node} 符合条件的节点


### findAll(selector)

> 查找子孙节点

- 参数 : selector {uiSelector} 筛选器 
- 返回 : {node[]} 符合条件的节点列表


# UiSelector - UI选择器

- 更新时间:2025-12-13 11:58:43

> UI选择器
> 
> 界面的元素有很多，但不一定都是我们要找的那个节点，因此我们需要一些筛选条件过滤掉这些节点。
> 
> UI选择器主要用来过滤界面元素，并且选中我们想要的元素。所以在使用的时候我们需要两类方法：(1).筛选元素;(2).选中元素;



```javascript
//(1)筛选元素
let selector = $act.selector() // 创建UI选择器
     .text("登录") //筛选文本是"登录"的元素
     .cls("android.widget.Button") //筛选类名为"android.widget.Button"的元素
     .pkg("org.aigame.pro") //筛选包名为"org.aigame.pro"的元素
     .desc("点击登录"); //筛选描述是"点击登录"的元素
//(2)选中节点
let node = selector.findFirst(); // 查找一个节点
//其实上面的代码可以直接写成：
let node = $act.selector()
     .text("登录") //筛选文本是"登录"的元素
     .cls("android.widget.Button") //筛选类名为"android.widget.Button"的元素
     .pkg("org.aigame.pro") //筛选包名为"org.aigame.pro"的元素
     .desc("点击登录") //筛选描述是"点击登录"的元素
     .findFirst(); // 查找一个节点
```




### screen(transCut, vertCut, index)

> 屏幕区域
> 
> 按照屏幕进行切割,在切割的范围中查找元素

- 参数 : transCut {int} 横向切割数
- 参数 : vertCut {int} 纵向切割数
- 参数 : index {int} 第几个区域
- 返回 : {UiSelector} 节点选择器
- 版本 : 1.0.0


```javascript
//你可以提前使用下面的方式找到自己想要的范围(查看$screen的文档)
$draw.closeAll();
//将屏幕分割成9份，找到最后一份的范围
let region = $screen.split(3, 3, 8);
//绘制出这个范围
$draw.rect(region);
//用上面这种方式可以快速的定位一个自己想要的范围，而且如果需要找的控件就在范围内，基本上就是全分辨率的。
//如果位置不合适，再调整参数，尽量提高容错，保证自己的脚本支持全分辨率。
//如果位置合适，再把这三个参数传入进来
let nodes = $act.selector()
.screen(3, 3, 8) //我们想要的三个参数
.findAll();
```


### clickable(able)

> 可点击的

- 参数 : able {boolean} 是否可点击
- 返回 : {UiSelector} 节点选择器
- 版本 : 1.0.0


### visible(able)

> 是否可见

- 参数 : able {boolean} 是否可见
- 返回 : {UiSelector} 节点选择器
- 版本 : 1.6.1


### longClickable(able)

> 可长按的

- 参数 : able {boolean} 是否可长按
- 返回 : {UiSelector} 节点选择器
- 版本 : 1.0.0


### enabled(able)

> 可用的

- 参数 : able {boolean} 是否可用
- 返回 : {UiSelector} 节点选择器
- 版本 : 1.0.0


### selected(able)

> 选中的

- 参数 : able {boolean} 是否选中
- 返回 : {UiSelector} 节点选择器
- 版本 : 1.0.0


### scrollable(able)

> 可滚动的

- 参数 : able {boolean} 是否可滚动
- 返回 : {UiSelector} 节点选择器
- 版本 : 1.0.0


### checkable(able)

> 可勾选的

- 参数 : able {boolean} 是否可勾选
- 返回 : {UiSelector} 节点选择器
- 版本 : 1.0.0


### checked(able)

> 勾选的

- 参数 : able {boolean} 是否勾选
- 返回 : {UiSelector} 节点选择器
- 版本 : 1.0.0


### region(x, y, w, h)

> 范围

- 参数 : x {int} x坐标
- 参数 : y {int} y坐标
- 参数 : w {int} 宽度
- 参数 : h {int} 高度
- 返回 : {UiSelector} 节点选择器
- 版本 : 1.0.0


### regionHas(x, y, w, h)

> 输入的范围包含了控件范围

- 参数 : x {int} x坐标
- 参数 : y {int} y坐标
- 参数 : w {int} 宽度
- 参数 : h {int} 高度
- 返回 : {UiSelector} 节点选择器
- 版本 : 1.0.0


### regionInside(x, y, w, h)

> 输入的范围在控件范围的里面

- 参数 : x {int} x坐标
- 参数 : y {int} y坐标
- 参数 : w {int} 宽度
- 参数 : h {int} 高度
- 返回 : {UiSelector} 节点选择器
- 版本 : 1.0.0


### multiLine(able)

> 多行的

- 参数 : able {boolean} 是否多行
- 返回 : {UiSelector} 节点选择器
- 版本 : 1.0.0


### drawOrder(order)

> 绘制顺序

- 参数 : order {int} 绘制顺序
- 返回 : {UiSelector} 节点选择器
- 版本 : 1.0.0


### desc(desc)

> 描述

- 参数 : desc {String} 描述
- 返回 : {UiSelector} 节点选择器
- 版本 : 1.0.0


### descNotNull(notNull)

> 描述不能为空
> 
> 如规定描述不能为空，当遇到描述为空的节点时会自动过滤这个节点

- 参数 : notNull {boolean} 是否不能为空
- 返回 : {UiSelector} 节点选择器
- 版本 : 1.7.6


### descHas(desc)

> 描述包含

- 参数 : desc {String} 描述
- 返回 : {UiSelector} 节点选择器
- 版本 : 1.0.0


### descStart(desc)

> 描述开头

- 参数 : desc {String} 描述
- 返回 : {UiSelector} 节点选择器
- 版本 : 1.0.0


### descEnd(desc)

> 描述结尾

- 参数 : desc {String} 描述
- 返回 : {UiSelector} 节点选择器
- 版本 : 1.0.0


### descMatch(regex)

> 描述匹配正则表达式

- 参数 : regex {String} 正则表达式
- 返回 : {UiSelector} 节点选择器
- 版本 : 1.6.8


### windowId(id)

> 窗口id

- 参数 : id {String} id
- 返回 : {UiSelector} 节点选择器
- 版本 : 1.0.0


### id(id)

> 资源id

- 参数 : id {String} id
- 返回 : {UiSelector} 节点选择器
- 版本 : 1.0.0


### idNotNull(notNull)

> 资源id不能为空
> 
> 如规定资源id不能为空，当遇到id为空的节点时会自动过滤这个节点

- 参数 : notNull {boolean} 是否不能为空
- 返回 : {UiSelector} 节点选择器
- 版本 : 1.7.6


### idHas(id)

> 资源id包含

- 参数 : id {String} id
- 返回 : {UiSelector} 节点选择器
- 版本 : 1.0.0


### idStart(id)

> 资源id开头

- 参数 : id {String} id
- 返回 : {UiSelector} 节点选择器
- 版本 : 1.0.0


### idEnd(id)

> 资源id结尾

- 参数 : id {String} id
- 返回 : {UiSelector} 节点选择器
- 版本 : 1.0.0


### idMatch(regex)

> 资源id匹配正则表达式

- 参数 : regex {String} 正则表达式
- 返回 : {UiSelector} 节点选择器
- 版本 : 1.6.8


### tip(tip)

> 提示信息

- 参数 : tip {String} tip
- 返回 : {UiSelector} 节点选择器
- 版本 : 1.0.0


### tipNotNull(notNull)

> 提示信息不能为空
> 
> 如规定提示信息不能为空，当遇到提示信息为空的节点时会自动过滤这个节点

- 参数 : notNull {boolean} 是否不能为空
- 返回 : {UiSelector} 节点选择器
- 版本 : 1.7.6


### tipHas(tip)

> 提示信息包含

- 参数 : tip {String} tip
- 返回 : {UiSelector} 节点选择器
- 版本 : 1.0.0


### tipStart(tip)

> 提示信息开头

- 参数 : tip {String} tip
- 返回 : {UiSelector} 节点选择器
- 版本 : 1.0.0


### tipEnd(tip)

> 提示信息结尾

- 参数 : tip {String} tip
- 返回 : {UiSelector} 节点选择器
- 版本 : 1.0.0


### tipMatch(regex)

> 提示信息匹配正则表达式

- 参数 : regex {String} 正则表达式
- 返回 : {UiSelector} 节点选择器
- 版本 : 1.6.8


### pkg(packageName)

> 包名

- 参数 : packageName {String} 包名
- 返回 : {UiSelector} 节点选择器
- 版本 : 1.0.0


### pkgNotNull(notNull)

> 包名不能为空
> 
> 如规定包名不能为空，当遇到提包名为空的节点时会自动过滤这个节点

- 参数 : notNull {boolean} 是否不能为空
- 返回 : {UiSelector} 节点选择器
- 版本 : 1.7.6


### pkgHas(packageName)

> 包名包含

- 参数 : packageName {String} 包名
- 返回 : {UiSelector} 节点选择器
- 版本 : 1.0.0


### pkgStart(packageName)

> 包名开头

- 参数 : packageName {String} 包名
- 返回 : {UiSelector} 节点选择器
- 版本 : 1.0.0


### pkgEnd(packageName)

> 包名结尾

- 参数 : packageName {String} 包名
- 返回 : {UiSelector} 节点选择器
- 版本 : 1.0.0


### pkgMatch(regex)

> 包名匹配正则

- 参数 : regex {String} 正则表达式
- 返回 : {UiSelector} 节点选择器
- 版本 : 1.6.8


### cls(className)

> 类名

- 参数 : className {String} 类名
- 返回 : {UiSelector} 节点选择器
- 版本 : 1.0.0


### clsNotNull(notNull)

> 类名不能为空
> 
> 如规定类名不能为空，当遇到提类名为空的节点时会自动过滤这个节点

- 参数 : notNull {boolean} 是否不能为空
- 返回 : {UiSelector} 节点选择器
- 版本 : 1.7.6


### clsHas(className)

> 类名包含

- 参数 : className {String} 类名
- 返回 : {UiSelector} 节点选择器
- 版本 : 1.0.0


### clsStart(className)

> 类名开头

- 参数 : className {String} 类名
- 返回 : {UiSelector} 节点选择器
- 版本 : 1.0.0


### clsEnd(className)

> 类名结尾

- 参数 : className {String} 类名
- 返回 : {UiSelector} 节点选择器
- 版本 : 1.0.0


### clsMatch(regex)

> 类名匹配正则表达式

- 参数 : regex {String} 正则表达式
- 返回 : {UiSelector} 节点选择器
- 版本 : 1.6.8


### text(text)

> 文本

- 参数 : text {String} 文本
- 返回 : {UiSelector} 节点选择器
- 版本 : 1.0.0


### textNotNull(notNull)

> 文本不能为空
> 
> 如规定文本不能为空，当遇到文本为空的节点时会自动过滤这个节点

- 参数 : notNull {boolean} 是否不能为空
- 返回 : {UiSelector} 节点选择器
- 版本 : 1.7.6


### textHas(text)

> 文本包含

- 参数 : text {String} 文本
- 返回 : {UiSelector} 节点选择器
- 版本 : 1.0.0


### textStart(text)

> 文本开头

- 参数 : text {String} 文本
- 返回 : {UiSelector} 节点选择器
- 版本 : 1.0.0


### textEnd(text)

> 文本结尾

- 参数 : text {String} 文本
- 返回 : {UiSelector} 节点选择器
- 版本 : 1.0.0


### textMatch(regex)

> 文本匹配正则

- 参数 : regex {String} 正则表达式
- 返回 : {UiSelector} 节点选择器
- 版本 : 1.6.8


### or()

> 构建或者过滤器
> 
> 创建新的过滤器，并且与之前的过滤器处于或者的关系，当选择当前界面元素的时候，如果存在多个过滤器，只要有一个过滤器满足条件，即可返回结果节点。

- 返回 : {UiSelector} 节点选择器
- 版本 : 1.7.8


```javascript
//这里我封装好了一个强制停止应用的示例
let killApp = function (APP) {
    //先打开指定app的设置界面
    $app.openAppSetting(APP);
    sleep(1000);
    //找到强制停止的按钮
    let node = $act.selector()
        //这里相当于构建了第1个过滤器
        .cls("android.widget.Button")
        .textMatch("强行停止|结束运行|停止|结束")
        .or() //调用 or 函数的时候，可以继续构建下一个过滤器
        //这里相当于构建了第2个过滤器
        .cls("android.widget.TextView")
        .textMatch("强行停止|结束运行|停止|结束")
        //其实你还可以继续用 or 构建更多的情况
        .waitFirst();
    if (node != null) {
        // 绘制节点位置
        node.draw();
        //点击这个节点
        node.click();
        //找到确定按钮
        let node_ensure = $act.selector()
            .cls("android.widget.Button")
            .text("确定")
            .waitFirst();
        if (node_ensure != null) {
            // 绘制节点位置
            node_ensure.draw();
            // 点击
            node_ensure.click();
            //关闭所有悬浮窗
            $draw.closeAll();
            //回到主程序
            $app.openSelf();
        }
    }
}
//先打开这个软件，让它存在运行的状态才能够出现强制停止
$app.run("抖音");
sleep(5000);
// 强制停止app
killApp("抖音");
```


### findAll()

> 查找全部

- 返回 : {Node[]} 找到的集合
- 版本 : 1.0.0


### find(index)

> 查找指定

- 参数 : index {int} 第几个，如果index在集合的范围内，就返回index对应的控件，否则返回第一个
- 返回 : {Node} 找到的控件
- 版本 : 1.0.0


### findFirst()

> 查找第一个

- 返回 : {Node} 找到的控件
- 版本 : 1.0.0


### findLast()

> 查找最后一个

- 返回 : {Node} 找到的控件
- 版本 : 1.0.0


### waitAll()

> 等待出现任意一个

- 返回 : {Node[]} 找到的控件集合
- 版本 : 1.0.0


### waitAll(failCallback)

> 等待出现任意一个
> 
> 会按照默认的等待次数来等待控件出现，当然你可以通过setWaitDur()和setWaitTime()来配置这些参数

- 返回 : {Node[]} 找到的控件列表
- 版本 : 1.0.0


```javascript
let nodes = $act.selector().text("登录").waitAll();
```


### wait(index, failCallback)

> 等待出现

- 参数 : index {int} 第几个，如果index在集合的范围内，就返回index对应的控件，否则返回第一个
- 参数 : failCallback {()=>{}} 失败回调:连一个控件也没有找到时会回调
- 返回 : {Node} 找到的控件
- 版本 : 1.0.0


### wait(index)

> 等待出现

- 参数 : index {int} 第几个，如果index在集合的范围内，就返回index对应的控件，否则返回第一个
- 返回 : {Node} 找到的控件
- 版本 : 1.0.0


### waitFirst()

> 等待出现第一个

- 返回 : {Node} 找到的控件
- 版本 : 1.0.0


### waitFirst(failCallback)

> 等待出现第一个

- 参数 : failCallback {()=>{}} 失败回调:连一个控件也没有找到时会回调
- 返回 : {Node} 找到的控件
- 版本 : 1.0.0


### waitLast()

> 等待出现最后一个

- 返回 : {Node} 找到的控件
- 版本 : 1.0.0


### waitLast(failCallback)

> 等待出现最后一个

- 参数 : failCallback {()=>{}} 失败回调:连一个控件也没有找到时会回调
- 返回 : {Node} 找到的控件
- 版本 : 1.0.0


### setWaitTime(times)

> 设置等待次数

- 参数 : times {int} 等待次数(默认:120)
- 版本 : 1.0.0


### setWaitDur(times)

> 设置等待延迟
> 
> 每次等待中会有一定的间隔

- 参数 : times {int} 等待延迟(默认:500[毫秒])
- 版本 : 1.0.0


### setMainWindow(yes)

> 设置是否只搜索主窗口
> 
> 默认情况下搜索所有的窗口，不过有时候应对一些复杂的UI可能会出现窗口过多(导致元素过多)导致栈溢出的异常，
> 部分app的创建界面如果构建的很复杂，也会导致节点元素不能被及时找出来，因此这个函数就是设置当前选择器只在主窗口中查找元素。
> 
> 举个比较奇葩的例子：有些软件只有当分析主窗口的时候才能找到节点，但是如果分析全部窗口反而找不到节点了，非常奇葩。

- 参数 : yes {boolean} true:只搜索主窗口，false:搜索所有窗口
- 返回 : 1.7.8


# $act - 手势动作

- 更新时间:2025-12-13 11:58:43

> 手势动作
> 
> $act是一个高度封装的框架，其中集成了无障碍、$root、$szk触摸方案，优先级为：$root>$szk>无障碍
> 
> $act中所有click、press、move函数都会优先判断是否有ROOT权限，如果有，则使用$root进行点击；之后判断是否有Shizuku权限，如果有，则使用$szk进行手势操作；之后判断是否有无障碍权限，如果有，则使用无障碍执行。




### hasPermit()

> 无障碍服务是否开启
> 
> 判断无障碍服务是否开启，如果开启了则返回true，否则返回false。

- 返回 : {boolean} 是否开启
- 版本 : 1.0.0


```javascript
//判断是否有权限
let hasPermit = $act.hasPermit();
$tip.show("是否获得无障碍",hasPermit);
```


### getPermit()

> 获得无障碍服务
> 
> 如果有Root权限:则使用Root权限为本应用授权永久无障碍
> 
> 如果有Shizuku权限:则使用Shizuku权限为本应用授权永久无障碍
> 
> 如果没有Root和Shizuku:则进行普通权限申请(非永久有效,受系统限制)
> 
> 该函数是一个阻塞式函数，请勿放在ui线程当中操作，如果你想在ui状态下申请无障碍，建议使用$permit.wza()函数。
> 
> 注意：永久无障碍其实是每次启动软件时，会自动自我授权无障碍，它不会立即获得无障碍权限，一般需要等待1-5秒的时间，不过这些操作都会在应用后台进行操作，因此用户并不会感知到这一操作，只会莫名其妙的觉得自己开启的无障碍权限从未关闭过一样。
> 在授权无障碍期间，你最好还是使用 $act.hasPermit() 判断无障碍权限是否可用。

- 返回 : {boolean} 是否获得
- 版本 : 1.0.0


```javascript
$act.getPermit();//获得权限
```


### click(x, y)

> 点击
> 
> 如果Root可用，优先使用Root执行手势；
> 如果Shizuku可用，优先使用Shizuku执行手势；
> 如果无障碍可用，使用无障碍执行手势；
> 如果以上都不可用，将无任何效果；

- 参数 : x {int} 点击位置x 
- 参数 : y {int} 点击位置y 
- 版本 : 1.0.0


```javascript
//点击手势
$act.click(500,800);
```


### click(x, y, dur)

> 点击
> 
> 如果Root可用，优先使用Root执行手势
> 如果Shizuku可用，优先使用Shizuku执行手势
> 如果无障碍可用，使用无障碍执行手势
> 如果以上都不可用，将无任何效果

- 参数 : x {int} 点击位置x 
- 参数 : y {int} 点击位置y 
- 参数 : dur {int} 点击后延迟 
- 版本 : 1.0.0


```javascript
//设置点击时常(长按效果)
sleep(1000);
$act.click(135,344,1500);
```


### click(x, y, dur, delay)

> 点击
> 
> 如果Root可用，优先使用Root执行手势
> 如果Shizuku可用，优先使用Shizuku执行手势
> 如果无障碍可用，使用无障碍执行手势
> 如果以上都不可用，将无任何效果

- 参数 : x {int} 点击位置x 
- 参数 : y {int} 点击位置y 
- 参数 : dur {int} 点击后延迟 
- 参数 : delay {int} 点击前延迟 
- 版本 : 1.0.0


```javascript
//点击手势(长按)(延迟一秒)
$act.click(500,800,1500,100);
```


### click(index)

> 点击
> 
> 如果Root可用，优先使用Root执行手势
> 如果Shizuku可用，优先使用Shizuku执行手势
> 如果无障碍可用，使用无障碍执行手势
> 如果以上都不可用，将无任何效果

- 参数 : index {int[]} 点击位置 
- 版本 : 1.0.0


```javascript
//点击
$act.click([500,800]);
```


### click(index, dur)

> 点击
> 
> 如果Root可用，优先使用Root执行手势
> 如果Shizuku可用，优先使用Shizuku执行手势
> 如果无障碍可用，使用无障碍执行手势
> 如果以上都不可用，将无任何效果

- 参数 : index {int[]} 点击位置  
- 参数 : dur {int} 点击后延迟 
- 版本 : 1.0.0


```javascript
//点击手势(长按)
$act.click([135,347],1500);
```


### click(index, dur, delay)

> 点击
> 
> 如果Root可用，优先使用Root执行手势
> 如果Shizuku可用，优先使用Shizuku执行手势
> 如果无障碍可用，使用无障碍执行手势
> 如果以上都不可用，将无任何效果

- 参数 : index {int[]} 点击位置 
- 参数 : dur {int} 点击后延迟 
- 参数 : delay {int} 点击前延迟 
- 版本 : 1.0.0


```javascript
//点击手势(长按)(延迟一秒)
$act.click([136,347],1500,100);
```


### click(index)

> 点击
> 
> 如果Root可用，优先使用Root执行手势
> 如果Shizuku可用，优先使用Shizuku执行手势
> 如果无障碍可用，使用无障碍执行手势
> 如果以上都不可用，将无任何效果

- 参数 : index {Point} 点击位置
- 版本 : 1.0.0


```javascript
//点击手势(点击opencv返参)
let point = new org.opencv.core.Point(136,347);
$act.click(point);
```


### click(index, dur)

> 点击
> 
> 如果Root可用，优先使用Root执行手势
> 如果Shizuku可用，优先使用Shizuku执行手势
> 如果无障碍可用，使用无障碍执行手势
> 如果以上都不可用，将无任何效果

- 参数 : index {Point} 点击位置
- 参数 : dur {int} 点击后延迟  
- 版本 : 1.0.0


```javascript
//点击手势(长按)(延迟一秒)
let point = new org.opencv.core.Point(136,347);
$act.click(point,1500);
```


### click(index, dur, delay)

> 点击
> 
> 如果Root可用，优先使用Root执行手势
> 如果Shizuku可用，优先使用Shizuku执行手势
> 如果无障碍可用，使用无障碍执行手势
> 如果以上都不可用，将无任何效果

- 参数 : index {Point} 点击位置
- 参数 : dur {int} 点击后延迟 
- 参数 : delay {int} 点击前延迟 
- 版本 : 1.0.0


```javascript
//点击手势(长按)(延迟一秒)
let point = new org.opencv.core.Point(136,347);
$act.click(point,1500,100);
```


### click(node)

> 点击节点
> 
> 如果节点支持点击，就是用节点本身的点击行为进行点击，如果不支持，则通过$act的坐标方式来点击节点的坐标位置。

- 参数 : node {Node} 点击位置  
- 版本 : 1.0.0


```javascript
//如果你通过选择器找到了节点，也可以通过这种方式来点击节点
let node = $act.selector()
.pkg("org.aigame.pro")
.cls("android.widget.FrameLayout")
.waitFirst();
if(node!=null){
     // 绘制节点位置
     node.draw();
     // 可以这样点击
     node.click();
     // 也可以这样点击
     $act.click(node);
}
```


### click(node, useAct)

> 点击节点
> 
> 如果节点支持点击，就是用节点本身的点击行为进行点击，如果不支持，则通过$act的坐标方式来点击节点的坐标位置。

- 参数 : node {Node} 点击位置 
- 参数 : useAct {boolean} 是否使用无障碍点击 
- 版本 : 1.0.0


```javascript
//如果你通过选择器找到了节点，也可以通过这种方式来点击节点
let node = $act.selector()
.pkg("org.aigame.pro")
.cls("android.widget.FrameLayout")
.waitFirst();
if(node!=null){
     // 绘制节点位置
     node.draw();
     // 可以这样点击
     node.click();
     // 也可以这样点击
     $act.click(node,true);//true表示直接使用$act的点击坐标方式进行点击
}
```


### press(node)

> 长按节点
> 
> 如果节点支持点击，就是用节点本身的点击行为进行长按，如果不支持，则通过$act的坐标方式来点击节点的坐标位置。

- 参数 : node {Node} 节点 
- 版本 : 1.0.0


```javascript
//如果你通过选择器找到了节点，也可以通过这种方式来点击节点
let node = $act.selector()
.pkg("org.aigame.pro")
.cls("android.widget.FrameLayout")
.waitFirst();
if(node!=null){
     // 绘制节点位置
     node.draw();
     // 长按节点 或者也可以直接调用 node.press();
     $act.press(node);
}
```


### press(node, useAct)

> 长按节点
> 
> 如果设备获得了root，将优先使用root来执行手势,如果没有root,则使用无障碍来执行手势

- 参数 : node {Node} 节点 
- 参数 : useAct {boolean} 是否使用act点击 
- 版本 : 1.0.0


### press(x, y)

> 长按
> 

- 参数 : x {int} 长按位置x 
- 参数 : y {int} 长按位置y 
- 版本 : 1.0.0


```javascript
//点击手势(长按)(延迟一秒)
$act.press(136,347);
```


### press(x, y, dur)

> 长按
> 

- 参数 : x {int} 长按位置x 
- 参数 : y {int} 长按位置y 
- 参数 : dur {int} 长按后延迟 
- 版本 : 1.0.0


```javascript
//点击手势(长按)(延迟一秒)
$act.press(136,347,1500);
```


### press(x, y, dur, delay)

> 长按
> 

- 参数 : x {int} 长按位置x 
- 参数 : y {int} 长按位置y 
- 参数 : dur {int} 长按后延迟 
- 参数 : delay {int} 长按前延迟 
- 版本 : 1.0.0


```javascript
//点击手势(长按)(延迟一秒)
$act.press(136,347,1500,100);
```


### slide(startX, startY, endX, endY, duration)

> 模拟人手滑动

- 参数 : startX {int} 起点x(必填) 
- 参数 : startY {int} 起点y(必填) 
- 参数 : endX {int} 终点x(必填) 
- 参数 : endY {int} 终点y(必填) 
- 参数 : duration {int} 持续时间(可为空:默认:1秒) 
- 版本 : 1.7.8


```javascript
//随机模拟真人滑动(推荐)
$act.slide(189,244,733,1440,3000);
```


### move(x1, y1, x2, y2)

> 滑动
> 

- 参数 : x1 {int} 起点x 
- 参数 : y1 {int} 起点y 
- 参数 : x2 {int} 终点x 
- 参数 : y2 {int} 终点y 
- 版本 : 1.0.0


```javascript
//滑动手势
$act.move(500,0,500,800);
```


### move(x1, y1, x2, y2, dur)

> 滑动
> 

- 参数 : x1 {int} 起点x 
- 参数 : y1 {int} 起点y 
- 参数 : x2 {int} 终点x 
- 参数 : y2 {int} 终点y 
- 参数 : dur {int} 滑动延迟 
- 版本 : 1.0.0


```javascript
//滑动手势
$act.move(500,0,500,800,500);
```


### move(x1, y1, x2, y2, dur, delay)

> 滑动
> 

- 参数 : x1 {int} 起点x 
- 参数 : y1 {int} 起点y 
- 参数 : x2 {int} 终点x 
- 参数 : y2 {int} 终点y 
- 参数 : dur {int} 滑动时间 
- 参数 : delay {int} 滑动延迟 
- 版本 : 1.0.0


```javascript
//滑动手势
$act.move(500,0,500,800,500.1000);
```


### move(node, dir)

> 滑动节点
> 
> 仅无障碍可用

- 参数 : node {Node} 节点 
- 参数 : dir {String} 方向(up|down|left|right)
- 版本 : 1.0.0


### move(node, x2, y2, dur)

> 滑动
> 

- 参数 : node {Node} 节点 
- 参数 : x2 {int} 终点x 
- 参数 : y2 {int} 终点y 
- 参数 : dur {int} 滑动时间 
- 版本 : 1.0.0


```javascript
//滑动手势
$act.move(node,800,500,1000);
```


### move(node, x2, y2, dur, delay)

> 滑动
> 

- 参数 : node {Node} 节点 
- 参数 : x2 {int} 终点x 
- 参数 : y2 {int} 终点y 
- 参数 : dur {int} 滑动时间 
- 参数 : delay {int} 滑动延迟 
- 版本 : 1.0.0


```javascript
//滑动手势
$act.move(node,800,500,1000,100);
```


### gesture(gesture)

> 多指手势

- 参数 : gesture {int[]} 动作数据数组[起点x,起点y,终点x,终点y,开始时间,时长]
- 版本 : 1.0.0


```javascript
// 手势模拟向下滑动
$act.gesture([500,0,500,800,0,500]);
```


### gesture(gesture1, gesture2)

> 双指手势
> 

- 参数 : gesture1 {int[]} 动作数据数组[起点x,起点y,终点x,终点y,开始时间,时长]
- 参数 : gesture2 {int[]} 动作数据数组[起点x,起点y,终点x,终点y,开始时间,时长]
- 版本 : 1.0.0


```javascript
// 双指放大
let centerX = 500;
let centerY = 800;
$act.gesture(
    [centerX,centerY,centerX-400,centerY-400,0,500],
    [centerX,centerY,centerX+400,centerY+400,0,500]
);
```


### gesture(gesture1, gesture2, gesture3)

> 三指动作
> 

- 参数 : gesture1 {int[]} 动作数据数组
- 参数 : gesture2 {int[]} 动作数据数组
- 参数 : gesture3 {int[]} 动作数据数组
- 版本 : 1.0.0


```javascript
//三指滑动动作
$act.gesture( [500,0,500,800,500,0] ,
[550,0,550,800,500,0] ,
[600,0,600,800,500,0]
);
```


### gesture(gesture1, gesture2, gesture3, gesture4)

> 四指动作
> 

- 参数 : gesture1 {int[]} 动作数据数组
- 参数 : gesture2 {int[]} 动作数据数组
- 参数 : gesture3 {int[]} 动作数据数组
- 版本 : 1.0.0


```javascript
//四指滑动动作
$act.gesture( [500,0,500,800,500,0] ,
[550,0,550,800,500,0] ,
[600,0,600,800,500,0] ,
[650,0,650,800,500,0]
);
```


### createPath(paths)

> 通过路径来构建path对象(默认持续时间为1秒)

- 参数 : paths {[][]} 动作数据数组
- 返回 : {Path}
- 版本 : 1.0.0


### createPath(paths, dur)

> 通过路径来构建path对象

- 参数 : paths {[][]} 动作数据数组
- 参数 : dur {int} 持续
- 返回 : {AgPath} 路径对象
- 版本 : 1.0.0


### createPath(paths, delay, dur)

> 通过路径来构建path对象

- 参数 : paths {[][]} 动作数据数组
- 参数 : delay {int} 开始时间 
- 参数 : dur {int} 延迟 
- 返回 : {Path}
- 版本 : 1.0.0


### path(paths)

> 执行路径

- 参数 : paths {AgPath...} 多路径
- 版本 : 1.0.0


### path(paths)

> 构建一个路径并且执行(默认时间为1秒)

- 参数 : paths {int[][]} 动作数据数组
- 版本 : 1.0.0


### path(paths, dur)

> 构建一个路径并且执行

- 参数 : paths {int[][]} 动作数据数组
- 参数 : dur {int} 延迟 
- 版本 : 1.0.0


### path(paths, startTime, dur)

> 构建一个路径并且执行

- 参数 : paths {int[][]} 动作数据数组
- 参数 : startTime {int} 开始时间 
- 参数 : dur {int} 延迟 
- 版本 : 1.0.0


### home()

> 点击home键
> 
> 如果有root则优先使用root执行
> 如果有Shizuku则优先使用shizuku执行
> 如果有无障碍则优先使用无障碍执行
> 如果以上都没有，则无效果

- 版本 : 1.0.0


```javascript
$act.home();
```


### back()

> 返回
> 
> 如果有root则优先使用root执行
> 如果有Shizuku则优先使用shizuku执行
> 如果有无障碍则优先使用无障碍执行
> 如果以上都没有，则无效果

- 版本 : 1.0.0


```javascript
$act.back();
```


### menu()

> 返回
> 
> 如果有root则优先使用root执行
> 如果有Shizuku则优先使用shizuku执行
> 如果有无障碍则优先使用无障碍执行
> 如果以上都没有，则无效果

- 版本 : 1.0.0


```javascript
$act.menu();
```


### recent()

> 近期任务
> 
> 如果有root则优先使用root执行
> 如果有Shizuku则优先使用shizuku执行
> 如果有无障碍则优先使用无障碍执行
> 如果以上都没有，则无效果

- 版本 : 1.0.0


```javascript
$act.recent();
```


### power()

> 长按电源
> 
> 如果有root则优先使用root执行
> 如果有Shizuku则优先使用shizuku执行
> 如果有无障碍则优先使用无障碍执行
> 如果以上都没有，则无效果

- 版本 : 1.0.0


```javascript
$act.power();
```


### lock()

> 锁屏
> 
> 如果有root则优先使用root执行
> 如果有Shizuku则优先使用shizuku执行
> 如果有无障碍则优先使用无障碍执行
> 如果以上都没有，则无效果

- 版本 : 1.0.0


```javascript
$act.lock();
```


### unlock()

> 唤醒屏幕
> 
> 如果有root则优先使用root执行
> 如果有Shizuku则优先使用shizuku执行
> 如果有无障碍则优先使用无障碍执行
> 如果以上都没有，则无效果

- 版本 : 1.0.0


```javascript
$act.unlock();
```


### splitScreen()

> 分屏

- 版本 : 1.0.0


```javascript
$act.splitScreen();
```


### settings()

> 设置

- 版本 : 1.0.0


```javascript
$act.settings();
```


### notifications()

> 通知

- 版本 : 1.0.0


```javascript
$act.notifications();
```


### screenshot()

> 截屏
> 
> 唤起手机自带的截屏操作

- 版本 : 1.0.0


```javascript
$act.screenshot();
```


### input(text)

> 粘贴到文本框
> 
> 如果有root则优先使用root执行
> 如果有Shizuku则优先使用shizuku执行
> 如果有无障碍则优先使用无障碍执行
> 如果以上都没有，则无效果

- 参数 : text {String} 需要输入的文字 
- 版本 : 1.0.0


```javascript
$act.input("我是要粘贴的内容");
```


### input(node, text)

> 粘贴到文本框
> 
> 无障碍专属的函数

- 参数 : node {AccessibilityNodeInfo} 指定节点
- 参数 : text {String} 需要输入的文字 
- 版本 : 1.0.0


```javascript
$act.input("我是要粘贴的内容");
```


### input(node, text)

> 粘贴到文本框
> 
> 无障碍专属的函数

- 参数 : node {Node} 指定节点 
- 参数 : text {String} 需要输入的文字 
- 版本 : 1.0.0


```javascript
$act.input("我是要粘贴的内容");
```


### activity()

> 获得activity类名

- 返回 : activity类名
- 版本 : 1.0.0


```javascript
let name = $act.activity();
log("当前类名:"+name);
```


### activity(callback)

> 设置窗口变化监听

- 参数 : callback {(name)=>{}} 回调 
- 版本 : 1.0.0


```javascript
//设置监听:
$act.activity((name)=> {
    log("当前界面==>"+name);
});
```


### selector()

> 创建一个ui选择器
> 

- 返回 : {UiSelector} UI选择器
- 版本 : 1.0.0


### setDevDensity(density)

> 设置开发环境的密度
> 
> 注意：此函数用于全分辨率适配，需要配合 $act.setAdapt(true) 来使用。
> 
> 测试API:此方法后续可能会被删除

- 参数 : density {float} 密度因子 
- 版本 : 1.0.0


### setAdapt(usable)

> 是否启动分辨率适配
> 
> 我将根据屏幕密度来等比例计算出坐标的位置。
> 
> 测试API:此方法后续可能会被删除

- 参数 : usable {boolean} 启用分辨率适配 
- 版本 : 1.0.0


### isOnlyAcc()

> 判断$act是否只使用无障碍服务

- 返回 : {boolean} 是否只使用无障碍服务


### setOnlyAcc(onlyAcc)

> 设置$act只使用无障碍服务
> 
> 在本应用中$act是一个高度封装的框架，很多动作都会优先判断是否有$root和$szk，如果有root则优先使用root来执行手势，如果有szk(Shizuku)则优先使用Shizuku执行手势，如果$touch可用，则使用$touch执行手势。
> 
> 正因为$act是一个高度封装的框架，导致运行速度会比较慢，毕竟内部的执行逻辑稍微复杂一些。
> 
> 然而有时候我们不需要用到$root、$szk、$touch来执行操作，故设计了这个函数，用来配置$act是否只使用无障碍来进行操作，以加快运行速度。

- 参数 : onlyAcc {boolean} 是否只使用无障碍进行操作 
- 版本 : 1.4.3


### setJitter(jitter)

> 设置抖动值
> 
> $act允许用户配置抖动值(默认是0)，以实现随机点击，而抖动值其实就是随机值的范围，例如：点击坐标 X=10，抖动值为5时，实际上点击的位置将可能是 X=5到15之间。
> 假设：点击 X=5，抖动值设置为10，则实际上 X抖动之后在0-15之间(而不是-5到15之间)，我要告诉你：抖动之后的坐标不会小于0。
> 
> 不过我需要提醒:我并不会判断你的坐标在抖动之后是否处于屏幕的外部，因此，你需要合理的设置抖动值。

- 参数 : jitter {int} 抖动值  
- 版本 : 1.4.3


### enableRoot(enableRoot)

> 启用$root
> 
> $act是一个高度封装的框架，很多动作都会判断是否有$root，如果有$root则优先使用$root来执行手势。
> 
> 默认情况下，$root是启用的，你可以通过此函数来禁用$root。

- 参数 : enableRoot {boolean} 是否启用$root 
- 版本 : 1.4.7


### isEnableRoot()

> 判断$root是否启用

- 返回 : {boolean} 是否启用$root
- 版本 : 1.4.7


### enableSzk(enableSzk)

> 启用$szk
> 
> $act是一个高度封装的框架，很多动作都会判断是否有$szk，如果有$szk则优先使用$szk来执行手势。
> 
> 默认情况下，$szk是启用的，你可以通过此函数来禁用$szk。

- 参数 : enableSzk {boolean} 是否启用$szk 


### isEnableSzk()

> 判断$szk是否启用

- 返回 : {boolean} 是否启用$szk
- 版本 : 1.4.7


# $ag - 图色框架

- 更新时间:2025-12-13 11:58:43

> 图色框架




### setDebug(debug)

> 开启调试模式
> 
> 默认是开启调试模式的(推荐开启:更加直观的看到执行效果),找到图片则会在屏幕上绘制图片的位置,找到颜色则绘制点

- 参数 : debug {boolean} 是否开启调试模式 


### findImg(options)

> 寻找图片
> 
> 自动截屏一次,然后在传入的region(范围)中找图片，如果region为空则全屏寻找,不管找没找到,都会回收掉资源,并且返回结果

- 参数 : options 参数 {object} 配置参数 
- 返回 : 位置 {point} 返回找到位置的中心点
- 版本 : 1.0.0


```javascript
//参数:
let options = {
    path:"",//图片路径
    region:[],//(可选)找图的范围:必须是4位,且后两位不能为0
    similar:0.8,//(可选)找图的相似值:不能低于(最小值:0.3)
    trans:false,//(可选)是否找透明背景的图片
};
//使用:
let point = $ag.findImg({
    path:"/sdcard/Pictures/t01.png",
    region:[200,200,300,500],
});
```


### findImgClick(options)

> 寻找图片并且点击
> 
> 先截屏一次,如果图片找到了,那么就点击这个图片位置中心点

- 参数 : options {obj} 参数 
- 返回 : {point} 位置
- 版本 : 1.0.0


```javascript
//参数:
let options = {
    path:"",//图片路径
    region:[],//(可选)找图的范围:必须是4位,且后两位不能为0
    similar:0.8,//(可选)找图的相似值:不能低于(最小值:0.3)
    trans:false,//(可选)是否找透明背景的图片
    px: 0, //(可选)点击位置相对于中点的x偏移量
    py: 0, //(可选)点击位置相对于中点的y偏移量
};
//使用:
let point = $ag.findImgClick({
    path:"/sdcard/Pictures/t01.png",
    region:[200,200,300,500],
});
```


### waitImg(options, failCallback)

> 等待图片
> 
> 截屏后找图没找到就会执行回调一次,然后就继续截屏并且找图
> 
> 值得注意的是ensure如果设置了true,那么你就要了解ensureMode的含义：
> 
> 1.ensureMode:"once"：假如传入的ensureTimes是3,那么就会循环截屏3次,只要其中有1次成功,那么就会返回找到的位置
> 2.ensureMode:"more"：假如传入的ensureTimes是3,那么就会循环截屏3次,必须保证3次全部都成功,那么就会返回找到的位置
> 
> 确认执行完毕之后,会返回找到的位置,如果没有找到,则继续等待图片,每次找图都会执行确认流程。
> 
> 整体流程是：
> 1.先截屏一次
> 2.执行确认流程(如果设置确认流程ensure为false,就执行正常找图流程)
> 3.如果确认流程通过(确认流程会重复截屏ensureTimes次,并且按照ensureMode处理结果),那么就返回找到的位置
> 4.如果确认流程没有通过(执行回调),那么就继续截屏并且执行回到1

- 参数 : options {object} 参数 
- 参数 : failCallback {(curTimes)=>{}} 找图失败(或确认流程失败)后回调 
- 返回 : {point} 找到图片的中点位置


```javascript
let options = {
    path:"",
    region:[],//(可选)
    similar:0.8,//(可选)
    trans:false,//(可选)是否寻找透明背景的图片
    ensure:false,//(可选)找到后是否要进行确认
    ensureMode:"once",//(可选)确认的模式是多次(more)还是一次
    ensureTimes:3,//(可选)确认找到的次数
    ensureDur:300,//(可选)每次确认的间隔时间
    waitTimes:75,//(可选)等待次数
    waitDur:800 //(可选)等待延迟
}
//使用:
let point = $ag.waitImg({
    path:"/sdcard/Pictures/t01.png",
    region:[200,200,300,500],
});
```


### waitImg(options)

> 等待图片

- 参数 : options {object} 参数 
- 返回 : {point} 中点位置


```javascript
let options = {
    path:"",
    region:[],//(可选)
    similar:0.8,//(可选)
    trans:false,//(可选)是否寻找透明背景的图片
    ensure:false,//(可选)找到后是否要进行确认
    ensureMode:"once",//(可选)确认的模式是多次(more)还是一次
    ensureTimes:3,//(可选)确认找到的次数
    ensureDur:300,//(可选)每次确认的间隔时间
    waitTimes:75,//(可选)等待次数
    waitDur:800 //(可选)等待延迟
}
```


### waitImgClick(options, failCallback)

> 等待图片并点击

- 参数 : options {obj} 参数 
- 参数 : failCallback {(curTimes)=>{}} 找图失败后回调 
- 返回 : {point} 中点位置


```javascript
let options = {
    path:"",
    region:[],//(可选)
    similar:0.8,//(可选)
    trans:false,//(可选)是否寻找透明背景的图片
    ensure:false,//(可选)找到后是否要进行确认
    ensureMode:"once",//(可选)确认的模式是多次(more)还是一次
    ensureTimes:3,//(可选)确认找到的次数
    ensureDur:300,//(可选)每次确认的间隔时间
    waitTimes:75,//(可选)等待次数
    waitDur:800, //(可选)等待延迟
    px: 0, //(可选)点击位置相对于中点的x偏移量
    py: 0, //(可选)点击位置相对于中点的y偏移量
}
```


### waitImgClick(options)

> 等待图片并点击

- 参数 : options {object} 配置 
- 返回 : {point} 中点位置


```javascript
let options = {
    path:"",
    region:[],
    similar:0.8,
    trans:false,//(可选)是否寻找透明背景的图片
    ensure:true,//可选
    ensureMode:"once",//可选
    ensureTimes:3,//可选
    ensureDur:300,//可选
    waitTimes:75,//可选
    waitDur:800, //可选
    px: 0, //(可选)点击位置相对于中点的x偏移量
    py: 0, //(可选)点击位置相对于中点的y偏移量
}
```


### findImgInRegions(options)

> 寻找图片
> 
> 给定一个范围数组,只能在指定的范围数组当中查找对应的图片,找到后,返回图片的位置和数组下标
> 
> 执行流程:先截屏,然后循环每个范围数组,对小图片进行查找，找到之后就立马返回
> 
> 使用场景:比如关闭广告的[关闭按钮],有时候这个关闭按钮出现在右上角,有时候出现在中间下方的位置,在这种不确定关闭图片位置的情况下，使用此函数，将可能出现关闭按钮的位置全部传入，找到后即可返回位置。

- 参数 : options 参数 
- 返回 : {point point,int index} 位置与范围下标


```javascript
let options = {
    path:"", //必填:图片路径
    region:[[],[],[]], //必填:多个范围数组
    similar:0.8, //可选
    trans:false, //可选(是否寻找透明图)
}
```


### findImgsOne(options)

> 寻找图片
> 
> 传入多组图片数据,截屏后找图,只要其中有一组数据成功找到,则直接返回结果
> 
> 适用的场景：比如我们每次打开游戏或者应用界面的时候，我们并不知道它会不会弹出来一个更新界面或者广告界面,此时我们可以使用次函数,把可能出现的界面情况都传入进去,只要找到了,那么就会返回执行结果,我们就能知道是哪一个界面了。

- 参数 : options {obj} 参数 
- 返回 : {point point,int index} 结果是一个对象,其中包含point和index两个属性,point是图片中点位置,index是图片下标


```javascript
let options = {
    data:[
    {
        path:"",//必填
        region:[],//必填
        similar:0.8,//可选(默认0.8)
        trans:false,//可选(是否寻找透明图)
    },
    {
        //...多个这样的数据
    }
    ]
}
```


### waitImgsOne(options)

> 等待图片
> 
> 传入多组图片数据,截屏后找图,只要其中有一组数据成功找到,则直接返回结果
> 
> 适用的场景：比如我们每次打开游戏或者应用界面的时候，我们并不知道它会不会弹出来一个更新界面或者广告界面,此时我们可以使用次函数,把可能出现的界面情况都传入进去,只要找到了,那么就会返回执行结果,我们就能知道是哪一个界面了。

- 参数 : options {obj} 参数 
- 返回 : {point point,int index} 图片中点位置和下标


```javascript
let options = {
    data:[
    {
        path:"",//必填
        region:[],//必填
        similar:0.8,//可选(默认0.8)
        trans:false,//可选(是否寻找透明图)
    },
    {
        //...多个这样的数据
    }
    ],
    waitTimes:75,//选填(默认75)
    waitDur:800 //选填(默认800)
}
```


### waitImgsOne(options, failCallback)

> 等待图片

- 参数 : options {obj} 参数 
- 参数 : failCallback {(curTimes)=>{}} 找图失败后回调 
- 返回 : {point point,int index} 图片中点位置和下标


```javascript
let options = {
    data:[
    {
        path:"",//必填
        region:[],//必填
        similar:0.8,//可选(默认0.8)
        trans:false,//可选(是否寻找透明图)
    },
    {
        //...多个这样的数据
    }
    ],
    waitTimes:75,//选填(默认75)
    waitDur:800 //选填(默认800)
}
```


### clickImgWhileNot(options)

> 循环点击图片(直到图片消失)
> 
> 使用场景：比如在一些比较卡顿的应用或游戏中,我希望点击关闭按钮,但是游戏界面比较卡顿,可以使用此函数不断的点击,直到关闭成功

- 参数 : options {obj} 参数 
- 返回 : {point} 中点位置


```javascript
let options = {
    path:"",
    region:[],//(可选)
    similar:0.8,//(可选)
    trans:false,//(可选)是否寻找透明背景的图片
    ensure:false,//(可选)找到后是否要进行确认
    ensureMode:"once",//(可选)确认的模式是多次(more)还是一次
    ensureTimes:3,//(可选)确认找到的次数
    ensureDur:300,//(可选)每次确认的间隔时间
    waitTimes:75,//(可选)等待次数
    waitDur:800, //(可选)等待延迟
    px: 0, //(可选)点击位置相对于中点的x偏移量
    py: 0, //(可选)点击位置相对于中点的y偏移量
}
```


### clickImgWhileNot(options, failCallback)

> 循环点击图片(直到图片消失)
> 
> 使用场景：比如游戏人物打开背包后要存放苹果,此时我们可以使用此函数不断的点击苹果,把它存放到背包中

- 参数 : options {obj} 参数 
- 参数 : failCallback {(curTimes)=>{}} 找图失败后回调 
- 返回 : {point} 中点位置


```javascript
let options = {
    path:"",
    region:[],//(可选)
    similar:0.8,//(可选)
    trans:false,//(可选)是否寻找透明背景的图片
    ensure:false,//(可选)找到后是否要进行确认
    ensureMode:"once",//(可选)确认的模式是多次(more)还是一次
    ensureTimes:3,//(可选)确认找到的次数
    ensureDur:300,//(可选)每次确认的间隔时间
    waitTimes:75,//(可选)等待次数
    waitDur:800, //(可选)等待延迟
    px: 0, //(可选)点击位置相对于中点的x偏移量
    py: 0, //(可选)点击位置相对于中点的y偏移量
}
```


### featureWaitImg(options)

> 等待图片特征

- 参数 : options {object} 配置 
- 返回 : {point} 找到的中心位置


```javascript
let options = {
    path:"",
    region:[],//(可选)
    similar:0.8,//(可选)
    ensure:false,//(可选)找到后是否要进行确认
    ensureMode:"once",//(可选)确认的模式是多次(more)还是一次
    ensureTimes:3,//(可选)确认找到的次数
    ensureDur:300,//(可选)每次确认的间隔时间
    waitTimes:75,//(可选)等待次数
    waitDur:800, //(可选)等待延迟
}
```


### featureWaitImg(options, failCallback)

> 等待图片特征

- 参数 : options {obj} 参数 
- 参数 : failCallback {(curTimes)=>{}} 找图失败后回调 
- 返回 : {point} 中点位置


```javascript
let options = {
    path:"",
    region:[],//(可选)
    similar:0.8,//(可选)
    ensure:false,//(可选)找到后是否要进行确认
    ensureMode:"once",//(可选)确认的模式是多次(more)还是一次
    ensureTimes:3,//(可选)确认找到的次数
    ensureDur:300,//(可选)每次确认的间隔时间
    waitTimes:75,//(可选)等待次数
    waitDur:800, //(可选)等待延迟
}
```


### featureImgClick(options)

> 等待图片特征并点击

- 参数 : options {object} 配置 
- 返回 : {point} 返回位置


```javascript
let options = {
    path:"",
    region:[],
    similar:0.8,
    px: 0, //(可选)点击位置相对于中点的x偏移量
    py: 0, //(可选)点击位置相对于中点的y偏移量
}
```


### featureWaitImgClick(options, failCallback)

> 等待图片特征并点击

- 参数 : options {obj} 参数 
- 参数 : failCallback {(curTimes)=>{}} 找图失败后回调 
- 返回 : {point} 中点位置


```javascript
let options = {
    path:"",
    region:[],
    similar:0.8,
    px: 0, //(可选)点击位置相对于中点的x偏移量
    py: 0, //(可选)点击位置相对于中点的y偏移量
}
```


### featureWaitImgClick(options)

> 等待图片并点击

- 参数 : options {object} 配置 
- 返回 : {point} 找到的位置中点


```javascript
let options = {
    path:"",
    region:[],
    similar:0.8,
    ensure:true,//可选
    ensureMode:"once",//可选
    ensureTimes:3,//可选
    ensureDur:300,//可选
    waitTimes:75,//可选
    waitDur:800, //可选
    px: 0, //(可选)点击位置相对于中点的x偏移量
    py: 0, //(可选)点击位置相对于中点的y偏移量
}
```


### featureImgsOne(options)

> 多图中找一个
> 
> 传入多个特征图片参数,如果找到了其中的一个就会返回结果

- 参数 : options {object} 配置 
- 返回 : {point:point,index:index} 位置与下标


```javascript
let options = {
    data:[
    {
        path:"",//必填
        region:[],//必填
        similar:0.8,//可选(默认0.8)
    },
    {
        //...多个这样的数据
    }
    ]
}
```


### featureWaitImgsOne(options)

> 等待多个特征中的一个

- 参数 : options {object} 配置 
- 返回 : {point:point,index:index} 特征结果位置中点和下标


```javascript
let options = {
    data:[
    {
        path:"",//必填
        region:[],//必填
        similar:0.8,//可选(默认0.8)
    },
    {
        //...多个这样的数据
    }
    ],
    waitTimes:75,//(选填)等待次数
    waitDur:800,//(选填)每次等待延迟
}
```


### featureWaitImgsOne(options, failCallback)

> 等待图片

- 参数 : options {obj} 参数 
- 参数 : failCallback {(curTimes)=>{}} 找图失败后回调 
- 返回 : {point} 中点位置


### featureImgInRegions(options)

> 点击图片特征直到消失

- 参数 : options {object} 配置 
- 返回 : {point} 找到的中点位置


```javascript
let options = {
    path:"",
    region:[],//(可选)
    similar:0.8,//(可选)
    ensure:false,//(可选)找到后是否要进行确认
    ensureMode:"once",//(可选)确认的模式是多次(more)还是一次
    ensureTimes:3,//(可选)确认找到的次数
    ensureDur:300,//(可选)每次确认的间隔时间
    waitTimes:75,//(可选)等待次数
    waitDur:800, //(可选)等待延迟
    px: 0, //(可选)点击位置相对于中点的x偏移量
    py: 0, //(可选)点击位置相对于中点的y偏移量
}
```


### clickImgWhileFeatureNot(options)

> 点击图片特征直到消失

- 参数 : options {object} 配置 
- 返回 : {point} 找到的中点位置


```javascript
let options = {
    path:"",
    region:[],//(可选)
    similar:0.8,//(可选)
    ensure:false,//(可选)找到后是否要进行确认
    ensureMode:"once",//(可选)确认的模式是多次(more)还是一次
    ensureTimes:3,//(可选)确认找到的次数
    ensureDur:300,//(可选)每次确认的间隔时间
    waitTimes:75,//(可选)等待次数
    waitDur:800, //(可选)等待延迟
    px: 0, //(可选)点击位置相对于中点的x偏移量
    py: 0, //(可选)点击位置相对于中点的y偏移量
}
```


### bloodPercent(options)

> 血条检测
> 
> 主要根据传入的颜色(可传入多个颜色以,分割)和血条的范围来计算出血条的百分比

- 参数 : options {object} 参数 
- 返回 : {int} -1-100的值(为-1则表示没有血量)


```javascript
let options = {
    region: [], //(必填)血条范围
    color: "#ff0000,#ff0000", //(必填)可传入多个
    threshold:5 //(可选)偏差值(默认5)
}
let p = $ag.bloodPercent(options);
```


### findColor(options)

> 找色
> 

- 参数 : options {object} 参数 
- 返回 : {Point} 坐标


```javascript
let options = {
    region: [], //(必填)范围
    color: "#ff0000,#ff0000", //(必填)颜色(多个用,分割)
    threshold:5 //(可选)偏差值(默认5)
}
```


### findMultiColors(options)

> 多点找色
> 
> 多点找色并不能很好的适配全分辨率,因为把颜色点相对位置写死了,而不同的设备中,相对点位不同

- 参数 : options {object} 参数 
- 返回 : {point} 位置


```javascript
let options = {
    multiColors:[
        [1,2,"#FF0000",5],//每个数据元都是px,py,color,threshold组成的
        [1,2,"#FF0000",5],//px,py是相对于传入的主颜色的偏移位置
        //...多个点色
    ],
    color:"#000000",
    threshold:5,
    region:[],
}
```


### findMultiColorsClick(options)

> 多点找色

- 参数 : options {object} 参数 
- 返回 : {point} 位置


```javascript
let options = {
    multiColors:[
        [1,2,"#FF0000",5],//每个数据元都是px,py,color,threshold组成的
        [1,2,"#FF0000",5],//px,py是相对于传入的主颜色的偏移位置
        //...多个点色
    ],
    color:"#000000",
    threshold:5,
    region:[],
    px:0, //(可选)点击位置x偏移量
    py:0 //(可选)点击位置y偏移量
}
```


### waitMultiColors(options)

> 等待多点色

- 参数 : options {object} 参数 
- 返回 : {point} 位置


### waitMultiColorsClick(options)

> 等待多点色

- 参数 : options {object} 参数 
- 返回 : {point} 位置


### waitMultiColors(options, failCallback)

> 等待多点色

- 参数 : options {object} 参数 
- 参数 : failCallback {(curTimes)=>{}}回调 
- 返回 : {point} 位置


```javascript
let options = {
    multiColors:[],
    color:"#000000",
    threshold:5,
    rect:null,
    ensure:false,
    ensureMode:"once",
    ensureTimes:3,
    ensureDur:1000,
    waitTimes:50,
    waitDur:1000,
}
```


### waitMultiColorsClick(options, failCallback)

> 等待图片

- 参数 : options {obj} 参数 
- 参数 : failCallback {(curTimes)=>{}} 找图失败后回调 
- 返回 : {point} 中点位置


### findColorClick(options)

> 找色点击

- 参数 : options {object} 参数 
- 返回 : {point} 位置


### waitColor(options, failCallback)

> 等待颜色

- 参数 : options {obj} 参数 
- 参数 : failCallback {(curTimes)=>{}} 找图失败后回调 
- 返回 : {point} 中点位置


```javascript
let options = {
    color:"",
    region: [],//(可选)找色的范围,建议填写上
    threshold:5,
    ensure:false,
    ensureMode:"once",
    ensureTimes:3,
    ensureDur:1000,
    waitTimes:50,
    waitDur:1000,
}
```


### waitColor(options)

> 等待颜色

- 参数 : options {obj} 参数 
- 返回 : {point} 中点位置


```javascript
let options = {
    color:"",
    region: [],//(可选)找色的范围,建议填写上
    threshold:5,
    ensure:false,
    ensureMode:"once",
    ensureTimes:3,
    ensureDur:1000,
    waitTimes:50,
    waitDur:1000,
}
```


### waitColorWhileNot(options, failCallback)

> 等待颜色消失

- 参数 : options {obj} 参数 
- 参数 : failCallback {(curTimes)=>{}} 找图失败后回调 


```javascript
let options = {
    color:"",
    region: [],//(可选)找色的范围,建议填写上
    threshold:5,
    ensure:false,
    ensureMode:"once",
    ensureTimes:3,
    ensureDur:1000,
    waitTimes:50,
    waitDur:1000,
}
```


### waitColorClick(options, failCallback)

> 等待颜色

- 参数 : options {obj} 参数 
- 参数 : failCallback {(curTimes)=>{}} 找图失败后回调 
- 返回 : {point} 中点位置


### waitColorClick(options)

> 等待颜色

- 参数 : options {obj} 参数 
- 返回 : {point} 中点位置


### findColorInRegions(options)

> 在多个区域中找色

- 参数 : options {object} 参数 
- 返回 : {point} 中点位置


```javascript
let options = {
    color:"",
    threshold: 5,
    region:[[],[],[]],//多个范围
}
let result = $ag.findColorInRegions(options);
```


### findColorsOne(options)

> 找到一种颜色

- 参数 : options {object} 参数 
- 返回 : {point} 中点位置


### setScreen(w, h)

> 设置屏幕信息(开发者环境)

- 参数 : w {int} 宽度 
- 参数 : h {int} 高度 


### closeDraw()

> 关闭绘制的图案


### screenInfo()

> 获得当前屏幕信息

- 返回 : {string} 屏幕信息


### setDevDensity(devDensity)

> 设置开发环境屏幕密度
> 
> 注意:此函数用于分辨率适配

- 参数 : devDensity 开发环境下的屏幕密度  


### setAdapt(usable)

> 是否启动分辨率适配

- 参数 : usable {boolean} 启用分辨率适配 


# AppInfo - 应用信息

- 更新时间:2025-12-13 11:58:44

> 应用信息
> 
> 通过 $app.ls(); 方法返回的列表元素类型




### const {String} appName;

> 应用名称


### const {String} pkgName;

> 包名


### const {Image} icon;

> 图标


### const {ApplicationInfo} info;

> 安卓原生应用信息
> 
> 类名：android.content.pm.ApplicationInfo


### getAppName()

> 获取应用名称

- 返回 : {string} 应用名称


### getPkgName()

> 获取包名

- 返回 : {string} 包名


### getIcon()

> 获取图标

- 返回 : {Image} 图标


### getInfo()

> 获取安卓原生应用信息

- 返回 : {ApplicationInfo} 安卓原生应用信息


### json()

> 转成json字符串

- 返回 : {string} json字符串
- 版本 : 1.7.0


# AppTaskInfo - 任务信息

- 更新时间:2025-12-13 11:58:44

> 应用任务信息
> 
> 通过 $app.lsRecent(); 方法返回的列表元素类型




### const {String} appName;

> 应用名称


### const {String} pkgName;

> 包名


### const {String} lastUseTime;

> 最后使用时间


### const {long} lastUsedTime;

> 最后使用时间


### const {ApplicationInfo} info;

> 安卓原生应用信息
> 
> 类型：{android.content.pm.ApplicationInfo}


### getLastUsedTime()

> 最后使用时间

- 返回 : {long} 最后使用时间


### getAppName()

> 获取应用名称

- 返回 : {string} 应用名称


### getPkgName()

> 获得包名

- 返回 : {string} 包名


### getLastUseTime()

> 获得最后时间格式化字符串

- 返回 : {string} 最后使用时间


### json()

> 将当信息对象转为json字符串

- 返回 : {String} json字符串
- 版本 : 1.7.0


# $app - 应用操作

- 更新时间:2025-12-13 11:58:44

> 应用操作
> 
> 这里包含了一写常用的应用操作、意图操作、或者一些拓展操作：发送短信等等。




这里我给个我自己经常使用的工具函数，就是添加QQ群函数。


```xml
//[工具] 可以用来添加QQ群
let joinQQGroup = function (qqNum) {
    $app.startActivity({
        data: `mqqapi://card/show_pslcard?src_type=internal&version=1&uin=${qqNum}&card_type=group&from=qrcode`,
        pkg: "com.tencent.mobileqq"
    });
}
//使用方式
joinQQGroup(661266412);
```


### getIcon(name)

> 获取应用图标

- 参数 : name {string} 应用名称或包名 
- 返回 : {Image} 图标
- 版本 : 1.0.0


```javascript
//获取悬浮窗权限
$floaty.getPermit();
//获取图标
let icon = $app.getIcon("QQ");//应用名称或者包名
//显示图片
$img.show(icon);//(需要用悬浮窗权限) 也可以直接调用 icon.show(); //icon是{Image}类对象，因此可以世界调用show()方法。
```


### runApp(appName)

> 运行应用

- 参数 : appName {String} 应用名 
- 返回 : {boolean} 是否运行成功
- 版本 : 1.0.0


```javascript
$app.runApp("QQ");//应用名
```


### launchApp(appName)

> 运行应用
> 
> 这个函数的效果和$app.runApp("应用");相同

- 参数 : appName {String} 应用名称 
- 返回 : {boolean} 是否运行成功
- 版本 : 1.0.0


```javascript
$app.launchApp("QQ");//应用名
```


### launch(appName)

> 运行应用
> 
> 这个函数的效果和$app.runApp("应用");相同

- 参数 : appName {String} 应用名称 
- 返回 : {boolean} 是否运行成功
- 版本 : 1.0.0


```javascript
$app.launch("QQ");//应用名或包名
```


### launchPkg(packageName)

> 运行包名
> 
> 此函数和$app.runPkg("包名");效果相同

- 参数 : packageName {String} 程序包名 
- 返回 : {boolean} 是否跳转成功
- 版本 : 1.0.0


```javascript
$app.launchPkg("com.tencent.mobileqq");//传入包名
```


### runPkg(packageName)

> 运行包名

- 参数 : packageName {String} 程序包名 
- 返回 : {boolean} 是否跳转成功
- 版本 : 1.0.0


```javascript
$app.runPkg("com.tencent.mobileqq");//传入包名
```


### run(name)

> 打开应用(推荐)
> 
> 最简洁的启动应用函数，推荐使用

- 参数 : name {string} 包名或程序名称 
- 返回 : {boolean} 是否打开成功
- 版本 : 1.0.0


```javascript
$app.run("QQ");//可传入包名或者应用名
```


### ls()

> 获得应用列表

- 返回 : {AppInfo[]} 应用信息列表
- 版本 : 1.0.0


```javascript
//获得所有应用信息
let apps = $app.ls();//返回一个AppInfo的列表
//打印所应用信息
for(let i = 0 ; i < apps.size() ; i++){
    let appInfo = apps.get(i);//获得{AppInfo}对象(注意{AppInfo}是由本平台封装的对象)
    //一些常用属性
    let appName = appInfo.appName;//应用名称{string}
    let pkgName = appInfo.pkgName;//包名{string}
    let icon = appInfo.icon;//图标{Image} 可以直接调用 icon.show(); 显示出来(注意{Image}是由本平台封装的对象)
    let info = appInfo.info;//安卓原生应用信息{android.content.pm.ApplicationInfo}
    //{ApplicationInfo}常用属性(安卓自带的对象)
    let sourceDir = info.sourceDir; // {string}应用APK文件的路径
    let className = info.className; // {string}应用的主Application类名
    let packageName = info.packageName; // {string}应用的包名
    let componentFactory = info.appComponentFactory; // {string}应用组件工厂类，用于创建Activity、Service等组件
    let sdkVersion = info.compileSdkVersion; // {int}应用编译时使用的SDK版本号
    let sdkName = info.compileSdkVersionCodename; // {string}应用编译时使用的SDK版本代号，如"Q"、"R"等
    let dataDir = info.dataDir; // {string}应用的数据目录，一般为/data/data/包名
    let dpDataDir = info.deviceProtectedDataDir; // {string}设备受保护存储中的应用数据目录
}
```


### lsUserApp()

> 获得用户应用列表

- 返回 : {AppInfo[]} 应用列表
- 版本 : 1.3.2


```javascript
//获得用户应用列表
let apps = $app.lsUserApp();
//打印所应用信息
for(let i = 0 ; i < apps.size() ; i++){
    log(apps.get(i));
}
```


### lsSysApp()

> 获得系统应用列表

- 返回 : {AppInfo[]} 应用列表
- 版本 : 1.3.2


```javascript
//获得系统应用列表
let apps = $app.lsSysApp();
//打印所应用信息
for(let i = 0 ; i < apps.size() ; i++){
    log(apps.get(i));
}
```


### lsRecent()

> 获得最近运行的应用

- 返回 : {AppTaskInfo[]} 应用信息列表
- 版本 : 1.0.1


```javascript
//获得最近运行的应用(需要用到查询应用使用情况的权限)
if ($app.hasUsagePermit()) {
    let pkgList = $app.lsRecent();
    if (pkgList !== null) {
        for (let i = 0; i < pkgList.size(); i++) {
            let taskInfo = pkgList.get(i);//获得{AppTaskInfo}对象(由本平台封装的对象)
            //常用属性：(可参考AppTaskInfo文档)
            let appName = taskInfo.appName;//{string}应用名称
            let pkgName = taskInfo.pkgName;//{string}包名
            let lastUseTime = taskInfo.lastUseTime;//{string}最后使用时间 对lastUsedTime进行格式化日期的字符串
            let lastUsedTime = taskInfo.lastUsedTime;//{long}最后使用时间
            let info = taskInfo.info;//{android.content.pm.ApplicationInfo}应用信息(安卓类对象)
        }
    }
} else {
    //获取查询应用使用情况的权限
    $app.getUsagePermit();
}
```


### startActivity(name)

> 打开AIGame中的界面
> 
> 允许用户打开本应用中集成的各种调试界面：Log日志、Device设备信息、Ocr文字识别、Yolo目标检测、Shizuku高级权限等。

- 参数 : name {string} 界面名称 
- 版本 : 1.6.9


```javascript
//打开日志界面
$app.startActivity("log");//推荐写法
$app.startActivity("console");//兼容auto.js写法
//打开设备信息界面
$app.startActivity("device");
//打开OCR调试界面
$app.startActivity("ocr");
//打开Yolo调试界面
$app.startActivity("yolo");
//打开Shizuku调试界面
$app.startActivity("shizuku");
```


### startActivity(name, activityName)

> 启动活动

- 参数 : name {String} 包名或应用名 
- 参数 : activityName {String} activity地址 
- 返回 : {boolean} 是否跳转成功
- 版本 : 1.0.0


```javascript
//打开QQ
$app.startActivity("QQ","com.tencent.mobileqq.activity.SplashActivity");
```


### pkgExists(pkgName)

> 包名是否存在

- 参数 : pkgName {String} 包名 
- 返回 : {boolean} 是否存在
- 版本 : 1.0.0


```javascript
let pkg = "org.aigame.pro";
if ($app.pkgExists(pkg)) {
    alert(pkg,"存在");
} else {
    alert(pkg,"不存在");
}
```


### getPackageName(appName)

> 获得包名名称
> 
> 效果和$app.pkgName("QQ");相同

- 参数 : appName {String} app名称 
- 返回 : {String} 包名
- 版本 : 1.0.0


```javascript
//获得包名
let pkg = $app.getPackageName("QQ");
alert("应用包名",pkg);
```


### pkgName(appName)

> 获得包名名称

- 参数 : appName {String} app名称 
- 返回 : {String} 包名
- 版本 : 1.0.0


```javascript
//获得包名
let pkg = $app.pkgName("QQ");
alert("应用包名",pkg);
```


### appName(packageName)

> 根据包名拿应用名

- 参数 : packageName {String} 包名 
- 返回 : {String} app名称
- 版本 : 1.0.0


```javascript
//获得应用名
let appName = $app.appName("com.android.settings");
alert("应用名称",appName);//设置
```


### installApk(apkPath)

> 安装apk文件
> 
> 此函数会获取系统的安装意图，然后尝试安装apk文件，前提是apk文件必须存在

- 参数 : apkPath {string} 路径(支持相对路径) 
- 返回 : {boolean} 是否成功获取安装意图
- 版本 : 1.3.3


```javascript
//安装本地apk文件
$app.installApk("./apk/qq.apk");
```


### uninstallApp(name)

> 卸载应用

- 参数 : name {string} 应用名称 
- 版本 : 1.0.0


```javascript
//此函数部分手机不支持
//卸载QQ
$app.uninstallApp("QQ");
```


### uninstallPkg(name)

> 卸载包名
> 
> 部分手机不支持

- 参数 : name {string} 应用名称或包名 
- 版本 : 1.0.0


```javascript
//此函数部分手机不支持
//卸载QQ
$app.uninstallPkg("com.tencent.mobileqq");
```


### uninstall(name)

> 卸载

- 参数 : name {string} 应用名称或包名 
- 版本 : 1.0.0


```javascript
//此函数部分手机不支持
//卸载QQ
$app.uninstall("QQ");//应用名或包名
```


### openUrl(url)

> 打开链接
> 
> 如果传入的网址不是以"http"开头的，则默认追加"http://"到连接前面

- 参数 : url {string} 网页链接 
- 版本 : 1.0.0


```javascript
//打开网址
let myUrl = "www.baidu.com";
$app.openUrl(myUrl);//http://www.baidu.com
```


### shareImg(imgPath)

> 分享图片

- 参数 : imgPath {string} 图片路径 
- 版本 : 1.0.0


```javascript
//分享本地图片
let path = "/sdcard/Pictures/t01.png";
$app.shareImg(path);
```


### shareText(content)

> 分享文本

- 参数 : content {string} 内容 
- 版本 : 1.0.0


```javascript
//分享文本
let text = "你好";
$app.shareText(text);
```


### sendSms(phone, message)

> 发送短信
> 
> 跳转到发送短信的界面

- 参数 : phone {string} 电话号码 
- 参数 : message {string} 短信内容 
- 版本 : 1.0.0


```javascript
$app.sendSms("13593749477","你好我是xxx");
```


### call(phoneNumber)

> 拨打电话
> 
> 如果拥有电话权限会直接拨通电话

- 参数 : phoneNumber {string} 电话号码 
- 版本 : 1.0.0


```javascript
$app.call("13593749477");
```


### sendMail(mail, title, content)

> 发送邮件
> 
> 需要手机有自带的邮箱功能或应用

- 参数 : mail {string} 收件邮箱 
- 参数 : title {string} 标题 
- 参数 : content {string} 内容 
- 返回 : {boolean} 是否发送成功
- 版本 : 1.0.0


```javascript
$app.sendMail("3502037911@qq.com","标题","内容");
```


### openAppSetting(name)

> 打开应用设置
> 
> 和$app.appSetting("AIGame Pro");效果相同
> 
> 会打开应用详情设置界面

- 参数 : name {string} 应用名称或包名 
- 返回 : {boolean} 是否打开成功
- 版本 : 1.0.0


```javascript
//前往权限设置界面
$app.openAppSetting("AIGame");
```


### appSetting(name)

> 打开应用设置
> 
> 会打开应用详情设置界面

- 参数 : name {string} 应用名称或包名 
- 返回 : {boolean} 是否打开成功
- 版本 : 1.0.0


```javascript
//前往权限设置界面
$app.appSetting("AIGame");
```


### viewFile(path)

> 查看文件

- 参数 : path {string} 文件路径 
- 返回 : {boolean} 是否打开成功
- 版本 : 1.0.0


```javascript
//打开文件
$app.viewFile("/sdcard/Pictures/test.text");
```


### editFile(path)

> 编辑文件

- 参数 : path {string} 文件路径 
- 返回 : {boolean} 是否打开成功
- 版本 : 1.0.0


```javascript
//编辑文件
$app.editFile("/sdcard/Pictures/test.text");
```


### hasUsagePermit()

> 是否有使用情况权限

- 返回 : {boolean} 是否有使用情况权限
- 版本 : 1.0.1


```javascript
$app.hasUsagePermit();
```


### getUsagePermit()

> 获取使用情况权限

- 返回 : {boolean} 是否打开成功
- 版本 : 1.0.1


```javascript
$app.getUsagePermit();
```


### intent(options)

> 创建意图

- 参数 : options {Object} 配置参数 
- 返回 : {Intent} 意图
- 版本 : 1.0.1


```javascript
//写必要的参数
let options = {
    action: "android.intent.action.VIEW",//只写VIEW也可以(自动追加前缀:"android.intent.action.")
    data: "https://www.baidu.com",//数据内容
    pkg: "com.baidu.BaiduMap",//包名
    type: "text/plain",//数据类型
    flags: ["FLAG_ACTIVITY_NEW_TASK","..."],//标志
    component: {
        cls: "org.aigame.pro.ActivityMain",
        pkg: "org.aigame.pro"
    },//组件
    categories: ["CATEGORY_DEFAULT","..."],//类别
    extras:[{
        name:"",
        value:""
    },{
        name:"",
        value:""
    }]//额外内容
}
//创建意图
let intent = $app.intent(options);
```


### sendBroadcast(intent)

> 发送异步广播

- 参数 : intent {Intent} 意图 
- 版本 : 1.0.1


### sendBroadcast(intent, permis)

> 发送异步广播(含权限)

- 参数 : intent {Intent} 意图 
- 参数 : permis {string} 权限 
- 版本 : 1.0.1


### sendOrderedBroadcast(intent, permis)

> 发送同步广播

- 参数 : intent {Intent} 意图 
- 参数 : permis {string} 权限 
- 版本 : 1.0.1


### startActivity(intent)

> 用意图启动Activity

- 参数 : intent {Intent} 意图 
- 版本 : 1.0.1


### startActivity(options)

> 启动Activity

- 参数 : options {Object} 意图配置 
- 版本 : 1.1.1


### getForeApps()

> 获取前台应用
> 
> 此方法只在低版本安卓中有明显效果，建议使用 $root.lsRunningApps((pkg)=>{}); 来获取前台应用

- 返回 : {String[]} 前台应用包名列表
- 版本 : 1.0.4


### kill(name)

> 杀死应用
> 
> 如果有root权限，优先使用root权限来杀死应用,如果有shizuku则使用shizuku来杀死应用
> 
> 在低版本的安卓中，直接就可以通过活动管理器杀死应用，但是在较高版本的安卓中(安卓9+)很可能无法直接杀死应用进程。

- 参数 : name {string} 应用名或包名 
- 版本 : 1.0.4


```javascript
//结束应用
$app.kill("QQ");
$app.kill("MT管理器");
```


### sendMms(phone, title, message, imgPath)

> 发送彩信

- 参数 : phone {string} 电话号码
- 参数 : title {string} 主题(可为null)
- 参数 : message {string} 短信内容
- 参数 : imgPath {string} 图片全路径(无法支持相对路径)
- 版本 : 1.4.9


```javascript
//发送彩信
$app.sendMms("13800000000", "测试彩信", "这是一条彩信", "/sdcard/DCIM/100ANDRO/IMG_20230801_100000.jpg");
```


### openSelf()

> 打开自身
> 
> 打开自身的主活动（通常是启动器图标点击后的活动）。
> 
> 此方法尝试使用启动器意图来打开应用。如果失败（例如，应用未安装），则会创建一个新的意图来启动主活动。
> 
> 如果是打包后的apk则会打开打包后的apk主界面

- 版本 : 1.6.2


```javascript
//打开自身应用
$app.openSelf();
```


# MenuBody - 按钮容器

- 更新时间:2025-12-13 11:58:44

> 按钮容器
> 
> 用于装载多个悬浮按钮的容器，并控制显示与关闭。




### add(menu)

> 添加悬浮按钮
> 
> 可以向按钮容器中添加多个悬浮小按钮

- 参数 : menu {MenuItem} 悬浮按钮
- 返回 : {MenuBody} 自己
- 版本 : 1.0.0


```javascript
//创建按钮容器(用来装小按钮(MenuItem))
let menuBody = $arc.body("我的悬浮球1号"); //指定容器名称
//添加按钮
menuBody.add($arc.item("logo_ag"));
//之后就可以显示出来了
menuBody.show();
```


### show()

> 显示悬浮按钮
> 
> 会优先判断是否存在悬浮球名称了，如果存在则不显示，如果不存在则记录悬浮球名称并且显示。

- 版本 : 1.0.0


```javascript
//创建按钮容器(用来装小按钮(MenuItem))
let menuBody = $arc.body("我的悬浮球1号");
//创建小按钮(自定义按钮的各种样式)
let menu1 = $arc.item("logo_ag").bg("#55FFFFFF"); //指定按钮图标
let menu2 = $arc.item("ic_close").style("outline").iconTint("#FF0000"); //可以这样指定样式[方法1]
let menu3 = $arc.item("ic_code_run");
let menu4 = $arc.item("ic_cloud");
let menu5 = $arc.item("ic_color");
//连续添加小按钮并且显示
menuBody.add(menu1) //添加小按钮1
        .add(menu2) //添加小按钮2
        .add(menu3) //添加小按钮3
        .add(menu4) //添加小按钮4
        .add(menu5) //添加小按钮5
        .show(); //这里直接调用显示
```


### name(name)

> 设置悬浮球名称
> 
> 每个悬浮球被显示之前都会判断当前悬浮球的名称是否已经存在了，如果存在了，就不显示。

- 参数 : name {string} 悬浮窗名称
- 返回 : {MenuBody} 自己
- 版本 : 1.0.0


```javascript
//创建按钮容器(用来装小按钮(MenuItem))
let menuBody = $arc.body("我的悬浮球1号") //创建悬浮球按钮容器
.name("悬浮球1号"); //为容器设置一个名称
```


### margin(left, right)

> 设置贴边边距

- 参数 : left {int} 左边距，默认为 0
- 参数 : right {int} 右边距，默认为 0
- 返回 : {MenuBody} 自己
- 版本 : 1.0.0


```javascript
//创建按钮容器(用来装小按钮(MenuItem))
let menuBody = $arc.body("我的悬浮球1号") //创建悬浮球按钮容器
.margin(50,50); //设置左右两边的贴边边距
```


### radius(radius)

> 设置圆弧半径
> 
> 圆弧半径决定了容器中每个小按钮展开时的距离

- 参数 : radius {int} 半径
- 返回 : {MenuBody} 自己
- 版本 : 1.0.0


```javascript
//创建按钮容器(用来装小按钮(MenuItem))
let menuBody = $arc.body("我的悬浮球1号") //创建悬浮球按钮容器
.radius(25); //设置圆弧半径
```


### global(isGlobalShow)

> 设置是否全局显示
> 
> 默认就是全局显示的（需要悬浮窗权限），任何应用都能够看到这个悬浮球，如果不是全局显示的，那么就只能在当前应用中显示。

- 参数 : isGlobalShow {boolean} 是否全局显示(默认:true)
- 返回 : {MenuBody} 自己
- 版本 : 1.0.0


```javascript
//创建按钮容器(用来装小按钮(MenuItem))
let menuBody = $arc.body("我的悬浮球1号") //创建悬浮球按钮容器
.global(true); //设置为全局显示(需要悬浮窗权限)
```


### dur(expandAnimDur)

> 设置展开动画时间
> 
> 默认是 250 毫秒

- 参数 : expandAnimDur {int} 展开动画时长
- 返回 : {MenuBody} 自己
- 版本 : 1.0.0


```javascript
//创建按钮容器(用来装小按钮(MenuItem))
let menuBody = $arc.body("我的悬浮球1号") //创建悬浮球按钮容器
.dur(500); //设置展开动画时间
```


### x(x)

> 设置初始位置
> 
> 初始位置决定了悬浮球最开始显示时的位置

- 参数 : x {int} x坐标
- 返回 : {MenuBody} 自己
- 版本 : 1.0.0


```javascript
//创建按钮容器(用来装小按钮(MenuItem))
let menuBody = $arc.body("我的悬浮球1号") //创建悬浮球按钮容器
.x(300); //设置初始位置
```


### y(y)

> 设置初始位置
> 
> 初始位置决定了悬浮球最开始显示时的位置

- 参数 : y {int} y坐标
- 返回 : {MenuBody} 自己
- 版本 : 1.0.0


```javascript
//创建按钮容器(用来装小按钮(MenuItem))
let menuBody = $arc.body("我的悬浮球1号") //创建悬浮球按钮容器
.y(500); //设置初始位置
```


# MenuItem - 悬浮按钮

- 更新时间:2025-12-13 11:58:44

> 悬浮按钮
> 
> 一个悬浮球中只能有一个容器，而一个容器可以添加多个悬浮小按钮，容器用来控制按钮的展开与关闭动画，而按钮主要是用于功能交互。




### style(style)

> 设置样式
> 
> 注意：此方法必须要优先调用!因为会重置其他设置的所有属性

- 参数 : style {String} 按钮样式(default,outline,tonal)
- 返回 : {MenuItem} 自己
- 版本 : 1.0.0


```javascript
//先创建小按钮
let item = $arc.item("logo_ag") //创建一个按钮
.style("outline"); //(优先调用)设置样式
```


### click(click)

> 设置点击事件
> 
> 当小按钮被点击的时候会执行其中的回调函数

- 参数 : click {()=>{}} 回调函数
- 返回 : {MenuItem} 自己
- 版本 : 1.0.0


```javascript
//先创建小按钮
let item = $arc.item("logo_ag");//图标资源名称或者图标的相对路径
//设置点击事件
item.click(()=>{
    //点击事件
    info("我被点击了");
});
```


### ripper(color)

> 设置涟漪颜色
> 
> 小按钮被点击时背景阴影会有水波涟漪的效果

- 参数 : color {string} 颜色
- 返回 : {MenuItem} 自己
- 版本 : 1.0.0


```javascript
//先创建小按钮
let item = $arc.item("logo_ag") //创建一个按钮(图标资源名称或者图标的相对路径)
.ripper("#FF0000");//设置涟漪颜色
```


### ripper(color)

> 设置涟漪颜色

- 参数 : color {int} 颜色值
- 返回 : {MenuItem} 自己
- 版本 : 1.0.0


```javascript
//先创建小按钮
let item = $arc.item("logo_ag") //创建一个按钮
.ripper($颜色.红色);//设置涟漪颜色
```


### tip(tip)

> 设置提示
> 
> 按钮被长按的时候就会显示提示文字

- 参数 : tip {string} 提示文字
- 返回 : {MenuItem} 自己
- 版本 : 1.0.0


```javascript
//先创建小按钮
let item = $arc.item("logo_ag") //创建一个按钮
.tip("提示文字");//设置长按提示文字
```


### bg(color)

> 设置背景颜色

- 参数 : color {string} 背景颜色
- 返回 : {MenuItem} 自己
- 版本 : 1.0.0


```javascript
//先创建小按钮
let item = $arc.item("logo_ag") //创建一个按钮
.bg("#FF0000");//设置按钮背景颜色
```


### bg(color)

> 设置背景颜色

- 参数 : color {int} 背景颜色值
- 返回 : {MenuItem} 自己
- 版本 : 1.0.0


```javascript
//先创建小按钮
let item = $arc.item("logo_ag") //创建一个按钮
.bg($颜色.红色); //设置背景颜色值
```


### radius(radius)

> 设置圆角大小

- 参数 : radius {float} 圆角大小
- 返回 : {MenuItem} 自己
- 版本 : 1.0.0


```javascript
//先创建小按钮
let item = $arc.item("logo_ag") //创建一个按钮
.radius(15); //设置圆角弧度大小
```


### icon(resName)

> 设置图标
> 
> 支持内置的icon设置
> 
> 支持路径中的图片(最好是相对于项目路径的)

- 参数 : resName {string} 资源名称或者本地路径
- 返回 : {MenuItem} 自己
- 版本 : 1.0.0


```javascript
//创建一个按钮
let item = $arc.item("ic_code_run"); //创建一个按钮
//设置点击事件
item.click(()=>{
    //点击时我们切换图标(设置图标)
    item.icon("ic_stop");//图标资源名称或者图标的相对路径
});
```


### iconPadding(padding)

> 设置图标内边距

- 参数 : padding {int} 边距
- 返回 : {MenuItem} 自己
- 版本 : 1.0.0


```javascript
//先创建小按钮
let item = $arc.item("logo_ag") //创建一个按钮
.iconPadding(10); //设置图标内边距
```


### iconSize(size)

> 设置图标尺寸

- 参数 : size {int} 尺寸
- 返回 : {MenuItem} 自己
- 版本 : 1.0.0


```javascript
//先创建小按钮
let item = $arc.item("logo_ag") //创建一个按钮
.iconSize(30); //设置按钮大小
```


### cancelIconTint()

> 取消填充颜色
> 
> 此函数等价于：iconTint(null);

- 返回 : {MenuItem} 自己
- 版本 : 1.0.0


```javascript
//先创建小按钮
let item = $arc.item("logo_ag") //创建一个按钮
.cancelIconTint(); //清空图标的颜色
```


### iconTint(color)

> 设置图标填充颜色
> 
> 当颜色值为null时，会取消填充颜色，即：cancelIconTint();

- 参数 : color {string} 颜色
- 返回 : {MenuItem} 自己
- 版本 : 1.0.0


```javascript
//先创建小按钮
let item = $arc.item("logo_ag") //创建一个按钮
.iconTint("#000000"); //设置图标颜色
```


### iconTint(color)

> 设置图标填充颜色

- 参数 : color {int} 颜色值
- 返回 : {MenuItem} 自己
- 版本 : 1.0.0


```javascript
//先创建小按钮
let item = $arc.item("logo_ag") //创建一个按钮
.iconTint($颜色.红色); //设置图标颜色值
```


### getW()

> 获取按钮宽度

- 返回 : {int} 宽度


```javascript
//先创建小按钮
let item = $arc.item("logo_ag");  //创建一个按钮
//获取宽度
item.getW();
//一般获取宽度可以用来设置弧度，例如：
item.setRadius(item.getW()/2);
```


### getH()

> 获取按钮高度

- 返回 : {int} 高度


```javascript
//先创建小按钮
let item = $arc.item("logo_ag");  //创建一个按钮
//获取高度
item.getH();
```


# $arc - 悬浮球

- 更新时间:2025-12-13 11:58:44

> 悬浮球
> 
> 轻松的实现悬浮球菜单效果，并且可以定制每个按钮的样式。




![](./img/407372540692722.gif)

### item(iconName)

> 创建悬浮按钮
> 
> 我们必须要先了解两个概念：容器(MenuBody)和悬浮按钮(MenuItem)；
> 
> 容器可以装多个悬浮按钮，并且可以显示出来。
> 
> 而悬浮按钮中每个按钮都有不一样的样式，所以悬浮按钮用来控制自身的样式。

- 参数 : iconName {string} 图标资源名或本地相对路径 
- 返回 : {MenuItem} 悬浮按钮
- 版本 : 1.0.0


```javascript
//创建悬浮小按钮,可以被容器添加进去
let menu1 = $arc.item("logo_ag");//内置图标资源名称或者本地自定义图片相对路径
//之后可以创建容器并且显示，例如：
$arc.body("悬浮球1号").add(menu1).show();
//如果有多个悬浮小按钮：
let menu01 = $arc.item("logo_ag");
let menu02 = $arc.item("ic_color");
$arc.body("悬浮球2号").add(menu01).add(menu02).show();
```


### body(name)

> 创建容器
> 
> 容器主要用来控制显示和关闭的，它可以装入多个悬浮按钮，之后显示出来。
> 
> 需要注意：如果悬浮球菜单已经存在了，那么将无法显示第二个名称相同的悬浮球。

- 参数 : name {string} 名称 
- 返回 : {MenuBody} 容器
- 版本 : 1.0.0


```javascript
//创建悬浮按钮容器,用于存放多个小按钮，并且显示
let mBody01 = $arc.body("悬浮球1号");//指定一个名称，方便后面根据名称关闭
//添加一个按钮并且显示，例如：
mBody01.add($arc.item("logo_ag"));
```


### has(name)

> 判断悬浮球是否存在

- 参数 : name {string} 名称 
- 返回 : {boolean} 是否存在
- 版本 : 1.0.0


```javascript
if($arc.has("悬浮球1号")){
    toast("悬浮球1号存在");
}
```


### close(name)

> 关闭
> 
> 根据容器的名称来关闭容器

- 参数 : name {string} 名称 
- 版本 : 1.0.0


```javascript
$arc.close("悬浮球1号");
```


### closeAll()

> 关闭全部
> 
> 将所有创建的悬浮球都关闭掉

- 版本 : 1.0.0


```javascript
//关闭全部悬浮球(容器)
$arc.closeAll();
```


# $bus - 消息总线

- 更新时间:2025-12-13 11:58:44

> 消息总线
> 
> 在全局中发送消息，任意位置获取并且处理消息




### ls()

> 列出所有监听器

- 返回 : {String[]} 监听器列表
- 版本 : 1.0.0


```javascript
//获得所有监听器列表
let monis = $bus.ls();
log(monis);//[我的监听器1号]
```


### post(name, object)

> 发送一条信息

- 参数 : name {String} 监听器名称 
- 参数 : object {Object} 信息内容 
- 版本 : 1.0.0


```javascript
$bus.post("我的监听器1号","我是数据");
```


### event(name, listener)

> 添加监听

- 参数 : name {string} 监听器名称 
- 参数 : listener {(data)=>{}} 监听器 
- 版本 : 1.0.0


```javascript
$bus.event("我的监听器1号",(data)=>{
    log("获得数据:",data);
    toast(data);
});
```


### close(name)

> 移除监听器

- 参数 : name {string} 名称 
- 版本 : 1.0.0


```javascript
//指定关闭监听器
$bus.close("我的监听器1号");
```


### clear()

> 移除所有监听器

- 版本 : 1.0.0


```javascript
$bus.clear();//关闭所有监听器
```


### stopAll()

> 关闭所有监听器

- 版本 : 1.0.0


```javascript
$bus.stopAll();//关闭所有监听器效果和clear()一样
```


# $canvas - 画布

- 更新时间:2025-12-13 11:58:44

> 画布




### paint()

> 获得一个画笔对象

- 返回 : {paint} 画笔对象
- 版本 : 1.3.1


### paint(color)

> 获得一个画笔对象

- 参数 : color {int} 颜色值，例如：$color.RED
- 返回 : {paint} 画笔对象
- 版本 : 1.3.1


### paint(color)

> 获得一个画笔对象

- 参数 : color {String} 颜色字符串，例如：#ff0000
- 返回 : {paint} 画笔对象
- 版本 : 1.3.1


### rect()

> 创建整数类型矩形

- 返回 : {Rect} 矩形对象


### rect(left, top, right, bottom)

> 创建整数类型矩形

- 参数 : left {int} 左
- 参数 : top {int} 上
- 参数 : right {int} 右
- 参数 : bottom {int} 下
- 返回 : {Rect} 矩形对象


### rectf()

> 创建浮点类型矩形

- 返回 : {RectF} 矩形对象


### rectf(left, top, right, bottom)

> 创建浮点类型矩形

- 参数 : left {float} 左
- 参数 : top {float} 上
- 参数 : right {float} 右
- 参数 : bottom {float} 下
- 返回 : {RectF} 矩形对象


### matrix()

> 获得一个矩阵对象

- 返回 : {Matrix} 路径对象


### matrix(src)

> 获得一个矩阵对象

- 参数 : src {Matrix} 源矩阵对象
- 返回 : {Matrix} 矩阵对象


### create()

> 创建一个画布对象

- 返回 : {XCanvas} 画布对象
- 版本 : 1.3.1


### create(image)

> 创建一个画布对象

- 参数 : image {Image} 图片对象
- 返回 : {XCanvas} 画布对象
- 版本 : 1.3.1


### create(path)

> 创建一个画布对象

- 参数 : path {string} 图片路径
- 返回 : {XCanvas} 画布对象
- 版本 : 1.3.1


### create(image)

> 创建一个画布对象

- 参数 : image {Bitmap} 图片对象
- 返回 : {XCanvas} 画布对象
- 版本 : 1.3.1


### create(w, h)

> 创建一个画布对象

- 参数 : w {int} 画布宽度
- 参数 : h {int} 画布高度
- 返回 : {XCanvas} 画布对象
- 版本 : 1.3.1


# $color - 颜色操作

- 更新时间:2025-12-13 11:58:44

> 颜色操作
> 
> 在$color中内置了很多常用的颜色，并且也有依据当前app主题动态获取对应颜色值的函数，尤其是在ui开发的过程中使用较多。
> 
> $color主要用来解析颜色，对比颜色，获取亮色暗色，为颜色设置透明度等等功能。




### const {int} BLACK;

> 黑色


### const {int} DGRAY;

> 深灰色


### const {int} GRAY;

> 灰色


### const {int} LGRAY;

> 浅灰色


### const {int} WHITE;

> 白色


### const {int} RED;

> 红色


### const {int} GREEN;

> 绿色


### const {int} BLUE;

> 蓝色


### const {int} YELLOW;

> 黄色


### const {int} CYAN;

> 青色


### const {int} MAGENTA;

> 品红


### const {int} TRANSPARENT;

> 透明


### find(img, color, threshold, region)

> 查找颜色的位置

- 参数 : img {Image} 在指定图片中找色 
- 参数 : color {String} 颜色值 
- 参数 : threshold {int} 阈值 
- 参数 : region {double[]} 范围 
- 返回 : {Point} 找到颜色的位置
- 版本 : 1.0.0


```javascript
//(1)截屏
let img = $screen.getScreen();
//(2)在屏幕上找到颜色
let point = $color.find(img, "#a55978", 5, [300,200,500,500]);
if (point != null) {
    //绘制出颜色的位置
    $draw.cross(point);
    sleep(3000);
}
img.close(); //回收截屏图片
$draw.closeAll(); //关闭绘制
```


### find(img, color, threshold)

> 查找颜色的位置

- 参数 : img {Image} 在指定图片中找色 
- 参数 : color {String} 颜色值 
- 参数 : threshold {int} 阈值 
- 返回 : {Point} 找到颜色的位置
- 版本 : 1.0.0


```javascript
//(1)截屏
let img = $screen.getScreen();
//(2)在屏幕上找到颜色
let point = $color.find(img, "#a55978", 5);
if (point != null) {
    //绘制出颜色的位置
    $draw.cross(point);
    sleep(3000);
}
img.close(); //回收截屏图片
$draw.closeAll(); //关闭绘制
```


### find(img, color)

> 查找颜色的位置

- 参数 : img {Image} 在指定图片中找色 
- 参数 : color {String} 颜色值 
- 返回 : {Point} 找到颜色的位置
- 版本 : 1.0.0


```javascript
//(1)截屏
let img = $screen.getScreen();
//(2)在屏幕上找到颜色
let point = $color.find(img, "#a55978");
if (point != null) {
    //绘制出颜色的位置
    $draw.cross(point);
    sleep(3000);
}
img.close(); //回收截屏图片
$draw.closeAll(); //关闭绘制
```


### findAll(img, color, threshold, region)

> 查找颜色所有的位置

- 参数 : img {Image} 在指定图片中找色 
- 参数 : color {String} 颜色值 
- 参数 : threshold {int} 阈值 
- 参数 : region {double[]} 范围 
- 返回 : {Point[]} 找到颜色的位置
- 版本 : 1.0.0


```javascript
let screenImg = $screen.getScreen();
let result = $color.findAll(screenImg,"#d28384",5,[]);
if(result!=null){
    for(let index of result){
        $draw.dot(index);//绘制位置的点
        $draw.log(index);//屏幕显示位置
        sleep(300);
    }
    //3秒后关闭悬浮绘制
    sleep(5000);
    $draw.closeAll();
}
```


### findAll(img, color, threshold)

> 查找颜色所有的位置

- 参数 : img {} 在指定图片中找色 
- 参数 : color {String} 颜色值 
- 参数 : threshold {int} 阈值 
- 返回 : {Point[]} 找到颜色的位置
- 版本 : 1.0.0


```javascript
let screenImg = $screen.getScreen();
let result = $color.findAll(screenImg,"#d28384",5);
if(result!=null){
    for(let index of result){
        $draw.dot(index);//绘制位置的点
        $draw.log(index);//屏幕显示位置
        sleep(300);
    }
    //3秒后关闭悬浮绘制
    sleep(5000);
    $draw.closeAll();
}
```


### findAll(img, color)

> 查找颜色所有的位置

- 参数 : img {} 在指定图片中找色 
- 参数 : color {String} 颜色值 
- 返回 : {Point[]} 找到颜色的位置
- 版本 : 1.0.0


```javascript
let screenImg = $screen.getScreen();
let result = $color.findAll(screenImg,"#d28384");
if(result!=null){
    for(let index of result){
        $draw.dot(index);//绘制位置的点
        $draw.log(index);//屏幕显示位置
        sleep(300);
    }
    //3秒后关闭悬浮绘制
    sleep(5000);
    $draw.closeAll();
}
```


### similar(c1, c2)

> 计算相似度

- 参数 : c1 {string|int} 颜色1 
- 参数 : c2 {string|int} 颜色2 
- 返回 : {double} 相似度
- 版本 : 1.0.0


```javascript
//计算相似度
let result = $color.similar("#1E1F22","#2B2D30");
log("相似度",result);
```


### similar(c1, c2)

> 计算相似度

- 参数 : c1 {string|int} 颜色1 
- 参数 : c2 {string|int} 颜色2 
- 返回 : {double} 相似度
- 版本 : 1.0.0


```javascript
//计算相似度
let result = $color.similar("#1E1F22","#2B2D30");
log("相似度",result);
```


### similar(c1, c2)

> 计算相似度

- 参数 : c1 {string|int} 颜色1 
- 参数 : c2 {string|int} 颜色2 
- 返回 : {double} 相似度
- 版本 : 1.0.0


```javascript
//计算相似度
let result = $color.similar("#1E1F22","#2B2D30");
log("相似度",result);
```


### similar(c1, c2)

> 计算相似度

- 参数 : c1 {string|int} 颜色1 
- 参数 : c2 {string|int} 颜色2 
- 返回 : {double} 相似度
- 版本 : 1.0.0


```javascript
//计算相似度
let result = $color.similar("#1E1F22","#2B2D30");
log("相似度",result);
```


### toString(color)

> 颜色值转换为8位字符

- 参数 : color {int} 颜色 
- 返回 : {string} 字符串颜色
- 版本 : 1.0.0


```javascript
//转为#00000000
let color = $color.toString(-166780);
```


### str(color)

> 颜色值转6位字符

- 参数 : color {int} 颜色值 
- 返回 : {string} 颜色
- 版本 : 1.0.0


```javascript
//转为#000000
let color = $color.str(-166780);
```


### parse(r, g, b)

> 解析rgb的颜色值

- 参数 : r {int} 红 
- 参数 : g {int} 绿 
- 参数 : b {int} 蓝 
- 返回 : {int} 颜色值
- 版本 : 1.0.0


```javascript
let color = $color.parse(105,78,230);
```


### parse(color)

> 解析颜色值
> 
> 该函数内置了M3风格主题的动态主题颜色，可以通过传入对应的主题字符串来获取对应的颜色值

- 参数 : color {string} 颜色 
- 返回 : {int} 颜色值
- 版本 : 1.0.0


```javascript
//解析颜色值
let colorValue = $color.parse("#1E1F22");
log("颜色值",colorValue);
//除了上面的常规使用方法你也可以用$color动态获取主题颜色
//获取颜色值(返回int类型的颜色值)
let color = $color.parse("white");
let color = $color.parse("black");
let color = $color.parse("null");
let color = $color.parse("none");
let color = $color.parse("green");
let color = $color.parse("red");
let color = $color.parse("blue");
let color = $color.parse("yellow");
//主题颜色值(返回int类型的颜色值)
let color = $color.parse("colorPrimary");//(常用)一般是主题最明显的颜色：蓝色主题一般呈现蓝色
let color = $color.parse("colorSurface");//(常用)一般是背景颜色：亮色主题一般呈现白色，暗色主题一般呈现黑色
let color = $color.parse("colorOnSurface");//(常用)一般是文字颜色：亮色主题一般呈现黑色，暗色主题一般呈现白色
let color = $color.parse("colorOnPrimary");
let color = $color.parse("colorPrimaryContainer");
let color = $color.parse("colorOnPrimaryContainer");
let color = $color.parse("colorSecondary");
let color = $color.parse("colorOnSecondary");
let color = $color.parse("colorSecondaryContainer");
let color = $color.parse("colorOnSecondaryContainer");
let color = $color.parse("colorTertiary");
let color = $color.parse("colorOnTertiary");
let color = $color.parse("colorTertiaryContainer");
let color = $color.parse("colorOnTertiaryContainer");
let color = $color.parse("colorError");
let color = $color.parse("colorErrorContainer");
let color = $color.parse("colorOnErrorContainer");
let color = $color.parse("colorOnBackground");
let color = $color.parse("colorSurfaceVariant");
let color = $color.parse("colorOnSurfaceVariant");
let color = $color.parse("colorOutline");
let color = $color.parse("colorOutlineVariant");
let color = $color.parse("colorPrimaryInverse");
```


### setAlpha(color, alpha)

> 设置颜色的透明度

- 参数 : color {int} 颜色值 
- 参数 : alpha {int} 透明度(0-255)  
- 返回 : {int} 颜色值
- 版本 : 1.4.3


```javascript
//解析颜色值
let colorValue = $color.parse("#1E1F22");
//设置颜色的透明度
let color = $color.setAlpha(colorValue,100);
```


### brighter(color)

> 获取较亮颜色

- 参数 : color {int} 颜色值 
- 返回 : {int} 颜色值
- 版本 : 1.4.3


```javascript
//解析颜色值
let colorValue = $color.parse("#1E1F22");
//获取较亮颜色
let color = $color.brighter(colorValue);
```


### darker(color)

> 获取较暗颜色值

- 参数 : color {int} 颜色值 
- 返回 : {int} 颜色值
- 版本 : 1.4.3


```javascript
//解析颜色值
let colorValue = $color.parse("#1E1F22");
//获取较暗颜色值
let color = $color.darker(colorValue);
```


### rgb(red, green, blue)

> 通过RGB通道获得颜色值

- 参数 : red {int} R通道 
- 参数 : green {int} G通道 
- 参数 : blue {int} B通道 
- 返回 : {int} 颜色值
- 版本 : 1.0.0


```javascript
let color = $color.rgb(105,78,230);
```


### argb(alpha, red, green, blue)

> 通过ARGB通道获得颜色值

- 参数 : alpha {int} A通道 
- 参数 : red {int} R通道 
- 参数 : green {int} G通道 
- 参数 : blue {int} B通道 
- 返回 : {int} 颜色值
- 版本 : 1.0.0


```javascript
let color = $color.argb(255,105,78,230);
```


### a(color)

> 计算[A通道]的值

- 参数 : color {String} 颜色 
- 返回 : {int} 数值
- 版本 : 1.0.0


```javascript
let a = $color.a("#357C94");
```


### r(color)

> 计算[R通道]的值

- 参数 : color {String} 颜色 
- 返回 : {int} 数值
- 版本 : 1.0.0


```javascript
let r = $color.r("#357C94");
```


### g(color)

> 计算[G通道]的值

- 参数 : color {String} 颜色 
- 返回 : {int} 数值
- 版本 : 1.0.0


```javascript
let g = $color.g("#357C94");
```


### b(color)

> 计算[B通道]的值

- 参数 : color {String} 颜色 
- 返回 : {int} 数值
- 版本 : 1.0.0


```javascript
let b = $color.b("#357C94");
```


### equals(c1, c2)

> 比较两个颜色

- 参数 : c1 {string|int} 颜色1 
- 参数 : c2 {string|int} 颜色2 
- 返回 : {boolean} 是否相等
- 版本 : 1.0.0


```javascript
let color = "#1E1F22";
let colorValue =-14803166;
let same = $color.equals(color,colorValue);
if(same){
    toast("颜色相同");
}else{
    toast("颜色不同");
}
```


### equals(c1, c2)

> 比较两个颜色

- 参数 : c1 {string|int} 颜色1 
- 参数 : c2 {string|int} 颜色2 
- 返回 : {boolean} 是否相等
- 版本 : 1.0.0


```javascript
let color = "#1E1F22";
let colorValue =-14803166;
let same = $color.equals(color,colorValue);
if(same){
    toast("颜色相同");
}else{
    toast("颜色不同");
}
```


### equals(c1, c2)

> 比较两个颜色

- 参数 : c1 {string|int} 颜色1 
- 参数 : c2 {string|int} 颜色2 
- 返回 : {boolean} 是否相等
- 版本 : 1.0.0


```javascript
let color = "#1E1F22";
let colorValue =-14803166;
let same = $color.equals(color,colorValue);
if(same){
    toast("颜色相同");
}else{
    toast("颜色不同");
}
```


### equals(c1, c2)

> 比较两个颜色

- 参数 : c1 {string|int} 颜色1 
- 参数 : c2 {string|int} 颜色2 
- 返回 : {boolean} 是否相等
- 版本 : 1.0.0


```javascript
let color = "#1E1F22";
let colorValue =-14803166;
let same = $color.equals(color,colorValue);
if(same){
    toast("颜色相同");
}else{
    toast("颜色不同");
}
```


### isDarkTheme()

> 是否是黑暗主题
> 

- 返回 : {boolean} 是否是深色主题


```javascript
let isDark = $color.isDarkTheme();
if(isDark){
    toast("黑暗主题");
}else{
    toast("亮色主题");
}
```


### isColor(colorStr)

> 判断颜色格式是否正确

- 参数 : colorStr {string} 颜色字符串 
- 返回 : {boolean} 是否是正确的颜色格式
- 版本 : 1.4.3


```javascript
let isColor = $color.isColor("#1E1F22");
if(isColor){
    toast("颜色格式正确");
}else{
    toast("颜色格式错误");
}
```


# $crypt - 加密算法

- 更新时间:2025-12-13 11:58:44

> 加密算法




### fromBase64(data)

> base64解码

- 参数 : data {string} base64编码的字符串
- 返回 : {string} 解码后的字符串
- 版本 : 1.0.0


### toBase64(data)

> base64编码

- 参数 : data {byte[]} 要编码的字节
- 返回 : {string} 编码后的字符串
- 版本 : 1.0.0


### toBase64(data)

> base64编码

- 参数 : data {string} 要编码的字符串
- 返回 : {string} 编码后的字符串
- 版本 : 1.0.0


### toBase64(data, encoding)

> base64编码

- 参数 : data {string} 要编码的字符串
- 参数 : encoding {string} 编码格式
- 返回 : {string} 编码后的字符串
- 版本 : 1.0.0


### aesKey()

> 生成一个AES加密的key

- 返回 : {string} key
- 版本 : 1.0.0


### aesJiami(data, key)

> AES加密字符串

- 参数 : data {string} 要加密的字符串
- 参数 : key {string} aes的密钥
- 返回 : {string} 加密后的字符串
- 版本 : 1.0.0


### aesJiemi(data, key)

> AES解密字符串

- 参数 : data {string} 要解密的字符串
- 参数 : key {string} aes的密钥
- 返回 : {string} 解密后的字符串
- 版本 : 1.0.0


### md5Key(size)

> 生成一个MD5加密的salt(盐值)

- 参数 : size {int} 长度
- 返回 : {byte[]} salt
- 版本 : 1.0.0


### md516(salt, data)

> md5加密

- 参数 : salt {byte[]} 盐值
- 参数 : data {string} 数据
- 返回 : 16位的MD5值
- 版本 : 1.0.0


### md532(salt, data)

> md5加密

- 参数 : salt {byte[]} 盐值
- 参数 : data {string} 数据
- 返回 : 32位的MD5值
- 版本 : 1.0.0


### digest(message, algorithm, options)

> 摘要

- 参数 : message {File|String|byte[]} 消息
- 参数 : algorithm {string} 算法
- 参数 : options {object} 选项
- 返回 : 摘要
- 版本 : 1.0.0


```javascript
//MD5加密
let result = $crypt.digest("我是你爸爸","md5",{
    input:"string",
    output:"hex"
});
log(result);
```


### md5(message, options)

> 摘要

- 参数 : message {File|String|byte[]} 消息
- 参数 : options {object} 选项
- 返回 : 摘要
- 版本 : 1.0.0


```javascript
//MD5加密
let result = $crypt.md5("我是加密的内容",{
    input:"string",
    output:"hex"
});
log(result);//a4f2086496066b767f9667d4737047b7
```


### sign(data, key, algorithm, options)

> 签名

- 参数 : data {File|String|byte[]}  签名的输入数据
- 参数 : key {CryptKey}   签名的密钥
- 参数 : algorithm {string} 签名的算法
- 参数 : options {object} 签名的选项
- 返回 : {object} 签名结果
- 版本 : 1.0.0


```javascript
//生成密钥对
let keyPair = $crypt.generateKeyPair("DSA", 1024);
log(keyPair)
log("签名:"); //数字签名只能用私钥进行签名
let signData = $crypt.sign("我是被签名的内容", keyPair.privateKey, "DSA", {
    input: "string",
    output: "byte"
});
log("验证:"); //数字签名只能用公钥进行验证
let verified = $crypt.verify("我是被签名的内容",signData, keyPair.publicKey, "DSA", {
    //输入文本的类型
    input: "string",
    output: "byte"
},{
    //输入签名的类型
    input: "byte",
});
log("验证结果:", verified);
```


### verify(msg_data, msg_sign, key, algorithm, optionsObj_data, optionsObj_sign)

> 验证

- 参数 : msg_data {object}   签名数据
- 参数 : msg_sign {object}  签名结果
- 参数 : key {CryptKey}    密钥
- 参数 : algorithm {string}   算法
- 参数 : optionsObj_data {object} 验证选项
- 参数 : optionsObj_sign {object}签名选项
- 返回 : 验证结果
- 版本 : 1.0.0


### digests()

> 获得所有摘要算法的名称

- 返回 : {string[]} 摘要算法的名称
- 版本 : 1.0.0


```javascript
//获得所有哈希算法的名称
let digests = $crypt.digests();
//每个算法都用一遍
for (let i = 0; i < digests.size(); i ++) {
    let result = $crypt.digest("我是加密的内容", digests.get(i), {
        input: "string",
        output: "hex"
    });
    log(result);
}
```


### digestFile(path, algorithm, options)

> 摘要文件

- 参数 : path {string} 文件路径
- 参数 : algorithm {string} 算法
- 参数 : options {object} 选项
- 返回 : {string|byte[]} 摘要
- 版本 : 1.0.0


### jiami(data, key, algorithm, options)

> 加密

- 参数 : data {object} 数据
- 参数 : key {object} 密钥
- 参数 : algorithm {string} 算法
- 参数 : options {object} 选项
- 返回 : {string|byte[]} 加密结果
- 版本 : 1.0.0


```javascript
//对称加密算法
//准备一个长度为16的密钥
let key = "ACSDFGHJUYDLOPSD";
let text = "我是被加密的明文";
log("AES加密");
let result = $crypt.jiami(text,key,"AES",{
input:"string",
output:"base64"
});
log("加密后：",result)
result = $crypt.jiemi(result,key,"AES",{
input:"base64",
output:"string"
});
log("解密后：",result)
```


### jiami(data, key, algorithm)

> 加密

- 参数 : data {object} 数据
- 参数 : key {object} 密钥
- 参数 : algorithm {string} 算法
- 返回 : {string|byte[]} 加密结果
- 版本 : 1.0.0


### jiemi(data, key, algorithm, options)

> 解密

- 参数 : data {object} 数据
- 参数 : key {object} 密钥
- 参数 : algorithm {string} 算法
- 参数 : options {object} 选项
- 返回 : {string|byte[]} 解密结果
- 版本 : 1.0.0


### jiemi(data, key, algorithm)

> 解密

- 参数 : data {object} 数据
- 参数 : key {object} 密钥
- 参数 : algorithm {string} 算法
- 返回 : {string|byte[]}  解密结果
- 版本 : 1.0.0


### key(data)

> 构建密钥对象

- 参数 : data {string|byte[]} 密钥数据
- 返回 : {CryptKey} 密钥
- 版本 : 1.0.0


### key(data)

> 生成密钥

- 参数 : data {String} 密钥数据
- 返回 : {CryptKey} 密钥
- 版本 : 1.0.0


### key(data)

> 生成密钥

- 参数 : data {byte[]} 密钥数据
- 返回 : {CryptKey} 密钥
- 版本 : 1.0.0


### keyPair(publicKey, privateKey)

> 构造密钥对

- 参数 : publicKey {byte[] | base64} 公钥
- 参数 : privateKey {byte[] | base64} 私钥
- 返回 : {CryptKeyPair}  密钥对
- 版本 : 1.0.0


### keyPair(publicKey, privateKey)

> 从字节数组当中构造一个keyPair

- 参数 : publicKey {byte[] | base64}  公钥
- 参数 : privateKey {byte[] | base64}  私钥
- 返回 : 密钥对
- 版本 : 1.0.0


### generateKeyPair(algorithm)

> 生成密钥对

- 参数 : algorithm {string} 算法
- 返回 : {CryptKeyPair} 密钥对
- 版本 : 1.0.0


### generateKeyPair(algorithm, length)

> 生成密钥对

- 参数 : algorithm {string} 算法
- 参数 : length {int}  长度
- 返回 : {CryptKeyPair} 密钥对
- 版本 : 1.0.0


# DateInfo - 日期信息

- 更新时间:2025-12-13 11:58:44

> 日期信息




### const {long} stamp;

> 时间戳


```javascript
//获取日期信息
let info = $date.info();
log(info.stamp);//时间戳
log(info.year);//年
log(info.month);//月
log(info.day);//日
log(info.week);//星期
log(info.hour);//时
log(info.min);//分
log(info.sec);//秒
log(info.mil);//毫秒
```


### const {int} year;

> 年


### const {int} month;

> 月


### const {int} day;

> 日


### const {int} week;

> 星期


### const {int} hour;

> 时


### const {int} min;

> 分


### const {int} sec;

> 秒


### const {int} mil;

> 毫秒


### getStamp()

> 获得时间戳

- 返回 : {long} 时间戳


```javascript
let info = $date.info("2025/12/08 12-35-24");
log(info.getStamp());
```


### getYear()

> 获得年

- 返回 : {int} 年


```javascript
let info = $date.info("2025/12/08 12-35-24");
log(info.getYear());
```


### getMonth()

> 获得月

- 返回 : {int} 月


```javascript
let info = $date.info("2025/12/08 12-35-24");
log(info.getMonth());
```


### getDay()

> 获得日

- 返回 : {int} 日


```javascript
let info = $date.info("2025/12/08 12-35-24");
log(info.getDay());
```


### getWeek()

> 获得星期

- 返回 : {int} 星期


```javascript
let info = $date.info("2025/12/08 12-35-24");
log(info.getWeek());
```


### getHour()

> 获得时

- 返回 : {int} 时


```javascript
let info = $date.info("2025/12/08 12-35-24");
log(info.getHour());
```


### getMin()

> 获得分

- 返回 : {int} 分


```javascript
let info = $date.info("2025/12/08 12-35-24");
log(info.getMin());
```


### getSec()

> 获得秒

- 返回 : {int} 秒


```javascript
let info = $date.info("2025/12/08 12-35-24");
log(info.getSec());
```


### getMil()

> 获得毫秒

- 返回 : {int} 毫秒


```javascript
let info = $date.info("2025/12/08 12-35-24");
log(info.getMil());
```


### json()

> 转换为JSON字符串

- 返回 : {string} JSON字符串


# $date - 日期工具

- 更新时间:2025-12-13 11:58:44

> 日期工具




### dt()

> 当前日期时间字符串
> 
> 函数名称dt表示dateTime的缩写

- 返回 : {string} 日期时间字符串,格式为:yyyy-MM-dd HH:mm:ss
- 版本 : 1.1.4


```javascript
let dateStr = $date.dt();
alert("日期",dateStr);//2025-10-25 18:32:53
```


### dt(time)

> 当前日期时间字符串
> 
> 指定时间戳,获得日期和时间的字符串
> 
> 函数名称dt表示dateTime的缩写

- 参数 : time {number} 时间戳
- 返回 : {string} 日期时间字符串,格式为:yyyy-MM-dd HH:mm:ss
- 版本 : 1.1.4


```javascript
let dateStr = $date.dt(1747985594110);
alert("日期",dateStr);
```


### dt(time)

> 当前日期时间字符串
> 
> 指定时间字符串,获得日期和时间的字符串
> 
> 函数名称dt表示dateTime的缩写

- 参数 : time {string} 时间字符串
- 返回 : {string} 日期时间字符串,格式为:yyyy-MM-dd HH:mm:ss
- 版本 : 1.1.4


```javascript
let dateStr = $date.dt("2025/12/08 12/35/24");
alert("日期",dateStr);//2025-12-08 12:35:24
```


### d()

> 当前日期字符串
> 
> 函数名称d表示date的缩写

- 返回 : {string} 日期字符串,格式为:yyyy-MM-dd
- 版本 : 1.1.4


```javascript
let dateStr = $date.d();
alert("日期",dateStr);//2025-05-23
```


### d(time)

> 当前日期字符串
> 
> 指定时间戳,获得日期的字符串
> 
> 函数名称d表示date的缩写

- 参数 : time {number} 时间戳
- 返回 : {string} 日期字符串,格式为:yyyy-MM-dd
- 版本 : 1.1.4


```javascript
let dateStr = $date.d(1747985594110);
alert("日期",dateStr);//2025-05-23
```


### parse(dateStr, pattern)

> 解析日期

- 参数 : dateStr {string} 日期字符串
- 参数 : pattern {string} 日期格式
- 返回 : {Date} 日期对象
- 版本 : 1.1.4


```javascript
//时间字符串的格式和后面解析模板的格式保持一致
//这样才能解析成功
let date = $date.parse("2025/12/08 12/35/24","yyyy/MM/dd HH/mm/ss");
alert("日期对象",date);//Dec 8, 2025 12:35:24 PM
```


### parse(dateStr)

> 解析日期
> 
> 内部预制了27种字符串的情况,自动使用这些情况的模板去匹配日期字符串
> 
> 如果解析失败,返回null

- 参数 : dateStr {string} 日期字符串
- 返回 : {Date} 日期对象
- 版本 : 1.1.4


```javascript
//自动解析
let date = $date.parse("2025/12/08 12/35/24");
alert("日期",date);//Mon Dec 08 12:35:24 GMT+08:00 2025
```


### info()

> 获取日期信息
> 
> 将当前日期的各个字段都分析出来,并且返回

- 返回 : {DateInfo} 日期信息对象
- 版本 : 1.1.4


```javascript
//获取当前日期信息
let info = $date.info();
alert("日期",info);
```


### info(time)

> 获取指定时间日期信息
> 
> 指定time时间,并且获得这个时间的所有信息

- 返回 : {DateInfo} 日期信息对象
- 版本 : 1.1.4


```javascript
//解析指定时间戳的日期信息
let info = $date.info(1747985594110);
alert("日期",info);
```


### info(time)

> 获取指定时间日期信息
> 
> 指定字符串时间,并且获得这个时间的所有信息

- 参数 : time {string}  时间字符串
- 返回 : {DateInfo} 日期信息对象
- 版本 : 1.1.4


```javascript
//解析指定时间戳的日期信息
let info = $date.info("2025/12/08 12-35-24");
alert("日期",info);
```


### format(time, pattern)

> 格式化日期

- 参数 : time {long} 时间戳
- 参数 : pattern {string} 日期格式
- 返回 : {string} 日期字符串
- 版本 : 1.1.4


```javascript
//第一个参数:日期时间戳
//第二个参数:自己想要的格式
let info = $date.format(1747985594110,"yyyy年MM月dd日 HH时mm分ss秒");
alert("日期",info);//2025年05月23日 15时33分14秒
```


### format(date, pattern)

> 格式化日期

- 参数 : date {Date} 日期
- 参数 : pattern {string} 日期格式
- 返回 : {string} 日期字符串
- 版本 : 1.1.4


```javascript
let date = new java.util.Date();
let info = $date.format(date,"yyyy年MM月dd日 HH时mm分ss秒");
alert("日期",info);//2025年05月23日 15时59分50秒
```


### format(dateStr, pattern)

> 格式化日期

- 参数 : dateStr {string} 标准日期字符串
- 参数 : pattern {string} 日期格式,自定义的字符串
- 返回 : {string} 日期字符串
- 版本 : 1.1.4


```javascript
//第一个参数:比较乱的日期字符串
//第二个参数:自己想要的格式
let info = $date.format("2025/12/08 12-35-24","yyyy年MM月dd日 HH时mm分ss秒");
alert("日期",info);//2025年12月08日 12时35分24秒
```


### date()

> 创建日期
> 
> 从当前时间创建一个日期对象

- 返回 : {Date} 当前日期
- 版本 : 1.1.4


```javascript
let info = $date.date();
alert("日期",info);//Fri May 23 15:56:07 GMT+08:00 2025
```


### date(time)

> 创建日期
> 
> 从指定时间戳中创建日期对象

- 参数 : time {long} 时间戳
- 返回 : {Date} 当前日期
- 版本 : 1.1.4


```javascript
let info = $date.date(1747985594110);
alert("日期",info);//Fri May 23 15:33:14 GMT+08:00 2025
```


### date(dateStr)

> 创建日期
> 
> 从字符串中创建日期对象，效果和parse(str)一样，内部预制了27种字符串的情况,自动使用这些情况的模板去匹配日期字符串，如果解析失败,返回null

- 参数 : dateStr {string} 日期字符串
- 返回 : {Date} 日期对象
- 版本 : 1.1.4


```javascript
let info = $date.date("2025/12/08 12-35-24");
alert("日期",info);//Mon Dec 08 12:35:24 GMT+08:00 2025
```


### dur(milliseconds)

> 将毫秒数转换为时间字符串 "x天x时x分x秒"

- 参数 : milliseconds {long}  毫秒数
- 返回 : {string} 格式化的时间字符串
- 版本 : 1.6.1


```javascript
let info = $date.dur(1234567890);
alert("日期",info);//14天6时56分7秒
```


### curTime()

> 获取当前时间戳

- 返回 : {long} 时间戳
- 版本 : 1.7.8


```javascript
let timestamp = $date.curTime();
alert("时间戳",timestamp);
```


# $device - 设备信息

- 更新时间:2025-12-13 11:58:44

> 设备信息




### const {int} width;

> 屏幕的宽度


### const {int} height;

> 屏幕的高度


### const {String} buildId;

> Build ID


### const {String} buildDisplay;

> Build Display


### const {String} product;

> 产品名称


### const {String} board;

> 主板名称


### const {String} brand;

> 品牌名称


### const {String} device;

> 设备名称


### const {String} model;

> 型号名称


### const {String} bootloader;

> 引导加载程序名称


### const {String} hardware;

> 硬件名称


### const {String} fingerprint;

> 指纹信息


### const {int} sdkInt;

> SDK版本号


### const {String} incremental;

> 内部版本号


### const {String} release;

> Android版本号


### const {String} code;

> 开发代号


### const {String} serial;

> 序列号


### const {String} baseOS;

> 基础操作系统版本
> 
> 仅在Android 6.0及更高版本中有效


### const {String} securityPatch;

> 安全补丁版本
> 
> 仅在Android 6.0及更高版本中有效


### getIMEI()

> 获取IMEI号码

- 返回 : {string} IMEI号码
- 版本 : 1.0.0


```javascript
log("IMEI:", $device.getIMEI());
```


### getAndroidId()

> 获取Android ID

- 返回 : {string} Android ID
- 版本 : 1.0.0


```javascript
log("Android ID:", $device.getAndroidId());
```


### getBrightness()

> 获取屏幕亮度

- 返回 : {int} 屏幕亮度
- 版本 : 1.0.0


```javascript
log("屏幕亮度:", $device.getBrightness());
```


### getBrightnessMode()

> 获取屏幕亮度模式

- 返回 : {int} 亮度模式
- 版本 : 1.0.0


```javascript
log("屏幕亮度模式:", $device.getBrightnessMode());
```


### getMusicVolume()

> 获取音乐音量

- 返回 : {int} 音乐音量值
- 版本 : 1.0.0


```javascript
log("音乐音量:", $device.getMusicVolume());
```


### getNotificationVolume()

> 获取通知音量

- 返回 : {int} 通知音量值
- 版本 : 1.0.0


```javascript
log("通知音量:", $device.getNotificationVolume());
```


### getAlarmVolume()

> 获取闹钟音量

- 返回 : {int} 闹钟音量值
- 版本 : 1.0.0


```javascript
log("闹钟音量:", $device.getAlarmVolume());
```


### getMusicMaxVolume()

> 获取音乐最大音量

- 返回 : {int} 音乐最大音量值
- 版本 : 1.0.0


```javascript
log("音乐最大音量:", $device.getMusicMaxVolume());
```


### getNotificationMaxVolume()

> 获取通知最大音量

- 返回 : {int} 通知最大音量值
- 版本 : 1.0.0


```javascript
log("通知最大音量:", $device.getNotificationMaxVolume());
```


### getAlarmMaxVolume()

> 获取闹钟最大音量

- 返回 : {int} 闹钟最大音量值
- 版本 : 1.0.0


```javascript
log("闹钟最大音量:", $device.getAlarmMaxVolume());
```


### getBattery()

> 电池电量百分比

- 返回 : {int} 电池电量百分比
- 版本 : 1.0.0


```javascript
log("电池电量百分比:", $device.getBattery());
```


### getTotalMem()

> 获取总内存

- 返回 : {long} 总内存大小，单位为字节
- 版本 : 1.0.0


```javascript
log("总内存:", $device.getTotalMem());
```


### getAvailMem()

> 获取可用内存

- 返回 : {long} 可用内存大小，单位为字节
- 版本 : 1.0.0


```javascript
log("可用内存:", $device.getAvailMem());
```


### isCharging()

> 是否正在充电

- 返回 : {boolean} 如果设备正在充电则返回true，否则返回false
- 版本 : 1.0.0


```javascript
log("是否正在充电:", $device.isCharging());
```


### isScreenOn()

> 判断设备屏幕是否亮起

- 返回 : {boolean} true:亮起
- 版本 : 1.0.0


```javascript
log("是否亮起:", $device.isScreenOn());
```


### isScreenOff()

> 判断设备屏幕是否熄灭

- 返回 : {boolean} true:熄灭
- 版本 : 1.0.0


```javascript
log("是否熄灭:", $device.isScreenOff());
```


### wakeUp()

> 唤醒设备屏幕

- 版本 : 1.0.0


```javascript
// 唤醒设备屏幕
$device.wakeUp();
```


### keepScreenOn()

> 保持设备屏幕常亮

- 版本 : 1.0.0


```javascript
// 保持屏幕常亮
$device.keepScreenOn();
```


### keepScreenOn(timeout)

> 保持设备屏幕常亮一段时间

- 参数 : timeout {long} 保持屏幕常亮的超时时间，单位为毫秒
- 版本 : 1.0.0


```javascript
// 保持屏幕常亮
$device.keepScreenOn(1000);
```


### keepScreenDim()

> 保持设备屏幕处于低亮度状态

- 版本 : 1.0.0


```javascript
// 保持屏幕低亮
$device.keepScreenDim();
```


### keepScreenDim(timeout)

> 保持设备屏幕处于低亮度状态

- 版本 : 1.0.0


```javascript
// 保持屏幕低亮
$device.keepScreenDim(1000);
```


### cancelKeepingAwake()

> 取消保持唤醒

- 版本 : 1.0.0


```javascript
// 取消唤醒
$device.cancelKeepingAwake();
```


### vibrate(millis)

> 震动指定时长

- 参数 : millis {long} 震动的时长，单位:ms
- 版本 : 1.0.0


```javascript
// 震动
$device.vibrate(1000);
```


### cancelVibration()

> 取消震动

- 版本 : 1.0.0


```javascript
// 取消震动
$device.cancelVibration();
```


### getMacAddress()

> 获取 MAC 地址
> 首先尝试从 WifiManager 获取，如果获取到的是伪造的 MAC 地址则视为无效
> 若无效则尝试通过网络接口获取，若还是无效且系统版本大于等于 Android 7.0（N），
> 则尝试从文件中读取

- 返回 : MAC 地址，如果无法获取则返回 null
- 版本 : 1.0.0


```javascript
// 获取mac地址
log("mac地址:",$device.getMacAddress());
```


### hasNavBar()

> 是否存在NavigationBar

- 返回 : {boolean} 是否存在NavigationBar
- 版本 : 1.0.0


```javascript
// 是否存在导航栏
log("是否存在导航栏:",$device.hasNavBar());
```


### getVirtualBarHeight()

> 获取虚拟功能键高度

- 返回 : {int} 虚拟功能键高度
- 版本 : 1.0.0


```javascript
// 导航栏高度
log("导航栏高度:",$device.getVirtualBarHeight());
```


### isLock()

> 判断设备是否锁定

- 返回 : {boolean} 是否锁定
- 版本 : 1.0.0


```javascript
// 设备是否锁定
log("设备是否锁定:",$device.isLock());
```


# $draw - 全屏绘制

- 更新时间:2025-12-13 11:58:44

> 全屏绘制




### 系统限制

在全局绘制框架中，绝大多数情况都会使用到全屏悬浮窗，但是这种方式在部分手机上用户手势会被拦截，这一类现象被称为"卡悬浮"。

```javascript
//这种悬浮窗是小型的，因此不会阻碍到用户手势(无论在任何系统中都适用)
$draw.i("信息");
$draw.d("调试");
$draw.w("警告");
```

经过测试，在MIUI系列的手机中，手机厂家会拦截悬浮窗手势，无论用何种悬浮窗类型，都无效，这是厂家在系统中刻下的基因。

```javascript
//这种悬浮窗是全屏的，对于MIUI的手机(小米红米之类的)会导致拦截用户手势而无法操作界面
$draw.i("信息",100,100);
$draw.d("调试",100,100);
$draw.w("警告",100,100);
$draw.rect(100,100,200,200); //绘制方框
$draw.line(100,100,200,200); //绘制线条
```

全屏绘制类的函数：例如：绘制线、文本、方框等，在ColorOS下(或者大多数国产安卓模拟器)，系统会提示是否允许显示在上层(安卓模拟器大多数默认允许)，经过用户允许之后就可以正常绘制并且不阻碍用户使用手机，
但是在MIUI系统中，没有任何提示，经调试发现该类系统会直接拦截所有用户手势，据了解是为了安全才如此设计。

作为开发者，你必须谨慎使用全局绘制，并不是所有手机都开放了全屏悬浮窗时的触摸事件。

:::tip
在1.8.0版本后，支持在root或者shizuku授权下，会自动尝试解锁卡悬浮，允许悬浮窗的触摸事件到达底层。
:::


### getPermit()

> 获取悬浮窗权限

- 返回 : {boolean} 是否有权限
- 版本 : 1.0.0


```javascript
$draw.getPermit();
```


### rect(rect)

> 绘制一个方框

- 参数 : rect {Rect} opencv的Rect对象
- 版本 : 1.0.0


```javascript
//绘制矩形
let rect = new org.opencv.core.Rect(0,0,100,100);
$draw.rect(rect);
```


### rect(node)

> 绘制一个方框

- 参数 : node {Node} 节点信息
- 版本 : 1.0.0


```javascript
//找到一个节点
let node = $act.selector().textHas("停止").findFirst();
//绘制矩形
$draw.rect(node);
```


### rect(x, y, w, h)

> 绘制一个方框

- 参数 : x {int} 起点x
- 参数 : y {int} 起点y
- 参数 : w {int} 宽度
- 参数 : h {int} 高度
- 版本 : 1.0.0


```javascript
//绘制矩形
$draw.rect(200,200,200,100);
```


### rect(x, y, w, h, color)

> 绘制一个方框

- 参数 : x {int} 起点x
- 参数 : y {int} 起点y
- 参数 : w {int} 宽度
- 参数 : h {int} 高度
- 参数 : color {string} 颜色
- 版本 : 1.1.1


```javascript
//绘制矩形
$draw.rect(200,200,200,100,"#FF0000");
```


### rect(x, y, w, h, ext)

> 绘制方框

- 参数 : x {int} 起点x
- 参数 : y {int} 起点y
- 参数 : w {int} 宽度
- 参数 : h {int} 高度
- 参数 : ext {int} 向四周拓展
- 版本 : 1.0.0


```javascript
//绘制一个向外拓展50像素的矩阵
$draw.rect(200,200,200,100,50);
```


### rect(x, y, w, h, ext, color)

> 绘制方框

- 参数 : x {int} 起点x
- 参数 : y {int} 起点y
- 参数 : w {int} 宽度
- 参数 : h {int} 高度
- 参数 : ext {int} 向四周拓展
- 参数 : color {string} 颜色
- 版本 : 1.1.0


```javascript
//绘制一个向外拓展50像素的矩阵
$draw.rect(200,200,200,100,50,"#FF0000");
```


### rect(x, y, w, h, ext, color)

> 绘制方框

- 参数 : x {int} 起点x
- 参数 : y {int} 起点y
- 参数 : w {int} 宽度
- 参数 : h {int} 高度
- 参数 : ext {int} 向四周拓展
- 参数 : color {int} 颜色
- 版本 : 1.1.1


```javascript
//绘制一个向外拓展50像素的矩阵
$draw.rect(200,200,200,100,50,$color.RED);
```


### rect(arr, ext, color)

> 绘制方框

- 参数 : arr {int[]} 范围数组
- 参数 : ext {int} 向四周拓展
- 参数 : color {int} 颜色
- 版本 : 1.8.2


```javascript
//绘制一个向外拓展50像素的矩阵
$draw.rect([200,200,200,100],50,$color.RED);
```


### rect(arr, ext, color)

> 绘制方框

- 参数 : arr {int[]} 范围数组
- 参数 : ext {int} 向四周拓展
- 参数 : color {string} 颜色
- 版本 : 1.8.2


```javascript
//绘制一个向外拓展50像素的矩阵
$draw.rect([200,200,200,100],50,"#FF0000");
```


### cross(point)

> 绘制一个十字准心

- 参数 : point {point} 位置
- 版本 : 1.0.0


```javascript
let point = new org.opencv.core.Point(100,100);
//绘制准心
$draw.cross(point);
```


### cross(index)

> 绘制一个十字准心

- 参数 : index {int[]} 位置
- 版本 : 1.0.0


```javascript
//绘制准心
$draw.cross([400,500]);
```


### cross(node)

> 绘制一个十字准心

- 参数 : node {AccessibilityNodeInfo} 节点信息
- 版本 : 1.0.0


```javascript
//绘制准心
$draw.cross(node);
```


### cross(node)

> 绘制一个十字准心

- 参数 : node {Node} 节点信息
- 版本 : 1.0.0


```javascript
//绘制准心
$draw.cross(node);
```


### cross(x, y)

> 绘制一个十字准心

- 参数 : x {int} 中心x
- 参数 : y {int} 中心y
- 版本 : 1.0.0


```javascript
//绘制准心
$draw.cross(400,500);
```


### cross(x, y, color)

> 绘制一个十字准心

- 参数 : x {int} 中心x
- 参数 : y {int} 中心y
- 参数 : color {string} 颜色
- 版本 : 1.1.0


```javascript
//绘制准心
$draw.cross(400,500,"#FF0000");
```


### cross(x, y, color)

> 绘制一个十字准心

- 参数 : x {int} 中心x
- 参数 : y {int} 中心y
- 参数 : color {int} 颜色值
- 版本 : 1.1.1


```javascript
//绘制准心
$draw.cross(400,500,$color.RED);
```


### dot(index)

> 绘制一个点

- 参数 : index {int[]} 点
- 版本 : 1.0.0


```javascript
$draw.dot([400,500]);
```


### dot(point)

> 绘制一个点

- 参数 : point {point} 点
- 版本 : 1.0.0


```javascript
$draw.dot(point);
```


### dot(x, y)

> 绘制一个点

- 参数 : x {int} 点x
- 参数 : y {int} 点y
- 版本 : 1.0.0


```javascript
//绘制一个点
$draw.dot(400,500);
```


### dot(x, y, color)

> 绘制一个点

- 参数 : x {int} 点x
- 参数 : y {int} 点y
- 参数 : color {string} 颜色
- 版本 : 1.0.0


```javascript
//绘制一个点
$draw.dot(400,500);
```


### dot(x, y, color)

> 绘制一个点

- 参数 : x {int} 点x
- 参数 : y {int} 点y
- 参数 : color {int} 颜色值
- 版本 : 1.1.1


```javascript
//绘制一个点
$draw.dot(400,500,$color.RED);
```


### text(text, x, y)

> 绘制文字

- 参数 : text {String} 文字
- 参数 : x {int} 起点x
- 参数 : y {int} 起点y
- 版本 : 1.0.0


```javascript
//绘制文字(默认字体大小:15dp)
$draw.text("Hello aigame !",400,300);
```


### text(text, x, y, size)

> 绘制文字

- 参数 : text {String} 文字
- 参数 : x {int} 起点x
- 参数 : y {int} 起点y
- 参数 : size {float} 字体大小
- 版本 : 1.0.0


```javascript
//绘制文字(大小为16dp)
$draw.text("Hello aigame !",400,400,16);
```


### text(text, x, y, size, color)

> 绘制文字

- 参数 : text {String} 文字
- 参数 : x {int} 起点x
- 参数 : y {int} 起点y
- 参数 : size {int} 字体大小
- 参数 : color {string} 颜色
- 版本 : 1.1.1


```javascript
//绘制文字(大小为16dp)
$draw.text("Hello aigame !",400,400,16,"#FF0000");
```


### text(text, x, y, size, color)

> 绘制文字

- 参数 : text {String} 文字
- 参数 : x {int} 起点x
- 参数 : y {int} 起点y
- 参数 : size {int} 字体大小
- 参数 : color {int} 颜色值
- 版本 : 1.1.1


```javascript
//绘制文字(大小为16dp)
$draw.text("Hello aigame !",400,400,16,$color.RED);
```


### circle(x, y)

> 绘制一个圆形
> 
> 半径默认为50像素

- 参数 : x {int} 圆心x
- 参数 : y {int} 圆心y
- 版本 : 1.1.1


```javascript
//绘制半径为50像素的圆形
$draw.circle(350,400);
```


### circle(x, y, r)

> 绘制一个圆形

- 参数 : x {int} 圆心x
- 参数 : y {int} 圆心y
- 参数 : r {int} 圆形半径
- 版本 : 1.0.0


```javascript
//绘制半径为100像素的圆形
$draw.circle(350,400,100);
```


### circle(x, y, r, ext)

> 绘制一个圆形

- 参数 : x {int} 圆心x
- 参数 : y {int} 圆心y
- 参数 : r {int} 圆形半径
- 参数 : ext {int} 圆形向四周拓展
- 版本 : 1.0.0


```javascript
//向外拓展50像素
$draw.circle(350,400,100,50);
```


### circle(x, y, r, ext, color)

> 绘制一个圆形

- 参数 : x {int} 圆心x
- 参数 : y {int} 圆心y
- 参数 : r {int} 圆形半径
- 参数 : ext {int} 圆形向四周拓展
- 参数 : color {string} 颜色
- 版本 : 1.0.0


```javascript
//向外拓展50像素
$draw.circle(350,400,100,50,"#FF0000");
```


### circle(x, y, r, ext, color)

> 绘制一个圆形

- 参数 : x {int} 圆心x
- 参数 : y {int} 圆心y
- 参数 : r {int} 圆形半径
- 参数 : ext {int} 圆形向四周拓展
- 参数 : color {int} 颜色值
- 版本 : 1.1.1


```javascript
//向外拓展50像素
$draw.circle(350,400,100,50,$color.RED);
```


### img(img, x, y, w, h)

> 绘制图片

- 参数 : img {Image} 图片对象
- 参数 : x {int} 起点x
- 参数 : y {int} 起点y
- 参数 : w {int} 宽度(绘制后的图片宽度)
- 参数 : h {int} 高度(绘制后的图片宽度)
- 版本 : 1.1.0


```javascript
let img = $img.read("/cat.png");
//绘制图片
$draw.img(img,200,200,100,150);
```


### line(x, y, toX, toY)

> 绘制一条线

- 参数 : x {int} 起点x
- 参数 : y {int} 起点y
- 参数 : toX {int} 目标x
- 参数 : toY {int} 目标y
- 版本 : 1.0.0


```javascript
//绘制一条线
$draw.line(300,0,100,1000);
```


### line(x, y, toX, toY, color)

> 绘制一条线

- 参数 : x {int} 起点x
- 参数 : y {int} 起点y
- 参数 : toX {int} 目标x
- 参数 : toY {int} 目标y
- 参数 : color {string} 颜色
- 版本 : 1.1.1


```javascript
//绘制一条线
$draw.line(300,0,100,1000,"#FF0000");
```


### line(x, y, toX, toY, color)

> 绘制一条线

- 参数 : x {int} 起点x
- 参数 : y {int} 起点y
- 参数 : toX {int} 目标x
- 参数 : toY {int} 目标y
- 参数 : color {int} 颜色值
- 版本 : 1.1.1


```javascript
//绘制一条线
$draw.line(300,0,100,1000,$color.RED);
```


### path(data)

> 绘制路径，传入的就是x和y的数组

- 参数 : data {int[][]} 二维数组，第二维数组是坐标
- 版本 : 1.0.0


```javascript
//国际通用手势
$draw.path([
    [100, 800],
    [120, 750],
    [150, 720],
    [180, 750],
    [200, 800],
    [200, 800],
    [220, 700],
    [250, 680],
    [280, 700],
    [300, 800],
    [300, 800],
    [320, 250],
    [350, 200],
    [380, 250],
    [400, 800],
    [400, 800],
    [420, 740],
    [450, 730],
    [480, 740],
    [500, 800],
    [500, 800],
    [520, 770],
    [550, 760],
    [580, 770],
    [600, 800]
]);
```


### path(data, color)

> 绘制路径，传入的就是x和y的数组

- 参数 : data {int[][]} 二维数组，第二维数组是坐标
- 参数 : color {string} 颜色
- 版本 : 1.1.1


```javascript
//国际通用手势
$draw.path([
    [100, 800],
    [120, 750],
    [150, 720],
    [180, 750],
    [200, 800],
    [200, 800],
    [220, 700],
    [250, 680],
    [280, 700],
    [300, 800],
    [300, 800],
    [320, 250],
    [350, 200],
    [380, 250],
    [400, 800],
    [400, 800],
    [420, 740],
    [450, 730],
    [480, 740],
    [500, 800],
    [500, 800],
    [520, 770],
    [550, 760],
    [580, 770],
    [600, 800]
],"#FF0000");
```


### path(data, color)

> 绘制路径，传入的就是x和y的数组

- 参数 : data {int[][]} 二维数组，第二维数组是坐标
- 参数 : color {int} 颜色值
- 版本 : 1.1.1


```javascript
//国际通用手势
$draw.path([
    [100, 800],
    [120, 750],
    [150, 720],
    [180, 750],
    [200, 800],
    [200, 800],
    [220, 700],
    [250, 680],
    [280, 700],
    [300, 800],
    [300, 800],
    [320, 250],
    [350, 200],
    [380, 250],
    [400, 800],
    [400, 800],
    [420, 740],
    [450, 730],
    [480, 740],
    [500, 800],
    [500, 800],
    [520, 770],
    [550, 760],
    [580, 770],
    [600, 800]
],$color.RED);
```


### i(text, x, y, size)

> 绘制日志文字

- 参数 : text {String} 文字
- 版本 : 1.0.0


```javascript
//字体大小单位:dp
$draw.i("信息",400,300,20);
```


### i(text, x, y)

> 绘制日志文字

- 参数 : text {String} 文字
- 版本 : 1.0.0


```javascript
$draw.i("信息",400,300);
```


### i(text)

> 绘制日志文字

- 参数 : text {String} 文字
- 版本 : 1.0.0


```javascript
$draw.i("信息");
```


### d(text, x, y, size)

> 绘制日志文字

- 参数 : text {String} 文字
- 版本 : 1.0.0


```javascript
//字体大小单位:dp
$draw.i("调试",400,300,20);
```


### d(text, x, y)

> 绘制日志文字

- 参数 : text {String} 文字
- 版本 : 1.0.0


```javascript
$draw.d("调试",400,300);
```


### d(text)

> 绘制日志文字

- 参数 : text {String} 文字
- 版本 : 1.0.0


```javascript
$draw.d("调试");
```


### w(text, x, y, size)

> 绘制日志文字

- 参数 : text {String} 文字
- 版本 : 1.0.0


```javascript
//字体大小单位:dp
$draw.w("警告",400,300,20);
```


### w(text, x, y)

> 绘制日志文字

- 参数 : text {String} 文字
- 版本 : 1.0.0


```javascript
$draw.w("警告",400,300);
```


### w(text)

> 绘制日志文字

- 参数 : text {String} 文字
- 版本 : 1.0.0


```javascript
$draw.w("警告");
```


### e(text, x, y, size)

> 绘制日志文字

- 参数 : text {String} 文字
- 参数 : x {float} 字体大小
- 版本 : 1.0.0


```javascript
//字体大小单位:dp
$draw.e("错误",400,300,20);
```


### e(text, x, y)

> 绘制日志文字

- 参数 : text {String} 文字
- 版本 : 1.0.0


```javascript
$draw.e("错误",400,300);
```


### e(text)

> 绘制日志文字

- 参数 : text {String} 文字
- 版本 : 1.0.0


```javascript
$draw.e("错误");
```


### v(text, x, y, size)

> 绘制日志文字

- 参数 : text {String} 文字
- 版本 : 1.0.0


```javascript
//字体大小单位:dp
$draw.v("信息",400,300,20);
```


### v(text, x, y)

> 绘制日志文字

- 参数 : text {String} 文字
- 版本 : 1.0.0


```javascript
$draw.v("信息",400,300);
```


### v(text)

> 绘制日志文字

- 参数 : text {String} 文字
- 版本 : 1.0.0


```javascript
$draw.v("信息");
```


### log(text, color, x, y, size)

> 绘制日志文字

- 参数 : text {String} 文字
- 参数 : color {String} 颜色
- 参数 : x {int} 位置x
- 参数 : y {int} 位置y
- 参数 : size {float} 字体大小
- 版本 : 1.0.0


```javascript
//字体大小单位:dp
$draw.log("信息","#57965C",400,300,20);
```


### log(text, color, x, y)

> 绘制日志文字

- 参数 : text {String} 文字
- 参数 : color {String} 颜色
- 参数 : x {int} 位置x
- 参数 : y {int} 位置y
- 版本 : 1.0.0


```javascript
//字体大小单位:dp 默认日志文字大小:12dp
$draw.log("信息","#57965C",400,300);
```


### log(text, color)

> 绘制日志文字

- 参数 : text {String} 文字
- 参数 : color {String} 颜色
- 版本 : 1.0.0


```javascript
$draw.log("信息","#57965C");
```


### log(text)

> 绘制日志文字

- 参数 : text {String} 文字
- 版本 : 1.0.0


```javascript
$draw.log("信息");
```


### log(text, x, y)

> 绘制日志文字

- 参数 : text {String} 文字
- 参数 : x {int} 位置x
- 参数 : y {int} 位置y
- 版本 : 1.0.0


```javascript
//字体大小单位:dp 默认日志文字大小:12dp
$draw.log("信息",400,300);
```


### closeAll()

> 关闭绘制日志的悬浮窗

- 版本 : 1.0.0


```javascript
//关闭所有绘制图案
$draw.closeAll();
```


### closeAll(delay)

> 关闭绘制日志的悬浮窗

- 参数 : delay {long} 延迟关闭时间
- 版本 : 1.0.0


```javascript
$draw.closeAll(1000);
```


### closeLog(delay)

> 关闭绘制日志的悬浮窗

- 参数 : delay {long} 延迟关闭时间
- 版本 : 1.0.0


```javascript
$draw.closeLog(1000);
```


### closeLog()

> 关闭绘制日志的悬浮窗

- 版本 : 1.0.0


```javascript
$draw.closeLog();
```


### clear()

> 清空所有绘制
> 
> 清空绘制本质上也是绘制的一种，因此它和其他绘制函数一样，会优先判断当前悬浮窗是否开启，
> 如果悬浮窗没有开启，则创建一个全局悬浮窗至于屏幕最上层，之后绘制透明颜色以达到清空的效果。
> 
> 如果你已经绘制过图案了，那么此时是存在顶层悬浮窗的，调用次函数的时候会直接绘制透明颜色以达到清空的效果。
> 
> 如果你不理解什么是绘制透明颜色，可以理解为：画布中的橡皮擦（本质上是把橡皮经过的位置绘制成透明颜色）

- 版本 : 1.6.8


```javascript
//清空全局绘制
$draw.clear();
```


# JsTaskInfo - 脚本任务信息

- 更新时间:2025-12-13 11:58:45

> 脚本任务信息




### const {String} ID;

> 任务ID


### const {String} startTime;

> 开始执行的时间


### const {String} endTime;

> 执行结束时的时间


### const {String} runTime;

> 执行时常


### const {String} name;

> 脚本名称


### const {String} path;

> 脚本路径


### getID()

> 任务ID

- 返回 : {string} 任务ID
- 版本 : 1.0.0


### getStartTime()

> 执行结束时的时间

- 返回 : {string} 执行结束时的时间
- 版本 : 1.0.0


### getName()

> 执行结束时的时间

- 返回 : {string} 执行结束时的时间
- 版本 : 1.0.0


### getPath()

> 执行结束时的时间

- 返回 : {string} 执行结束时的时间
- 版本 : 1.0.0


# $task - 脚本任务

- 更新时间:2025-12-13 11:58:45

> 脚本任务
> 
> 每个正在执行的代码文件中都会内置一个专属对象：任务对象($task)
> 
> 你可以通过任务对象($task)来控制当前任务的执行
> 
> 你也可以通过任务对象($task)来获取当前任务的信息




### const {String} ID;

> 任务唯一序列
> 
> 该序列会和当前线程名称保持一致


```javascript
log("当前任务唯一序列:",$task.ID);
```


### const {long} startTime;

> 当前任务的开始执行时间

- 版本 : 1.3.9


```javascript
log("当前任务的开始执行时间:",$task.startTime);
```


### const {String} name;

> 当前任务名称
> 
> 有时也指路径或文件名称

- 版本 : 1.3.9


```javascript
log("当前任务名称:",$task.name);
```


### const {String} threadName;

> 当前任务线程名称
> 
> 线程名称通常与ID相同

- 版本 : 1.3.9


```javascript
log("当前任务线程名称:",$task.threadName);
```


### const {String} path;

> 当前脚本路径
> 
> 此属性并不重要，取决于执行脚本时传入的路径参数值，如果是临时文件，则路径是随机生成的。

- 版本 : 1.3.9


```javascript
log("当前脚本路径:",$task.path);
```


### stop()

> 停止任务
> 
> 每个任务($task)都是一条新的线程，如果你的代码中存在死循环，则循环不会停止(因为循环会被当作一条命令执行，表示执行完毕这个命令了)，请处理好脚本逻辑。

- 版本 : 1.0.0


```javascript
$task.stop();
```


### getInfo()

> 获取脚本任务信息

- 返回 : {JsTaskInfo} 任务信息
- 版本 : 1.0.0


```javascript
let info = $task.getInfo();
alert("任务信息",info.toString());
```


### isRunning()

> 是否正在运行

- 返回 : {boolean} 返回是否正在运行
- 版本 : 1.0.0


```javascript
let is = $task.isRunning();
if(is){
    alert("任务正在运行");
}else{
    alert("任务已经停止运行");
}
```


### getID()

> 获取当前任务的ID

- 返回 : {string} 返回当前任务的ID
- 版本 : 1.0.0


```javascript
let id = $task.getID();
alert("任务ID",id);
```


### getStartTime()

> 获取当前任务的开始时间

- 返回 : {long} 返回当前任务的开始时间
- 版本 : 1.0.0


```javascript
let time = $task.getStartTime();
alert("任务开始时间",time);
```


### getName()

> 获取当前任务的名称

- 返回 : {string} 返回当前任务的名称
- 版本 : 1.0.0


```javascript
let name = $task.getName();
alert("任务名称",name);
```


### getThreadName()

> 获取当前任务的线程名称

- 返回 : {string} 返回当前任务的线程名称
- 版本 : 1.0.0


```javascript
let tn = $task.getThreadName();
alert("线程名称",tn);
```


### getPath()

> 获取当前任务的脚本路径

- 返回 : {string} 返回当前任务的脚本路径
- 版本 : 1.0.0


```javascript
let path = $task.getPath();
alert("脚本路径",path);
```


### getPath(relativePath)

> 获取相对当前脚本路径的绝对路径

- 参数 : relativePath {string} 相对路径
- 返回 : {string} 返回绝对路径
- 版本 : 1.0.0


```javascript
let path = $task.getPath("../res");
alert("相对路径",path);
```


### pause()

> 暂停当前任务

- 版本 : 1.3.9


```javascript
//我演示一个错误的用法：
$task.pause();//当暂停以后，下面的代码不会被执行
//...其他代码
$task.start();//这行代码不被执行到，因此这样调用毫无意义
```


### start()

> 继续运行暂停的任务

- 版本 : 1.3.9


```javascript
$task.start();
```


### isPause()

> 任务是否暂停

- 返回 : {boolean} 是否暂停
- 版本 : 1.3.9


```javascript
log("是否暂停",$task.isPause());
```


### isStop()

> 判断任务是否停止
> 
> 只有当调用了'$task.stop()'或者'$engine.stop(ID)'或'$engine.stopAll()'才会返回'true'

- 返回 : {boolean} 是否停止
- 版本 : 1.7.0


```javascript
//因此，在多线程中正确书写死循环的方式：
$thread.run(()=>{
    while(!$task.isStop()){
        log("正在运行...");
        sleep(1000);
    }
    log("脚本停止");
});
```


# $engine - 脚本引擎

- 更新时间:2025-12-13 11:58:45

> 脚本引擎
> 
> 脚本引擎是全局唯一的对象，主要负责调度脚本的运行，脚本任务创建、运行、暂停、继续等操作都可以通过脚本引擎对象完成。




### run(path)

> 运行路径中的代码

- 参数 : path {string} 脚本路径
- 返回 : {string} taskID
- 版本 : 1.0.0


```javascript
let id = $engine.run("/sdcard/脚本.js");
```


### run(jsFile)

> 运行路径中的代码

- 参数 : jsFile {File} 代码文件
- 返回 : {string} taskID
- 版本 : 1.0.0


```javascript
let id = $engine.run($file.open("/sdcard/脚本.js"));
```


### runCode(code)

> 运行代码

- 参数 : code {string} 代码 
- 返回 : {string} taskID
- 版本 : 1.0.0


```javascript
let id = $engine.runCode(`
    alert("提示","我被运行了");
`);
```


### runCode(path, code)

> 运行代码
> 
> 此处传入的路径只是决定了$task中的上下文环境路径，但不是通过该路径读取文件内容，因此可以随意填写。

- 参数 : path {string} 路径(决定了$task的路径:$task.getPath()) 
- 参数 : code {string} 代码 
- 返回 : {string} taskID
- 版本 : 1.0.0


```javascript
let id = $engine.runCode("/sdcard/main.js",`
    alert("提示","我被运行了");
`);
```


### pause(id)

> 暂停运行
> 
> 该方法会暂停未执行完毕的所有脚本

- 参数 : id {string} 任务ID 
- 版本 : 1.3.9


```javascript
let id = $engine.run("/sdcard/脚本.js");
//暂停运行
$engine.pause(id);
sleep(2000);
//继续运行
$engine.start(id);
```


### isPause(id)

> 判断任务是否处于暂停状态
> 
> 遍历所有任务列表，查询这个id的任务是否处于暂停状态

- 参数 : id {string} 任务id 
- 返回 : {boolean} false:运行态; true:暂停态; null:未找到;
- 版本 : 1.3.9


```javascript
let isPause = $engine.isPause(id);
if(isPause!=null){
    if(isPause){
        info("任务已暂停");
    }else{
        info("任务正在跑");
    }
}else{
    info("未找到任务");
}
```


### start(id)

> 开始运行
> 
> 该方法会继续运行暂停的脚本

- 参数 : id {string} 任务ID 
- 版本 : 1.3.9


```javascript
let id = $engine.run("/sdcard/脚本.js");
//暂停运行
$engine.pause(id);
sleep(2000);
//继续运行
$engine.start(id);
```


### ls()

> 列出所有的任务信息

- 返回 : {JsTaskInfo[]} 任务列表信息
- 版本 : 1.0.0


```javascript
let taskList = $engine.ls();
for(let task of taskList){
    log(task);
}
```


### stop(id)

> 停止指定任务

- 参数 : id {string} 任务id 
- 版本 : 1.0.0


```javascript
let id = $engine.run("/sdcard/脚本.js");
$engine.stop(id);
```


### stopAll(exit)

> 停止所有任务

- 参数 : exit {boolean} 是否退出系统 
- 版本 : 1.0.0


```javascript
$engine.stopAll(true);//会杀死app
```


### stopAll()

> 停止所有任务

- 版本 : 1.0.0


```javascript
$engine.stopAll();
```


### lsTask()

> 获得任务列表信息

- 返回 : {$task[]} 任务列表信息
- 版本 : 1.0.0


```javascript
let taskList = $engine.lsTask();
for(let task of taskList){
    log(task);
}
```


### has(id)

> 停止指定任务

- 参数 : id {string} 任务id 
- 版本 : 1.5.0


```javascript
let id = $engine.run("/sdcard/脚本.js");
//怕判断任务是否存在(任务结束后会自动销毁)
let hasTask = $engine.has(id);
if(hasTask){
    $engine.stop(id);
}
```


# EventType

- 更新时间:2025-09-29 12:40:13




### key 按键事件(主页、最近任务)

> 按键事件(主页、最近任务)
> 
> - 系统事件、无需权限
```javascript
$event.on("key",(data)=>{
	log(data);
});
```


### media 媒体存储事件

> 媒体存储事件
> 
> - 系统事件、无需权限
```javascript
$event.on("media",(data)=>{
	log(data);
});
```


### lock 设备锁屏事件

> 设备锁屏事件
> 
> - 系统事件、无需权限
```javascript
$event.on("lock",(data)=>{
	log(data);
});
```


### bluetooth 蓝牙事件

> 蓝牙事件
> 
> - 系统事件、无需权限
```javascript
$event.on("bluetooth",(data)=>{
	log(data);
});
```


### net 网络事件

> 网络事件
> 
> - 系统事件、无需权限
```javascript
$event.on("net",(data)=>{
	log(data);
});
```


### wifi wifi事件

> wifi事件
> 
> - 系统事件、无需权限
```javascript
$event.on("wifi",(data)=>{
	log(data);
});
```


### wifiState wifi状态事件

> wifi状态事件
> 
> - 系统事件、无需权限
```javascript
$event.on("wifiState",(data)=>{
	log(data);
});
```


### power 电量事件

> 电量事件
> 
> - 系统事件、无需权限
```javascript
$event.on("power",(data)=>{
	log(data);
});
```


### battery 电池事件

> 电池事件
> 
> - 系统事件、无需权限
```javascript
$event.on("battery",(data)=>{
	log(data);
});
```


### screenDir 屏幕旋转事件

> 屏幕旋转事件
> 
> - 系统事件、无需权限
```javascript
$event.on("screenDir",(data)=>{
	log(data);
});
```


### screen 屏幕事件

> 屏幕事件
> 
> - 系统事件、无需权限
```javascript
$event.on("screen",(data)=>{
	log(data);
});
```


### screenUnlock 解锁事件

> 解锁事件
> 
> - 系统事件、无需权限
```javascript
$event.on("screenUnlock",(data)=>{
	log(data);
});
```


### notify 系统通知

> 系统通知
> 
> - 系统事件、需要通知访问权限
```javascript
$event.on("notify",(data)=>{
	log(data);
});
```


### volume 音量事件

> 音量事件
> 
> - 系统事件、无需权限
```javascript
$event.on("volume",(data)=>{
	log(data);
});
```

# $event - 事件监听

- 更新时间:2025-12-13 11:58:45

> 事件监听
> 
> $event主要用来监听一些系统级别的事件,也会处理一些基础的应用事件,这些事件部分会依赖无障碍权限才可以监听得到。
> 
> 此对象是一个线程安全的对象,内部已经处理好了线程并发情况,因此可以在任何线程中调用。




### on(name, callback)

> 挂载事件监听
> 
> 此函数是[唯一监听器]，全局只会被设置一次(用户调用)，当调用多次该函数时，后者将覆盖前者的数据。
> 
> 如果想要取消[唯一监听器]，只需要将第二个参数设置为null即可，例如：$event.on("lock",null);//取消锁屏事件
> 
> 在$event中，事件分为好几个大类，一般有：(1)系统事件 (2)无障碍事件 (3)软件内部事件
> 
> 一般情况下:(1)系统事件:不需要任何权限，但也有个例(比如：蓝牙需要附近设备权限以及位置权限)，
> 但在(2)无障碍事件中:需要开启无障碍权限，否则无法监听得到。

- 参数 : name {string} 事件类型名称
- 参数 : callback {(data)=>{log(data);};} 回调函数


```javascript
//如果你想监听某些事件，必须要知道这些事件的名称，请参考{EventType}文档
//监听WIFI事件
$event.on("wifi",(data)=>{
    //data中包含着非常详细的描述信息，通过日志就能打印获取
    log(data);
});
```


### add(name, callback)

> 添加事件监听
> 
> 每次调用该函数，否会增加一个监听器，即使是相同的名称，也会添加到监听器列表中。
> 
> 在$event对象中，存在两种事件触发机制：[唯一监听器]和[监听器列表]
> 
> [唯一监听器]是通过on(name,callback)函数来进行设置的，它是全局唯一的，当事件触发的时候，只会被调用一次。
> 
> [监听器列表]是通过add(name,callback)函数来进行添加的，你可以多次添加多个监听器，甚至允许名称相同，当事件触发时，会调用你添加的所有监听器(软件重启后，监听器列表会被重置清空)。
> 
> 当系统事件触发的时候，会先触发[唯一监听器]，然后再触发[监听器列表]中的所有监听器。

- 参数 : name {string} 事件类型名称
- 参数 : callback {(data)=>{log(data);};} 回调函数


### ls()

> 获取监听器列表名

- 返回 : {string[]} 监听器列表名


### clear()

> 清空监听器列表


# $excel - 表格操作

- 更新时间:2025-12-13 11:58:45

> 表格操作
> 
> 用于读取和写入二维数组到表格中，这个库需要在安卓8+的系统上才能完美运行。




### read(path)

> 读取第一个表格

- 参数 : path {String} 路径(支持相对路径)
- 返回 : {String[][]} 表格数据
- 版本 : 1.7.8


```javascript
//读取第一个表格数据
let data = $excel.read("data.xlsx");//相对路径
log(data);
// 输出:
// [
//    ["学号","姓名","年龄","性别","入学日期"],
//    ["2023001","张三","20","男","2023-09-01"],
//    ["2023002","李四","19","女","2023-09-01"],
//    ["2023003","王五","21","男","2022-09-01"],
//    ["2023004","赵六","20","女","2023-09-01"]
// ]
```


![](./img/228115506309900.png)

### read(path, index)

> 读取表格

- 参数 : path {String} 路径(支持相对路径)
- 参数 : index {int} 表格索引
- 返回 : {String[][]} 表格数据
- 版本 : 1.7.8


```javascript
//读取第2个表格数据
let data = $excel.read("data.xlsx", 1);//相对路径
log(data);
// 输出:
// [
//    ["商品ID","商品名称","商品单价","库存"],
//    ["P001","笔记本电脑","4999","10"],
//    ["P002","智能手机","3999","25"],
//    ["P003","平板电脑","2499","18"],
//    ["P004","无线耳机","799","50"]
// ]
```


![](./img/228156133564800.png)

### num(path)

> 表格数量

- 参数 : path {String} 路径(支持相对路径)
- 返回 : {int} 表格数量
- 版本 : 1.7.8


```javascript
//获取表格的数量
let sheetNum = $excel.num("data.xlsx");//相对路径
log(sheetNum);//输出:3
```


### ls(path)

> 列表

- 参数 : path {String} 路径(支持相对路径)
- 返回 : {String[]} 表格名称列表
- 版本 : 1.7.8


```javascript
//获取表格的数量
let sheetList = $excel.ls("data.xlsx");//相对路径
log(sheetList);//输出:["班级表","商品表","部门表"]
```


### loop(path, onSheet)

> 遍历所有表格

- 参数 : path {String} 路径(支持相对路径)
- 参数 : onSheet {(sheetName,sheetData)=>{}} 数据回调
- 版本 : 1.7.8


```javascript
//遍历所有表格数据
let data = $excel.loop("data.xlsx", (name, data) => {
    alert(name,data);
});
```


### write(sheetName, sheetData, path)

> 写入表格

- 参数 : sheetName {String} 表格名称
- 参数 : sheetData {String[][]} 表格数据
- 参数 : path {String} 保存路径(不支持相对路径,必须是绝对路径)
- 版本 : 1.7.8


```javascript
//数据
let sheetData = [
    ["姓名", "年龄"],
    ["小红", "18"],//注意必须都是字符串类型
    ["小明", "19"]
];
//表名
let sheetName = "我的表格";
//路径(必须是绝对路径)
let savePath = "/sdcard/demo.xlsx";
$excel.write(sheetName, sheetData, savePath);
```


![](./img/227580225758600.png)

# LoadExtConfig - 加载扩展配置

- 更新时间:2025-12-13 11:58:45

> 加载扩展配置




### const {List<String>} path;

> dex、apk、jar等拓展包的路径
> 
> 类型：字符串数组


### const {List<LoadSoConfig>} so;

> so文件加载情况配置
> 
> 类型：LoadSoConfig[] so文件加载配置数组


# LoadSoConfig - 加载so文件配置

- 更新时间:2025-12-13 11:58:45

> 加载so文件配置




### const {String} path;

> so文件路径
> 
> 类型：字符串


### const {boolean} load;

> 是否加载so文件
> 
> 类型：布尔值


# $ext - 拓展:加载Dex,Apk,Jar,So

- 更新时间:2025-12-13 11:58:45

> 加载DexApkJarSo拓展API
> 
> $ext顾名思义就是"拓展"的意思，主要用来加载第三方库，拓展本应用中没有的功能。




### loadApk(apkPath)

> 加载apk文件

- 参数 : apkPath {string} apk文件路径
- 返回 : {DexClassLoader} 类加载器
- 版本 : 1.2.5


```javascript
$ext.loadApk("/sdcard/测试.apk");
```


### loadDex(dexPath)

> 加载dex文件
> 
> $ext中存在一个内置的缓存机制,被加载的dex文件会被生成一个唯一的id作为类加载器的标识,
> 
> 在起初加载dex文件的时候会保存id和类加载器对象
> 
> 当再次加载相同的dex文件时,会通过id直接取得类加载器对象来执行类
> 
> 如果想重新加载需要调用$ext.clear()清除id和类加载器

- 参数 : dexPath {string} dex文件路径
- 返回 : {DexClassLoader} 类加载器
- 版本 : 1.1.0


```javascript
$ext.loadDex("./res/demo.dex");
//开始使用dex中的类
```


### loadDexs(paths)

> 加载多个dex文件

- 参数 : paths {string[]} dex文件路径
- 返回 : {DexClassLoader} 类加载器
- 版本 : 1.2.6


```javascript
//加载多个dex文件(传入所有dex文件的路径数组即可)
$ext.loadDexs(["/res/demo1.dex","/res/demo2.dex","/res/demo3.dex"]);
```


### loadJar(jarPath)

> 加载jar文件
> 
> $ext中存在一个内置的缓存机制,被加载的jar文件会被生成一个唯一的id作为类加载器的标识,
> 
> 在起初加载jar文件的时候会保存id和类加载器对象
> 
> 当再次加载相同的jar文件时,会通过id直接取得类加载器对象来执行类
> 
> 如果想重新加载需要调用$ext.clear()清除id和类加载器
> 
> 注意:被加载的jar必须经过安卓开发环境(AndroidStudio)编译生成class字节码归档文件才可被加载

- 参数 : jarPath {string} jar文件路径
- 返回 : {DexClassLoader} 类加载器
- 版本 : 1.1.0


```javascript
$ext.loadJar("/res/demo.jar");
//开始使用jar中的类
```


### loadJars(paths)

> 加载多个jar文件
> 
> 注意:被加载的jar必须经过安卓开发环境(AndroidStudio)编译生成class字节码归档文件才可被加载

- 参数 : paths {string[]} jar文件路径
- 返回 : {DexClassLoader} 类加载器
- 版本 : 1.2.6


```javascript
//加载多个jar文件(传入所有jar文件的路径数组即可)
$ext.loadJars(["/res/demo1.dex","/res/demo2.dex","/res/demo3.dex"]);
```


### loadDex(options)

> 加载dex/so文件
> 
> 值得注意的就是so文件也有很多架构(x86_64,arm64_v8a等),根据自己手机的架构来选择需要加载的so文件(安卓特性);
> 此外:如果dex(java代码)中已经使用System.load(so);加载过的so文件不要重复加载,因为so文件只能被类加载器加载一次(安卓机制)

- 参数 : options {LoadExtConfig} 加载配置
- 返回 : {DexClassLoader} 类加载器
- 版本 : 1.1.0


```javascript
let options = {
    path:["dexOrJarPath"],//jar或者dex文件路径数组(可以传入多个dex或jar文件路径)
    so:[
         {path:"soPath", load:false},
         {
            path:"soPath",//so文件路径
            load:false //是否执行系统加载System.load(so);
         },
         //...
    ]
}
$ext.loadDex(options);
//开始使用dex里面的类
```


### loadJar(options)

> 加载jar/so文件
> 
> 值得注意的就是so文件也有很多架构(x86_64,arm64_v8a等),根据自己手机的架构来选择需要加载的so文件(安卓特性);
> 此外:如果dex(java代码)中已经使用System.load(so);加载过的so文件不要重复加载,因为so文件只能被类加载器加载一次(安卓机制)
> 
> 注意:被加载的jar必须经过安卓开发环境(AndroidStudio)编译生成class字节码归档文件才可被加载

- 参数 : options {LoadExtConfig} 加载配置
- 返回 : {DexClassLoader} 类加载器
- 版本 : 1.1.0


```javascript
let options = {
    path:["dexOrJarPath"],//jar或者dex文件路径数组,可以传入多个dex或jar文件路径
    so:[
         {path:"soPath", load:false},
         {
            path:"soPath",//so文件路径
            load:false //是否执行系统加载System.load(so);
         },
         //...
    ]
}
$ext.loadJar(options);
//开始使用jar里面的类
```


### loadApk(options)

> 加载apk/so文件

- 参数 : options {LoadExtConfig} 加载配置
- 返回 : {DexClassLoader} 类加载器
- 版本 : 1.2.5


```javascript
let options = {
    path:["apk路径"],数组格式,但是只支持一个apk路径,传入多个apk文件路径,只会加载第一个apk文件
    so:[
         {path:"soPath", load:false},
         {
            path:"soPath", //so文件路径
            load:false //是否执行系统加载System.load(so);
         },
         //...
    ]
}
$ext.loadApk(options);
//开始使用apk里面的类
```


### clear()

> 清除缓存的类加载器
> 
> $ext中存在一个内置的缓存机制,被加载的jar/dex文件会被生成一个唯一的id作为类加载器的标识,
> 
> 在起初加载jar/dex文件的时候会保存id和类加载器对象
> 
> 当再次加载相同的jar/dex文件时,会通过id直接取得类加载器对象来执行类
> 
> 如果想重新加载需要调用$ext.clear()清除id和类加载器
> 
> 如果只是单纯的加载dex/jar文件,这个函数可以随便调用;
> 但是如果加载了so文件,这个函数最好只使用一次,因为so文件只能被一个类加载器加载一次
> 
> 就算不小心把加载过so文件的类加载器清空了也没有关系，重启app重新运行即可。

- 版本 : 1.1.0


```javascript
$ext.clear();
```


### delete()

> 删除缓存文件
> 
> dex加载必须要在安卓的私有目录(安卓机制),所以每次加载的dex文件都会放在私有目录下面
> 
> 然而我们最主要只是拿到类加载器,当加载完后dex文件也就不需要了,所以可以调用这个函数来删除dex文件

- 版本 : 1.1.1


```javascript
$ext.delete();
```


# FcConfig - 文件选择配置

- 更新时间:2025-12-13 11:58:45

> 文件选择配置




### const {String} mode;

> 选择模式:多选或者单选(single,multi)


### const {String} type;

> 选择类型:文件还是目录,还是两者都(file,mkdir,all)


### const {String} path;

> 默认路径 /sdcard


### const {String} root;

> 最高根路径 /sdcard


### const {String} ext;

> 后缀过滤(使用逗号分割)


# $fc - 文件选择器

- 更新时间:2025-12-13 11:58:45

> 文件选择器




### show(callback)

> 显示文件选择器
> 
> 默认是单选文件

- 参数 : callback {(files)=>{}}回调
- 版本 : 1.0.0


```javascript
$fc.show((files)=> {
    for (let i = 0; i < files.length; i++) {
        log(files[i]);
    }
});
```


### show(callback, options)

> 显示文件选择器

- 参数 : callback {(files)=>{}}回调
- 参数 : options {object} 配置参数
- 版本 : 1.0.0


```javascript
//多选：文件和目录
$fc.show((files)=> {
    for (let i = 0; i < files.length; i++) {
        log(files[i]);
    }
}, {
    root: "/sdcard",
    path: "/sdcard/Pictures",
    mode: "m",
    type: "a"
});
//配置参数如下:
let options = {
    mode: "m", //多选模式("single","multi")写一个字母就行了
    type: "a", //文件和目录("file","mkdir","all")写一个字母就行了
    root: "/sdcard", //[可选]最高根路径
    path: "/sdcard/Pictures", //[可选]默认路径
    ext: "jpg,png" //[可选]后缀过滤
}
```


# $file - 文件系统

- 更新时间:2025-12-13 11:58:45

> 文件系统
> 
> 文件系统本身是用来操作外部存储(sdcard)文件的，但是部分函数也可以操作assets目录(app打包后的项目目录)下的文件。
> 
> 如果你希望通过$file操作assets下的文件，你需要知道如下规则：
> 
> 1.assets中的文件夹不能以_开头(安卓机制)否则无法读取文件
> 
> 2.assets只能进行读取操作，因此我们可以进行的操作有：罗列文件、拷贝文件、读取文件




### uri(path)

> 获得Uri对象
> 
> 通过文件提供器{FileProvider}来解析文件路径，获得{Uri}对象。
> 
> 如果你想单纯的解析字符串构建Uri对象，那么可以使用$http.uri("uriStr");函数
> 
> 该函数只能操作外部存储(sdcard)文件，不能操作assets目录下的文件。

- 参数 : path {String} 路径 
- 返回 : {Uri} Uri对象
- 版本 : 1.3.7


```javascript
//一般用来获取图片uri
let uri = $file.uri("/storage/emulated/0/Pictures/小红.png");
```


### open(path)

> 获得File对象
> 
> 该函数本质上是一个拼接函数，无论传入的path是否存在，都会根据构想返回一个完整路径。

- 参数 : path {string} 路径(支持相对路径) 
- 返回 : {File} 文件对象
- 版本 : 1.0.0


```javascript
//获得res目录
let file = $file.open("res");
alert("文件对象",file);///storage/emulated/0/Pictures/API教学/res
```


### isFile(path)

> 是否是文件
> 
> 如果传入的路径不存在或者不是目录都会返回false，该函数只能操作外部存储(sdcard)文件，不能操作assets目录下的文件。

- 参数 : path {string} 路径(支持相对路径) 
- 返回 : {boolean} 是否是文件
- 版本 : 1.0.0


```javascript
//是否是文件
log($file.isFile("res"));//false
log($file.isFile("main.js"));//true
```


### isDir(path)

> 是否是文件夹
> 
> 如果传入的路径不存在或者不是目录都会返回false，该函数只能操作外部存储(sdcard)文件，不能操作assets目录下的文件。

- 参数 : path {string} 路径 
- 返回 : {boolean} 是否是文件夹
- 版本 : 1.0.0


```javascript
//是否是目录
log($file.isDir("res"));//true
log($file.isDir("main.js"));//false
```


### isEmptyDir(path)

> 是否是空文件夹
> 
> 只有当目标路径是目录并且存在文件的时候才会返回false，如果文件不存在或者不是目录都会返回true。

- 参数 : path {string} 路径(支持相对路径) 
- 返回 : {boolean} 是否是空文件夹
- 版本 : 1.0.0


```javascript
//是否是空目录
log($file.isEmptyDir("res"));//false
log($file.isEmptyDir("xml"));//true
```


### isEmpty(path)

> 是否是空文件或文件夹
> 
> 如果不存在则返回false
> 
> 如果是文件则判断文件内容是否为空
> 
> 如果是文件夹则判断文件夹是否为空

- 参数 : path {string} 路径(支持相对路径) 
- 返回 : {boolean} 是否是文件夹
- 版本 : 1.0.0


```javascript
//是否是空文件或文件夹
log($file.isEmpty("res"));//false
log($file.isEmpty("xml"));//true
log($file.isEmpty("main.js"));//false
```


### join(parent, child)

> 路径拼接

- 参数 : parent {string} 路径(不支持相对路径) 
- 参数 : child {string} 路径(不支持相对路径) 
- 返回 : {string} 路径
- 版本 : 1.0.0


```javascript
let path = $file.join("sdcard", "Pictures");
alert("路径",path);
```


### join(path)

> 拼接路径

- 参数 : path {string[]} 路径数组(不支持相对路径) 
- 返回 : {string} 拼接好的路径
- 版本 : 1.0.0


```javascript
let path = $file.join(["sdcard", "Pictures", "我的项目", "res"]);
alert("路径",path);
```


### create(path)

> 创建文件
> 
> 如果目录不存在,则会自动创建目录。此函数只能操作外部存储(sdcard)文件，不能操作assets目录下的文件。

- 参数 : path {string} 路径(支持相对路径) 
- 返回 : {boolean} 是否创建成功(文件存在会返回false)
- 版本 : 1.0.0


```javascript
$file.create("xml/res/test.js");
```


### mkdir(path)

> 创建目录
> 
> 只能操作外部存储(sdcard)目录，不能操作assets目录下的目录。

- 参数 : path {string} 路径(支持相对路径) 
- 返回 : {boolean} 是否创建成功
- 版本 : 1.0.0


```javascript
$file.mkdir("xml/kir");
```


### exists(path)

> 路径是否存在

- 参数 : path {string} 路径(支持相对路径) 
- 返回 : {boolean} 是否存在
- 版本 : 1.0.0


```javascript
$file.create("./测试文件夹/a.js");
if($file.exists("./测试文件夹/a.js")){
    alert("文件","路径存在");
}
```


### ensureDir(path)

> 确保文件夹存在
> 
> 如果路径中的目录不存在则会创建目录

- 参数 : path {string} 路径(支持相对路径) 
- 返回 : {string} 路径
- 版本 : 1.0.0


```javascript
//创建目录:/测试文件夹/demo
$file.ensureDir("./测试文件夹/demo/a.js");
```


### read(path)

> 读取文件
> 
> 此函数支持读取assets中的文件，适用于打包app后读取文本文件。在未打包时将会读取sdcard上的文件。

- 参数 : path {string} 路径(支持相对路径) 
- 返回 : {string} 文本内容
- 版本 : 1.0.0


```javascript
//开始读取文件
let content = $file.read("./main.js");
alert("内容",content);
```


### read(path, encoding)

> 读取文件
> 
> 此函数支持读取assets中的文件，适用于打包app后读取文本文件。在未打包时将会读取sdcard上的文件。

- 参数 : path {string} 路径(支持相对路径) 
- 参数 : encoding {string} 编码 
- 返回 : {string} 文本内容
- 版本 : 1.0.0


```javascript
let content = $file.read("./main.js","gbk");
alert("内容",content);
```


### reads(path)

> 读取文件行
> 
> 此函数支持读取assets中的文件，适用于打包app后读取文本文件。在未打包时将会读取sdcard上的文件。

- 参数 : path {string} 路径(支持相对路径) 
- 返回 : {string[]} 文件行列表
- 版本 : 1.0.0


```javascript
let list = $file.reads("./main.js");
alert("内容",list);
```


### readByte(path)

> 读取文件字节
> 
> 此函数支持读取assets中的文件，适用于打包app后读取二进制文件。在未打包时将会读取sdcard上的二进制文件。

- 参数 : path {string} 路径 
- 返回 : {byte[]} 文件字节
- 版本 : 1.0.0


```javascript
let data = $file.readByte("./main.js");
log("内容:",data);
```


### write(content, path)

> 写入文件
> 
> 只适用于写入到外部存储

- 参数 : content {string} 内容 
- 参数 : path {string} 路径(支持相对路径) 
- 版本 : 1.0.0


```javascript
$file.write("我是内容","./xml/a.js");
```


### write(content, path, encoding)

> 写入文件
> 
> 只适用于写入到外部存储

- 参数 : content {string} 内容 
- 参数 : path {string} 路径 
- 参数 : encoding {string} 编码 
- 版本 : 1.0.0


```javascript
$file.write("我是内容","./code/a.js","GBK");
```


### writes(lines, path)

> 写入行数据
> 
> 只适用于写入到外部存储

- 参数 : lines {string[]} 行数据 
- 参数 : path {string} 路径(支持相对路径) 
- 版本 : 1.0.0


```javascript
$file.writes(["我是内容1","我是内容2","我是内容3"],"./code/a.js");
```


### add(content, path)

> 追加文件
> 
> 只适用于写入到外部存储

- 参数 : content {string} 内容 
- 参数 : path {string} 路径(支持相对路径) 
- 版本 : 1.0.0


```javascript
//追加一行字符并且换行
$file.add("我是新的内容\n","./code/a.js");
```


### adds(lines, path)

> 追加行数据
> 
> 只适用于写入到外部存储

- 参数 : lines {string[]} 行数据 
- 参数 : path {string} 路径(支持相对路径) 
- 版本 : 1.0.0


```javascript
//无需换行符号,自动换行
$file.adds(["追加01","追加02","追加03"],"./code/a.js");
```


### writeByte(bytes, path)

> 写入文件
> 
> 只适用于写入到外部存储

- 参数 : bytes {byte[]} 内容 
- 参数 : path {string} 路径(支持相对路径) 
- 版本 : 1.0.0


```javascript
$file.writeByte([09,46,36,7,89,34],"./xml/mFile.txt");
```


### copy(src, dest)

> 拷贝文件
> 
> 支持将assets文件拷贝到外部存储，也支持将外部存储文件拷贝到指定路径中，虽然目标路径支持书写相对路径，但是建议源路径使用相对路径，而目标路径最好用绝对路径。

- 参数 : src {string} 源(支持相对路径) 
- 参数 : dest {string} 目标(支持相对路径) 
- 版本 : 1.6.8


```javascript
//把assets文件拷贝到sdcard上
$file.copy("res/a.txt","/sdcard/Pictures/测试项目/res/a.txt");
```


### move(src, dest)

> 移动文件或文件夹
> 
> 此函数只适用于操作外部存储文件

- 参数 : src {string} 源文件夹(支持相对路径) 
- 参数 : dest {string} 目标文件夹(支持相对路径) 
- 版本 : 1.0.0


```javascript
//把位于modules文件夹下的所有文件都移动到xml下
//注意传入的都是目录(可以是相对路径)
let ok = $file.move("modules","xml");
if(ok){
    alert("移动文件","成功");
}else{
    alert("移动文件","失败");
}
//移动文件的话,src必须是存在的(支持相对路径)
let ok = $file.move("res/code.js","/");
if(ok){
    alert("移动文件","成功");
}else{
    alert("移动文件","失败");
}
```


### rename(src, dest)

> 重命名文件
> 
> 此函数只适用于操作外部存储文件

- 参数 : src {string} 源 
- 参数 : dest {string} 目标 
- 返回 : {boolean} 是否重命名成功
- 版本 : 1.0.0


```javascript
let ok = $file.rename("run.js","res/code.js");
if(ok){
    alert("重命名","成功");
}else{
    alert("重命名","失败");
}
```


### size(path)

> 获取文件大小
> 
> 如果文件不存在,则返回0，此函数只适用于操作外部存储文件

- 参数 : path {string} 路径(支持相对路径) 
- 返回 : {number} 文件大小
- 版本 : 1.0.0


```javascript
let size = $file.size("./xml/mFile.txt");
alert("文件大小",size);//6(字节)
```


### sizeStr(size)

> 获取文件可视化大小
> 
> 如果文件不存在，则返回0b，此函数只适用于操作外部存储文件

- 参数 : size {long} 文件长度
- 返回 : {string} 文件大小
- 版本 : 1.0.0


```javascript
let size = $file.size(1099);
alert("文件大小",size);//6(字节)
```


### sizeStr(path)

> 获取文件可视化大小
> 
> 如果文件不存在，则返回0b，此函数只适用于操作外部存储文件

- 参数 : path {string} 路径(支持相对路径) 
- 返回 : {string} 文件大小(格式化单位)
- 版本 : 1.0.0


```javascript
let size = $file.sizeStr("./xml/mFile.txt");
alert("文件大小",size);//6 B
```


### name(path)

> 文件名称
> 
> 该函数本质上就是字符串操作，解析得到文件名称。

- 参数 : path {string} 路径 
- 返回 : {string} 文件名称
- 版本 : 1.0.0


```javascript
let fn = $file.name("./xml/mFile.txt");
alert("文件名称",fn);//mFile.txt
```


### mainName(path)

> 主文件名
> 
> 不包含后缀名的文件名称，该函数本质上就是字符串操作，解析得到文件名称(不包含后缀)。

- 参数 : path {string} 路径 
- 返回 : {string} 文件名称
- 版本 : 1.0.0


```javascript
let fn = $file.mainName("./xml/mFile.txt");
alert("文件名称",fn);//mFile
```


### ext(path)

> 后缀名
> 
> 该函数本质上就是字符串操作，解析得到文件后缀名。

- 参数 : path {string} 路径 
- 返回 : {string} 文件名称
- 版本 : 1.0.0


```javascript
let fn = $file.ext("./xml/mFile.txt");
alert("后缀名",fn);//txt
```


### sd()

> 获得存储目录

- 返回 : {string} sdcard路径
- 版本 : 1.0.0


```javascript
let path = $file.sd();
alert("SDCard路径",path);///storage/emulated/0
```


### del(path)

> 删除文件或文件夹
> 
> 递归删除文件或者文件夹,如果没有删除成功,则内部会有三次重试机制,强制进行删除
> 
> 该函数只适用于操作外部存储文件

- 参数 : path {string} 文件路径(支持相对路径) 
- 返回 : {boolean} 是否删除成功
- 版本 : 1.0.0


```javascript
//删除目录
$file.del("tools");
//删除文件
$file.del("main.js");
```


### ls(path)

> 罗列文件
> 
> 该函数支持罗列打包后apk中的资源文件(assets目录)，但是注意书写相对路径

- 参数 : path {string} 路径(支持相对路径) 
- 返回 : {list[string]} 文件路径集合
- 版本 : 1.6.8


```javascript
let arr = $file.ls("res");
for(let path of arr){
    log(path);
}
```


### ls(path, filter)

> 罗列文件
> 
> 支持罗列打包后apk中的资源文件，但是注意书写相对路径

- 参数 : path {string} 路径(支持相对路径) 
- 参数 : filter {(path)=>{return true;}} 过滤函数 
- 返回 : {list[string]} 文件路径集合
- 版本 : 1.6.8


```javascript
let arr = $file.ls("res",(path)=>{
    //过滤器
    return true;
});
for(let path of arr){
    log(path);
}
```


### loopFiles(path, accept)

> 递归遍历文件
> 
> 该函数只适用于操作外部存储文件

- 参数 : path {string}  路径(支持相对路径)
- 参数 : accept {(file)=>{return false;}} 过滤函数 
- 返回 : {File[]} 文件列表
- 版本 : 1.4.9


```javascript
$file.looFiles("/res",(file)=>{
    //参数类型:file:java.io.File
    return true;
});
```


### lsVideo()

> 罗列视频文件
> 
> 通过安卓媒体库获取视频文件,需要获取读取视频权限($permit.readVideo())

- 返回 : {VideoInfo[]} 视频文件列表
- 版本 : 1.5.4


```javascript
//VideoInfo属性:
let info = {
    id: 0,    //视频id
    name: "视频名称",
    path: "视频路径",
    size: 0,  //视频大小
    dur: 0,   //视频时长
    time: 0,  //时间
}
//获取视频列表
let arr = $file.lsVideo();
//遍历视频列表
for(let info of arr){
    log(info);
}
```


### lsAudio()

> 罗列音频文件
> 
> 通过安卓媒体库获取音频文件,需要获取读取音频权限($permit.readAudio())

- 返回 : {AudioInfo[]} 音频文件列表
- 版本 : 1.5.4


```javascript
//AudioInfo属性:
let info = {
    id: 0,    //音频id
    name: "音频名称",
    path: "音频路径",
    size: 0,  //音频大小
    dur: 0,   //音频时长
    artist: "艺术家",
    album: "专辑",
    time: 0,  //时间
}
//获取音频列表
let arr = $file.lsAudio();
//遍历音频列表
for(let info of arr){
    log(info);
}
```


### lsImages()

> 罗列图片文件
> 
> 通过安卓媒体库获取图片文件,需要获取读取图片权限($permit.readImage())

- 返回 : {ImageInfo[]} 图片文件列表
- 版本 : 1.5.4


```javascript
//ImageInfo属性:
let info = {
    id: 0,    //图片id
    name: "图片名称",
    path: "图片路径",
    size: 0,  //图片大小
    width: 0, //图片宽度
    height: 0,//图片高度
    time: 0,  //时间
}
//获取图片列表
let arr = $file.lsImages();
//遍历图片列表
for(let info of arr){
    log(info);
}
```


### getDir(name, isPublic)

> 获取安卓目录路径
> 
> 获取安卓系统指定目录的路径，根据目录类型返回对应的目录路径字符串。
> 
> 目录类型可选项有: "pictures","图片", "downloads","下载", "dcim", "music","音乐", "movies","视频", "documents", "文档", "alarms", "闹钟", "notifications", "通知", "podcasts", "播客", "ringtones", "铃声"
> 
> 如果目录类型为自己自己自定义的目录名称，则会返回应用内部私有目录路径，并且以传入的目录类型作为目录的名称。

- 参数 : name {string} 目录类型,可选项有: "pictures","图片", "downloads","下载", "dcim", "music","音乐", "movies","视频", "documents", "文档", "alarms", "闹钟", "notifications", "通知", "podcasts", "播客", "ringtones", "铃声"
- 参数 : isPublic {boolean} 是否为公共目录(true为公共目录，false为私有目录)，默认为true，公共目录访问时都需要存储权限
- 返回 : {string} 目录路径字符串
- 版本 : 1.6.1


```javascript
let videoPath = $file.getDir("视频",true);
```


### getDir(name)

> 获取安卓公共目录路径
> 
> 获取安卓系统指定目录的路径，根据目录类型返回对应的目录路径字符串。
> 
> 目录类型可选项有: "pictures","图片", "downloads","下载", "dcim", "music","音乐", "movies","视频", "documents", "文档", "alarms", "闹钟", "notifications", "通知", "podcasts", "播客", "ringtones", "铃声"
> 
> 如果目录类型为自己自己自定义的目录名称，则会返回应用内部私有目录路径，并且以传入的目录类型作为目录的名称。

- 参数 : name {string} 目录类型,可选项有: "pictures","图片", "downloads","下载", "dcim", "music","音乐", "movies","视频", "documents", "文档", "alarms", "闹钟", "notifications", "通知", "podcasts", "播客", "ringtones", "铃声"
- 返回 : {string} 目录路径字符串
- 版本 : 1.6.1


```javascript
let videoPath = $file.getDir("视频");
```


### flushSd(successCallback, failCallback)


# AdjFloaty - 可调节悬浮窗

- 更新时间:2025-12-13 11:58:45

> 可调节悬浮窗
> 
> 通过$floaty.newAdj(xml|path)创建，天生就是一个可以调节的悬浮窗，支持移动到自己想要移动的位置，调节悬浮窗的大小，关闭悬浮窗等操作。




### const {WindowManager.LayoutParams} params;

> 悬浮窗参数
> 
> 类型：{android.view.WindowManager.LayoutParams}

- 版本 : 1.5.4


### const {WindowManager} manager;

> 悬浮窗管理器
> 
> 类型：{android.view.WindowManager}

- 版本 : 1.5.4


### id(id)

> 选择控件

- 参数 : id {string} 控件id
- 返回 : {XView} 控件


```javascript
let adj = $floaty.newAdj("main.xml");
//找控件
let but = adj.id("button_close");
```


### close()

> 关闭悬浮窗


```javascript
let adj = $floaty.newAdj("main.xml");
//找控件
let but = adj.id("button_close");
//点击按钮后关闭悬浮窗
but.click(()=>{
    adj.close();
});
```


### getW()

> 获得宽度

- 返回 : {int} 宽度


```javascript
let adj = $floaty.newAdj("main.xml");
//获得宽度
let w = adj.getW();
```


### getX()

> 获得x坐标

- 返回 : {int} x坐标


```javascript
let adj = $floaty.newAdj("main.xml");
//获得x坐标
let x = adj.getX();
```


### getY()

> 获得y坐标

- 返回 : {int} y坐标


```javascript
let adj = $floaty.newAdj("main.xml");
//获得y坐标
let y = adj.getY();
```


### getH()

> 获得高度

- 返回 : {int} 高度


```javascript
let adj = $floaty.newAdj("main.xml");
//获得高度
let h = adj.getH();
```


# AppFloaty - 应用级悬浮窗

- 更新时间:2025-12-13 11:58:45

> 应用级悬浮窗
> 
> 通过$floaty.newApp(xml|path)创建，该悬浮窗不会覆盖标题栏和导航栏，是一个比较友好的悬浮窗。




### const {WindowManager.LayoutParams} params;

> 悬浮窗参数
> 
> 类型：{android.view.WindowManager.LayoutParams}

- 版本 : 1.3.5


### const {WindowManager} manager;

> 悬浮窗管理器
> 
> 类型：{android.view.WindowManager}

- 版本 : 1.3.5


### onScreenChange(callback)

> 设置屏幕旋转监听

- 参数 : callback {(screenInfo)=>{}} 屏幕旋转时回调
- 版本 : 1.4.3


```javascript
let floaty = $floaty.newApp("./floaty/main.xml");
floaty.onScreenChange((screenInfo)=>{
    //屏幕旋转时回调
    floaty.fill(true);//设置成全屏
});
```


### id(id)

> 获取控件

- 参数 : id {string} 控件id
- 返回 : {XView} 组件
- 版本 : 1.3.5


```javascript
//创建悬浮窗对象
let floaty = $floaty.newApp(`
<ui>
    <linear w="max" h="max">
        <!--省略组件-->
        <button id="mButton" text="关闭"/>
    </linear>
</ui>
`);
//获取按钮控件
let mButton = floaty.id("mButton");
//绑定点击事件
mButton.click(()=>{
    //关闭悬浮窗
    floaty.close();
});
```


### fill(fill)

> 是否全屏显示
> 
> 此函数会将悬浮窗的尺寸设置成全屏大小，之后刷新悬浮窗界面
> 
> 当fill(true)的时候悬浮窗将位置设置为(0,0)并且设置宽高为最大后全屏显示；
> 
> 当fill(false)的时候悬浮窗将位置设置为上次位置，并且宽高设置为自适应，之后显示。

- 参数 : fill {boolean} 是否全屏
- 返回 : {SysFloaty} 自己
- 版本 : 1.3.5


```javascript
//创建悬浮窗对象
let floaty = $floaty.newApp(`
<ui>
    <linear w="max" h="max">
        <!--省略组件-->
    </linear>
</ui>
`);
//全屏显示
floaty.fill(true);
```


### touch(touchable)

> 设置是否可触摸
> 
> 此函数会配置悬浮窗的参数是否可以触摸，之后刷新悬浮窗界面

- 参数 : touchable {boolean} 是否可触摸
- 返回 : {SysFloaty} 自己
- 版本 : 1.3.5


```javascript
//创建悬浮窗对象
let floaty = $floaty.newApp(`
<ui>
    <linear w="max" h="max">
        <!--省略组件-->
    </linear>
</ui>
`);
//设置不可触摸
floaty.touch(false);
```


### setX(x)

> 设置X坐标
> 
> 此函数会设置悬浮窗x坐标参数，之后刷新悬浮窗界面

- 参数 : x {int} X坐标
- 返回 : {SysFloaty} 自己
- 版本 : 1.3.5


```javascript
//创建悬浮窗对象
let floaty = $floaty.newApp(`
<ui>
    <linear w="max" h="max">
        <!--省略组件-->
    </linear>
</ui>
`);
//设置X坐标
floaty.setX(100);
```


### setY(y)

> 设置Y坐标
> 
> 此函数会设置悬浮窗y坐标参数，之后刷新悬浮窗界面

- 参数 : y {int} Y坐标
- 返回 : {SysFloaty} 自己
- 版本 : 1.3.5


```javascript
//创建悬浮窗对象
let floaty = $floaty.newApp(`
<ui>
    <linear w="max" h="max">
        <!--省略组件-->
    </linear>
</ui>
`);
//设置Y坐标
floaty.setY(100);
```


### setXY(x, y)

> 设置XY坐标
> 
> 此函数会设置悬浮窗xy坐标参数，之后刷新悬浮窗界面

- 参数 : x {int} X坐标
- 参数 : y {int} Y坐标
- 返回 : {SysFloaty} 自己
- 版本 : 1.3.5


```javascript
//创建悬浮窗对象
let floaty = $floaty.newApp(`
<ui>
    <linear w="max" h="max">
        <!--省略组件-->
    </linear>
</ui>
`);
//设置XY坐标
floaty.setXY(100, 100);
```


### setW(w)

> 设置宽度
> 
> 此函数会设置悬浮窗宽度参数，之后刷新悬浮窗界面

- 参数 : w {int} 宽度
- 返回 : {SysFloaty} 自己
- 版本 : 1.3.5


```javascript
//创建悬浮窗对象
let floaty = $floaty.newApp(`
<ui>
    <linear w="max" h="max">
        <!--省略组件-->
    </linear>
</ui>
`);
//设置宽度
floaty.setW(100);
```


### setH(h)

> 设置高度
> 
> 此函数会设置悬浮窗高度参数，之后刷新悬浮窗界面

- 参数 : h {int} 高度
- 返回 : {SysFloaty} 自己
- 版本 : 1.3.5


```javascript
//创建悬浮窗对象
let floaty = $floaty.newApp(`
<ui>
    <linear w="max" h="max">
        <!--省略组件-->
    </linear>
</ui>
`);
//设置高度
floaty.setH(100);
```


### setWH(w, h)

> 设置宽高
> 
> 此函数会设置悬浮窗宽高参数，之后刷新悬浮窗界面

- 参数 : w {int} 宽度
- 参数 : h {int} 高度
- 返回 : {SysFloaty} 自己
- 版本 : 1.3.5


```javascript
//创建悬浮窗对象
let floaty = $floaty.newApp(`
<ui>
    <linear w="max" h="max">
        <!--省略组件-->
    </linear>
</ui>
`);
//设置宽高
floaty.setWH(100, 100);
```


### check()

> 断言
> 
> 判断悬浮窗是否处于可此操作状态，不可操作的状态情况如下：
> 
> 1.view为空或被移除
> 
> 2.悬浮窗被关闭

- 返回 : {boolean} 是否可操作
- 版本 : 1.3.5


```javascript
//创建悬浮窗对象
let floaty = $floaty.newApp(`
<ui>
    <linear w="max" h="max">
        <!--省略组件-->
    </linear>
</ui>
`);
//断言
if(floaty.check()){
    //可以操作
}else{
    //悬浮窗已经关闭啦，不能操作了
}
```


### close()

> 关闭悬浮窗

- 版本 : 1.3.5


```javascript
//创建悬浮窗对象
let floaty = $floaty.newApp(`
<ui>
    <linear w="max" h="max">
        <!--省略组件-->
    </linear>
</ui>
`);
//关闭悬浮窗
floaty.close();
```


# SelectFloaty - 选择悬浮窗

- 更新时间:2025-12-13 11:58:45

> 选择悬浮窗
> 
> 通过$floaty.newSelect((rect)=>{})创建，创建后立马会显示一个区域选择方框，当用户关闭的时候会回调选择的范围。




### const {WindowManager.LayoutParams} params;

> 悬浮窗参数
> 
> 类型：{android.view.WindowManager.LayoutParams}

- 版本 : 1.8.3


### const {WindowManager} manager;

> 悬浮窗管理器
> 
> 类型：{android.view.WindowManager}

- 版本 : 1.8.3


### close()

> 关闭悬浮窗

- 版本 : 1.8.3


# SysFloaty - 系统级悬浮窗

- 更新时间:2025-12-13 11:58:45

> 系统级悬浮窗
> 
> 通过$floaty.newSys(xml|path)创建，悬浮窗会盖住导航栏和状态栏，是一个比较霸道的悬浮窗。




### const {WindowManager.LayoutParams} params;

> 悬浮窗参数
> 
> 类型：{android.view.WindowManager.LayoutParams}

- 版本 : 1.3.5


### const {WindowManager} manager;

> 悬浮窗管理器
> 
> 类型：{android.view.WindowManager}

- 版本 : 1.3.5


### onScreenChange(callback)

> 设置屏幕旋转监听

- 参数 : callback {(screenInfo)=>{}} 屏幕旋转时回调
- 版本 : 1.4.3


```javascript
let floaty = $floaty.newSys("./floaty/main.xml");
floaty.onScreenChange((screenInfo)=>{
    //屏幕旋转时回调
    floaty.fill(true);//设置成全屏
});
```


### id(id)

> 获取控件

- 参数 : id {string} 控件id
- 返回 : {XView} 组件
- 版本 : 1.3.5


```javascript
//创建悬浮窗对象
let floaty = $floaty.newSys(`
<ui>
    <linear w="max" h="max">
        <!--省略组件-->
        <button id="mButton" text="关闭"/>
    </linear>
</ui>
`);
//获取按钮控件
let mButton = floaty.id("mButton");
//绑定点击事件
mButton.click(()=>{
    //关闭悬浮窗
    floaty.close();
});
```


### fill(fill)

> 是否全屏显示
> 
> 此函数会将悬浮窗的尺寸设置成全屏大小，之后刷新悬浮窗界面
> 
> 当fill(true)的时候悬浮窗将位置设置为(0,0)并且设置宽高为最大后全屏显示；
> 
> 当fill(false)的时候悬浮窗将位置设置为上次位置，并且宽高设置为自适应，之后显示。

- 参数 : fill {boolean} 是否全屏
- 返回 : {SysFloaty} 自己
- 版本 : 1.3.5


```javascript
//创建悬浮窗对象
let floaty = $floaty.newSys(`
<ui>
    <linear w="max" h="max">
        <!--省略组件-->
    </linear>
</ui>
`);
//全屏显示
floaty.fill(true);
```


### touch(touchable)

> 设置是否可触摸
> 
> 此函数会配置悬浮窗的参数是否可以触摸，之后刷新悬浮窗界面

- 参数 : touchable {boolean} 是否可触摸
- 返回 : {SysFloaty} 自己
- 版本 : 1.3.5


```javascript
//创建悬浮窗对象
let floaty = $floaty.newSys(`
<ui>
    <linear w="max" h="max">
        <!--省略组件-->
    </linear>
</ui>
`);
//设置不可触摸
floaty.touch(false);
```


### setX(x)

> 设置X坐标
> 
> 此函数会设置悬浮窗x坐标参数，之后刷新悬浮窗界面

- 参数 : x {int} X坐标
- 返回 : {SysFloaty} 自己
- 版本 : 1.3.5


```javascript
//创建悬浮窗对象
let floaty = $floaty.newSys(`
<ui>
    <linear w="max" h="max">
        <!--省略组件-->
    </linear>
</ui>
`);
//设置X坐标
floaty.setX(100);
```


### setY(y)

> 设置Y坐标
> 
> 此函数会设置悬浮窗y坐标参数，之后刷新悬浮窗界面

- 参数 : y {int} Y坐标
- 返回 : {SysFloaty} 自己
- 版本 : 1.3.5


```javascript
//创建悬浮窗对象
let floaty = $floaty.newSys(`
<ui>
    <linear w="max" h="max">
        <!--省略组件-->
    </linear>
</ui>
`);
//设置Y坐标
floaty.setY(100);
```


### setXY(x, y)

> 设置XY坐标
> 
> 此函数会设置悬浮窗xy坐标参数，之后刷新悬浮窗界面

- 参数 : x {int} X坐标
- 参数 : y {int} Y坐标
- 返回 : {SysFloaty} 自己
- 版本 : 1.3.5


```javascript
//创建悬浮窗对象
let floaty = $floaty.newSys(`
<ui>
    <linear w="max" h="max">
        <!--省略组件-->
    </linear>
</ui>
`);
//设置XY坐标
floaty.setXY(100, 100);
```


### setW(w)

> 设置宽度
> 
> 此函数会设置悬浮窗宽度参数，之后刷新悬浮窗界面

- 参数 : w {int} 宽度
- 返回 : {SysFloaty} 自己
- 版本 : 1.3.5


```javascript
//创建悬浮窗对象
let floaty = $floaty.newSys(`
<ui>
    <linear w="max" h="max">
        <!--省略组件-->
    </linear>
</ui>
`);
//设置宽度
floaty.setW(100);
```


### setH(h)

> 设置高度
> 
> 此函数会设置悬浮窗高度参数，之后刷新悬浮窗界面

- 参数 : h {int} 高度
- 返回 : {SysFloaty} 自己
- 版本 : 1.3.5


```javascript
//创建悬浮窗对象
let floaty = $floaty.newSys(`
<ui>
    <linear w="max" h="max">
        <!--省略组件-->
    </linear>
</ui>
`);
//设置高度
floaty.setH(100);
```


### setWH(w, h)

> 设置宽高
> 
> 此函数会设置悬浮窗宽高参数，之后刷新悬浮窗界面

- 参数 : w {int} 宽度
- 参数 : h {int} 高度
- 返回 : {SysFloaty} 自己
- 版本 : 1.3.5


```javascript
//创建悬浮窗对象
let floaty = $floaty.newSys(`
<ui>
    <linear w="max" h="max">
        <!--省略组件-->
    </linear>
</ui>
`);
//设置宽高
floaty.setWH(100, 100);
```


### check()

> 断言
> 
> 判断悬浮窗是否处于可此操作状态，不可操作的状态情况如下：
> 
> 1.view为空或被移除
> 
> 2.悬浮窗被关闭

- 返回 : {boolean} 是否可操作
- 版本 : 1.3.5


```javascript
//创建悬浮窗对象
let floaty = $floaty.newSys(`
<ui>
    <linear w="max" h="max">
        <!--省略组件-->
    </linear>
</ui>
`);
//断言
if(floaty.check()){
    //可以操作
}else{
    //悬浮窗已经关闭啦，不能操作了
}
```


### close()

> 关闭悬浮窗

- 版本 : 1.3.5


```javascript
//创建悬浮窗对象
let floaty = $floaty.newSys(`
<ui>
    <linear w="max" h="max">
        <!--省略组件-->
    </linear>
</ui>
`);
//关闭悬浮窗
floaty.close();
```


# $floaty - 悬浮窗

- 更新时间:2025-12-13 11:58:45

> 悬浮窗




### getPermit()

> 获取悬浮窗权限
> 
> 这个方法是个阻塞方法，如果没有获取到悬浮窗权限，则每隔30秒会请求一次权限，那么后面的代码不会被执行，并且会一直等待悬浮窗权限，直到获取到为止。
> 
> 如果你希望只获取一次悬浮窗权限，可以调用$permit.floaty();来获取权限

- 返回 : {boolean} 是否有权限
- 版本 : 1.0.0


```javascript
//获取悬浮窗权限
let hasPermit = $floaty.getPermit();
if(hasPermit){
    log("获取到悬浮窗权限");
}
```


### hasPermit()

> 是否有悬浮窗权限

- 返回 : {boolean} 是否有悬浮窗权限
- 版本 : 1.0.0


```javascript
//是否有悬浮窗权限
let hasPermit = $floaty.hasPermit();
if(hasPermit){
    log("有悬浮窗权限");
}
```


### newAdj(xmlOrPath)

> 创建可调节悬浮窗

- 参数 : xmlOrPath {xml|path} xml或路径
- 返回 : {AdjustableFloaty} 可调节悬浮窗
- 版本 : 1.4.4


```javascript
//你可以直接引入一个布局文件创建一个可调节悬浮窗
let adjFloaty = $floaty.newAdj("./res/layout/floaty_adj.xml");
//你也可以直接把xml写成字符串传入
let adjFloaty = $floaty.newAdj(`<ui>...</ui>`);
```


### newApp(xmlOrPath)

> 创建应用级悬浮窗

- 参数 : xmlOrPath {xml|path} xml或路径
- 返回 : {AppFloaty} 悬浮窗
- 版本 : 1.4.4


```javascript
//你可以直接引入一个布局文件创建一个应用级悬浮窗
let appFloaty = $floaty.newApp("./res/layout/floaty_app.xml");
//你也可以直接把xml写成字符串传入
let appFloaty = $floaty.newApp(`<ui>...</ui>`);
```


### newApp(xmlOrPath, touchable)

> 创建应用级悬浮窗

- 参数 : xmlOrPath {xml|path} xml或路径
- 参数 : touchable {boolean} 是否可触摸(默认:true)
- 返回 : {AppFloaty} 悬浮窗
- 版本 : 1.8.3


```javascript
//你可以直接引入一个布局文件创建一个应用级悬浮窗
let appFloaty = $floaty.newApp("./res/layout/floaty_app.xml",false);
//你也可以直接把xml写成字符串传入
let appFloaty = $floaty.newApp(`<ui>...</ui>`,false);
```


### newSys(xmlOrPath)

> 创建系统级悬浮窗
> 
> 系统级悬浮窗可以全屏覆盖包括导航栏和状态栏的位置，不过这种悬浮窗容易被第三方应用检测到，部分游戏检测到此类悬浮窗后会自动闪退。

- 参数 : xmlOrPath {xml|path} xml或路径
- 返回 : {SysFloaty} 悬浮窗
- 版本 : 1.4.4


```javascript
//你可以直接引入一个布局文件创建一个系统级悬浮窗
let sysFloaty = $floaty.newSys("./res/layout/floaty_sys.xml");
//你也可以直接把xml写成字符串传入
let sysFloaty = $floaty.newSys(`<ui>...</ui>`);
```


### newSys(xmlOrPath, touchable)

> 创建系统级悬浮窗
> 
> 系统级悬浮窗可以全屏覆盖包括导航栏和状态栏的位置，不过这种悬浮窗容易被第三方应用检测到，部分游戏检测到此类悬浮窗后会自动闪退。

- 参数 : xmlOrPath {xml|path} xml或路径
- 参数 : touchable {boolean} 是否可触摸(默认:true)
- 返回 : {SysFloaty} 悬浮窗
- 版本 : 1.8.3


```javascript
//你可以直接引入一个布局文件创建一个系统级悬浮窗
let sysFloaty = $floaty.newSys("./res/layout/floaty_sys.xml",false);
//你也可以直接把xml写成字符串传入
let sysFloaty = $floaty.newSys(`<ui>...</ui>`,false);
```


### newSelect(callback)

> 创建选择范围悬浮窗
> 
> 该悬浮窗将显示一个范围选择器，你可以调节选框的大小和位置，当悬浮窗关闭的时候，将会回调出选框的位置和范围数据。

- 参数 : callback {SimpleFloatArrCallback} 关闭时回调范围数据
- 返回 : {SelectFloaty} 选择范围悬浮窗
- 版本 : 1.8.3


```javascript
$floaty.newSelect((rect)=>{
    log("用户选择范围:",rect);
});
```


![](./img/floaty_newSelect.png)

### closeAll()

> 关闭所有悬浮窗

- 版本 : 1.0.0


```javascript
$floaty.closeAll();
```


# $global - 全局函数

- 更新时间:2025-12-13 11:58:45

> 全局函数
> 
> 全局函数，在调用的时候无需使用`$`前缀直接写函数即可




### sleep(ms)

> 睡眠

- 参数 : ms {int} 毫秒 
- 版本 : 1.0.0


```javascript
//停止1秒钟
sleep(1000);
```


### tip(info)

> 提示

- 参数 : info {string} 信息 
- 版本 : 1.0.0


```javascript
tip("我是提示");
```


### alert(title, msg)

> 对话框

- 参数 : title {string} 标题 
- 参数 : msg {string} 内容 
- 版本 : 1.0.0


```javascript
alert("提示对话框","我很好");
```


### showImg(img)

> 显示图片

- 参数 : img {image|string} 图片路径或图片对象 
- 版本 : 1.0.0


```javascript
//显示图片路径上的图片
let imgPath = "sdcard/Pictures/示例/全局函数/t01.png";
showImg(imgPath);
//显示图片对象(Image)
let img = $img.read(imgPath);
showImg(img);
```


### closeLog()

> 关闭绘制日志

- 版本 : 1.0.0


```javascript
closeLog();
```


### closeDraw()

> 关闭绘制
> 
> 关闭绘制悬浮窗

- 版本 : 1.0.0


```javascript
closeDraw();
```


### clearDraw()

> 清空绘制
> 
> 此方法会清空绘制，但是不会关闭绘制悬浮窗

- 版本 : 1.0.0


```javascript
clearDraw();
```


### getClip()

> 获取剪切板内容
> 
> 谷歌官方发布表明从安卓13开始将支持应用设置剪切板的内容为敏感信息，这就导致，获取剪切板的内容很可能无法获取，或者获取到的内容为空。
> 
> 因此在实际开发中，如果你发现自己无法获取剪切板的内容，完全属于正常现象，此外，较高版本的安卓系统中，剪切板无法后台获取。

- 返回 : {string} 剪切板内容 
- 版本 : 1.0.0


```javascript
let clip = getClip();
```


### setClip(text)

> 设置剪切板内容

- 参数 : text {string} 内容 
- 版本 : 1.0.0


```javascript
setClip("我是剪切板内容");
```


### hasClip()

> 是否有剪切板内容

- 返回 : {boolean} 是否有剪切板内容
- 版本 : 1.0.0


```javascript
if(hasClip()){
    let clip = getClip();
}
```


### clearClip()

> 清空剪切板内容

- 返回 : {boolean} 是否清空成功
- 版本 : 1.0.0


```javascript
clearClip();
```


### curPkg()

> 获取无障碍检测到的包名

- 返回 : {string} 活动名称
- 版本 : 1.3.1


```javascript
let pkgName = curPkg();
```


### curCls()

> 获取无障碍检测到的活动名

- 返回 : {string} 活动名称
- 版本 : 1.3.1


```javascript
let actName = curCls();
```


### curTime()

> 获取当前时间戳

- 返回 : {long} 时间戳
- 版本 : 1.7.8


```javascript
let stamp = curTime();
log(stamp);
```


### info(msg)

> 悬浮土司提示
> 
> 悬浮窗土司，可以显示在任何app界面，但是需要悬浮窗权限。

- 参数 : msg {string...} 日志信息  


```javascript
info("提示信息");
```


### infoLog(msg)

> 悬浮土司加控制台打印

- 参数 : msg {string...} 日志信息 


```javascript
infoLog("提示信息");
```


### toast(msg)

> 系统土司
> 
> 部分手机需要开启通知权限才允许显示在其他应用上方

- 参数 : msg {string...} 日志信息 


```javascript
toast("提示信息");
```


### toastLog(msg)

> 系统土司加控制台打印

- 参数 : msg {string...} 日志信息 


```javascript
toastLog("提示信息");
```


### log(msg)

> 控制台日志

- 参数 : msg {string...} 日志信息 


```javascript
log("信息");
```


### print(msg)

> 控制台日志

- 参数 : msg {string...} 日志信息 


```javascript
print("信息");
```


### random()

> 随机数(0-1)

- 返回 : {float} 随机数(0-1)


```javascript
log(random());//0-1之间的随机数
```


### random(max)

> 随机数(0-max)

- 参数 : max {int} 最大值 


```javascript
log(random(10));//0-10之间的随机数
```


### random(min, max)

> 随机数(min-max)

- 参数 : min {int} 最小值 
- 参数 : max {int} 最大值 


```javascript
log(random(10,30));//10-30之间的随机数
```


### require(path)

> 导入模块

- 参数 : path {string} 模块路径或相对路径 
- 返回 : {JsObject} 模块对象


```javascript
let MyClass = require("mCls.js");
let obj = new MyClass();
```


# $html - 网页操作

- 更新时间:2025-12-13 11:58:45

> 网页操作




### escape(html)

> 转义HTML字符
> 
> 此函数会遍历么一个字符，将特殊字符进行转义。
> 

- 参数 : html 被转义的文本
- 返回 : 转义后的文本


```javascript
let html = "<div>123</div>";
let escapeHtml = $html.escape(html);
```


### unescape(text)

> 还原被转义的HTML特殊字符

- 参数 : text {string} HTML字符串
- 返回 : {string} 转换后的字符串


### cleanHtmlTag(text)

> 清除所有HTML标签

- 参数 : text {string} 文本
- 返回 : {string} 清除标签后的文本


### removeHtmlTag(text, tagNames)

> 删除HTML标签(包括内容)

- 参数 : text {string} 文本
- 参数 : tagNames {string...} 要清除的标签
- 返回 : 去除标签后的文本


### unwrapHtmlTag(text, tagNames)

> 清除指定HTML标签(不包括内容)

- 参数 : text {string} 文本
- 参数 : tagNames {string...} 要清除的标签
- 返回 : {string} 去除标签后的文本


### removeHtmlTag(text, withTagContent, tagNames)

> 清除指定HTML标签

- 参数 : text {string} 文本
- 参数 : withTagContent {boolean} 是否去掉被包含在标签中的内容
- 参数 : tagNames {string...}  要清除的标签
- 返回 : {string} 去除标签后的文本


### removeHtmlAttr(html, attrs)

> 去除HTML标签中的所有属性

- 参数 : html {string} 文本
- 参数 : attrs {string...} 属性名
- 返回 : {string} 处理后的文本


### removeAllHtmlAttr(html, tagNames)

> 去除指定标签的所有属性

- 参数 : html {string} 内容
- 参数 : tagNames {string...} 指定标签
- 返回 : {string} 处理后的文本


### filter(html)

> 过滤HTML文本，防止XSS攻击

- 参数 : html {string} HTML内容
- 返回 : {string} 过滤后的内容


### getWeiYunNote(shortLink)

> 处理腾讯微笔记
> 
> 我们可以在[腾讯微云]->[我的]->[笔记]中创建一个纯文本笔记(切记不要有特殊字符，例如粗体或者改变文本颜色等等特殊处理都不要有)，之后我们点击分享，就可以看到链接最后面的一个字段，我称之为短链接，把短链接放入到这个函数中来，我将解析你的微云笔记，最后把处理好的文本字符串返回给你。
> 
> 这样以来，你可以把腾讯微云当作你的免费云数据库来使用，写一个微云笔记，把自己的数据(例如json字符)存入到笔记中，需要使用的时候使用这个函数拉取后解析成json对象(JSON.parse(str))，就可以使用数据了。

- 参数 : shortLink {string} 短链接 
- 返回 : {string} 处理好的字符串
- 版本 : 1.5.0


```javascript
// 微云笔记链接：https://share.weiyun.com/bnaMAKsa
// 短链接：bnaMAKsa
let noteContent = $html.getWeiYunNote("bnaMAKsa");
// 解析json字符串
let jsonObj = JSON.parse(noteContent);
```


# HttpResponse - 网络请求响应体

- 更新时间:2025-12-13 11:58:45

> HttpResponse - 网络请求响应体




### const {Response} response;

> OkHttp3原生响应对象
> 可以直接调用原生方法
> 如：response.body().string()


### const {String} desc;

> 响应描述
> 如果存在异常,将会设置为异常信息


### const {boolean} success;

> 响应是否成功
> 如果存在异常,将会设置为false


### const {int} statusCode;

> 响应状态码
> 
> 适配auto.js的习惯,保留了这个字段,但是不建议使用,因为不够简约,推荐使用code或者status


### const {int} status;

> 响应状态码


### const {int} code;

> 响应状态码


### const {String} statusMessage;

> 响应状态信息
> 
> 适配auto.js的习惯,保留了这个字段,但是不建议使用,因为不够简约,推荐使用msg


### const {String} msg;

> 响应状态信息


### const {String} method;

> 请求方法


### const {String} url;

> 请求地址


### const {String} str;


### const {String} string;


### const {String} json;


### const {String} bytes;


### getStatusCode()

> 响应状态码

- 返回 : {int} 响应状态码


### getStatusMessage()

> 响应状态信息

- 返回 : {string} 响应状态信息


### str()

> 读取响应字符串

- 返回 : {string} 响应字符串


### string()

> 读取响应字符串
> 
> 适配auto.js的习惯,保留了这个字段,但是不建议使用,因为不够简约,推荐使用str()

- 返回 : {string} 响应字符串


### json()

> 读取响应字符串并转为json对象

- 返回 : {object} 响应字符串转为json对象


### bytes()

> 读取响应字节

- 返回 : {byte[]} 响应字节


### getDesc()

> 读取响应字符串

- 返回 : {string} 响应字符串


### isSuccess()

> 响应是否成功

- 返回 : {boolean} 响应是否成功


### getMethod()

> 响应是否成功

- 返回 : {boolean} 响应是否成功


### getUrl()

> 请求地址

- 返回 : {string} 请求地址


### getStatus()

> 响应状态码

- 返回 : {int} 响应状态码


### getMsg()

> 响应状态码

- 返回 : {int} 响应状态码


# $http - 网络请求

- 更新时间:2025-12-13 11:58:45

> 网络请求




### uri(uri)

> 解析Uri字符串
> 
> 如果你想通过文件提供器{FileProvider}来解析文件路径，那么可以使用$file.uri("path");函数

- 参数 : uri {String} Uri字符串
- 返回 : {Uri} Uri对象
- 版本 : 1.3.7


```javascript
let uri = $http.uri("smsto:"+$str.uriEncode("13693749475"));
```


### get(url)

> 同步请求

- 参数 : url {url} 链接地址
- 返回 : {HttpResponse} 返回结果
- 版本 : 1.2.0


```javascript
//全部配置参数
let opt = {
    url:"",//请求地址
    head:{
        "key":"value",
        "key2":"value2"
    },
    data: "请求数据",//支持file、xml、json、string等类型，会自动判断
    connectTimeout:30, //[可选]连接超时时间(默认30秒)
    readTimeout:30, //[可选]读超时时间(默认30秒)
    writeTimeout:30, //[可选]写超时时间(默认30秒)
    callTimeout:60 //[可选]请求超时时间(默认60秒)
}
//如果要发送文件
let opt = {
    url:"",//请求地址
    head:{ },
    data: "/sdcard/img.png"
}
//如果要发送json
let opt = {
    url:"",//请求地址
    head:{ },
    //直接写json对象，或json字符串也可以
    data: {
        "key":"value",
        "key2":"value2"
    }
}
```


### get(opts)

> GET请求

- 参数 : opts {HttpOptions} 配置
- 返回 : {HttpResponse} 返回结果
- 版本 : 1.2.0


### post(opts)

> POST请求

- 参数 : opts {HttpOptions} 配置
- 返回 : {HttpResponse} 返回结果
- 版本 : 1.2.0


### del(opts)

> DELETE请求

- 参数 : opts {HttpOptions} 配置
- 返回 : {HttpResponse} 返回结果
- 版本 : 1.2.0


### delete(opts)

> DELETE请求

- 参数 : opts {HttpOptions} 配置
- 返回 : {HttpResponse} 返回结果
- 版本 : 1.2.0


### put(opts)

> PUT请求

- 参数 : opts {HttpOptions} 配置
- 返回 : {HttpResponse} 返回结果
- 版本 : 1.2.0


### patch(opts)

> PATCH请求

- 参数 : opts {HttpOptions} 配置
- 返回 : {HttpResponse} 返回结果
- 版本 : 1.2.0


### download(url, savePath)

> 下载文件

- 参数 : url {string}  url
- 参数 : savePath {string} 保存路径


### download(url, savePath, completeCallback)

> 下载文件

- 参数 : url {string}  url
- 参数 : savePath {string} 保存路径
- 参数 : completeCallback {()=>{}} 下载完成回调


### download(url, savePath, completeCallback, onFailure)

> 下载文件

- 参数 : url {string}  url
- 参数 : savePath {string} 保存路径
- 参数 : completeCallback {()=>{}} 下载完成回调
- 参数 : onFailure {(res)=>}  错误回调


### download(url, savePath, progressListener, completeCallback, onFailure)

> 下载文件

- 参数 : url {string}  url
- 参数 : savePath {string} 保存路径
- 参数 : progressListener {(cur,total,percent)=>{}} 进度监听器
- 参数 : completeCallback {()=>{}} 下载完成回调
- 参数 : onFailure {(res)=>}    错误回调


```javascript
$http.download(
"https://pics0.baidu.com/feed/f11f3a292df5e0feee2783e88baf3fa75fdf727e.jpeg?token=4afc91463326e4f4a44e2cde691a54a0",
"/sdcard/美女.png",
(cur,total,percent)=>{
    log("下载进度",percent);
},()=>{
    log("下载完毕");
},(res)=>{
    log("下载失败",res);
});
```


### wifiIp()

> 获取wifi的ip地址
> 
> 如果连接方式不是wifi则返回null

- 返回 : {string} ip地址


# Image - 图片

- 更新时间:2025-12-13 11:58:45

> 表示图片
> 
> 是为了防止图片占用太大的内存,于是封装此对象用于表示图片,一般情况下,在本应用中绝大多数使用图片的场景都会自动回收图片,以免占用过多内存。




### const {int} width;

> 图片宽度


### const {int} height;

> 图片高度


### getMat()

> 获取mat类型


### getBitmap()

> 获取bitmap类型


### width()

> 图片宽度


### height()

> 图片高度


### getWidth()

> 图片宽度


### getHeight()

> 图片高度


### close()

> 释放资源


### recycle()

> 释放资源


### pixel(x, y)

> 获取像素值

- 参数 : x {int} x坐标
- 参数 : y {int} y坐标
- 返回 : {int} 像素值


### pixel(point)

> 获取像素值

- 参数 : point {Point} 坐标
- 返回 : {int} 像素值


### save(path)

> 保存图片

- 参数 : path {String} 保存路径


### show()

> 显示图片


### copy()

> 复制图片
> 
> 从源图片数据中拷贝一份图片后返回

- 返回 : {Image} 拷贝后的图片
- 版本 : 1.7.0


```javascript
let screenImg = $screen.getScreen();
let img = screenImg.copy();
//接下来可以对 screenImg 以及 img 分别进行操作
```


### json()

> 转json字符串

- 返回 : {String} json字符串


# $img - 图片操作

- 更新时间:2025-12-13 11:58:46

> 图片操作




### makePng(image, color, threshold)

> 制作透明图片

- 参数 : image {Image} 需要处理的图片
- 参数 : color {string} 保留的颜色
- 参数 : threshold {number} 允许颜色的误差
- 返回 : {Image} 生成新的png图片


```javascript
//相对于项目的路径
let img = $img.read("/$img/res/t01.png");
let pngImg = $img.makePng(img ,"#db0306", 20);
//保存到本地
$img.save(pngImg,"/$img/img/s01.png");
$img.show(pngImg);
```


### makePng(image, colors, thresholds)

> 制作透明图片
> 
> 注意：颜色的数量和阈值数量保持一致

- 参数 : image {Image} 需要处理的图片
- 参数 : colors {string} 保留的颜色
- 参数 : thresholds {number} 允许颜色的误差
- 返回 : {Image} 生成新的png图片


```javascript
//相对于项目的路径
let img = $img.read("/$img/res/t01.png");
let pngImg = $img.makePng(img ,["#db0306","#a70602","#a02a16"], [20,20,20]);
//保存到本地
$img.save(pngImg,"/$img/img/s02.png");
$img.show(pngImg);
```


### makePng(image, colors, thresholds, options)

> 制作透明图片

- 参数 : image {Image} 需要处理的图片
- 参数 : colors {string} 保留的颜色
- 参数 : thresholds {number} 允许颜色的误差
- 参数 : options {object} 配置参数
- 返回 : {Image} 生成新的png图片


```javascript
let options = {
    isBlur:true,//开启滤波(默认值:true)
    blurSize:1,//滤波大小(默认值:1)
    isDilate:true,//开启膨胀(默认值:true)
    dilateSize:1,//膨胀大小(默认值:1)
    isErode:true,//开启腐蚀(默认值:true)
    erodeSize:3,//腐蚀大小(默认值:3)
}
```


### read(imgPath)

> 读取图片
> 
> 支持相对路径写法
> 
> 读取资源失败时会返回空null

- 参数 : imgPath {string} 图片路径
- 返回 : {Image} 读取的图片


```javascript
//图片路径
let path = "sdcard/Pictures/示例/$img/res/p01.png";
//读取图片
let img = $img.read(path);
```


### open(imgPath)

> 构建img对象
> 
> 和read效果一样的

- 参数 : imgPath {string} 图片路径
- 返回 : {Image} 图片对象
- 版本 : 1.2.4


```javascript
//图片路径
let path = "sdcard/Pictures/示例/$img/res/p01.png";
//读取图片
let img = $img.open(path);
```


### open(bitmap)

> 构建img对象

- 参数 : bitmap {Bitmap} 安卓图片对象
- 返回 : {Image} 图片对象
- 版本 : 1.2.4


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let mImg = ui.id("mImg");
//获取图片(安卓图片对象)
let bitmap = mImg.getImg();
//构建$img对象
let img = $img.open(bitmap);
```


### read(imgFile)

> 读取图片
> 
> 读取资源失败时会返回空null

- 参数 : imgFile {File} 图片路径
- 返回 : {Image} 读取的图片


### save(image, path, format, quality)

> 保存图片
> 
> 支持相对路径写法

- 参数 : image {Image} 需要保存的图片
- 参数 : path {string} 保存路径
- 参数 : format {string} 格式
- 参数 : quality {int} 质量


```javascript
//截屏并且保存到本地
//但是在实际中我们可以直接调用$screen.save("路径");更加方便
$screen.getPermit();
let screenImg = $screen.getScreen();
$img.save(screenImg,"/$img/img/s05.png","png",100);
```


### save(image, path)

> 保存图片
> 
> 默认保存png格式，质量为100，支持相对路径写法

- 参数 : image {Image} 需要保存的图片
- 参数 : path {string} 保存路径


```javascript
//截屏并且保存到本地
//但是在实际中我们可以直接调用$screen.save("路径");更加方便
$screen.getPermit();
let screenImg = $screen.getScreen();
$img.save(screenImg,"/$img/img/s05.png");
```


### toBase64(image, format, quality)

> 转换base64

- 参数 : image {Image} 需要转换为base64的图片
- 参数 : format {string} 格式
- 参数 : quality {int} 质量
- 返回 : 图片的base64字符串


```javascript
let img = $img.read("/$img/res/t01.png");
let baseStr = $img.toBase64( img ,"png" , 50);
alert("图片Base64",baseStr);
```


### toBase64(image)

> 转换base64

- 参数 : image {Image} 需要转换的图片
- 返回 : {string} base64字符串


```javascript
//图片路径
let path = "sdcard/Pictures/示例/$img/res/p01.png";
//读取图片
let img = $img.read(path);
//转化为base64
let imgBase64 = $img.toBase64(img);
log(imgBase64)
```


### toBase64(path)

> 转换base64

- 参数 : path {string} 需要转换的图片
- 返回 : {string} base64字符串


```javascript
//图片路径
let path = "sdcard/Pictures/示例/$img/res/p01.png";
//转化为base64
let imgBase64 = $img.toBase64(path);
log(imgBase64)
```


### readBase64(base64)

> 加载base64

- 参数 : base64 {string} base64字符串
- 返回 : {Image} 图片对象


```javascript
let img = $img.read("/$img/res/t01.png");
let baseStr = $img.toBase64( img ,"png" , 50);
alert("图片Base64",baseStr);
//从base64中读取图片
let img2 = $img.readBase64(baseStr);
showImg(img2);
```


### clip(image, x, y, w, h)

> 裁剪图片

- 参数 : image {img} 原本的图片
- 参数 : x {int}  开始坐标
- 参数 : y {int} 开始坐标
- 参数 : w {int}  宽度
- 参数 : h {int} 高度
- 返回 : {Image} 新的图片


```javascript
//图片路径
let path = "sdcard/Pictures/示例/$img/res/p03.png";
//读取图片
let img = $img.read(path);
//操作图片
let image = $img.clip(img, 0, 0, 300, 200);
//显示图片
$img.show(image);
```


### resize(image, w, h, interpolation)

> 设置尺寸
> 
> 插值方式(忽略大小写)：
> NEAREST,
> LINEAR,
> CUBIC,
> AREA,
> LANCZOS4,
> EXACT

- 参数 : image {Image}      需要处理的图片
- 参数 : w {int} 宽度
- 参数 : h {int}  高度
- 参数 : interpolation {string} 插值方式
- 返回 : 图片


```javascript
//图片路径
let path = "sdcard/Pictures/示例/$img/res/p02.png";
//读取图片
let img = $img.read(path);
//操作图片
let image = $img.resize(img, 200, 200, "INTER_CUBIC");
//显示图片
$img.show(image);
```


### resize(image, w, h)

> 设置尺寸
> 
> 使用默认插值方式:LINEAR

- 参数 : image {Image} 需要处理的图片
- 参数 : w {int} 宽度
- 参数 : h {int} 高度
- 返回 : {Image} 处理后的图片


```javascript
//图片路径
let path = "sdcard/Pictures/示例/$img/res/p02.png";
//读取图片
let img = $img.read(path);
//操作图片
let image = $img.resize(img, 200, 200);
//显示图片
$img.show(image);
```


### scale(image, scaleX, scaleY, interpolation)

> 缩放图片

- 参数 : image {Image}  需要处理的图片
- 参数 : scaleX {double} 宽度缩放倍数
- 参数 : scaleY {double}   高度缩放倍数
- 参数 : interpolation {string}  插值方式
- 返回 : {Image} 处理后的图片


```javascript
//图片路径
let path = "sdcard/Pictures/示例/$img/res/p02.png";
//读取图片
let img = $img.read(path);
//操作图片
let image = $img.scale(img, 0.3, 0.2, "CUBIC");
//显示图片
$img.show(image);
```


### scale(image, scaleX, scaleY)

> 缩放图片

- 参数 : image {Image}  需要处理的图片
- 参数 : scaleX {double} 宽度缩放倍数
- 参数 : scaleY {double} 高度缩放倍数
- 返回 : {Image} 处理后的图片


```javascript
//图片路径
let path = "sdcard/Pictures/示例/$img/res/p02.png";
//读取图片
let img = $img.read(path);
//操作图片
let image = $img.scale(img, 0.3, 0.2);
//显示图片
$img.show(image);
```


### rotate(image, degree, x, y)

> 旋转图片

- 参数 : image {Image} 需要处理的图片
- 参数 : degree {float} 旋转的角度
- 参数 : x {int} 旋转中心点x坐标
- 参数 : y {int} 旋转中心点y =坐标
- 返回 : {Image} 处理后的图片


```javascript
//图片路径
let path = "sdcard/Pictures/示例/$img/res/p02.png";
//读取图片
let img = $img.read(path);
//操作图片
let image = $img.rotate(img, 45, 100, 200);
//显示图片
$img.show(image);
```


### rotate(image, degree)

> 旋转图片

- 参数 : image {Image}  需要处理的图片
- 参数 : degree {float} 旋转的角度
- 返回 : {Image}  处理后的图片


```javascript
//图片路径
let path = "sdcard/Pictures/示例/$img/res/p02.png";
//读取图片
let img = $img.read(path);
//操作图片
let image = $img.rotate(img, 45);
//显示图片
$img.show(image);
```


### rotate(image)

> 旋转图片
> 
> 默认旋转90度

- 参数 : image {Image}   需要处理的图片
- 返回 : {Image}   处理后的图片


```javascript
//图片路径
let path = "sdcard/Pictures/示例/$img/res/p02.png";
//读取图片
let img = $img.read(path);
//操作图片
let image = $img.rotate(img);//默认旋转90度
//显示图片
$img.show(image);
```


### concat(img1, img2, dir)

> 拼接图片

- 参数 : img1 {Image}     需要拼接的图片1
- 参数 : img2 {Image}  需要拼接的图片2
- 参数 : dir {string} 拼接方向(left,right,top,bottom)
- 返回 : {Image}  拼接好的图片


```javascript
//相对于项目的路径
let t1 = $img.read("/$img/res/t02.png");
let t2 = $img.read("/$img/res/t03.png");
//调整一下尺寸(保持一致)
t1 = $img.resize(t1,300,200);
t2 = $img.resize(t2,300,200);
//调整一下大小
let img = $img.concat(t1,t2,"bottom");
showImg(img);
```


### gray(image)

> 灰度化

- 参数 : image {Image} 需要灰度化的图片
- 返回 : {Image}  灰度化的图片


```javascript
//图片路径
let path = "sdcard/Pictures/示例/$img/res/p02.png";
//读取图片
let img = $img.read(path);
//操作图片
let image = $img.gray(img);
//显示图片
$img.show(image);
```


### threshold(image, min, max)

> 二值化图片

- 参数 : image {Image} 需要处理的图片
- 参数 : min {double} 最小阈值
- 参数 : max {double} 最大阈值
- 返回 : {Image} 处理后的图片


```javascript
//图片路径
let path = "sdcard/Pictures/示例/$img/res/p02.png";
//读取图片
let img = $img.read(path);
//操作图片
let image = $img.threshold(img, 150, 255);
//显示图片
$img.show(image);
```


### adaptiveThreshold(image, maxValue, adaptiveMethod, thresholdType, blockSize, C)

> 自适应二值化

- 参数 : image {Image} 图片
- 参数 : maxValue {number} 最大值
- 参数 : adaptiveMethod {string} 在一个邻域内计算阈值所采用的算法 默认值是：GAUSSIAN_C
- 参数 : thresholdType {string} 阈值化类型 默认值是：BINARY
- 参数 : blockSize {number} 邻域块大小
- 参数 : C {number} 偏移值调整量
- 返回 : {Image} 处理后的图片


```javascript
//图片路径
let path = "sdcard/Pictures/示例/$img/res/p02.png";
//读取图片
let img = $img.read(path);
//操作图片
let image = $img.adaptiveThreshold(img,255,"MEAN_C","BINARY", 11, 2);
//显示图片
$img.show(image);
```


### cvtColor(img, code, dstCn)

> 颜色空间转换

- 参数 : img {Image} 图片
- 参数 : code {string} 颜色空间转换的类型，可选的值有一共有205个 默认值:COLOR_BGR2GRAY
- 参数 : dstCn {int} 目标图像的颜色通道数量，如果不填写则根据其他参数自动决定。
- 返回 : {Image} 颜色转换后的图片


```javascript
//图片路径
let path = "sdcard/Pictures/示例/$img/res/p02.png";
//读取图片
let img = $img.read(path);
//操作图片
let image = $img.cvtColor(img,"RGBA2BGR",null);
//显示图片
$img.show(image);
```


### cvtColor(img, code)

> 颜色空间转换

- 参数 : img {Image} 图片
- 参数 : code {string} 颜色空间转换的类型，可选的值有一共有205个 默认值:COLOR_BGR2GRAY
- 返回 : {Image} 颜色转换后的图片


```javascript
//图片路径
let path = "sdcard/Pictures/示例/$img/res/p02.png";
//读取图片
let img = $img.read(path);
//操作图片
let image = $img.cvtColor(img,"RGBA2BGR");
//显示图片
$img.show(image);
```


### inRange(img, lowerBound, upperBound)

> 图片二值化

- 参数 : img {Image} 图片
- 参数 : lowerBound {string|number}  颜色下界
- 参数 : upperBound {string|number}  颜色上界
- 返回 : {Image} 处理后的图片


```javascript
//图片路径
let path = "sdcard/Pictures/示例/$img/res/p02.png";
//读取图片
let img = $img.read(path);
//操作图片
let image = $img.inRange(img,"#666666","#FFFFFF");
//显示图片
$img.show(image);
```


### blur(img, size, point, type)

> 模糊处理
> 
> 模糊类型(不区分大小写)：
> CONSTANT,
> REPLICATE,
> REFLECT,
> WRAP,
> REFLECT_101,
> TRANSPARENT,
> REFLECT101,
> DEFAULT,
> ISOLATED

- 参数 : img {Image} 图片
- 参数 : size {double[]} 定义滤波器的大小，如[3, 3]
- 参数 : point {double[]} 指定锚点位置(被平滑点)，默认为图像中心
- 参数 : type {string} 推断边缘像素类型，默认为"DEFAULT"
- 返回 : {Image} 处理后的图片


```javascript
//图片路径
let path = "sdcard/Pictures/示例/$img/res/p02.png";
//读取图片
let img = $img.read(path);
//操作图片
let image = $img.blur(img,[10,10],[-1,-1],"REPLICATE");
//显示图片
$img.show(image);
```


### medianBlur(img, size)

> 中值滤波

- 参数 : img {Image} 图片
- 参数 : size {int} 定义滤波器的大小
- 返回 : {Image} 处理后的图片


```javascript
//图片路径
let path = "sdcard/Pictures/示例/$img/res/p02.png";
//读取图片
let img = $img.read(path);
//操作图片
let image = $img.medianBlur(img,3);
//显示图片
$img.show(image);
```


### gaussianBlur(img, size, sigmaX, sigmaY, type)

> 高斯模糊
> 
> 模糊类型(不区分大小写)：
> CONSTANT,
> REPLICATE,
> REFLECT,
> WRAP,
> REFLECT_101,
> TRANSPARENT,
> REFLECT101,
> DEFAULT,
> ISOLATED

- 参数 : img {Image} 图片
- 参数 : size {double[]} 定义滤波器的大小，如[3, 3]
- 参数 : sigmaX {double} x方向的标准方差，不填写则自动计算
- 参数 : sigmaY {double} y方向的标准方差，不填写则自动计算
- 参数 : type {string} 推断边缘像素类型，默认为"DEFAULT"
- 返回 : {Image} 处理后的图片


```javascript
//图片路径
let path = "sdcard/Pictures/示例/$img/res/p02.png";
//读取图片
let img = $img.read(path);
//操作图片
let image = $img.gaussianBlur(img,[15,15],0,0,"WRAP");
//显示图片
$img.show(image);
```


### flip(image)

> 左右翻转

- 参数 : image {Image} 需要处理的图片
- 返回 : {Image} 处理后的图片


```javascript
//图片路径
let path = "sdcard/Pictures/示例/$img/res/p02.png";
//读取图片
let img = $img.read(path);
//操作图片
let image = $img.flip(img);
//显示图片
$img.show(image);
```


### upside(image)

> 上下翻转

- 参数 : image {Image} 需要处理的图片
- 返回 : {Image} 处理后的图片


```javascript
//图片路径
let path = "sdcard/Pictures/示例/$img/res/p02.png";
//读取图片
let img = $img.read(path);
//操作图片
let image = $img.upside(img);
//显示图片
$img.show(image);
```


### flip(image, sx, sy)

> 水平翻转

- 参数 : image {Image} 需要处理的图片
- 参数 : sx {float}   横向翻转的方向
- 参数 : sy {float}  纵向翻转的方向
- 返回 : {Image} 处理后的图片


```javascript
//图片路径
let path = "sdcard/Pictures/示例/$img/res/p02.png";
//读取图片
let img = $img.read(path);
//操作图片(上下反转)
let image = $img.flip(img,-1,-1);
//显示图片
$img.show(image);
```


### putTop(bigImg, smallImg, x, y)

> 在大图片上面放置一个小图片

- 参数 : bigImg {Image} 大图片
- 参数 : smallImg {Image} 小图片
- 参数 : x {int} 小图片左上角x
- 参数 : y {int} 小图片左上角y
- 返回 : {Image}  处理完成的图片


```javascript
//图片路径
let path1 = "sdcard/Pictures/示例/$img/res/p02.png"; //大图片
let path2 = "sdcard/Pictures/示例/$img/res/p04.png"; //小图片
let bigImg = $img.read(path1);
let smallImg = $img.read(path2);
//设置放置的位置
let image = $img.putTop(bigImg, smallImg, 20, 20);
//显示图片
$img.show(image);
```


### findColor(image, color, threshold, x, y, w, h)

> 查找颜色

- 参数 : image {Image} 需要处理的图片
- 参数 : color {string} 需要查找的颜色
- 参数 : threshold {int} 阈值
- 参数 : x {int} 范围x起点坐标
- 参数 : y {int} 范围y起点坐标
- 参数 : w {int} 范围宽度
- 参数 : h {int} 范围高度
- 返回 : {Image} 处理后的图片


```javascript
let img = $img.read("/$img/res/t01.png");
let point = $img.findColor(img,"#d80005",5,0,0,100,100);
alert("结果",point);
```


### findColor(image, color, threshold, region)

> 查找颜色

- 参数 : image {Image} 需要处理的图片
- 参数 : color {string} 需要查找的颜色
- 参数 : threshold {int} 阈值
- 参数 : region {int[]}  找色范围
- 返回 : {Point} 找到的结果


```javascript
let img = $img.read("/$img/res/t01.png");
let point = $img.findColor(img,"#d80005",5,[0,0,100,100]);
alert("结果",point);
```


### findColor(image, color, threshold)

> 查找颜色

- 参数 : image {Image}  需要处理的图片
- 参数 : color {string} 需要查找的颜色
- 参数 : threshold {int} 阈值
- 返回 : {Image} 处理后的图片


```javascript
let img = $img.read("/$img/res/t01.png");
let point = $img.findColor(img,"#d80005",5);
alert("结果",point);
```


### findColor(image, color)

> 查找颜色

- 参数 : image {Image} 需要处理的图片
- 参数 : color {string} 需要查找的颜色
- 返回 : {Image} 处理后的图片


```javascript
let img = $img.read("/$img/res/t01.png");
let point = $img.findColor(img,"#d80005");
alert("结果",point);
```


### findMultiColors(image, region, color, threshold, colors)

> 多点找色

- 参数 : image {Image} 图片
- 参数 : region {int[]} 范围
- 参数 : color {string} 起点颜色
- 参数 : threshold {int} 起点色阈值
- 参数 : colors {int[]} 点色数据
- 返回 : {point} 位置


```javascript
let img = $img.read("/$img/res/t01.png");
let point = $img.findMultiColors(img,[0],"#e70216",5,[
	-54, -13, "#db0306", 5,
	-121, -13, "#dc0407", 5,
	-155, -18, "#d80306", 5,
	-132, -85, "#da0306", 5,
	-78, -63, "#dd0206", 5,
	-49, -100, "#db0306", 5,
	6, -77, "#db0306", 5,
	3, -42, "#db0306", 5,
	-103, -52, "#dc0406", 5,
]);
alert("结果",point);
```


### findImg(bigImg, minImg, options)

> 找图

- 参数 : bigImg {Image} 大图片
- 参数 : minImg {Image} 小图片
- 参数 : options {object} 参数
- 返回 : {Point} 找到的位置(中心点)


```javascript
//相对于项目的路径
let img1 = $img.read("/$img/res/t04.png");
let img2 = $img.read("/$img/res/t05.png");
let point = $img.findImg(img1,img2,{
    similar:0.8,//(可选)相似度
    region:[0,0,500,600],//(可选)范围
    trans:false,//(可选)是否开启透明找图模式
    drawResult:true,//(可选)是否保存结果图片
    savePath:"/$img/img/result.png",//(可选)保存结果图片
});
alert("结果",point);
if($file.exists("/$img/img/result.png")){
    showImg("/$img/img/result.png");
}
```


### findImg(bigImg, minImg)

> 找图

- 参数 : bigImg 大图片
- 参数 : minImg 小图片
- 返回 : 找到的位置(中心点)


```javascript
//相对于项目的路径
let img1 = $img.read("/$img/res/t05.png");
let img2 = $img.read("/$img/res/t04.png");
let point = $img.findImg(img1,img2);
alert("结果",point);
```


### findImgAll(bigImg, minImg, options)

> 找到所有图片位置

- 参数 : bigImg {Image} 大图片
- 参数 : minImg {Image} 需要查找的小图片
- 参数 : options {object} 查找参数
- 返回 : {point[]} 所有的位置集合


```javascript
let img1 = $img.read("/$img/res/t06.png");
let img2 = $img.read("/$img/res/t07.png");
let point = $img.findImgAll(img1,img2,{
    similar:0.8,//(可选)相似度
    region:[0,0,350,280],//(可选)范围
    trans:false,//(可选)是否开启透明找图模式
    drawResult:true,//(可选)是否保存结果图片
    savePath:"/$img/img/result.png",//(可选)保存结果图片
});
alert("结果",point);
if($file.exists("/$img/img/result.png")){
    showImg("/$img/img/result.png");
}
```


### findImgAll(bigImg, minImg)

> 找到所有图片位置

- 参数 : bigImg {Image} 大图片
- 参数 : minImg {Image} 需要查找的小图片
- 返回 : {point[]} 所有的位置集合


```javascript
let img1 = $img.read("/$img/res/t06.png");
let img2 = $img.read("/$img/res/t07.png");
let point = $img.findImgAll(img1,img2);
alert("结果",point);
if($file.exists("/$img/img/result.png")){
    showImg("/$img/img/result.png");
}
```


### featureMatch(bigImg, smallImg, params)

> 特征匹配

- 参数 : bigImg {Image} 大图
- 参数 : smallImg {Image} 小图
- 参数 : params {Image} 特征匹配参数
- 返回 : {Result} 结果集


```javascript
let img1 = $img.read("/$img/res/t04.png");
let img2 = $img.read("/$img/res/t05.png");
let point = $img.featureMatch(img1,img2,{
    similar:0.75,//(可选)相似度
    fastMode:false,//(可选)快速模式
    isGray:false,//(可选)灰度化后匹配
    drawKeyPoints:false,//(可选)结果图片是否绘制特征点
    drawMatches:true,//(可选)结果图片是否绘制匹配点
    drawResult:true,//(可选)是否绘制结果图片
    savePath:"/$img/img/result_feature.png",//(可选)保存图片路径
});
alert("结果",point);
if($file.exists("/$img/img/result_feature.png")){
    showImg("/$img/img/result_feature.png");
}
```


### featureMatch(bigImg, smallImg)

> 特征匹配

- 参数 : bigImg {Image}  大图
- 参数 : smallImg {Image} 小图
- 返回 : {Result} 找到的图片中心点


```javascript
let img1 = $img.read("/$img/res/t04.png");
let img2 = $img.read("/$img/res/t05.png");
let point = $img.featureMatch(img1,img2);
alert("结果",point);
```


### show(image)

> 显示图片

- 参数 : image 需要显示的图片


### show(path)

> 显示图片

- 参数 : path {string} 图片路径


```javascript
//把图片显示在屏幕上
let imgPath = "sdcard/Pictures/t01.png";
$img.show(imgPath);
```


# $log - 日志框架

- 更新时间:2025-12-13 11:58:45

> 日志框架




### i(args)

> 打印信息日志

- 参数 : args {string...} 日志
- 版本 : 1.0.0


```javascript
$log.i("信息");
```


### info(args)

> 打印信息日志

- 参数 : args {string...} 日志
- 版本 : 1.0.0


```javascript
$log.info("信息");
```


### d(args)

> 打印调试日志

- 参数 : args {string...} 日志
- 版本 : 1.0.0


```javascript
$log.d("调试");
```


### debug(args)

> 打印调试日志

- 参数 : args {string...} 日志
- 版本 : 1.2.8


```javascript
$log.debug("调试");
```


### w(args)

> 打印警告日志

- 参数 : args {string...} 日志
- 版本 : 1.0.0


```javascript
$log.w("警告");
```


### warn(args)

> 打印警告日志

- 参数 : args {string...} 日志
- 版本 : 1.2.8


```javascript
$log.warn("警告");
```


### e(args)

> 打印异常日志

- 参数 : args {string...} 日志
- 版本 : 1.0.0


```javascript
$log.e("异常");
```


### err(args)

> 打印异常日志

- 参数 : args {string...} 日志
- 版本 : 1.2.8


```javascript
$log.err("异常");
```


### v(args)

> 打印冗余日志

- 参数 : args {string...} 日志
- 版本 : 1.0.0


```javascript
$log.v("冗余");
```


### log(args)

> 打印日志

- 参数 : args {string...} 日志
- 版本 : 1.0.0


```javascript
$log.log("hello");
```


### print(args)

> 打印日志

- 参数 : args {string...} 日志
- 版本 : 1.2.0


```javascript
$log.print("hello");
```


### floaty()

> 打开日志悬浮窗

- 版本 : 1.0.0


```javascript
$log.floaty();
```


### activity()

> 打开日志界面

- 版本 : 1.1.2


```javascript
$log.activity();
```


### delete()

> 删除本地缓存

- 版本 : 1.0.6


```javascript
$log.delete();
```


# $media - 媒体播放

- 更新时间:2025-12-13 11:58:45

> 媒体播放




### play(path)

> 播放音频
> 
> 直接播放音频，播放结束之后我将自动回收音频资源。
> 
> 注意:如果音频资源加载失败会返回null，资源文件已经处于播放状态也会返回null(不过一般不会出现这个情况，因为每次调用play函数的时候都会重新创建新的媒体播放器，因此播放状态也是未播放的)。

- 参数 : path {string} 音频路径(支持相对路径) 
- 返回 : {MediaPlayer} 媒体播放器
- 版本 : 1.5.2


```javascript
$media.play("res/mTip.mp3");
```


### create()

> 创建媒体播放器
> 
> 当你拿到MediaPlayer对象之后，它的所有方法请参考{android.media.MediaPlayer}类

- 返回 : {MediaPlayer} 媒体播放器
- 版本 : 1.5.2


```javascript
let mediaPlayer = $media.create();
//常用的{MediaPlayer}方法有:其他方法请参考{android.media.MediaPlayer}类
//mediaPlayer.isPlaying();//是否处于播放状态
//mediaPlayer.isLooping();//是否是循环播放
//mediaPlayer.start();//开始播放
//mediaPlayer.stop();//停止播放
//mediaPlayer.getDuration();//总时长
//mediaPlayer.getCurrentPosition();//当前进度
//mediaPlayer.seekTo(long,int);//跳转到进度
//mediaPlayer.seekTo(int);//跳转到进度
//mediaPlayer.prepare();//准备资源
//mediaPlayer.reset();//重置
//mediaPlayer.release();//释放资源
```


### create(path)

> 创建媒体播放器
> 
> 创建媒体播放器，并且加载音频路径，如果加载成功则返回媒体播放器，如果加载失败则返回null。

- 参数 : path {string} 音频路径(支持相对路径) 
- 返回 : {MediaPlayer} 媒体播放器
- 版本 : 1.5.2


### setPath(mediaPlayer, path)

> 为媒体播放器设置音频路径
> 
> 如果音频资源没有找到，则会返回false，如果成功设置，则会准备音频，并且返回true。
> 
> 如果此函数被重复调用，可能会抛出异常。

- 参数 : mediaPlayer {MediaPlayer} 媒体播放器 
- 参数 : path {string} 音频路径 
- 返回 : {boolean} 是否设置成功
- 版本 : 1.5.2


# OcrOptions - 识别配置

- 更新时间:2025-12-13 11:58:45

> 识别配置




### const {String} color;

> 二值化识别需要指定文字颜色


### const {Number[]} region;

> 识别区域


### const {Integer} threshold;

> 二值化识别文字用到的阈值


### const {Boolean} gray;

> 是否使用灰度化识别


### const {Boolean} number;

> 是否提取数字


### const {Boolean} save;

> 是否保存结果


### const {String} savePath;

> 保存路径
> 
> 当开启保存结果图片的时候才会按照这个路径来保存处理后的图片


# $ocr - 文字识别

- 更新时间:2025-12-13 11:58:45

> 文字识别
> 
> 文字识别是指通过计算机视觉技术，将图片中的文字提取出来，转换为程序可处理的文本格式。文字识别在很多场景下都有广泛的应用，比如文档扫描、图片识别、验证码识别等等。
> 
> 目前本应用内涵盖三种识别引擎,分别是 PaddleOcr、PpOcrV5、GoogleMlkit。




### v(name)

> 设置要使用的OCR引擎
> 
> 下面我简单介绍几个识别引擎的特点,ncnn速度最快,但是部分手机会出现识别混乱的现象;
> mlkit是google提供的OCR引擎,速度较慢,但是识别准确率较高,并且兼容性比ncnn好很多;
> ppv5是2025年比较流行的一款OCR识别方案,支持识别中英文以及特殊字符,精确度高,不过它是和ncnn同系列的产品;

- 参数 : name {string} 可选:ncnn,mlkit(默认),ppv5 
- 版本 : 1.2.2


```javascript
//此函数要放在识别之前调用
$ocr.v("mlkit");//设置要使用的OCR引擎
```


### init()

> 初始化ocr
> 
> 在使用OCR(文字识别)之前,需要加载文字模型,因此需要进行初始化,不过目前版本来看,初始化速度都很快,一般都在1秒左右
> 
> 实际上mlkit是不需要初始化的,此外如果你忘记了初始化,在进行识别文字的时候,也会自动进行初始化

- 返回 : {DetectResult} 结果
- 版本 : 1.0.0


```javascript
$ocr.init();
```


### getPoint(word, options)

> 识别文字拿位置
> 
> 识别后将把每行结果去除空格和换行符后,判断是否包含指定文字,如果包含则返回该文字识别出来的位置
> 
> 该函数其实是对detect函数的封装,只是在识别到文字后,会判断文字关系是否包含指定文字,如果包含则返回该文字识别出来的位置

- 参数 : word {string} 文字 
- 参数 : options {OcrOptions} 配置 
- 返回 : {Point} 位置
- 版本 : 1.0.0


```javascript
//配置方式1:灰度化识别
let options = {
    region: [0,0,200,100], //(可选)识别范围(为空则识别整个屏幕)
    gray: true, //(必须)开启灰度化(默认:false),开启后会将图片转换为灰度图,识别速度会快很多,但是识别准确率会低一些
    save: true, //(可选)是否保存图片(默认:false),开启后会将识别到的图片保存到指定路径
    savePath: "/sdcard/ocr.png" //(可选)保存图片路径(为空则不保存图片),仅开启保存图片功能时有效
};
//配置方式2:二值化识别
let options = {
    region: [0,0,200,100], //(可选)识别范围(为空则识别整个屏幕)
    color: "#EEEEEE", //(必须)文字颜色(默认:#EEEEEE)
    threshold: 20, //(可选)二值化阈值(默认:20)推荐在20-50之间
    save: true, //(可选)是否保存图片(默认:false),开启后会将识别到的图片保存到指定路径
    savePath: "/sdcard/ocr.png" //保存图片路径(为空则不保存图片),仅开启保存图片功能时有效
};
//上面的配置自己根据自身需求选择一个即可
//返回opencv的Point对象
let point = $ocr.getPoint("文字", options);
if (point != null) {
    //直接点击opencv的Point对象
    $act.click(point);
}
```


### line(options)

> 识别单行文字
> 
> 识别的方式有二值化和灰度化，自行配置即可，识别完成后会对识别的结果进行包装处理，提取出文字为单行字符串，并且去除不需要的空格和换行符。
> 
> 当你开启提取数字的时候,该函数会把提取的数字按照','号进行分隔。
> 
> 该函数是对detect函数的封装,只是在识别到文字后,会先去除空白字符之后拼接成一行;

- 参数 : options {OcrOptions} 配置 
- 返回 : {String} 一行字符
- 版本 : 1.0.0


```javascript
let options = {
    region: [0,0,200,100], //(推荐)识别范围(为空则识别整个屏幕)
    number: true, //(可选)是否提取数字(用,号分割)
    //其他配置项目参考detect方法
};
let result = $ocr.line(options);
```


### detect(options)

> 识别文字
> 
> 会自动截屏并且识别文字,支持灰度化识别,支持二值化(默认)识别
> 
> 如果你是小白,那么请记住:二值化其实就是把图片转换为黑白的图片,而灰度化就是把图片转换为灰度的图片,经过处理之后的图片识别起来更加准确。

- 参数 : options {OcrOptions} 参数 
- 返回 : {DetectResult} 结果
- 版本 : 1.0.0


```javascript
//灰度化识别
let options = {
    region: [0,0,200,100], //识别范围(为空则识别整个屏幕)
    gray: true, //开启灰度化
    save: true, //是否保存图片
    savePath: "/sdcard/ocr.png" //保存图片路径(为空则不保存图片)
};
let result = $ocr.detect(options);
//二值化识别
let options = {
    region: [0,0,200,100], //识别范围(为空则识别整个屏幕)
    color: "#EEEEEE", //文字颜色(默认:#EEEEEE)
    threshold: 20, //二值化阈值(默认:20)
    save: true, //是否保存图片
    savePath: "/sdcard/ocr.png" //保存图片路径(为空则不保存图片)
};
//最原始的识别函数
let result = $ocr.detect(options);
```


### detect64(base64)

> 识别base64图片

- 参数 : base64 {String} 图片base64字符串 
- 返回 : {DetectResult} 结果
- 版本 : 1.0.0


```javascript
//识别base64图片
let img = $img.read("/sdcard/test.png");
let base64 = $img.toBase64(img);
//一般情况下,base64可以从服务器端获取,而上面的代码是把本地图片转成base64的
let result = $ocr.detect64(base64);
```


### detectPath(imgPath)

> 识别路径中图片

- 参数 : imgPath {String} 图片路径 
- 返回 : {DetectResult} 结果
- 版本 : 1.0.0


```javascript
//识别本地图片
let result = $ocr.detectPath("/sdcard/test.png");
```


### detectImg(img)

> 识别图片

- 参数 : img {Image} 图片对象 
- 返回 : {DetectResult} 结果
- 版本 : 1.0.0


```javascript
//获取本地图片对象
let img = $img.read("/sdcard/test.png");
//识别图片对象
let result = $ocr.detectImg(img);
if (result.isSuccess()) {
    //...
}
```


### detectBitmap(bitmap)

> 识别路径中图片

- 参数 : bitmap {Bitmap} 位图对象 
- 返回 : {DetectResult} 结果
- 版本 : 1.7.0


```javascript
//获取一个位图对象
let img = $img.read("/sdcard/t01.png");
let bitmap = img.getBitmap();
//识别本地图片
let result = $ocr.detectBitmap(bitmap);
```


# $permit - 权限工具

- 更新时间:2025-12-13 11:58:46

> 权限工具




### floaty()

> 获取悬浮窗权限
> 
> 注意：在$permit中调用任何权限,都只会调用一次

- 版本 : 1.1.6


```javascript
//获取悬浮窗权限
$permit.floaty();
```


### hasFloaty()

> 判断是否有悬浮窗权限
> 
> 注意：在$permit中调用任何权限,都只会调用一次

- 返回 : {boolean} 是否有权限
- 版本 : 1.1.6


```javascript
log("悬浮窗",$permit.hasFloaty());
```


### wza()

> 获取无障碍权限
> 
> 注意：在$permit中调用任何权限,都只会调用一次
> 
> 如果有Root权限:则使用Root权限为本应用授权永久无障碍
> 
> 如果有Shizuku权限:则使用Shizuku权限为本应用授权永久无障碍
> 
> 如果没有Root和Shizuku:则进行普通权限申请(非永久有效,受系统限制)

- 版本 : 1.1.6


```javascript
//获取无障碍权限
$permit.wza();
```


### hasWza()

> 判断是否有无障碍权限
> 
> 注意：在$permit中调用任何权限,都只会调用一次

- 返回 : {boolean} 是否有权限
- 版本 : 1.1.6


```javascript
log("无障碍",$permit.hasWza());
```


### sd()

> 获取存储权限
> 
> 注意：在$permit中调用任何权限,都只会调用一次

- 版本 : 1.1.6


```javascript
//获取存储权限
$permit.sd();
```


### hasSd()

> 判断是否有存储权限
> 
> 注意：在$permit中调用任何权限,都只会调用一次

- 返回 : {boolean} 是否有权限
- 版本 : 1.1.6


```javascript
log("存储权限",$permit.hasSd());
```


### call()

> 获取电话权限
> 
> 注意：在$permit中调用任何权限,都只会调用一次

- 版本 : 1.1.6


```javascript
//获取电话权限
$permit.call();
```


### hasCall()

> 判断是否有电话权限
> 
> 注意：在$permit中调用任何权限,都只会调用一次

- 返回 : {boolean} 是否有权限
- 版本 : 1.1.6


```javascript
log("打电话",$permit.hasCall());
```


### set()

> 获取修改系统设置权限
> 
> 注意：在$permit中调用任何权限,都只会调用一次

- 版本 : 1.1.6


```javascript
//获取修改设置权限
$permit.set();
```


### hasSet()

> 判断是否有修改系统设置权限
> 
> 注意：在$permit中调用任何权限,都只会调用一次

- 返回 : {boolean} 是否有权限
- 版本 : 1.1.6


```javascript
log("修改设置",$permit.hasSet());
```


### net()

> 获取网络权限
> 
> 注意：在$permit中调用任何权限,都只会调用一次

- 版本 : 1.1.6


```javascript
//获取网络权限
$permit.net();
```


### hasNet()

> 判断是否有网络权限
> 
> 注意：在$permit中调用任何权限,都只会调用一次

- 返回 : {boolean} 是否有权限
- 版本 : 1.1.6


```javascript
log("网络权限",$permit.hasNet());
```


### camera()

> 获取相机权限
> 
> 注意：在$permit中调用任何权限,都只会调用一次

- 版本 : 1.1.6


```javascript
//获取相机权限
$permit.camera();
```


### hasCamera()

> 判断是否有相机权限
> 
> 注意：在$permit中调用任何权限,都只会调用一次

- 返回 : {boolean} 是否有权限
- 版本 : 1.1.6


```javascript
log("相机权限",$permit.hasCamera());
```


### record()

> 获取录音权限
> 
> 注意：在$permit中调用任何权限,都只会调用一次

- 版本 : 1.1.6


```javascript
//获取录音权限
$permit.record();
```


### hasRecord()

> 判断是否有录音权限
> 
> 注意：在$permit中调用任何权限,都只会调用一次

- 返回 : {boolean} 是否有权限
- 版本 : 1.1.6


```javascript
log("录音权限",$permit.hasRecord());
```


### readSms()

> 获取读取短信权限
> 
> 注意：在$permit中调用任何权限,都只会调用一次

- 版本 : 1.1.6


```javascript
//获取读取信息权限
$permit.readSms();
```


### hasReadSms()

> 判断是否有读取短信权限
> 
> 注意：在$permit中调用任何权限,都只会调用一次

- 返回 : {boolean} 是否有权限
- 版本 : 1.1.6


```javascript
log("读取短信",$permit.hasReadSms());
```


### sendSms()

> 获取发送短信权限
> 
> 注意：在$permit中调用任何权限,都只会调用一次

- 版本 : 1.1.6


```javascript
//获取发送信息权限
$permit.sendSms();
```


### hasSendSms()

> 判断是否有发送短信权限
> 
> 注意：在$permit中调用任何权限,都只会调用一次

- 返回 : {boolean} 是否有权限
- 版本 : 1.1.6


```javascript
log("发送短信",$permit.hasSendSms());
```


### readContact()

> 获取读取联系人权限
> 
> 注意：在$permit中调用任何权限,都只会调用一次

- 版本 : 1.1.6


```javascript
//获取读取联系人权限
$permit.readContact();
```


### hasReadContact()

> 判断是否有读取联系人权限
> 
> 注意：在$permit中调用任何权限,都只会调用一次

- 返回 : {boolean} 是否有权限
- 版本 : 1.1.6


```javascript
log("读取联系人",$permit.hasReadContact());
```


### writeContact()

> 获取写入联系人权限
> 
> 注意：在$permit中调用任何权限,都只会调用一次

- 版本 : 1.1.6


```javascript
//获取写入联系人权限
$permit.writeContact();
```


### hasWriteContact()

> 判断是否有写入联系人权限
> 
> 注意：在$permit中调用任何权限,都只会调用一次

- 返回 : {boolean} 是否有权限
- 版本 : 1.1.6


```javascript
log("写入联系人",$permit.hasWriteContact());
```


### loc()

> 获取定位权限
> 
> 注意：在$permit中调用任何权限,都只会调用一次

- 版本 : 1.1.6


```javascript
//获取定位权限
$permit.loc();
```


### hasLoc()

> 判断是否有定位权限
> 
> 注意：在$permit中调用任何权限,都只会调用一次

- 返回 : {boolean} 是否有权限
- 版本 : 1.1.6


```javascript
log("位置权限",$permit.hasLoc());
```


### readCalendar()

> 获取读取日历权限
> 
> 注意：在$permit中调用任何权限,都只会调用一次

- 版本 : 1.2.2


```javascript
//获取读取日历权限
$permit.readCalendar();  //获取读取日历权限
```


### hasReadCalendar()

> 判断是否有读取日历权限
> 
> 注意：在$permit中调用任何权限,都只会调用一次

- 返回 : {boolean} 是否有权限
- 版本 : 1.2.2


```javascript
log("读取日历",$permit.hasReadCalendar());
```


### writeCalendar()

> 获取写入日历权限
> 
> 注意：在$permit中调用任何权限,都只会调用一次

- 版本 : 1.2.2


```javascript
//获取写入日历权限
$permit.writeCalendar();
```


### hasWriteCalendar()

> 判断是否有写入日历权限
> 
> 注意：在$permit中调用任何权限,都只会调用一次

- 返回 : {boolean} 是否有权限
- 版本 : 1.2.2


```javascript
log("写入日历",$permit.hasWriteCalendar());
```


### hasPermit(permitName)

> 判断是否有权限
> 
> 注意：在$permit中调用任何权限,都只会调用一次

- 参数 : permitName {string} 权限名 
- 返回 : {boolean} 是否有权限
- 版本 : 1.2.2


```javascript
//判断是否有权限
$permit.hasPermit("android.Manifest.permission.GET_ACCOUNTS");
//等同于
$permit.hasPermit("android.permission.GET_ACCOUNTS");
```


### hasPermit(permitNames)

> 判断是否有权限
> 
> 注意：在$permit中调用任何权限,都只会调用一次

- 参数 : permitNames {string[]} 权限名 
- 返回 : {boolean} 是否有权限
- 版本 : 1.2.2


```javascript
let permits = ["android.permission.READ_CALENDAR","android.permission.WRITE_CALENDAR"];
//判断是否有权限
$permit.hasPermit(permits);
```


### getPermit(permitNames)

> 获取权限
> 
> 注意：在$permit中调用任何权限,都只会调用一次

- 参数 : permitNames {string[]} 权限名 
- 版本 : 1.2.2


```javascript
let permits = ["android.permission.READ_CALENDAR","android.permission.WRITE_CALENDAR"];
//获取权限
$permit.getPermit(permits);
```


### getPermit(permitName)

> 获取权限
> 
> 注意：在$permit中调用任何权限,都只会调用一次

- 参数 : permitName {string} 权限名 
- 版本 : 1.2.2


```javascript
//获取权限
$permit.getPermit("android.Manifest.permission.GET_ACCOUNTS");
//等同于
$permit.getPermit("android.permission.GET_ACCOUNTS");
```


### hasNotifyAccess()

> 是否已授予通知访问权限

- 返回 : {boolean} 是否有通知访问权限
- 版本 : 1.6.4


### notifyAccess()

> 获取通知访问权限
> 
> 此权限将允许应用读取所有通知

- 版本 : 1.6.4


### hasReadVideo()

> 判断是否有读取视频权限

- 返回 : {boolean} 是否有读取视频权限
- 版本 : 1.6.4


### readVideo()

> 获取读取视频权限

- 版本 : 1.6.4


### hasReadImage()

> 判断是否有读取图片权限

- 返回 : {boolean} 是否有读取视频权限
- 版本 : 1.6.4


### readImage()

> 获取读取图片权限

- 版本 : 1.6.4


### hasReadAudio()

> 判断是否有读取音频权限

- 返回 : {boolean} 是否有读取视频权限
- 版本 : 1.6.4


### readAudio()

> 获取读取音频权限

- 版本 : 1.6.4


### hasReadMedia()

> 判断是否有读取媒体权限
> 
> 这个方法综合了读取音频、图片、视频权限

- 返回 : {boolean} 是否有读取媒体权限
- 版本 : 1.6.4


### readMedia()

> 获取读取媒体权限
> 
> 这个方法综合了读取音频、图片、视频权限

- 版本 : 1.6.4


# <span style="color: green">[稳定]</span>$plugin - 插件开发

> 我将教会你如何开发属于自己的apk插件，你可以在手机上开发，也可以使用电脑。 手机上开发，推荐使用AIDE进行安卓app的开发；
> 电脑端推荐使用AndroidStudio进行安卓app开发。



## 01.开发插件类

> 在你的项目中随便创建一个类，类名、包名都可随意，不过你需要遵守一个规则：那就是构造函数的参数类型，必须是(Activity,Context)，除此以外，没有任何限制了。

```java
package com.demo.test1;

import android.app.Activity;
import android.content.Context;
import android.content.res.Resources;

import androidx.appcompat.app.AppCompatActivity;

public class MyPlugin {

    /**
     * 插件类必须有两个构造参数(或者无参构造,但是推荐写两个参数,以便于插件实现更多的功能)
     * <p>
     * 注意：这两个参数类型都不能变！
     *
     * @param parentActivity {Activity} 宿主软件的Activity (测试时可以用插件自己的Activity)
     * @param selfContext    {Context} 插件自己的Context
     */
    public MyPlugin(Activity parentActivity, Context selfContext) {
        //其实宿主软件的Activity是AppCompatActivity类型的，因此如果你想访问宿主软件的activity的主题等资源，可以这么做：
        if (parentActivity instanceof AppCompatActivity) {
            AppCompatActivity appCompatActivity = (AppCompatActivity) parentActivity;
            //获取宿主软件的主题(M3风格的主题)
            Resources.Theme theme = appCompatActivity.getTheme();
            //获取宿主软件的资源
            Resources resources = appCompatActivity.getResources();
        }
    }

    //插件被加载后，这个函数就可以被直接调用了
    public String getPluginName() {
        return "MyPlugin";
    }

    //你也可以继续写更多你想实现的方法
}
```

### 02.添加元数据

> 当你开发玩自己的插件类的时候，你需要把这个类显示声明在元数据中，否则宿主软件无法找到这个类。


```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools">

    <application android:label="我的插件" android:icon="@mipmap/ic_launcher">

        <!--
        在这里定义一个元数据
        名称(name)必须是：org.aigame.plugin.className
        值(value)是插件的全类名：当$plugin加载后会创建这个类的实例
        -->
        <meta-data android:name="org.aigame.plugin.className"
            android:value="com.demo.test1.MyPlugin" />

    </application>
</manifest>
```


### 03.安装与调用

> 你需要把开发好的插件apk安装到手机上，然后在宿主软件中使用$plugin来调用插件。

```javascript
//1.加载插件
let obj = $plugin.load("com.demo.test1");
//2.调用插件类中的函数
obj.getPluginName();
```

# $plugin - 插件系统

- 更新时间:2025-12-13 11:58:46

> 插件系统
> 
> 本应用内置一个使用非常方便的插件系统，开发者可以开发自己的apk插件并且在这里进行调用。
> 
> 一个插件其实就是一个apk文件，它被安装在安卓手机上，之后就可以在本应用中使用$plugin进行调用。
> 
> 
> 和$ext不同的地方在于：
> 
> 1.$ext主要用于加载dex、jar、so、apk文件，$ext加载的是apk文件，无需安装apk文件，并且可以直接使用apk中的类。
> 
> 2.$plugin对象主要通过load("包名")加载已安装的插件apk，加载完成后，会返回一个主类对象，该对象中的函数可以直接调用，无需像$ext加载的apk那样需要导包调用。
> 
> 3.$plugin插件机制访问插件apk的资源更加方便。




### load(packageName)

> 加载插件

- 参数 : packageName {string} 插件的包名 
- 返回 : {object} 插件的实例对象
- 版本 : 1.4.0


```javascript
//加载插件
let myObj = $plugin.load("com.example.myplugin");
//使用api
myObj.myApi();
```


### ls()

> 获得插件列表

- 返回 : {AppInfo[]} 插件列表
- 版本 : 1.4.0


```javascript
//罗列所有插件应用
let infoList = $plugin.ls();
//打印信息
for (let info of infoList) {
    log("应用名:",info.appName);
    log("包名:",info.pkgName);
    //显示图标: info.icon.show();
}
```


# QrOptions - 制作二维码配置

- 更新时间:2025-12-13 11:58:46

> 制作二维码配置




### const {Integer} w;

> 宽度(默认500)


### const {Integer} h;

> 高度(默认500)


### const {Integer} margin;

> 边距(默认2)


### const {String} foreColor;

> 前景颜色(默认#000000)


### const {String} bgColor;

> 背景颜色(默认#FFFFFF)


# $qr - 二维码工具

- 更新时间:2025-12-13 11:58:46

> 二维码工具
> 
> 使用$qr你可以实现制作二维码，或者识别二维码




### make(content)

> 制作二维码

- 参数 : content {string} 二维码内容 
- 返回 : {Image} 图片对象
- 版本 : 1.2.3


```javascript
//生成二维码
let img = $qr.make("欢迎来到AIGame!");
//显示图片
img.show();//或者调用 showImg(img); 全局函数也可也显示图片
//保存到本地
img.save("/sdcard/qr.png");
```


### make(content, options)

> 制作二维码

- 参数 : content {string} 二维码内容 
- 参数 : options {QrOptions} 参数 
- 返回 : {Image} 图片对象
- 版本 : 1.2.3


```javascript
//生成二维码
let img = $qr.make("Hello AIGame !", {
    w: 500,//宽度(默认:500)
    h: 500,//高度(默认:500)
    margin: 2,//边距(默认:2)
    foreColor: "#2AACB8",//前景色(默认:#000000)
    bgColor: "#2B2D30",//背景色(默认:#FFFFFF)
});
if (img != null) {
    //显示图片
    img.show(); //或者调用 showImg(img); 全局函数也可也显示图片
    //保存到本地
    img.save("/sdcard/qr.png");
}
```


### parse(path)

> 解析二维码

- 参数 : path {string} 图片路径 
- 返回 : {string} 二维码内容
- 版本 : 1.2.3


```javascript
let content = $qr.parse("/sdcard/qr.png");
```


### parse(image)

> 解析二维码

- 参数 : image {Image} 图片对象 
- 返回 : {string} 二维码内容
- 版本 : 1.2.3


```javascript
//获得image对象
let img = $img.read("/sdcard/qr.png");
//识别image对象
let content = $qr.parse(img);
```


### parse(x, y, w, h)

> 解析屏幕上的二维码
> 
> 根据传入的范围来解析屏幕上的二维码,需要截屏权限

- 参数 : x {int} x坐标 
- 参数 : y {int} y坐标 
- 参数 : w {int} 宽度 
- 参数 : h {int} 高度 
- 返回 : {string} 二维码内容
- 版本 : 1.2.3


```javascript
//截屏后识别指定范围的二维码
let content = $qr.parse(0,400,1080,600);
```


### parse(region)

> 解析屏幕上的二维码
> 
> 根据传入的范围来解析屏幕上的二维码,需要截屏权限

- 参数 : region {int[]} 范围 
- 返回 : {string} 二维码内容
- 版本 : 1.2.3


```javascript
//截屏后识别指定范围的二维码
let content = $qr.parse([0,400,1080,600]);
```


### parse(rect)

> 解析屏幕上的二维码
> 
> 根据传入的范围来解析屏幕上的二维码,需要截屏权限

- 参数 : rect {rect} opencv的范围对象
- 返回 : {string} 二维码内容
- 版本 : 1.2.3


```javascript
//使用opencv中的范围对象
let rect = new org.opencv.core.Rect(0, 400, 1080, 600);
//解析截屏范围中的二维码
let content = $qr.parse(rect);
```


# $res - 资源管理器

- 更新时间:2025-12-13 11:58:46

> 资源管理器
> 
> 针对脚本引擎设计的资源管理器，方便存储和读取资源，支持跨线程访问，在对于一些大型项目中，可以起到非常好的维护效果。




### create(appName)

> 创建一个资源对象

- 参数 : appName {string} 应用名称,决定了资源文件存放的位置 
- 返回 : {AgRes} 资源对象
- 版本 : 1.0.0


```javascript
let res = $res.create("我的资源");
```


### set(resName, resData)

> 设置一个资源

- 参数 : resName {string} 资源名称 
- 参数 : resData {object} 资源数据,就是js对象,可以直接把js对象存入进来,用的时候打点调用即可 
- 版本 : 1.0.0


```javascript
//(1)创建资源对象(指定名称)
let res = $res.create("我的资源");
//(2)添加资源
res.set("名字","张三");
```


### get(resName)

> 获取一个资源

- 参数 : resName {string} 资源名称 
- 返回 : {object} 资源数据
- 版本 : 1.0.0


```javascript
//(1)创建资源对象(指定名称)
let res = $res.create("我的资源");
//(2)添加资源
res.set("名字","张三");
//(3)获取资源
log(res.get("名字"));
```


### get(resName, defaultValue)

> 获取资源

- 参数 : resName {String} 资源名称 
- 参数 : defaultValue {String} 默认值 
- 返回 : {String} 资源值


```javascript
//如果本身就不存在数据，就会返回默认值
let data = $res.get("name","张三");
```


### get(resName, defaultValue)

> 获取资源

- 参数 : resName {String} 资源名称 
- 参数 : defaultValue {float} 默认值 
- 返回 : {float} 资源值


```javascript
//如果本身就不存在数据，就会返回默认值
let data = $res.get("PI",3.14);
```


### get(resName, defaultValue)

> 获取资源

- 参数 : resName {String} 资源名称 
- 参数 : defaultValue {int} 默认值 
- 返回 : {int} 资源值


```javascript
//如果本身就不存在数据，就会返回默认值
let data = $res.get("age",18);
```


### get(resName, defaultValue)

> 获取资源

- 参数 : resName {String} 资源名称 
- 参数 : defaultValue {boolean} 默认值 
- 返回 : {boolean} 资源值


```javascript
//如果本身就不存在数据，就会返回默认值
let isBoy = $res.get("sex",false);
```


### load(path)

> 加载本地资源到内部存储中
> 
> 本质上就是把sdcard下的资源文件拷贝到内部存储中

- 参数 : path {string} 本地资源路径,可以是相对路径,但前提是文件必须要存在 
- 返回 : {boolean} 是否加载成功
- 版本 : 1.1.4


```javascript
//先准备数据名称
let res = $res.create("我的资源");
//加载数据到应用内部存储空间中(导入时不会添加.res后缀名,所以要写全文件名)
res.load("/data.res");//sdcard/当前项目/data.res
//看看数据
log(res.cat());
```


### ls()

> 列出所有资源名称

- 返回 : {string[]} 资源名称列表
- 版本 : 1.0.0


```javascript
//(1)创建资源对象(指定名称)
let res = $res.create("我的资源");
//(2)查询所有资源名称
let resList = res.ls();
log(resList);
```


### cat()

> 查看当前资源内容
> 
> 本质上是将存储的js对象转换成格式化美化后的json字符串

- 返回 : {string} 资源内容
- 版本 : 1.0.0


```javascript
//(1)加载资源对象(指定名称)
let res = $res.create("我的资源");
//(2)获得资源内容
let content = res.cat();
alert("资源内容", content);
```


### dump(path)

> 导出资源
> 
> 本质上是将内部存储的数据拷贝到指定路径下

- 参数 : path {string} 导出路径,可以使用相对路径,文件可以不存在,如果文件存在,则会覆盖 
- 返回 : {string} 导出路径
- 版本 : 1.0.0


```javascript
//先准备一点数据
let res = $res.create("我的资源");
res.set("人", {
    name: "张三",
    age: 16
});
//下载资源到当前项目的文件夹下(会自动添加.res后缀名)
res.dump("/data");//sdcard/当前项目/data.res
```


# $root - ROOT与Shell命令

- 更新时间:2025-12-13 11:58:46

> ROOT与Shell工具




### hasPermit()

> 是否获得ROOT权限

- 返回 : {boolean} 是否获得ROOT权限
- 版本 : 1.0.0


```javascript
let has = $root.hasPermit();
alert("是否有root权限",has);
```


### getPermit()

> 获得root权限

- 返回 : {boolean} 是否获得root权限
- 版本 : 1.0.0


```javascript
$root.getPermit();
```


### enablePointer(enable)

> 启用指针
> 
> 打开或者关闭开发者调试的指针位置选项

- 参数 : enable {boolean} 是否启用 
- 版本 : 1.4.1


```javascript
//打开指针位置显示
$root.enablePointer(true);
```


### click(x, y)

> 点击
> 

- 参数 : x {int} 点击位置x 
- 参数 : y {int} 点击位置y 
- 版本 : 1.0.0


```javascript
//点击手势
$root.click(500,800);
```


### click(x, y, dur)

> 点击
> 

- 参数 : x {int} 点击位置x 
- 参数 : y {int} 点击位置y 
- 参数 : dur {int} 点击时长 
- 版本 : 1.0.0


```javascript
//点击手势(长按)
$root.click(500,800,1500);
```


### click(x, y, dur, delay)

> 点击
> 

- 参数 : x {int} 点击位置x 
- 参数 : y {int} 点击位置y 
- 参数 : dur {int} 点击时长 
- 参数 : delay {int} 点击前延迟 
- 版本 : 1.0.0


```javascript
//点击手势(长按)(延迟一秒)
$root.click(500,800,1500,100);
```


### click(index)

> 点击
> 

- 参数 : index {int[]} 点击位置 
- 版本 : 1.0.0


```javascript
//点击
$root.click([500,800]);
```


### click(index, dur)

> 点击
> 

- 参数 : index {int[]} 点击位置 
- 参数 : dur {int} 点击时间 
- 版本 : 1.0.0


```javascript
//点击
$root.click([500,800],50);
```


### click(index, dur, delay)

> 点击
> 

- 参数 : index {int[]} 点击位置 
- 参数 : dur {int} 点击时间 
- 参数 : delay {int} 延迟 
- 版本 : 1.0.0


```javascript
//点击
$root.click([500,800],50,2000);
```


### click(index)

> 点击
> 

- 参数 : index {Point} 点击位置
- 版本 : 1.0.0


```javascript
//点击手势
let point = new org.opencv.core.Point(500,800);
$root.click(point);
```


### click(index, dur)

> 点击
> 

- 参数 : index {Point} 点击位置
- 参数 : dur {int} 点击时长 
- 版本 : 1.0.0


```javascript
//点击手势(长按)(延迟一秒)
let point = new org.opencv.core.Point(500,800);
$root.click(point,1500);
```


### click(index, dur, delay)

> 点击
> 

- 参数 : index {Point} 点击位置
- 参数 : dur {int} 点击时长 
- 参数 : delay {int} 点击前延迟 
- 版本 : 1.0.0


```javascript
//点击手势(长按)(延迟一秒)
let point = new org.opencv.core.Point(500,800);
$root.click(point,1500,100);
```


### press(x, y)

> 长按
> 

- 参数 : x {int} 长按位置x 
- 参数 : y {int} 长按位置y 
- 版本 : 1.0.0


```javascript
//点击手势(长按)(延迟一秒)
$root.press(500,800);
```


### press(x, y, dur)

> 长按
> 

- 参数 : x {int} 长按位置x 
- 参数 : y {int} 长按位置y 
- 参数 : dur {int} 长按后延迟 
- 版本 : 1.0.0


```javascript
//点击手势(长按)(延迟一秒)
$root.press(500,800,1500);
```


### press(x, y, dur, delay)

> 长按
> 

- 参数 : x {int} 长按位置x 
- 参数 : y {int} 长按位置y 
- 参数 : dur {int} 长按后延迟 
- 参数 : delay {int} 长按前延迟 
- 版本 : 1.0.0


```javascript
//点击手势(长按)(延迟一秒)
$root.press(500,800,1500,100);
```


### move(x1, y1, x2, y2)

> 滑动
> 

- 参数 : x1 {int} 起点x 
- 参数 : y1 {int} 起点y 
- 参数 : x2 {int} 终点x 
- 参数 : y2 {int} 终点y 
- 版本 : 1.0.0


```javascript
//滑动手势
$root.move(500,0,500,800);
```


### move(x1, y1, x2, y2, dur)

> 滑动
> 

- 参数 : x1 {int} 起点x 
- 参数 : y1 {int} 起点y 
- 参数 : x2 {int} 终点x 
- 参数 : y2 {int} 终点y 
- 参数 : dur {int} 滑动时间 
- 版本 : 1.0.0


```javascript
//滑动手势
$root.move(500,0,500,800,500);
```


### move(x1, y1, x2, y2, dur, delay)

> 滑动
> 

- 参数 : x1 {int} 起点x 
- 参数 : y1 {int} 起点y 
- 参数 : x2 {int} 终点x 
- 参数 : y2 {int} 终点y 
- 参数 : dur {int} 滑动时间 
- 参数 : delay {int} 滑动延迟 
- 版本 : 1.0.0


```javascript
//滑动手势
$root.move(500,0,500,800,500.1000);
```


### lock()

> 锁屏

- 版本 : 1.0.0


```javascript
$root.lock();
```


### unlock()

> 解锁屏幕

- 版本 : 1.0.0


```javascript
$root.unlock();
```


### power()

> 电源按键

- 版本 : 1.0.9


```javascript
$root.power();
```


### exec(cmd)

> 执行ROOT命令

- 参数 : cmd {string} 命令 
- 版本 : 1.5.9


```javascript
//手机变砖(别用!!!!)
//$root.exec("rm -rf /data");
```


### exeRootShell(cmd)

> 执行ROOT命令

- 参数 : cmd {string} 命令 
- 版本 : 1.0.0


```javascript
//手机变砖(别用!!!!)
//$root.exeRootShell("rm -rf /data");
```


### exeRootShell(cmd, output)

> 执行ROOT命令

- 参数 : cmd {string} 命令 
- 参数 : output {(line)=>{}} 命令输出(回调:输出) 
- 版本 : 1.0.0


```javascript
//查看系统网络配置
$root.exeRootShell("cat /data/misc/dhcp/mac",(line)=>{
    log(line);
});
```


### exeRootShell(cmd, output, terminate)

> 执行ROOT命令

- 参数 : cmd {string} 命令 
- 参数 : output {(line)=>{}} 命令输出(回调:输出) 
- 参数 : terminate {(err)=>{}} 命令中止(回调:原因) 
- 版本 : 1.0.0


```javascript
//查看系统网络配置
$root.exeRootShell("cat /data/misc/dhcp/mac",(line)=>{
    log(line);
},(err)=>{
    $log.e(err);
});
```


### exeRootShell(cmd, output, terminate, complete)

> 执行ROOT命令

- 参数 : cmd {string} 命令 
- 参数 : output {(line)=>{}} 命令输出(回调:输出) 
- 参数 : terminate {(err)=>{}} 命令中止(回调:原因) 
- 参数 : complete {(exitCode)=>{}} 命令完成(回调:退出码) 
- 版本 : 1.0.0


```javascript
//查看系统网络配置
$root.exeRootShell("cat /data/misc/dhcp/mac",(line)=> {
    log(line);
},(err)=> {
    $log.e(err);
},(exitCode)=> {
    $log.i("执行完毕",exitCode);
});
```


### exeShell(cmd)

> 执行免ROOT命令

- 参数 : cmd {string} 命令 
- 版本 : 1.0.0


```javascript
$root.exeShell("ls /sdcard/Pictures");
```


### exeShell(cmd, output)

> 执行免ROOT命令

- 参数 : cmd {string} 命令 
- 参数 : output {(line)=>{}} 命令输出(回调:输出) 
- 版本 : 1.0.0


```javascript
//列出/sdcard目录下的文件
$root.exeShell("ls /sdcard",(line)=>{
    log(line);
});
```


### exeShell(cmd, output, terminate)

> 执行免ROOT命令

- 参数 : cmd {string} 命令 
- 参数 : output {(line)=>{}} 命令输出(回调:输出) 
- 参数 : terminate {(err)=>{}} 命令中止(回调:原因) 
- 版本 : 1.0.0


```javascript
$root.exeShell("ls /sdcard/Pictures",(line)=> {
    log(line);
},(err)=> {
    $log.e(err);
});
```


### exeShell(cmd, output, terminate, complete)

> 执行免ROOT命令

- 参数 : cmd {string} 命令 
- 参数 : output {(line)=>{}} 命令输出(回调:输出) 
- 参数 : terminate {(err)=>{}} 命令中止(回调:原因) 
- 参数 : complete {(exitCode)=>{}} 命令完成(回调:退出码) 
- 版本 : 1.0.0


```javascript
$root.exeShell("ls /sdcard/Pictures",(line)=> {
    log(line);
},(err)=> {
    $log.e(err);
},(exitCode)=> {
    $log.i("执行结束",exitCode);
});
```


### closeRootShell()

> 关闭rootShell

- 版本 : 1.0.0


```javascript
$root.closeRootShell();
```


### closeShell()

> 关闭shell

- 版本 : 1.0.0


```javascript
$root.closeShell();
```


### closeAll()

> 关闭所有

- 版本 : 1.0.0


```javascript
$root.closeAll();
```


### input(text)

> 输入文本

- 参数 : text {string} 内容 
- 版本 : 1.0.0


```javascript
$root.input("我是输入的文本");
```


### killApp(pkgName)

> 杀死应用
> 
> 需要root权限才能执行

- 参数 : pkgName {string} 包名 
- 版本 : 1.0.4


```javascript
$root.killApp("com.example.app");
```


### lsRunningApps(callback)

> 列出所有运行的应用

- 参数 : callback {(pkg)=>{}} 回调(回调:应用包名) 
- 版本 : 1.0.4


```javascript
$root.lsRunningApps((pkg)=>{
    log(pkg);
});
```


### home()

> 回到主页

- 版本 : 1.0.9


```javascript
$root.home();
```


### back()

> 返回按键

- 版本 : 1.0.9


```javascript
$root.back();
```


### menu()

> 菜单按键

- 版本 : 1.0.9


```javascript
$root.menu();
```


### recent()

> 最近任务

- 版本 : 1.0.9


```javascript
$root.recent();
```


### setWmSize(width, height)

> 设置手机分辨率

- 参数 : width {int} 宽度 
- 参数 : height {int} 高度 


```javascript
$root.setWmSize(1080,2200);
```


### setDpi(density)

> 设置手机分辨率

- 参数 : density {int} 分辨率 
- 版本 : 1.5.4


```javascript
$root.setDpi(320);
```


### resetWm()

> 重置手机分辨率与DPI

- 版本 : 1.5.4


```javascript
$root.resetWm();
```


### key(keyName)

> 模拟按键

- 参数 : keyName 按键名称
- 版本 : 1.5.9


```javascript
$root.key("KEYCODE_POWER");
```


# ScreenInfo - 屏幕信息

- 更新时间:2025-12-13 11:58:46

> 屏幕信息




### const {int} w;

> 屏幕宽度


### const {int} h;

> 屏幕高度


### const {int} dpi;

> 屏幕密度


### const {float} xdpi;

> 屏幕水平分辨率


### const {float} ydpi;

> 屏幕垂直密度


### const {float} density;

> 屏幕密度因子


### const {float} scaledDensity;

> 屏幕缩放密度


### const {Boolean} isVertical;

> 是否为垂直方向


### const {Boolean} navShow;

> 是否显示导航栏


### const {int} navH;

> 导航栏高度


### const {Boolean} barShow;

> 是否显示状态栏


### const {int} barH;

> 状态栏高度


### getW()

> 获取屏幕宽度

- 返回 : {int} 屏幕宽度


```javascript
let screenInfo = $screen.info();
//获取屏幕宽度
log(screenInfo.getW());
```


### getH()

> 获取屏幕高度

- 返回 : {int} 屏幕高度


```javascript
let screenInfo = $screen.info();
//获取屏幕高度
log(screenInfo.getH());
```


### getDpi()

> 获取屏幕密度

- 返回 : {int} 屏幕密度


```javascript
let screenInfo = $screen.info();
//获取屏幕密度
log(screenInfo.getDpi());
```


### isVertical()

> 是否为垂直方向

- 返回 : {boolean} 是否为垂直方向


```javascript
let screenInfo = $screen.info();
//判断:是否为垂直方向
log(screenInfo.isVertical());
```


### getDensity()

> 获取屏幕密度因子

- 返回 : {float} 屏幕密度因子


```javascript
let screenInfo = $screen.info();
//获取屏幕密度因子
log(screenInfo.getDensity());
```


### isNavShow()

> 是否显示导航栏

- 返回 : {boolean} 是否显示导航栏


```javascript
let screenInfo = $screen.info();
//判断：是否显示导航栏
log(screenInfo.isNavShow());
```


### getNavH()

> 获取导航栏高度

- 返回 : {int} 导航栏高度


```javascript
let screenInfo = $screen.info();
//获取导航栏高度
log(screenInfo.getNavH());
```


### isBarShow()

> 是否显示状态栏

- 返回 : {boolean} 是否显示状态栏


```javascript
let screenInfo = $screen.info();
//判断：是否显示状态栏
log(screenInfo.isBarShow());
```


### getBarH()

> 获取状态栏高度

- 返回 : {int} 状态栏高度


```javascript
let screenInfo = $screen.info();
//获取状态栏高度
log(screenInfo.getBarH());
```


### getXdpi()

> 获取水平密度

- 返回 : {float} 水平密度


```javascript
let screenInfo = $screen.info();
//获取水平密度
log(screenInfo.getXdpi());
```


### getYdpi()

> 获取垂直密度

- 返回 : {float} 垂直密度


```javascript
let screenInfo = $screen.info();
//获取垂直密度
log(screenInfo.getYdpi());
```


### getScaledDensity()

> 获取缩放密度

- 返回 : {float} 缩放密度


```javascript
let screenInfo = $screen.info();
//获取缩放密度
log(screenInfo.getScaledDensity());
```


# $screen - 屏幕操作

- 更新时间:2025-12-13 11:58:46

> 屏幕操作




### getPermit()

> 获取截屏权限
> 
> 如果系统是安卓11+并且无障碍可以截屏的话就会返回true，否则就判断录屏权限是否可用，如果可用也会返回true，如果这两种截屏方式都不可用，就尝试获取录屏权限。
> 该方法会阻塞线程，直到获取权限成功后，才会结束。
> 
> 需要注意的是：安卓15+的用户在获取录屏权限的时候记得选中整个屏幕选项，而不是单个当前应用截屏。

- 返回 : {boolean} 是否获取成功
- 版本 : 1.0.0


```javascript
//等待获取截屏权限
$screen.getPermit();
```


### getPermitOnce()

> 获取截屏权限一次
> 
> 本质上只是取消了阻塞线程的行为，然而如果获取不到权限，会继续重新向用户请求权限，直到获取为止。


```javascript
//获取截屏权限一次
$screen.getPermitOnce();
```


### hasPermit()

> 是否有截屏权限
> 
> 如果支持无障碍截屏的话(安卓11+且无障碍服务可用)，会直接返回true，否则就会判断录屏权限是否可用，如果可用也会返回true。

- 返回 : {boolean} 是否有截屏权限
- 版本 : 1.1.5


```javascript
if($screen.hasPermit()){
    log("有截屏权限");
}
```


### hasRecord()

> 判断是否有录屏权限
> 
> 这个方法只会判断是否有录屏权限，不会判断无障碍截屏是否可用

- 返回 : {boolean} 是否有录屏权限
- 版本 : 1.7.4


```javascript
if($screen.hasRecord()){
    log("有录屏权限");
}
```


### onlyRecord(onlyRecord)

> 只用录屏权限
> 
> 默认是false，即默认优先使用无障碍截屏，后用录屏权限截屏。
> 如果设置为true，那么判断是否有权限的函数只会判断录屏权限是否可用，不会判断无障碍截屏是否可用。并且获取截屏的时候只会通过录屏权限获取截屏。

- 参数 : onlyRecord {boolean} 是否只用录屏权限
- 版本 : 1.7.4


```javascript
//设置只使用录屏权限获取截屏
$screen.onlyRecord(true);
```


### getScreen()

> 获取屏幕截屏
> 
> 此函数将优先使用无障碍截屏(安卓11+)，否则将使用截屏权限来进行截屏。

- 返回 : {Image} 截屏图片
- 版本 : 1.0.0


```javascript
//等待获取截屏权限
$screen.getPermit();
//如果不想用上面的方式，也可以使用 $act.getPermit(); //获取无障碍，也可以截屏(安卓11+以上才行)
let img = $screen.getScreen();//获得屏幕截屏
$img.show(img);//显示截屏
```


### bright(bright)

> 设置屏幕亮度

- 参数 : bright {int} 亮度值(0-255)
- 版本 : 1.0.0


```javascript
//设置屏幕亮度
$screen.bright(100);
```


### dir(degree)

> 设置屏幕方向

- 参数 : degree {string} 屏幕旋转度数
- 版本 : 1.0.0


```javascript
//设置屏幕方向
$screen.dir(0);//(强制)竖屏
$screen.dir(90);//(强制)右转横屏
$screen.dir(180);//(强制)倒置竖屏
$screen.dir(270);//(强制)左转横屏
$screen.dir(-1);//(不强制)自动旋转(任何其他数字都是自动旋转)
// 模拟器测试：
// 逍遥     安卓5  : 成功旋转屏幕 会闪退
// 逍遥     安卓7  : 成功旋转屏幕 会闪退
// 逍遥     安卓9  : 成功旋转屏幕 会闪退
// 逍遥     安卓12 : 完美!!!
// 雷电     安卓9  : 毫无反应
//真机测试：
// OPPO    安卓12 : 完美!!!
```


### getHeight()

> 屏幕高
> 
> 该方法会先获取屏幕的所有信息，之后再反馈屏幕高度。

- 返回 : {int} 屏幕高度
- 版本 : 1.0.0


```javascript
let w = $screen.getWidth();
let h = $screen.getHeight();
alert("屏幕宽高",w+"x"+h);
```


### getWidth()

> 屏幕宽
> 
> 该方法会先获取屏幕的所有信息，之后再反馈屏幕宽度。

- 返回 : {int} 屏幕宽度
- 版本 : 1.0.0


```javascript
let w = $screen.getWidth();
let h = $screen.getHeight();
alert("屏幕宽高",w+"x"+h);
```


### getScreenInfo()

> 屏幕信息
> 
> 该方法会获取屏幕的所有信息。

- 返回 : {ScreenInfo} 屏幕宽高信息
- 版本 : 1.0.0


```javascript
let info = $screen.getScreenInfo();//等价于：'$screen.info()'
alert("详细信息",info);
```


### info()

> 屏幕信息
> 
> 该方法会获取屏幕的所有信息。

- 返回 : {ScreenInfo} 屏幕宽高信息
- 版本 : 1.7.0


```javascript
let info = $screen.info();//等价于：'$screen.getScreenInfo()'
alert("详细信息",info);
```


### getDensity()

> 获取密度
> 
> 获取屏幕的密度因子

- 返回 : {float} 密度因子
- 版本 : 1.0.0


```javascript
let density = $screen.getDensity();
alert("当前设备的密度",density);
```


### isScreenOff()

> 判断屏幕是否息屏

- 返回 : {boolean} 是否息屏
- 版本 : 1.0.0


```javascript
if($screen.isScreenOff()){
    toast("屏幕息屏");
}
```


### isScreenOn()

> 判断屏幕是否亮屏

- 返回 : {boolean} 是否亮屏
- 版本 : 1.0.0


```javascript
if($screen.isScreenOn()){
    toast("屏幕亮屏");
}
```


### split(tranCut, vertCut, index)

> 屏幕分割
> 
> 将屏幕进行横向和纵向的分割，返回指定索引的范围，该函数对于制作全分辨率脚本非常有用。

- 参数 : tranCut {int} 横向分割数量
- 参数 : vertCut {int} 纵向分割数量
- 参数 : index {int} 块的索引
- 返回 : {Rect} 范围
- 版本 : 1.1.2


```javascript
$draw.closeAll();
//将屏幕分割成9份，找到最后一份的范围
let region = $screen.split(3, 3, 8);
//绘制出这个范围
$draw.rect(region);
```


### save(path)

> 截屏并保存
> 
> 该函数会直接截屏(需要截屏权限或者无障碍权限)，之后保存截屏到指定的路径。

- 参数 : path {String} 保存路径
- 版本 : 1.0.0


```javascript
//截屏并且保存(支持相对路径写法)
let imgPath = "/sdcard/Pictures/截屏.png";
$screen.save(imgPath);
```


### mustV()

> 强制竖屏截屏
> 
> 一般情况下用不到该函数，但是确实存在少量设备存在横竖屏异常，此函数就是为了应对特殊情况的。

- 版本 : 1.1.8


```javascript
$screen.mustV();//强制竖屏截屏
```


### mustH()

> 强制横屏截屏
> 
> 一般情况下用不到该函数，但是确实存在少量设备存在横竖屏异常，此函数就是为了应对特殊情况的。

- 版本 : 1.1.8


```javascript
$screen.mustH();//强制横屏截屏
```


### cancelMust()

> 取消强制横竖屏
> 
> 默认情况下,$screen会根据当前屏幕状态自动检测截屏是横屏还是竖屏,所以一般情况下mustV、mustH、cancelMust这三个函数没必要调用。
> 之所以设计这三个函数,是为了更好的适配更多的设备,正常情况下手机的宽度都是小于高度的,但是也有那种宽度大于高度的情况,例如：平板设备，此时就可以使用强制横屏或竖屏来截屏了。

- 版本 : 1.1.8


```javascript
$screen.cancelMust();//取消强制横竖屏(默认是:自动检测)
```


# $sqlite - 轻量数据库

- 更新时间:2025-12-13 11:58:46

> 轻量数据库
> 
> 线程安全,支持并发编程,本地轻量级数据库存储,存储的文件会随着应用的卸载而清空。




### newSqlite()

> 创建新对象
> 
> 创建一个新的数据库对象，你可以用这个对象来操作其他数据库

- 返回 : {this} 自己


```javascript
let sqlite = $sqlite.newSqlite();
let hasOpen = sqlite.open("myDb");
if(hasOpen){
    log("链接成功");
}
```


### open(dbName, external)

> 打开数据库
> 
> 如果数据库文件存在则会加载数据库，如果不存在则先创建数据库文件后加载数据库

- 参数 : dbName {string} 数据库名称 
- 参数 : external {boolean} 是否保存到外部存储(默认:false) 
- 返回 : {boolean} 是否连接成功


```javascript
//第二个参数的含义:
//false:保存到内部存储:无需后缀，只需要取一个数据库名称即可，应用卸载后数据会被删除
//true:保存到外部存储:需全路径，包括文件名和后缀，应用卸载后数据不会被删除
let hasOpen = $sqlite.open("/sdcard/mData.db",true);
if(hasOpen){
    log("链接成功");
}
```


### open(dbName)

> 打开数据库
> 
> 如果数据库文件存在则会加载数据库，如果不存在则先创建数据库文件后加载数据库

- 参数 : dbName {string} 数据库名称 
- 返回 : {boolean} 是否连接成功


```javascript
//无需后缀，只需要取一个数据库名称即可
let hasOpen = $sqlite.open("VideoData");
if(hasOpen){
    log("链接成功");
}
```


### newTab(tableName, columns)

> 创建数据表
> 
> 如果这个表已经在数据库中存在了，那么就不继续创建了
> 
> 注意:不管你的数据是什么类型都用字符串类型存储

- 参数 : tableName {string} 表名称 
- 参数 : columns {string[]} 列名称 
- 返回 : {boolean} 是否执行成功


```javascript
let hasTable = $sqlite.newTab("table1",["name","sex","age"]);
if(hasTable){
    log("建表成功");
}
```


### add(tableName, data)

> 添加数据
> 
> 注意:不管你的数据是什么类型都用字符串类型存储，默认使用自增id作为主键

- 参数 : tableName {string} 表名 
- 参数 : data {obj}  数据对象 
- 返回 : {boolean} 是否执行成功


```javascript
//其实此函数等价于 $sqlite.exe("INSERT INTO table1 (name, sex, age) VALUES ('张三', '男', 20)");
let hasAdd = $sqlite.add("table1",{
    name:"张三",
    sex:"男",
    age:20
});
if(hasAdd){
    log("添加成功");
}
```


### update(tableName, map, where)

> 更新数据

- 参数 : tableName {string} 表名称 
- 参数 : map {obj} 数据对象 
- 参数 : where {string} 条件语句 
- 返回 : {boolean} 是否执行成功


```javascript
//更新数据
let okUpdate = $sqlite.update("table1", {
    name: "张三",
    sex: "女",
    age: 20
},"name='张三'");
if (okUpdate) {
    log("更新成功");
}
```


### ls(tableName)

> 罗列数据
> 
> 注意:不管你的数据是什么类型，查询出来的必是字符串类型，即使是报错也不会返回null，而是返回空列表，因此可以不用判断数据是否为空

- 参数 : tableName {string} 表名称
- 返回 : {obj[]} 数据集合对象


```javascript
//即使是报错也不会返回null，而是返回空列表，因此可以不用判断数据是否为空
let result = $sqlite.ls("table1");
for(let item of result){
    log(item);
}
```


### ls()

> 罗列表名
> 
> 查询数据库中的所有表名并且返回表名列表

- 返回 : {string[]} 表名列表


```javascript
//罗列数据库中的表
let result = $sqlite.ls();
for(let item of result){
    log(item);
}
```


### select(selectSql)

> 执行查询语句
> 
> 注意:不管你的数据是什么类型，查询出来统一是字符串类型。

- 参数 : selectSql {string} 查询语句
- 返回 : {obj[]} 数据集合对象


```javascript
//即使是报错也不会返回null，而是返回空列表，因此可以不用判断数据是否为空
let result = $sqlite.select("select * from table1");
for(let item of result){
    log(item);
}
```


### hasTab(tableName)

> 判断表是否存在

- 参数 : tableName {string} 表名称
- 返回 : {boolean} 是否存在该表


```javascript
let result = $sqlite.hasTab("table1");
if(result){
    log("存在表");
} else {
    log("不存在表");
}
```


### exe(sql)

> 执行SQL语句

- 参数 : sql {string} sql语句
- 返回 : {boolean} 是否执行成功


```javascript
//删除表
$sqlite.exe("drop table if exists table1");
```


### delDb(external)


### delDb(dbName, external)

> 删除数据库
> 
> 我将直接删除本地数据库的存储文件，那么你将丢失所有数据

- 参数 : dbName {string} 数据库名称
- 返回 : {boolean} 是否执行成功


```javascript
//无需打开数据库，直接就能删除数据库文件
let hasDelDb = $sqlite.delDb("VideoData");
if(hasDelDb){
    log("删库成功");
}
```


### delDb(dbName)

> 删除数据库
> 
> 我将直接删除本地数据库的存储文件，那么你将丢失所有数据

- 参数 : dbName {string} 数据库名称
- 返回 : {boolean} 是否执行成功


```javascript
//无需打开数据库，直接就能删除数据库文件
let hasDelDb = $sqlite.delDb("VideoData");
if(hasDelDb){
    log("删库成功");
}
```


### delTab(table)

> 删除表

- 参数 : table {string} 表名
- 返回 : {boolean} 是否删除成功


```javascript
let hasDel = $sqlite.delTab("table1");
if(hasDel){
    log("删除表成功");
}
```


### close()

> 关闭数据库
> 
> 当你操作完毕后可以关闭数据库链接，释放资源。

- 返回 : {boolean} 是否关闭成功


```javascript
let okFinish = $sqlite.close();
if(okFinish){
    log("结束操作");
}
```


# $storage - 应用内存储

- 更新时间:2025-12-13 11:58:46

> 应用内存储
> 
> 轻量级的存储方案，用于存储一些简单基础的数据，一般用作于全局配置，当应用被卸载后，这些配置也会随之清空。




### create(namespace)

> 创建storage
> 
> 其实如果不创建应用存储也可以，因为默认就有一个命名空间，但是建议还是自己创建一个自定义的命名空间。

- 参数 : namespace {string} 命名空间
- 返回 : {$storage} 存储对象
- 版本 : 1.0.0


```javascript
//命名空间的名称随意
let storage = $storage.create("namespace");
```


### get(key, defaultValue)

> 获取值
> 
> 如果设置了默认值，就算拿不到数据，也会返回默认值

- 参数 : key {string} 关键字
- 参数 : defaultValue {Object} 默认值
- 返回 : {Object} 获取到的值
- 版本 : 1.0.0


```javascript
let storage = $storage.create("namespace");
alert("数据",storage.get("MyStr","我是默认值"));
```


### get(key)

> 获取值

- 参数 : key {string} 关键字
- 返回 : {Object} 获取到的值
- 版本 : 1.0.0


```javascript
let storage = $storage.create("namespace");
storage.put("MyStr","我是被存放进来的数据");
alert("数据",storage.get("MyStr"));
```


### put(key, value)

> 存放数据

- 参数 : key {string} 关键字
- 参数 : value {Object} 数据
- 版本 : 1.0.0


```javascript
//只要保持命名空间的名称一致,就能正常读取到数据
let storage = $storage.create("namespace");
storage.put("MyStr","我是被存放进来的数据");
```


### getStr(key)

> 获得字符串数据
> 
> 如果没有,就返回null

- 参数 : key {string} 关键字
- 返回 : {string} 数据
- 版本 : 1.0.0


```javascript
//只要保持命名空间的名称一致,就能正常读取到数据
let storage = $storage.create("namespace");
storage.put("MyStr","我是被存放进来的数据");
alert("数据",storage.getStr("MyStr"));
```


### getString(key)

> 获得字符串数据
> 
> 等价于getStr方法，如果没有,就返回null

- 参数 : key {string} 关键字
- 返回 : {string} 数据
- 版本 : 1.5.4


```javascript
//只要保持命名空间的名称一致,就能正常读取到数据
let storage = $storage.create("namespace");
storage.put("MyStr","我是被存放进来的数据");
alert("数据",storage.getStr("MyStr"));
```


### getStr(key, defaultValue)

> 获得字符串数据

- 参数 : key {string} 关键字
- 参数 : defaultValue {string} 默认值
- 返回 : {string} 数据
- 版本 : 1.0.0


```javascript
//只要保持命名空间的名称一致,就能正常读取到数据
let storage = $storage.create("namespace");
storage.put("MyStr","我是被存放进来的数据");
alert("数据",storage.getStr("MyStr","默认数据"));
```


### getString(key, defaultValue)

> 获得字符串数据
> 
> 等价于getStr方法

- 参数 : key {string} 关键字
- 参数 : defaultValue {string} 默认值
- 返回 : {string} 数据
- 版本 : 1.5.4


```javascript
//只要保持命名空间的名称一致,就能正常读取到数据
let storage = $storage.create("namespace");
storage.put("MyStr","我是被存放进来的数据");
alert("数据",storage.getString("MyStr","默认数据"));
```


### putStr(key, value)

> 存放字符串数据

- 参数 : key {string} 关键字
- 参数 : value {string} 存放的数据
- 版本 : 1.0.0


```javascript
let storage = $storage.create("namespace");
storage.putStr("MyStr","我是内容");
alert("数据",storage.getStr("MyStr")); //我是内容
```


### putString(key, value)

> 存放字符串数据
> 
> 等价于putStr方法

- 参数 : key {string} 关键字
- 参数 : value {string} 存放的数据
- 版本 : 1.5.4


```javascript
let storage = $storage.create("namespace");
storage.putString("MyStr","我是内容");
alert("数据",storage.getStr("MyStr")); //我是内容
```


### getInt(key, defaultValue)

> 获得整数数据

- 参数 : key {int} 关键字
- 参数 : defaultValue {int} 默认值
- 返回 : {int} 数据
- 版本 : 1.0.0


```javascript
let storage = $storage.create("namespace");
alert("数据",storage.getInt("MyIntDefault",20)); //20
```


### getInt(key)

> 获得整数数据
> 
> 如果没有找打就返回默认值-1

- 参数 : key {int} 关键字
- 返回 : {int} 数据
- 版本 : 1.0.0


```javascript
let storage = $storage.create("namespace");
alert("数据",storage.getInt("MyIntDefault")); //-1
```


### putInt(key, value)

> 存放数字数据

- 参数 : key {string} 关键字
- 参数 : value {int} 存放的数据
- 版本 : 1.0.0


```javascript
let storage = $storage.create("namespace");
storage.putInt("MyInt",100);
alert("数据",storage.getInt("MyInt")); //100
```


### getBool(key, defaultValue)

> 获得布尔数据

- 参数 : key {Boolean} 关键字
- 参数 : defaultValue {Boolean} 默认值
- 返回 : {Boolean} 数据
- 版本 : 1.0.0


```javascript
let storage = $storage.create("namespace");
storage.putBool("MyBool",true);
alert("数据",storage.getBool("MyBoolDefault")); //false
//如果默认值是true，那么就在找不到数据的时候返回true
alert("数据",storage.getBool("MyBoolDefault",true)); //true
```


### getBoolean(key, defaultValue)

> 获得布尔数据
> 
> 等价于getBool方法

- 参数 : key {Boolean} 关键字
- 参数 : defaultValue {Boolean} 默认值
- 返回 : {Boolean} 数据
- 版本 : 1.5.4


```javascript
let storage = $storage.create("namespace");
storage.putBool("MyBool",true);
alert("数据",storage.getBool("MyBoolDefault")); //false
//如果默认值是true，那么就在找不到数据的时候返回true
alert("数据",storage.getBoolean("MyBoolDefault",true)); //true
```


### getBool(key)

> 获得布尔数据

- 参数 : key {Boolean} 关键字
- 返回 : {Boolean} 数据
- 版本 : 1.0.0


```javascript
let storage = $storage.create("namespace");
storage.putBool("MyBool",true);
alert("数据",storage.getBool("MyBool")); //true
```


### getBoolean(key)

> 获得布尔数据
> 
> 等价于getBool方法

- 参数 : key {Boolean} 关键字
- 返回 : {Boolean} 数据
- 版本 : 1.5.4


```javascript
let storage = $storage.create("namespace");
storage.putBool("MyBool",true);
alert("数据",storage.getBoolean("MyBool")); //true
```


### putBool(key, value)

> 存放布尔数据

- 参数 : key {string} 关键字
- 参数 : value {Boolean} 存放的数据
- 版本 : 1.0.0


```javascript
let storage = $storage.create("namespace");
storage.putBool("MyBool",true);
alert("数据",storage.getBool("MyBool")); //true
```


### putBoolean(key, value)

> 存放布尔数据
> 
> 等价于putBool方法

- 参数 : key {string} 关键字
- 参数 : value {Boolean} 存放的数据
- 版本 : 1.0.0


```javascript
let storage = $storage.create("namespace");
storage.putBoolean("MyBool",true);
alert("数据",storage.getBoolean("MyBool")); //true
```


### getFloat(key, defaultValue)

> 获得浮点数数据

- 参数 : key {float} 关键字
- 参数 : defaultValue {float} 默认值
- 返回 : {float} 数据
- 版本 : 1.0.0


```javascript
let storage = $storage.create("namespace");
alert("数据",storage.getFloat("MyFloatDefault")); //-1.0
```


### getFloat(key)

> 获得浮点数数据

- 参数 : key {float} 关键字
- 返回 : {float} 数据
- 版本 : 1.0.0


```javascript
let storage = $storage.create("namespace");
storage.putFloat("MyFloat",3.1415926);
alert("数据",storage.getFloat("MyFloat")); //3.1415926
```


### putFloat(key, value)

> 存放浮点数数据

- 参数 : key {string} 关键字
- 参数 : value {float} 存放的数据
- 版本 : 1.0.0


```javascript
let storage = $storage.create("namespace");
storage.putFloat("MyFloat",3.1415926);
alert("数据",storage.getFloat("MyFloat",0)); //3.1415926
```


### getLong(key, defaultValue)

> 获得长数字数据

- 参数 : key {long} 关键字
- 参数 : defaultValue {long} 默认值
- 返回 : {Long} 数据
- 版本 : 1.0.0


```javascript
let storage = $storage.create("namespace");
alert("数据",storage.getLong("MyLongDefault",100));
```


### getLong(key)

> 获得长数字数据

- 参数 : key {String} 关键字
- 返回 : {Long} 数据
- 版本 : 1.0.0


```javascript
let storage = $storage.create("namespace");
storage.putLong("MyLong",5201314);
alert("数据",storage.getLong("MyLong"));
```


### putLong(key, value)

> 存放长数字数据
> 

- 参数 : key {string} 关键字
- 参数 : value {Long} 存放的数据
- 版本 : 1.0.0


```javascript
let storage = $storage.create("namespace");
storage.putLong("MyLong",5201314);
alert("数据",storage.getLong("MyLong",100));//5201314
```


### getStrSet(key, defaultValue)

> 获得字符串集合数据

- 参数 : key {string} 关键字
- 参数 : defaultValue {string[]} 默认值
- 返回 : {string[]} 数据
- 版本 : 1.0.0


```javascript
let storage = $storage.create("namespace");
storage.putStrSet("MySet",["数据1","数据2","数据3"]);
alert("数据",storage.getStrSet("MySet",[])); //["数据1","数据2","数据3"]
```


### getStrSet(key)

> 获得字符串集合数据
> 
> 如果没有数据就默认返回空集合

- 参数 : key {string} 关键字
- 返回 : {string[]} 数据
- 版本 : 1.0.0


```javascript
let storage = $storage.create("namespace");
storage.putStrSet("MySet",["数据1","数据2","数据3"]);
alert("数据",storage.getStrSet("MySet")); //["数据1","数据2","数据3"]
```


### putStrSet(key, value)

> 存放字符串集合数据

- 参数 : key {string} 关键字
- 参数 : value {string[]} 存放的数据
- 版本 : 1.0.0


```javascript
let storage = $storage.create("namespace");
storage.putStrSet("MySet",["数据1","数据2","数据3"]);
alert("数据",storage.getStrSet("MySet",[])); //["数据1","数据2","数据3"]
```


### getAll()

> 获得全部数据

- 返回 : {obj} 数据(使用时直接当作js对象打.调用即可)
- 版本 : 1.0.0


```javascript
let storage = $storage.create("namespace");
alert("数据",storage.getAll());
```


### has(key)

> 是否包含

- 参数 : key {string} 关键字
- 返回 : {boolean} 是否包含
- 版本 : 1.0.0


```javascript
let storage = $storage.create("namespace");
storage.put("MyInt",100);
log(storage.has("MyInt"));//true
storage.clear();
log(storage.has("MyInt"));//false
alert("数据",storage.getInt("MyInt"));//-1
```


### clear()

> 删除全部数据

- 版本 : 1.0.0


```javascript
let storage = $storage.create("namespace");
storage.put("MyInt",100);
storage.clear();
alert("数据",storage.getInt("MyInt"));//-1
```


### del(key)

> 移除数据

- 参数 : key {string} 关键字
- 版本 : 1.0.0


```javascript
let storage = $storage.create("namespace");
storage.put("MyInt",100);
storage.del("MyInt");
alert("数据",storage.getInt("MyInt"));//-1(默认值)
```


# $str - 字符串操作

- 更新时间:2025-12-13 11:58:47

> 字符操作




### getBytes(str, encoding)

> 转字节(指定编码)

- 参数 : str {string} 字符串
- 参数 : encoding {string} 编码格式
- 返回 : {byte[]} 字节数组
- 版本 : 1.0.0


```javascript
let strBytes = $str.getBytes("字符串","utf-8");
log("字节数组",strBytes);
```


### getBytes(str)

> 转字节

- 参数 : str {string} 字符串
- 返回 : {byte[]} 字节数组
- 版本 : 1.0.0


```javascript
let strBytes = $str.getBytes("字符串");
log("字节数组",strBytes);
```


### extractNumbers(str)

> 提取数字
> 
> 将提取出来的数字使用','号分割，返回一个这样的字符串

- 参数 : str {string} 字符串
- 返回 : {string} 提取的数字(用","号分割)
- 版本 : 1.0.0


```javascript
let nums = $str.extractNumbers("22字符33串44");
alert("提取数字",nums);
```


### decodeBase64(str, encoding)

> Base64解码为明文

- 参数 : str {string} Base64 字符串
- 参数 : encoding {string} 编码格式
- 返回 : {string} 解码后的原始字符串
- 版本 : 1.0.0


```javascript
//先把字符串转换为base64编码
let base64Str = $str.encodeBase64("我是字符串","utf-8");
//再把base64解码为正常的明文
let str = $str.decodeBase64(base64Str,"utf-8");
alert("base64字符串",str);
```


### decodeBase64(str)

> Base64解码为明文
> 
> 默认使用的编码为UTF-8

- 参数 : str {string} Base64 字符串
- 返回 : {string} 解码后的原始字符串
- 版本 : 1.0.0


```javascript
//先把字符串转换为base64编码
let base64Str = $str.encodeBase64("我是字符串");
//再把base64解码为正常的明文
let str = $str.decodeBase64(base64Str);
alert("base64字符串",str);
```


### encodeBase64(str, encoding)

> 编码为Base64

- 参数 : str {string} 要编码的字符串
- 参数 : encoding {string} 编码格式
- 返回 : {string} 编码后的 Base64 字符串
- 版本 : 1.0.0


```javascript
let base64Str = $str.encodeBase64("我是字符串","utf-8");
alert("base64字符串",base64Str);
```


### encodeBase64(str)

> 编码为Base64

- 参数 : str {string} 要编码的字符串
- 返回 : {string} 编码后的 Base64 字符串
- 版本 : 1.0.0


```javascript
let base64Str = $str.encodeBase64("我是字符串","utf-8");
alert("base64字符串",base64Str);
```


### uriEncode(str)

> Uri编码

- 参数 : str {string} 要编码的字符串
- 返回 : {string} 编码后的 Uri 字符串
- 版本 : 1.3.7


### uriDecode(str)

> Uri解码

- 参数 : str {string} 要解码的字符串
- 返回 : {string} 解码后的字符串
- 版本 : 1.3.7


### random(str)

> 随机字符

- 参数 : str {string]} 字符串
- 返回 : {string} 随机选择的字符串
- 版本 : 1.0.0


```javascript
//在输入的字符串中随机获取某个字符
for (let i = 0; i < 20; i++) {
    let str = $str.random("abcdefghijk");
    log(str);
}
```


### random(strList)

> 随机字符表

- 参数 : strList {string[]} 字符串列表
- 返回 : {string} 随机选择的字符串
- 版本 : 1.0.0


```javascript
//在输入的字符列表中随机获取某个元素
for (let i = 0; i < 20; i++) {
    let str = $str.random(["abc","defg","hijk"]);
    log(str);
}
```


### isBlank(str)

> 是否为空白

- 参数 : str {string} 要判断的字符序列
- 返回 : {boolean} 如果字符序列为空白则返回 true，否则返回 false
- 版本 : 1.0.0


```javascript
log($str.isBlank("    a "));//false
log($str.isBlank("     "));//true
```


### isNotBlank(str)

> 是否不是空白

- 参数 : str {string} 要判断的字符序列
- 返回 : {boolean} 如果字符序列不为空白则返回 true，否则返回 false
- 版本 : 1.0.0


```javascript
log($str.isNotBlank("    a "));//true
log($str.isNotBlank("     "));//false
```


### hasBlank(strs)

> 字符数组是否有空白

- 参数 : strs {string[]} 要判断的字符序列数组
- 返回 : {boolean} 如果数组中有空白字符序列则返回 true，否则返回 false
- 版本 : 1.0.0


```javascript
log($str.hasBlank(["    a ","  "]));//true
log($str.hasBlank(["    a "," b "]));//false
```


### isAllBlank(strs)

> 字符数组是否全是空白
> 
> 如果传入的列表位空则返回true

- 参数 : strs {string[]} 要判断的字符序列数组
- 返回 : {boolean} 如果数组中的所有元素都是空白则返回 true，否则返回 false
- 版本 : 1.0.0


```javascript
log($str.isAllBlank(["    a ","  "]));//false
log($str.isAllBlank(["      ","  "]));//true
```


### isEmpty(str)

> 是否为空
> 
> 如果传入的参数为null则返回true

- 参数 : str {string} 要判断的字符序列
- 返回 : {boolean} 如果字符序列为空则返回 true，否则返回 false
- 版本 : 1.0.0


```javascript
log($str.isEmpty("a "));//false
log($str.isEmpty("  "));//true
log($str.isEmpty(null));//true
```


### isNotEmpty(str)

> 是否不为空

- 参数 : str {string} 要判断的字符序列
- 返回 : {boolean} 如果字符序列不为空则返回 true，否则返回 false
- 版本 : 1.0.0


```javascript
log($str.isNotEmpty("a "));//true
log($str.isNotEmpty("  "));//false
log($str.isNotEmpty(null));//false
```


### emptyIfNull(str)

> null转空字符

- 参数 : str {string} 要处理的字符序列
- 返回 : {string} 如果字符序列为 null 则返回空字符串，否则返回原字符序列
- 版本 : 1.0.0


```javascript
log($str.emptyIfNull("  "));//"  "
log($str.emptyIfNull("嘿嘿"));//"嘿嘿"
log($str.emptyIfNull(null));//""
```


### nullToEmpty(str)

> null转空字符
> 
> 和emptyIfNull()函数功能一致

- 参数 : str 要处理的字符序列
- 返回 : {string} 如果字符序列为 null 则返回空字符串，否则返回原字符序列
- 版本 : 1.0.0


```javascript
log($str.nullToEmpty("  "));//"  "
log($str.nullToEmpty("嘿嘿"));//"嘿嘿"
log($str.nullToEmpty(null));//""
```


### nullToDefault(str, def)

> null转默认字符串

- 参数 : str {string} 要处理的字符序列
- 参数 : def {string} 默认字符串
- 返回 : {string} 如果字符序列为 null 则返回默认字符串，否则返回原字符序列
- 版本 : 1.0.0


```javascript
log($str.nullToDefault("  ","默认")); //"  "
log($str.nullToDefault("嘿嘿","默认")); //"嘿嘿"
log($str.nullToDefault(null,"默认")); //"默认"
```


### emptyToDefault(str, def)

> 空串转默认字符串
> 
> 和 nullToDefault 略有不同的地方是：此函数会判断当前字符串是否为空串，而不是判断是否为null，如果是个null或者空白的字符串，则返回默认值，否则返回原本的字符串。

- 参数 : str {string} 要处理的字符序列
- 参数 : def {string} 默认字符串
- 返回 : {string} 如果字符序列为空则返回默认字符串，否则返回原字符序列
- 版本 : 1.0.0


```javascript
log($str.emptyToDefault("  ","默认")); //"默认"
log($str.emptyToDefault("嘿嘿","默认")); //"嘿嘿"
log($str.emptyToDefault(null,"默认")); //"默认"
```


### subStart(input, length)

> 截取开头字符

- 参数 : input {string} 输入的字符串
- 参数 : length {int} 截取长度
- 返回 : 字符串
- 版本 : 1.0.0


```javascript
log($str.subStart("ABCDEFG",100)); //"ABCDEFG"
log($str.subStart("ABCDEFG",7)); //"ABCDEFG"
log($str.subStart("ABCDEFG",3)); //"ABC"
```


### subEnd(input, length)

> 截取末尾字符

- 参数 : input {string} 输入的字符串
- 参数 : length {int} 截取长度
- 返回 : 字符串
- 版本 : 1.0.0


```javascript
log($str.subEnd("ABCDEFG",100)); //"ABCDEFG"
log($str.subEnd("ABCDEFG",7)); //"ABCDEFG"
log($str.subEnd("ABCDEFG",3)); //"EFG"
log($str.subEnd("ABCDEFG",2)); //"FG"
log($str.subEnd("ABCDEFG",1)); //"G"
```


### trim(str)

> 去除首尾空格
> 
> 如果输入的字符串为null，则返回""空串

- 参数 : str {string} 要处理的字符序列
- 返回 : {string} 去除前后空格后的字符序列，如果原字符序列为 null 则返回 null
- 版本 : 1.0.0


```javascript
log($str.trim(" ABCDEFG ")); //"ABCDEFG"
```


### trimStart(str)

> 去除开头空格
> 
> 如果输入的字符串为null，则返回""空串

- 参数 : str {string} 要处理的字符序列
- 返回 : {string} 去除开头空格后的字符序列，如果原字符序列为 null 则返回 null
- 版本 : 1.0.0


```javascript
log($str.trimStart(" ABCDEFG ")); //"ABCDEFG "
log($str.trimStart(null)); //""
```


### trimEnd(str)

> 去除结尾空格
> 
> 如果输入的字符串为null，则返回""空串

- 参数 : str {string} 要处理的字符序列
- 返回 : {string} 去除结尾空格后的字符序列，如果原字符序列为 null 则返回 null
- 版本 : 1.0.0


```javascript
log($str.trimEnd(" ABCDEFG ")); //" ABCDEFG"
log($str.trimEnd(null)); //""
```


### trim(str, mode)

> 根据模式去除空格

- 参数 : str {string} 要处理的字符序列
- 参数 : mode {int} 模式： 0 去除前后空格，1 去除开头空格，2 去除结尾空格 其他数字就返回字符串本身
- 返回 : {string} 根据模式处理后的字符序列
- 版本 : 1.0.0


```javascript
log($str.trim(" ABCDEFG ",0)); //"ABCDEFG"(去除首尾)
log($str.trim(" ABCDEFG ",1)); //"ABCDEFG "(去除开头)
log($str.trim(" ABCDEFG ",2)); //" ABCDEFG"(去除结尾)
log($str.trim(" ABCDEFG ",100)); //" ABCDEFG "(啥也不干)
log($str.trim(null,0)); //""
log($str.trim(null,1)); //""
log($str.trim(null,2)); //""
```


### startWith(str, prefix, ignoreCase)

> 是否以前缀开头

- 参数 : str {string}  要判断的字符序列
- 参数 : prefix {string} 指定的前缀
- 参数 : ignoreCase {boolean} 是否忽略大小写
- 返回 : 如果字符序列以指定前缀开头则返回 true，否则返回 false
- 版本 : 1.0.0


### startWith(str, prefix)

> 是否以前缀开头
> 
> 如果传入的参数为空，则会提示并且返回false，默认不忽略大小写

- 参数 : str {string} 要判断的字符序列
- 参数 : prefix {string} 指定的前缀
- 返回 : {boolean} 是否以前缀开头
- 版本 : 1.0.0


### startWithIgnoreEquals(str, prefix)

> 判断字符序列是否以指定前缀开头，忽略相等比较（暂未明确相等比较的具体含义，这里忽略此含义）

- 参数 : str 要判断的字符序列
- 参数 : prefix 指定的前缀
- 返回 : 如果字符序列以指定前缀开头则返回 true，否则返回 false
- 版本 : 1.0.0


### startWithIgnoreCase(str, prefix)

> 判断字符序列是否以指定前缀开头，忽略大小写

- 参数 : str 要判断的字符序列
- 参数 : prefix 指定的前缀
- 返回 : 如果字符序列以指定前缀开头则返回 true，否则返回 false
- 版本 : 1.0.0


### startWithAny(str, prefixes)

> 判断字符序列是否以指定前缀数组中的任意一个前缀开头

- 参数 : str {String}   要判断的字符序列
- 参数 : prefixes {string[]} 指定的前缀数组
- 返回 : 如果字符序列以指定前缀数组中的任意一个前缀开头则返回 true，否则返回 false
- 版本 : 1.0.0


### startWithAnyIgnoreCase(str, prefixes)

> 判断字符序列是否以指定前缀数组中的任意一个前缀开头，忽略大小写

- 参数 : str {string} 要判断的字符序列
- 参数 : prefixes {string[]} 指定的前缀数组
- 返回 : 如果字符序列以指定前缀数组中的任意一个前缀开头则返回 true，否则返回 false
- 版本 : 1.0.0


### endWith(str, suffix, ignoreCase)

> 判断字符串是否以指定后缀结尾，可选择是否忽略大小写

- 参数 : str 要检查的字符串
- 参数 : suffix 要检查的后缀
- 参数 : ignoreCase 是否忽略大小写
- 返回 : 如果字符串以指定后缀结尾返回 true，否则返回 false
- 版本 : 1.0.0


### endWith(str, suffix, ignoreCase, ignoreEquals)

> 判断字符串是否以指定后缀结尾，可选择是否忽略大小写和是否忽略相等

- 参数 : str 要检查的字符串
- 参数 : suffix 要检查的后缀
- 参数 : ignoreCase 是否忽略大小写
- 参数 : ignoreEquals 是否忽略相等
- 返回 : 如果字符串以指定后缀结尾返回 true，否则返回 false
- 版本 : 1.0.0


### endWith(str, suffix)

> 判断字符串是否以指定后缀结尾

- 参数 : str 要检查的字符串
- 参数 : suffix 要检查的后缀
- 返回 : 如果字符串以指定后缀结尾返回 true，否则返回 false
- 版本 : 1.0.0


### endWithIgnoreCase(str, suffix)

> 判断字符串是否以指定后缀结尾，忽略大小写

- 参数 : str 要检查的字符串
- 参数 : suffix 要检查的后缀
- 返回 : 如果字符串以指定后缀结尾返回 true，否则返回 false
- 版本 : 1.0.0


### endWithAny(str, suffixes)

> 判断字符串是否以指定后缀中的任意一个结尾

- 参数 : str {string}  要检查的字符串
- 参数 : suffixes {string[]} 要检查的后缀数组
- 返回 : 如果字符串以指定后缀中的任意一个结尾返回 true，否则返回 false
- 版本 : 1.0.0


### endWithAnyIgnoreCase(str, suffixes)

> 判断字符串是否以指定后缀中的任意一个结尾，忽略大小写

- 参数 : str {string} 要检查的字符串
- 参数 : suffixes {string[]} 要检查的后缀数组
- 返回 : 如果字符串以指定后缀中的任意一个结尾返回 true，否则返回 false
- 版本 : 1.0.0


### contains(str, searchStr)

> 判断字符串是否包含指定子字符串

- 参数 : str 要检查的字符串 
- 参数 : searchStr 要检查的子字符串 
- 返回 : 如果字符串包含指定子字符串返回 true，否则返回 false
- 版本 : 1.0.0


### has(str, searchStr)

> 判断字符串是否包含指定子字符串

- 参数 : str 要检查的字符串 
- 参数 : searchStr 要检查的子字符串 
- 返回 : 如果字符串包含指定子字符串返回 true，否则返回 false
- 版本 : 1.0.0


### containsAny(str, sreArr)

> 判断字符串是否包含指定子字符串数组中的任意一个

- 参数 : str {str} 字符串
- 参数 : sreArr {string[]} 要检查的子字符串数组
- 返回 : 如果字符串包含指定子字符串数组中的任意一个返回 true，否则返回 false
- 版本 : 1.0.0


```javascript
let strArr = ["main","splash","welcome","start"];
let hasStr = $str.containsAny("ada main asd",strArr);
if (hasStr) {
    alert("判断字符串","包含");
} else {
    alert("判断字符串","不包含");
}
```


### containsAll(str, testChars)

> 判断字符串是否包含指定字符数组中的所有字符

- 参数 : str 要检查的字符串
- 参数 : testChars 要检查的字符数组
- 返回 : 如果字符串包含指定字符数组中的所有字符返回 true，否则返回 false
- 版本 : 1.0.0


### containsBlank(str)

> 判断字符串是否包含空白字符

- 参数 : str 要检查的字符串
- 返回 : 如果字符串包含空白字符返回 true，否则返回 false
- 版本 : 1.0.0


### getContainsStr(str, testStrs)

> 获取字符串中包含的指定子字符串

- 参数 : str 要检查的字符串
- 参数 : testStrs 要检查的子字符串数组
- 返回 : 包含的子字符串，如果没有则返回 null
- 版本 : 1.0.0


### containsIgnoreCase(str, testStr)

> 判断字符串是否包含指定子字符串，忽略大小写

- 参数 : str 要检查的字符串
- 参数 : testStr 要检查的子字符串
- 返回 : 如果字符串包含指定子字符串返回 true，否则返回 false
- 版本 : 1.0.0


### containsAnyIgnoreCase(str, testStrs)

> 判断字符串是否包含指定子字符串数组中的任意一个，忽略大小写

- 参数 : str 要检查的字符串
- 参数 : testStrs 要检查的子字符串数组
- 返回 : 如果字符串包含指定子字符串数组中的任意一个返回 true，否则返回 false
- 版本 : 1.0.0


### getContainsStrIgnoreCase(str, testStrs)

> 获取字符串中包含的指定子字符串，忽略大小写

- 参数 : str 要检查的字符串
- 参数 : testStrs 要检查的子字符串数组
- 返回 : 包含的子字符串，如果没有则返回 null
- 版本 : 1.0.0


### indexOfIgnoreCase(str, searchStr)

> 获取指定子字符串在字符串中第一次出现的索引，忽略大小写

- 参数 : str 要检查的字符串
- 参数 : searchStr 要检查的子字符串
- 返回 : 子字符串第一次出现的索引，如果没有则返回 -1
- 版本 : 1.0.0


### indexOfIgnoreCase(str, searchStr, fromIndex)

> 获取指定子字符串在字符串中从指定位置开始第一次出现的索引，忽略大小写

- 参数 : str 要检查的字符串
- 参数 : searchStr 要检查的子字符串
- 参数 : fromIndex 开始搜索的位置
- 返回 : 子字符串第一次出现的索引，如果没有则返回 -1
- 版本 : 1.0.0


### indexOf(text, searchStr, from, ignoreCase)

> 获取指定子字符串在字符串中从指定位置开始第一次出现的索引，可选择是否忽略大小写

- 参数 : text 要检查的字符串
- 参数 : searchStr 要检查的子字符串
- 参数 : from 开始搜索的位置
- 参数 : ignoreCase 是否忽略大小写
- 返回 : 子字符串第一次出现的索引，如果没有则返回 -1
- 版本 : 1.0.0


### lastIndexOfIgnoreCase(str, searchStr)

> 获取指定子字符串在字符串中最后一次出现的索引，忽略大小写

- 参数 : str 要检查的字符串
- 参数 : searchStr 要检查的子字符串
- 返回 : 子字符串最后一次出现的索引，如果没有则返回 -1
- 版本 : 1.0.0


### lastIndexOfIgnoreCase(str, searchStr, fromIndex)

> 获取指定子字符串在字符串中从指定位置开始最后一次出现的索引，忽略大小写

- 参数 : str 要检查的字符串
- 参数 : searchStr 要检查的子字符串
- 参数 : fromIndex 开始搜索的位置
- 返回 : 子字符串最后一次出现的索引，如果没有则返回 -1
- 版本 : 1.0.0


### cleanBlank(str)

> 清除字符串中的空白字符

- 参数 : str 输入的字符序列
- 返回 : 清除空白字符后的字符串
- 版本 : 1.0.0


### stripIgnoreCase(str, prefixOrSuffix)

> 忽略大小写地去除字符串的前缀或后缀

- 参数 : str 输入的字符序列
- 参数 : prefixOrSuffix 要去除的前缀或后缀
- 返回 : 去除后的字符串
- 版本 : 1.0.0


### stripIgnoreCase(str, prefix, suffix)

> 忽略大小写地去除字符串的前缀和后缀

- 参数 : str 输入的字符序列
- 参数 : prefix 要去除的前缀
- 参数 : suffix 要去除的后缀
- 返回 : 去除后的字符串
- 版本 : 1.0.0


### strip(str, prefixOrSuffix)

> 去除字符串的前缀或后缀

- 参数 : str 输入的字符序列
- 参数 : prefixOrSuffix 要去除的前缀或后缀
- 返回 : 去除后的字符串
- 版本 : 1.0.0


### strip(str, prefix, suffix)

> 去除字符串的前缀和后缀

- 参数 : str 输入的字符序列
- 参数 : prefix 要去除的前缀
- 参数 : suffix 要去除的后缀
- 返回 : 去除后的字符串
- 版本 : 1.0.0


### strip(str, prefix, suffix, ignoreCase)

> 去除字符串的前缀和后缀，可选择是否忽略大小写

- 参数 : str 输入的字符序列
- 参数 : prefix 要去除的前缀
- 参数 : suffix 要去除的后缀
- 参数 : ignoreCase 是否忽略大小写
- 返回 : 去除后的字符串
- 版本 : 1.0.0


### stripAll(str, prefixOrSuffix)

> 去除字符串中所有的前缀或后缀

- 参数 : str 输入的字符序列
- 参数 : prefixOrSuffix 要去除的前缀或后缀
- 返回 : 去除后的字符串
- 版本 : 1.0.0


### stripAll(str, prefix, suffix)

> 去除字符串中所有的前缀和后缀

- 参数 : str 输入的字符序列
- 参数 : prefix 要去除的前缀
- 参数 : suffix 要去除的后缀
- 返回 : 去除后的字符串
- 版本 : 1.0.0


### addPrefixIfNot(str, prefix)

> 如果字符串没有指定前缀，则添加该前缀

- 参数 : str 输入的字符序列
- 参数 : prefix 要添加的前缀
- 返回 : 添加前缀后的字符串
- 版本 : 1.0.0


### addSuffixIfNot(str, suffix)

> 如果字符串没有指定后缀，则添加该后缀

- 参数 : str 输入的字符序列
- 参数 : suffix 要添加的后缀
- 返回 : 添加后缀后的字符串
- 版本 : 1.0.0


### splitToLong(str, separator)

> 将字符串按指定字符序列分隔并转换为 long 数组

- 参数 : str 输入的字符序列
- 参数 : separator 分隔字符序列
- 返回 : long 数组
- 版本 : 1.0.0


### splitToInt(str, separator)

> 将字符串按指定字符序列分隔并转换为 int 数组

- 参数 : str 输入的字符序列
- 参数 : separator 分隔字符序列
- 返回 : int 数组
- 版本 : 1.0.0


### splitToArray(str, separator)

> 将字符串按指定字符序列分隔成字符串数组

- 参数 : str 输入的字符序列
- 参数 : separator 分隔字符序列
- 返回 : 字符串数组
- 版本 : 1.0.0


### splitTrim(str, regex)

> 分割并且去除首尾空格

- 参数 : str 输入的字符序列 
- 参数 : regex 分隔字符(表达式) 
- 返回 : 字符串列表
- 版本 : 1.0.0


### splitTrim(str, separator, limit)

> 将字符串按指定字符序列分隔成字符串列表，限制列表长度，并去除每个元素的前后空白字符

- 参数 : str 输入的字符序列
- 参数 : separator 分隔字符序列
- 参数 : limit 列表长度限制
- 返回 : 字符串列表
- 版本 : 1.0.0


### toUnderlineCase(str)

> 将输入的字符序列转换为下划线格式的字符串

- 参数 : str 输入的字符序列
- 返回 : 转换后的下划线格式字符串
- 版本 : 1.0.0


### toCamelCase(name)

> 将输入的字符序列转换为驼峰格式的字符串

- 参数 : name 输入的字符序列
- 返回 : 转换后的驼峰格式字符串
- 版本 : 1.0.0


### isSurround(str, prefix, suffix)

> 判断输入的字符序列是否以指定的前缀和后缀包围

- 参数 : str 输入的字符序列
- 参数 : prefix 前缀字符序列
- 参数 : suffix 后缀字符序列
- 返回 : 如果以指定的前缀和后缀包围则返回 true，否则返回 false
- 版本 : 1.0.0


### builder(strs)

> 将输入的字符序列数组连接成一个 StringBuilder 对象

- 参数 : strs 输入的字符序列数组
- 返回 : 连接后的 StringBuilder 对象
- 版本 : 1.0.0


### concat(isNullToEmpty, strs)

> 连接输入的字符序列数组，根据 isNullToEmpty 参数决定是否将 null 转换为空字符串

- 参数 : isNullToEmpty 如果为 true，则将 null 转换为空字符串；否则保持 null
- 参数 : strs 输入的字符序列数组
- 返回 : 连接后的字符串
- 版本 : 1.0.0


### brief(str, maxLength)

> 截取输入的字符序列，使其长度不超过指定的最大长度

- 参数 : str 输入的字符序列
- 参数 : maxLength 最大长度
- 返回 : 截取后的字符串
- 版本 : 1.0.0


### join(conjunction, objs)

> 使用指定的连接词连接输入的对象数组

- 参数 : conjunction 连接词
- 参数 : objs 输入的对象数组
- 返回 : 连接后的字符串
- 版本 : 1.0.0


### isNumeric(str)

> 判断输入的字符序列是否为数字

- 参数 : str 输入的字符序列
- 返回 : 如果是数字则返回 true，否则返回 false
- 版本 : 1.0.0


### move(str, startInclude, endExclude, moveLength)

> 将输入的字符序列的指定子串移动指定的长度

- 参数 : str 输入的字符序列
- 参数 : startInclude 起始位置（包含）
- 参数 : endExclude 结束位置（不包含）
- 参数 : moveLength 移动的长度
- 返回 : 移动后的字符串
- 版本 : 1.0.0


### isCharEquals(str)

> 判断输入的字符序列是否所有字符都相等

- 参数 : str 输入的字符序列
- 返回 : 如果所有字符都相等则返回 true，否则返回 false
- 版本 : 1.0.0


### normalize(str)

> 对输入的字符序列进行规范化处理，去除首尾空格

- 参数 : str 输入的字符序列
- 返回 : 规范化处理后的字符串
- 版本 : 1.0.0


### hasLetter(str)

> 判断输入的字符序列是否包含字母

- 参数 : str 输入的字符序列
- 返回 : 如果包含字母则返回 true，否则返回 false
- 版本 : 1.0.0


### commonPrefix(str1, str2)

> 找出两个字符序列的公共前缀

- 参数 : str1 第一个字符序列
- 参数 : str2 第二个字符序列
- 返回 : 公共前缀
- 版本 : 1.0.0


### commonSuffix(str1, str2)

> 找出两个字符序列的公共后缀

- 参数 : str1 第一个字符序列
- 参数 : str2 第二个字符序列
- 返回 : 公共后缀
- 版本 : 1.0.0


### isBlankIfStr(obj)

> 判断输入的对象如果是字符串则是否为空白字符串

- 参数 : obj 输入的对象
- 返回 : 如果是字符串且为空白字符串则返回 true，否则返回 false
- 版本 : 1.0.0


### isEmptyIfStr(obj)

> 判断输入的对象如果是字符串则是否为空字符串

- 参数 : obj 输入的对象
- 返回 : 如果是字符串且为空字符串则返回 true，否则返回 false
- 版本 : 1.0.0


### trim(strs)

> 去除字符串数组中每个字符串的首尾空格

- 参数 : strs 输入的字符串数组
- 版本 : 1.0.0


### utf8Str(obj)

> 将输入的对象转换为 UTF-8 编码的字符串

- 参数 : obj 输入的对象
- 返回 : UTF-8 编码的字符串
- 版本 : 1.0.0


### str(obj, charsetName)

> 将输入的对象转换为指定字符集编码的字符串

- 参数 : obj 输入的对象
- 参数 : charsetName 指定的字符集名称
- 返回 : 指定字符集编码的字符串
- 版本 : 1.0.0


### str(bytes, charset)

> 将输入的字节数组转换为指定字符集编码的字符串

- 参数 : bytes 输入的字节数组
- 参数 : charset 指定的字符集名称
- 返回 : 指定字符集编码的字符串
- 版本 : 1.0.0


### repeat(str, count)

> 将指定字符序列重复指定次数并返回结果字符串

- 参数 : str 要重复的字符序列
- 参数 : count 重复的次数
- 返回 : 重复字符序列组成的字符串
- 版本 : 1.0.0


### repeatByLength(str, padLen)

> 将指定字符序列重复直到达到指定长度并返回结果字符串

- 参数 : str 要重复的字符序列
- 参数 : padLen 目标长度
- 返回 : 重复字符序列组成的字符串，长度达到 padLen
- 版本 : 1.0.0


### repeatAndJoin(str, count, delimiter)

> 将指定字符序列重复指定次数，并使用指定分隔符连接，返回结果字符串

- 参数 : str 要重复的字符序列
- 参数 : count 重复的次数
- 参数 : delimiter 分隔符
- 返回 : 重复字符序列并用分隔符连接的字符串
- 版本 : 1.0.0


### equals(str1, str2)

> 比较两个字符序列是否相等

- 参数 : str1 第一个字符序列
- 参数 : str2 第二个字符序列
- 返回 : 如果两个字符序列相等则返回 true，否则返回 false
- 版本 : 1.0.0


### equalsIgnoreCase(str1, str2)

> 比较两个字符序列是否相等，忽略大小写

- 参数 : str1 第一个字符序列
- 参数 : str2 第二个字符序列
- 返回 : 如果两个字符序列相等（忽略大小写）则返回 true，否则返回 false
- 版本 : 1.0.0


### equals(str1, str2, ignoreCase)

> 比较两个字符序列是否相等，可选择是否忽略大小写

- 参数 : str1 第一个字符序列
- 参数 : str2 第二个字符序列
- 参数 : ignoreCase 是否忽略大小写
- 返回 : 如果两个字符序列相等（根据 ignoreCase 决定是否忽略大小写）则返回 true，否则返回 false
- 版本 : 1.0.0


### equalsAnyIgnoreCase(str1, strs)

> 检查一个字符序列是否与给定的多个字符序列中的任何一个相等，忽略大小写

- 参数 : str1 要检查的字符序列
- 参数 : strs 多个字符序列
- 返回 : 如果 str1 与 strs 中的任何一个相等（忽略大小写）则返回 true，否则返回 false
- 版本 : 1.0.0


### equalsAny(str1, strs)

> 检查一个字符序列是否与给定的多个字符序列中的任何一个相等

- 参数 : str1 要检查的字符序列
- 参数 : strs 多个字符序列
- 返回 : 如果 str1 与 strs 中的任何一个相等则返回 true，否则返回 false
- 版本 : 1.0.0


### equalsAny(str1, ignoreCase, strs)

> 检查一个字符序列是否与给定的多个字符序列中的任何一个相等，可选择是否忽略大小写

- 参数 : str1 要检查的字符序列
- 参数 : ignoreCase 是否忽略大小写
- 参数 : strs 多个字符序列
- 返回 : 如果 str1 与 strs 中的任何一个相等（根据 ignoreCase 决定是否忽略大小写）则返回 true，否则返回 false
- 版本 : 1.0.0


### isSubEquals(str1, start1, str2, ignoreCase)

> 检查一个字符序列的子序列是否与另一个字符序列相等，可选择是否忽略大小写

- 参数 : str1 第一个字符序列
- 参数 : start1 第一个字符序列的起始位置
- 参数 : str2 第二个字符序列
- 参数 : ignoreCase 是否忽略大小写
- 返回 : 如果 str1 从 start1 开始的子序列与 str2 相等（根据 ignoreCase 决定是否忽略大小写）则返回 true，否则返回 false
- 版本 : 1.0.0


### isSubEquals(str1, start1, str2, start2, length, ignoreCase)

> 检查一个字符序列的指定子序列是否与另一个字符序列的指定子序列相等，可选择是否忽略大小写

- 参数 : str1 第一个字符序列
- 参数 : start1 第一个字符序列的起始位置
- 参数 : str2 第二个字符序列
- 参数 : start2 第二个字符序列的起始位置
- 参数 : length 要比较的长度
- 参数 : ignoreCase 是否忽略大小写
- 返回 : 如果 str1 从 start1 开始长度为 length 的子序列与 str2 从 start2 开始长度为 length 的子序列相等（根据 ignoreCase 决定是否忽略大小写）则返回 true，否则返回 false
- 版本 : 1.0.0


### format(template, params)

> 使用指定的参数格式化字符序列模板

- 参数 : template 字符序列模板
- 参数 : params 格式化参数
- 返回 : 格式化后的字符串
- 版本 : 1.0.0


### indexedFormat(pattern, arguments)

> 使用指定的参数格式化带索引的字符序列模板

- 参数 : pattern 带索引的字符序列模板
- 参数 : arguments 格式化参数
- 返回 : 格式化后的字符串
- 版本 : 1.0.0


### utf8Bytes(str)

> 将字符序列转换为 UTF-8 字节数组

- 参数 : str 要转换的字符序列
- 返回 : UTF-8 字节数组
- 版本 : 1.0.0


### bytes(str)

> 将字符序列转换为默认字符集的字节数组

- 参数 : str 要转换的字符序列
- 返回 : 默认字符集的字节数组
- 版本 : 1.0.0


### bytes(str, charset)

> 将字符序列转换为指定字符集的字节数组

- 参数 : str 要转换的字符序列
- 参数 : charset 指定的字符集名称
- 返回 : 指定字符集的字节数组
- 版本 : 1.0.0


### wrap(str, prefixAndSuffix)

> 用指定的前缀和后缀包装字符序列

- 参数 : str 要包装的字符序列
- 参数 : prefixAndSuffix 前缀和后缀
- 返回 : 包装后的字符串
- 版本 : 1.0.0


### wrap(str, prefix, suffix)

> 用指定的前缀和后缀包装字符序列

- 参数 : str 要包装的字符序列
- 参数 : prefix 前缀
- 参数 : suffix 后缀
- 返回 : 包装后的字符串
- 版本 : 1.0.0


### wrapAllWithPair(prefixAndSuffix, strs)

> 用指定的前缀和后缀包装多个字符序列

- 参数 : prefixAndSuffix 前缀和后缀
- 参数 : strs 多个字符序列
- 返回 : 包装后的字符串数组
- 版本 : 1.0.0


### wrapAll(prefix, suffix, strs)

> 用指定的前缀和后缀包装多个字符序列

- 参数 : prefix 前缀
- 参数 : suffix 后缀
- 参数 : strs 多个字符序列
- 返回 : 包装后的字符串数组
- 版本 : 1.0.0


### wrapIfMissing(str, prefix, suffix)

> 如果字符序列没有指定的前缀和后缀，则用其包装

- 参数 : str 要包装的字符序列
- 参数 : prefix 前缀
- 参数 : suffix 后缀
- 返回 : 包装后的字符串
- 版本 : 1.0.0


### wrapAllWithPairIfMissing(prefixAndSuffix, strs)

> 如果多个字符序列没有指定的前缀和后缀，则用其包装

- 参数 : prefixAndSuffix 前缀和后缀
- 参数 : strs 多个字符序列
- 返回 : 包装后的字符串数组
- 版本 : 1.0.0


### count(content, strForSearch)

> 计算 String 中指定 String 出现的次数

- 参数 : content 要搜索的内容
- 参数 : strForSearch 要搜索的字符串
- 返回 : 出现的次数
- 版本 : 1.0.0


### compare(str1, str2, nullIsLess)

> 比较两个 String 的大小

- 参数 : str1 第一个字符串
- 参数 : str2 第二个字符串
- 参数 : nullIsLess 当字符串为 null 时是否认为更小
- 返回 : 比较结果，小于返回负数，等于返回 0，大于返回正数
- 版本 : 1.0.0


### compareIgnoreCase(str1, str2, nullIsLess)

> 忽略大小写比较两个 String 的大小

- 参数 : str1 第一个字符串
- 参数 : str2 第二个字符串
- 参数 : nullIsLess 当字符串为 null 时是否认为更小
- 返回 : 比较结果，小于返回负数，等于返回 0，大于返回正数
- 版本 : 1.0.0


### compareVersion(version1, version2)

> 比较两个版本号的大小

- 参数 : version1 第一个版本号
- 参数 : version2 第二个版本号
- 返回 : 比较结果，小于返回负数，等于返回 0，大于返回正数
- 版本 : 1.0.0


### appendIfMissing(str, suffix, suffixes)

> 如果字符串不以指定后缀结尾，则添加后缀

- 参数 : str 原始字符串
- 参数 : suffix 要添加的后缀
- 参数 : suffixes 其他可能的后缀
- 返回 : 添加后缀后的字符串
- 版本 : 1.0.0


### appendIfMissingIgnoreCase(str, suffix, suffixes)

> 如果字符串不以指定后缀结尾（忽略大小写），则添加后缀

- 参数 : str 原始字符串
- 参数 : suffix 要添加的后缀
- 参数 : suffixes 其他可能的后缀
- 返回 : 添加后缀后的字符串
- 版本 : 1.0.0


### appendIfMissing(str, suffix, ignoreCase, testSuffixes)

> 如果字符串不以指定后缀结尾（可指定是否忽略大小写），则添加后缀

- 参数 : str 原始字符串
- 参数 : suffix 要添加的后缀
- 参数 : ignoreCase 是否忽略大小写
- 参数 : testSuffixes 其他可能的后缀
- 返回 : 添加后缀后的字符串
- 版本 : 1.0.0


### prependIfMissing(str, prefix, prefixes)

> 如果字符串不以指定前缀开头，则添加前缀

- 参数 : str 原始字符串
- 参数 : prefix 要添加的前缀
- 参数 : prefixes 其他可能的前缀
- 返回 : 添加前缀后的字符串
- 版本 : 1.0.0


### prependIfMissingIgnoreCase(str, prefix, prefixes)

> 如果字符串不以指定前缀开头（忽略大小写），则添加前缀

- 参数 : str 原始字符串
- 参数 : prefix 要添加的前缀
- 参数 : prefixes 其他可能的前缀
- 返回 : 添加前缀后的字符串
- 版本 : 1.0.0


### prependIfMissing(str, prefix, ignoreCase, prefixes)

> 如果字符串不以指定前缀开头（可指定是否忽略大小写），则添加前缀

- 参数 : str 原始字符串
- 参数 : prefix 要添加的前缀
- 参数 : ignoreCase 是否忽略大小写
- 参数 : prefixes 其他可能的前缀
- 返回 : 添加前缀后的字符串
- 版本 : 1.0.0


### replaceIgnoreCase(str, searchStr, replacement)

> 忽略大小写替换字符串中的指定内容

- 参数 : str 原始字符串
- 参数 : searchStr 要查找的字符串
- 参数 : replacement 替换后的字符串
- 返回 : 替换后的字符串
- 版本 : 1.0.0


### replace(str, searchStr, replacement)

> 替换字符串中的指定内容

- 参数 : str 原始字符串
- 参数 : searchStr 要查找的字符串
- 参数 : replacement 替换后的字符串
- 返回 : 替换后的字符串
- 版本 : 1.0.0


### lastIndexOf(text, searchStr, from, ignoreCase)

> 从指定位置开始查找指定字符序列最后一次出现的位置，可选择是否忽略大小写

- 参数 : text 要查找的文本
- 参数 : searchStr 要查找的字符序列
- 参数 : from 开始查找的位置
- 参数 : ignoreCase 是否忽略大小写
- 返回 : 最后一次出现的位置，如果未找到则返回 -1
- 版本 : 1.0.0


### ordinalIndexOf(str, searchStr, ordinal)

> 查找指定字符序列在另一个字符序列中第 ordinal 次出现的位置

- 参数 : str 要查找的文本
- 参数 : searchStr 要查找的字符序列
- 参数 : ordinal 要查找的第几次出现（从 1 开始）
- 返回 : 第 ordinal 次出现的位置，如果未找到则返回 -1
- 版本 : 1.0.0


### removeAll(str, strToRemove)

> 从字符序列中移除所有指定的字符序列

- 参数 : str 原始字符序列
- 参数 : strToRemove 要移除的字符序列
- 返回 : 移除后的字符序列
- 版本 : 1.0.0


### removeAny(str, strsToRemove)

> 从字符序列中移除指定的多个字符序列中的任意一个

- 参数 : str 原始字符序列
- 参数 : strsToRemove 要移除的多个字符序列
- 返回 : 移除后的字符序列
- 版本 : 1.0.0


### removeAllLineBreaks(str)

> 移除字符序列中的所有换行符

- 参数 : str 原始字符序列
- 返回 : 移除换行符后的字符序列
- 版本 : 1.0.0


### removePreAndLowerFirst(str, preLength)

> 移除字符序列的前 preLength 个字符并将第一个字符转换为小写

- 参数 : str 原始字符序列
- 参数 : preLength 要移除的前缀长度
- 返回 : 处理后的字符序列
- 版本 : 1.0.0


### removePreAndLowerFirst(str, prefix)

> 移除字符序列的指定前缀并将第一个字符转换为小写

- 参数 : str 原始字符序列
- 参数 : prefix 要移除的前缀
- 返回 : 处理后的字符序列
- 版本 : 1.0.0


### removePrefix(str, prefix)

> 移除字符序列的指定前缀

- 参数 : str 原始字符序列
- 参数 : prefix 要移除的前缀
- 返回 : 移除前缀后的字符序列
- 版本 : 1.0.0


### removeAllPrefix(str, prefix)

> 移除字符序列中所有的指定前缀

- 参数 : str 原始字符序列
- 参数 : prefix 要移除的前缀
- 返回 : 移除所有前缀后的字符序列
- 版本 : 1.0.0


### removePrefixIgnoreCase(str, prefix)

> 忽略大小写地移除字符序列的指定前缀

- 参数 : str 原始字符序列
- 参数 : prefix 要移除的前缀
- 返回 : 移除前缀后的字符序列
- 版本 : 1.0.0


### removeSuffix(str, suffix)

> 移除字符序列的指定后缀

- 参数 : str 原始字符序列
- 参数 : suffix 要移除的后缀
- 返回 : 移除后缀后的字符序列
- 版本 : 1.0.0


### removeAllSuffix(str, suffix)

> 移除字符序列中所有的指定后缀

- 参数 : str 原始字符序列
- 参数 : suffix 要移除的后缀
- 返回 : 移除所有后缀后的字符序列
- 版本 : 1.0.0


### removeSufAndLowerFirst(str, suffix)

> 移除字符序列的指定后缀并将第一个字符转换为小写

- 参数 : str 原始字符序列
- 参数 : suffix 要移除的后缀
- 返回 : 处理后的字符序列
- 版本 : 1.0.0


### removeSuffixIgnoreCase(str, suffix)

> 忽略大小写地移除字符序列的指定后缀

- 参数 : str 原始字符序列
- 参数 : suffix 要移除的后缀
- 返回 : 移除后缀后的字符序列
- 版本 : 1.0.0


### wrapAllIfMissing(prefix, suffix, strs)

> 如果字符串数组中的每个字符串没有指定的前缀和后缀，则添加前缀和后缀

- 参数 : prefix 要添加的前缀
- 参数 : suffix 要添加的后缀
- 参数 : strs 字符串数组
- 返回 : 处理后的字符串数组
- 版本 : 1.0.0


### unWrap(str, prefix, suffix)

> 移除字符串的指定前缀和后缀

- 参数 : str 要处理的字符串
- 参数 : prefix 要移除的前缀
- 参数 : suffix 要移除的后缀
- 返回 : 处理后的字符串
- 版本 : 1.0.0


### isWrap(str, prefix, suffix)

> 判断字符串是否以指定的前缀和后缀包裹

- 参数 : str 要判断的字符串
- 参数 : prefix 前缀
- 参数 : suffix 后缀
- 返回 : 如果字符串以指定的前缀和后缀包裹则返回 true，否则返回 false
- 版本 : 1.0.0


### isWrap(str, wrapper)

> 判断字符串是否以指定的包裹字符串包裹

- 参数 : str 要判断的字符串
- 参数 : wrapper 包裹字符串
- 返回 : 如果字符串以指定的包裹字符串包裹则返回 true，否则返回 false
- 版本 : 1.0.0


### padPre(str, length, padStr)

> 在字符串前面填充指定的字符串，直到达到指定的长度

- 参数 : str 要填充的字符串
- 参数 : length 填充后的长度
- 参数 : padStr 用于填充的字符串
- 返回 : 填充后的字符串
- 版本 : 1.0.0


### padAfter(str, length, padStr)

> 在字符串后面填充指定的字符串，直到达到指定的长度

- 参数 : str 要填充的字符串
- 参数 : length 填充后的长度
- 参数 : padStr 用于填充的字符串
- 返回 : 填充后的字符串
- 版本 : 1.0.0


### center(str, size)

> 将字符串居中，使用空格填充

- 参数 : str 要居中的字符串
- 参数 : size 填充后的总长度
- 返回 : 居中后的字符串
- 版本 : 1.0.0


### center(str, size, padStr)

> 将字符串居中，使用指定的字符串填充

- 参数 : str 要居中的字符串
- 参数 : size 填充后的总长度
- 参数 : padStr 用于填充的字符串
- 返回 : 居中后的字符串
- 版本 : 1.0.0


### replace(str, searchStr, replacement, ignoreCase)

> 替换字符串中所有匹配的子字符串

- 参数 : str 原始字符串
- 参数 : searchStr 要查找的子字符串
- 参数 : replacement 用于替换的字符串
- 参数 : ignoreCase 是否忽略大小写
- 返回 : 替换后的字符串
- 版本 : 1.0.0


### replace(str, fromIndex, searchStr, replacement, ignoreCase)

> 从指定索引开始替换字符串中所有匹配的子字符串

- 参数 : str 原始字符串
- 参数 : fromIndex 开始查找的索引
- 参数 : searchStr 要查找的子字符串
- 参数 : replacement 用于替换的字符串
- 参数 : ignoreCase 是否忽略大小写
- 返回 : 替换后的字符串
- 版本 : 1.0.0


### replace(str, startInclude, endExclude, replacedStr)

> 替换指定范围内的子字符串

- 参数 : str 原始字符串
- 参数 : startInclude 开始索引（包含）
- 参数 : endExclude 结束索引（不包含）
- 参数 : replacedStr 用于替换的字符串
- 返回 : 替换后的字符串
- 版本 : 1.0.0


### replaceLast(str, searchStr, replacedStr)

> 替换字符串中最后一个匹配的子字符串

- 参数 : str 原始字符串
- 参数 : searchStr 要查找的子字符串
- 参数 : replacedStr 用于替换的字符串
- 返回 : 替换后的字符串
- 版本 : 1.0.0


### replaceLast(str, searchStr, replacedStr, ignoreCase)

> 替换字符串中最后一个匹配的子字符串，可选择是否忽略大小写

- 参数 : str 原始字符串
- 参数 : searchStr 要查找的子字符串
- 参数 : replacedStr 用于替换的字符串
- 参数 : ignoreCase 是否忽略大小写
- 返回 : 替换后的字符串
- 版本 : 1.0.0


### replaceFirst(str, searchStr, replacedStr)

> 替换字符串中第一个匹配的子字符串

- 参数 : str 原始字符串
- 参数 : searchStr 要查找的子字符串
- 参数 : replacedStr 用于替换的字符串
- 返回 : 替换后的字符串
- 版本 : 1.0.0


### replaceFirst(str, searchStr, replacedStr, ignoreCase)

> 替换字符串中第一个匹配的子字符串，可选择是否忽略大小写

- 参数 : str 原始字符串
- 参数 : searchStr 要查找的子字符串
- 参数 : replacedStr 用于替换的字符串
- 参数 : ignoreCase 是否忽略大小写
- 返回 : 替换后的字符串
- 版本 : 1.0.0


### hide(str, startInclude, endExclude)

> 隐藏指定范围内的字符

- 参数 : str 原始字符串
- 参数 : startInclude 开始索引（包含）
- 参数 : endExclude 结束索引（不包含）
- 返回 : 隐藏后的字符串
- 版本 : 1.0.0


### replaceChars(str, chars, replacedStr)

> 替换字符串中指定字符集合中的字符

- 参数 : str 原始字符串
- 参数 : chars 要替换的字符集合（字符串形式）
- 参数 : replacedStr 用于替换的字符串
- 返回 : 替换后的字符串
- 版本 : 1.0.0


### length(cs)

> 获取字符串的长度

- 参数 : cs 字符串
- 返回 : 字符串的长度，如果字符串为 null 则返回 0
- 版本 : 1.0.0


### totalLength(strs)

> 获取多个字符串的总长度

- 参数 : strs 字符串数组
- 返回 : 所有字符串的总长度，如果数组为 null 则返回 0
- 版本 : 1.0.0


### maxLength(string, length)

> 如果字符串长度超过指定长度，截取到指定长度

- 参数 : string 原始字符串
- 参数 : length 最大长度
- 返回 : 截取后的字符串
- 版本 : 1.0.0


### upperFirstAndAddPre(str, preString)

> 将字符串首字母大写并添加前缀

- 参数 : str 原始字符串
- 参数 : preString 要添加的前缀
- 返回 : 处理后的字符串
- 版本 : 1.0.0


### upperFirst(str)

> 将字符串首字母大写

- 参数 : str 原始字符串
- 返回 : 首字母大写后的字符串
- 版本 : 1.0.0


### lowerFirst(str)

> 将字符串首字母小写

- 参数 : str 原始字符串
- 返回 : 首字母小写后的字符串
- 版本 : 1.0.0


### isUpperCase(str)

> 判断字符串是否全部为大写

- 参数 : str 要判断的字符串
- 返回 : 如果字符串全部为大写则返回 true，否则返回 false
- 版本 : 1.0.0


### isLowerCase(str)

> 判断字符串是否全部为小写

- 参数 : str 要判断的字符串
- 返回 : 如果字符串全部为小写则返回 true，否则返回 false
- 版本 : 1.0.0


### swapCase(str)

> 反转字符串的大小写

- 参数 : str 原始字符串
- 返回 : 大小写反转后的字符串
- 版本 : 1.0.0


### toString(obj)

> 将对象转换为字符串

- 参数 : obj 要转换的对象
- 返回 : 对象的字符串表示，如果对象为 null，则返回 "null"
- 版本 : 1.0.0


### toStringOrNull(obj)

> 将对象转换为字符串，如果对象为 null 则返回 null

- 参数 : obj 要转换的对象
- 返回 : 对象的字符串表示，如果对象为 null，则返回 null
- 版本 : 1.0.0


### toStringOrEmpty(obj)

> 将对象转换为字符串，如果对象为 null 则返回空字符串

- 参数 : obj 要转换的对象
- 返回 : 对象的字符串表示，如果对象为 null，则返回空字符串
- 版本 : 1.0.0


### builder()

> 创建一个默认容量的 StringBuilder 对象

- 返回 : 一个默认容量的 StringBuilder 对象
- 版本 : 1.0.0


### builder(capacity)

> 创建一个指定容量的 StringBuilder 对象

- 参数 : capacity 指定的容量
- 返回 : 一个指定容量的 StringBuilder 对象
- 版本 : 1.0.0


### reverse(str)

> 反转字符串

- 参数 : str 要反转的字符串
- 返回 : 反转后的字符串，如果输入为 null 则返回 null
- 版本 : 1.0.0


### similar(str1, str2)

> 计算两个字符串的相似度，返回相似度比例（0.0 - 1.0）

- 参数 : str1 第一个字符串
- 参数 : str2 第二个字符串
- 返回 : 相似度比例
- 版本 : 1.0.0


### similar(str1, str2, scale)

> 计算两个字符串的相似度，返回相似度比例（0.0 - 1.0），并根据 scale 进行四舍五入

- 参数 : str1 第一个字符串
- 参数 : str2 第二个字符串
- 参数 : scale 小数位数
- 返回 : 四舍五入后的相似度比例
- 版本 : 1.0.0


### uuid()

> 生成一个 UUID 字符串

- 返回 : UUID 字符串
- 版本 : 1.0.0


### split(str, separator, limit, isTrim, ignoreEmpty)

> 按照指定分隔符分割字符串序列，可设置分割次数限制、是否去除前后空格、是否忽略空字符串

- 参数 : str 要分割的字符序列
- 参数 : separator 分隔符
- 参数 : limit 分割次数限制，小于等于 0 表示无限制
- 参数 : isTrim 是否去除分割后的子字符串前后空格
- 参数 : ignoreEmpty 是否忽略空字符串
- 返回 : 分割后的字符串列表
- 版本 : 1.0.0


### split(str, len)

> 按照指定长度分割字符序列

- 参数 : str 要分割的字符序列
- 参数 : len 分割的长度
- 返回 : 分割后的字符串数组
- 版本 : 1.0.0


### split(str, separator)


### cut(str, partLength)

> 按照指定长度切割字符序列

- 参数 : str 要切割的字符序列
- 参数 : partLength 切割的长度
- 返回 : 切割后的字符串数组
- 版本 : 1.0.0


### sub(str, fromIndexInclude, toIndexExclude)

> 截取字符序列中指定范围的子字符串

- 参数 : str 要截取的字符序列
- 参数 : fromIndexInclude 起始位置（包含）
- 参数 : toIndexExclude 结束位置（不包含）
- 返回 : 截取的子字符串
- 版本 : 1.0.0


### subPreGbk(str, len, suffix)

> 截取字符序列中指定长度的子字符串（按 GBK 编码），可添加后缀

- 参数 : str 要截取的字符序列
- 参数 : len 截取的长度
- 参数 : suffix 截取后的后缀
- 返回 : 截取的子字符串
- 版本 : 1.0.0


### subPreGbk(str, len, halfUp)

> 截取字符序列中指定长度的子字符串（按 GBK 编码），可选择是否四舍五入

- 参数 : str 要截取的字符序列
- 参数 : len 截取的长度
- 参数 : halfUp 是否四舍五入
- 返回 : 截取的子字符串
- 版本 : 1.0.0


### subPre(string, toIndexExclude)

> 截取字符序列中从开头到指定位置（不包含）的子字符串

- 参数 : string 要截取的字符序列
- 参数 : toIndexExclude 结束位置（不包含）
- 返回 : 截取的子字符串
- 版本 : 1.0.0


### subSuf(string, fromIndex)

> 截取字符序列中从指定位置到结尾的子字符串

- 参数 : string 要截取的字符序列
- 参数 : fromIndex 起始位置
- 返回 : 截取的子字符串
- 版本 : 1.0.0


### subSufByLength(string, length)

> 截取字符序列中从结尾开始指定长度的子字符串

- 参数 : string 要截取的字符序列
- 参数 : length 截取的长度
- 返回 : 截取的子字符串
- 版本 : 1.0.0


### subWithLength(input, fromIndex, length)

> 截取字符串中从指定位置开始指定长度的子字符串

- 参数 : input 要截取的字符串
- 参数 : fromIndex 起始位置
- 参数 : length 截取的长度
- 返回 : 截取的子字符串
- 版本 : 1.0.0


### subBefore(string, separator, isLastSeparator)

> 截取之前字符串

- 参数 : string 要截取的字符序列 
- 参数 : separator 分隔符 
- 参数 : isLastSeparator 是否使用最后一个分隔符 
- 返回 : 截取的子字符串
- 版本 : 1.0.0


### subAfter(string, separator, isLastSeparator)

> 截取之后字符串

- 参数 : string 要截取的字符序列 
- 参数 : separator 分隔符 
- 参数 : isLastSeparator 是否使用最后一个分隔符  
- 返回 : 截取的子字符串
- 版本 : 1.0.0


### subBetween(str, before, after)

> 截取字符序列中两个指定分隔符之间的子字符串

- 参数 : str 要截取的字符序列
- 参数 : before 前分隔符
- 参数 : after 后分隔符
- 返回 : 截取的子字符串
- 版本 : 1.0.0


### subBetween(str, beforeAndAfter)

> 截取字符序列中指定分隔符之间的子字符串（前后分隔符相同）

- 参数 : str 要截取的字符序列
- 参数 : beforeAndAfter 前后分隔符
- 返回 : 截取的子字符串
- 版本 : 1.0.0


### subBetweenAll(str, prefix, suffix)

> 从给定的字符序列中提取所有位于指定前缀和后缀之间的子字符串

- 参数 : str 要进行搜索的字符序列，不能为 null
- 参数 : prefix 作为子字符串起始标记的字符序列，不能为 null
- 参数 : suffix 作为子字符串结束标记的字符序列，不能为 null
- 返回 : 包含所有找到的子字符串的数组，如果没有找到则返回空数组
- 版本 : 1.0.0


### subBetweenAll(str, prefixAndSuffix)

> 从给定的字符序列中提取所有位于指定前缀和后缀（前缀和后缀相同）之间的子字符串

- 参数 : str 要进行搜索的字符序列，不能为 null
- 参数 : prefixAndSuffix 作为子字符串起始和结束标记的字符序列，不能为 null
- 返回 : 包含所有找到的子字符串的数组，如果没有找到则返回空数组
- 版本 : 1.0.0


# $sys - 系统工具

- 更新时间:2025-12-13 11:58:47

> 系统工具




### airplane(enable)

> 设置飞行模式
> 
> 如果无法修改系统达到设置飞行模式的目的，那么就要求用户手动设置飞行模式

- 参数 : enable {boolean} 是否开启飞行模式(ture:开启,false:关闭)
- 版本 : 1.0.0


```javascript
//设置飞行模式
$sys.airplane(true);
```


### volume(mode, volume)

> 设置媒体音量
> 
> 注意：音量模式可以只写前三个字母,比如：sys,rin,mus,ala,acc

- 参数 : mode {string} 音量模式(system|ring|music|alarm|notification|call|dtmf|accessibility)
- 参数 : volume {int} 音量大小
- 版本 : 1.0.0


```javascript
//设置音量大小
//注意：前面的英文字母可以只写前3位，比如：sys,rin,mus,ala,acc
$sys.volume("system",100);//系统
$sys.volume("ring",100);//铃声
$sys.volume("music",100);//媒体
$sys.volume("alarm",100);//闹钟
$sys.volume("notification",100);//通知
$sys.volume("call",100);//电话
$sys.volume("dtmf",100);//双音多频(信号的音量流)
$sys.volume("accessibility",100);//无障碍
toast("音量已全部加满！");
```


### getDeviceId()

> 获得唯一标识

- 返回 : 设备唯一标识
- 版本 : 1.0.0


```javascript
let id = $sys.getDeviceId();
alert("设备id",id);
```


### hasClip()

> 判断剪切板是否有内容

- 返回 : {boolean} 是否存在剪切板
- 版本 : 1.0.0


```javascript
//判断是否有内容
if($sys.hasClip()){
    //获得内容
    let content = $sys.getClip();
    $tip.i(content);
}
```


### clearClip()

> 清除剪切板内容

- 返回 : {boolean} 是否清除成功
- 版本 : 1.0.0


```javascript
$sys.clearClip();
```


### getClip()

> 获得剪切板文字
> 
> 谷歌官方发布表明从安卓13开始将支持应用设置剪切板的内容为敏感信息，这就导致，获取剪切板的内容很可能无法获取，或者获取到的内容为空。
> 
> 因此在实际开发中，如果你发现自己无法获取剪切板的内容，完全属于正常现象，此外，较高版本的安卓系统中，剪切板无法后台获取。

- 返回 : {String} 剪切板的文字
- 版本 : 1.0.0


```javascript
//获得内容
let content = $sys.getClip();
alert("剪切板",content);
```


### setClip(text)

> 设置剪切板

- 参数 : text {String} 需要添加的文字
- 返回 : {String} 获得文字
- 版本 : 1.0.0


```javascript
//设置剪切板
$sys.setClip("Hello AIGame !");
```


### ignorePower(pkgName)

> 是否忽略电池优化
> 
> 该功能只能在部分低版本安卓系统上才可使用

- 参数 : pkgName {string} 包名
- 返回 : {boolean} 是否成功
- 版本 : 1.0.0


```javascript
//是否忽略电池优化
let is = $sys.ignorePower("org.aigame.app");
alert("是否忽略电池优化",is);
```


### requestIgnorePower(pkgName)

> 请求忽略电池优化
> 
> 该功能只能在部分低版本安卓系统上才可使用

- 参数 : pkgName {string} 包名
- 版本 : 1.0.0


```javascript
//请求忽略电池优化
$sys.requestIgnorePower("org.aigame.app");
```


### stayAlive(enable)

> 开启前台保活服务

- 参数 : enable {boolean} 是否开启
- 版本 : 1.1.2


```javascript
//开启前台保活服务
$sys.stayAlive(true);
//关闭前台保活服务
$sys.stayAlive(false);
```


### hasStayAlive()

> 是否开启前台保活服务

- 返回 : {boolean} 是否开启
- 版本 : 1.1.2


```javascript
//是否开启前台保活服务
let is = $sys.hasStayAlive();
alert("是否开启前台保活服务",is);
```


### hasPointer()

> 判断是否开启指针
> 
> 判断是否开启开发者调试的指针位置显示

- 返回 : {boolean} 是否开启
- 版本 : 1.4.1


```javascript
if($sys.hasPointer()){
    //已经开启了开发者指针
    alert("指针状态","指针已开启");
}
```


### pointer(enable)

> 开发者指针授权
> 
> 需要root或者shizuku权限才能开启指针

- 版本 : 1.7.0


```javascript
//授权开启开发者指针
$sys.pointer(true);
//等待一秒后再判断指针是否可用(指针授权并非是立马生效的)
sleep(1000);
//判断指针是否可用
if($sys.hasPointer()){
    //指针已开启
    alert("指针授权","指针已开启");
}
```


# $szk - Shizuku工具

- 更新时间:2025-12-13 11:58:46

> Shizuku工具
> 
> 这是一种不需要root就能享受到root同等级权限的工具




### getPermit()

> 获取Shizuku权限
> 
> 如果Shizuku权限已经获取，那么就判断是否链接上服务，如果服务没有链接则尝试连接服务
> 

- 版本 : 1.0.8


```javascript
$szk.getPermit();
```


### hasPermit()

> 是否可用
> 
> 1.判断Shizuku是否授权
> 
> 2.判断Shizuku服务是否可用
> 
> 3.如果Shizuku可用,则判断是否获取到了服务实例
> 
> 4.如果没有获取服务实例,则会尝试重连服务(重连服务成功就会创建服务实例)
> 

- 返回 : {boolean} 判断Shizuku是否获取权限并且可用
- 版本 : 1.0.8


```javascript
if($szk.hasPermit()){
    log("Shizuku权限已获取");
}
```


### enablePointer(enable)

> 启用指针
> 
> 打开或者关闭开发者调试的指针位置选项

- 参数 : enable {boolean} 是否启用
- 版本 : 1.4.1


```javascript
//打开指针位置显示
$szk.enablePointer(true);
```


### waitPermit()

> 等待Shizuku权限
> 
> 此函数是个阻塞同步方法,只有当本函数执行完毕后,下面的方法才会执行
> 
> 如果shizuku没有安装或者不可用会直接返回false,否则就会循环等待shizuku权限,直到shizuku权限获取成功
> 
> 但是这个函数不能作为获取权限来使用，它不会获取shizuku权限，所以你需要调用getPermit()成功获取权限后再调用此方法，
> 设计这个方法是因为:shizuku权限获取后,并不是立马就能执行命令了，而是需要等待一段时间，而这个函数就是用来衔接这段等待时间的。

- 返回 : {boolean} 等待shizuku权限成功返回true,否则返回false
- 版本 : 1.2.0


### waitPermit(callback)

> 等待Shizuku权限
> 
> 此函数是个异步方法,放在后台等待shizuku权限,如果获取成功就执行回调

- 参数 : callback ((success)=>{}) 执行回调,参数是授权是否成功
- 版本 : 1.2.0


### click(x, y)

> 点击
> 

- 参数 : x {int} 点击位置x
- 参数 : y {int} 点击位置y
- 版本 : 1.0.8


```javascript
//点击手势(长按)(时长一秒)
$szk.click(500,800);
```


### click(x, y, dur)

> 点击
> 

- 参数 : x {int} 点击位置x
- 参数 : y {int} 点击位置y
- 参数 : dur {int} 点击持续时长
- 版本 : 1.0.8


```javascript
//点击手势(长按)(时长一秒)
$szk.click(500,800,1000);
```


### click(x, y, dur, delay)

> 点击
> 

- 参数 : x {int} 点击位置x
- 参数 : y {int} 点击位置y
- 参数 : dur {int} 点击持续时长
- 参数 : delay {int} 点击前延迟
- 版本 : 1.0.8


```javascript
//点击手势(长按)(时长一秒)
$szk.click(500,800,1000,100);
```


### click(index)

> 点击
> 

- 参数 : index {int[]} 点击位置
- 版本 : 1.0.8


```javascript
//点击
$szk.click([500,800]);
```


### click(index, dur)

> 点击
> 

- 参数 : index {int[]} 点击位置
- 参数 : dur {int} 点击持续时长
- 版本 : 1.0.8


```javascript
//点击
$szk.click([500,800],50);
```


### click(index, dur, delay)

> 点击
> 

- 参数 : index {int[]} 点击位置
- 参数 : dur {int} 点击持续时长
- 参数 : delay {int} 延迟
- 版本 : 1.0.8


```javascript
//点击
$szk.click([500,800],50,2000);
```


### click(index)

> 点击
> 

- 参数 : index {Point} 点击位置
- 版本 : 1.0.8


```javascript
//点击手势(长按)
let point = new org.opencv.core.Point(500,800);
$szk.click(point);
```


### click(index, dur)

> 点击
> 

- 参数 : index {Point} 点击位置
- 参数 : dur {int} 点击持续时长
- 版本 : 1.0.8


```javascript
//点击手势(长按)(时长一秒)
let point = new org.opencv.core.Point(500,800);
$szk.click(point,1000);
```


### click(index, dur, delay)

> 点击
> 

- 参数 : index {Point} 点击位置
- 参数 : dur {int} 点击持续时长
- 参数 : delay {int} 点击前延迟
- 版本 : 1.0.8


```javascript
//点击手势(长按)(时长一秒)
let point = new org.opencv.core.Point(500,800);
$szk.click(point,1000,100);
```


### press(x, y)

> 长按
> 

- 参数 : x {int} 长按位置x
- 参数 : y {int} 长按位置y
- 版本 : 1.0.8


```javascript
//点击手势(长按)(时长一秒)
$szk.press(500,800);
```


### press(x, y, dur)

> 长按
> 

- 参数 : x {int} 长按位置x
- 参数 : y {int} 长按位置y
- 参数 : dur {int} 长按持续时间
- 版本 : 1.0.8


```javascript
//点击手势(长按)(时长一秒)
$szk.press(500,800,1000);
```


### press(x, y, dur, delay)

> 长按
> 

- 参数 : x {int} 长按位置x
- 参数 : y {int} 长按位置y
- 参数 : dur {int} 长按持续时间
- 参数 : delay {int} 长按前延迟
- 版本 : 1.0.8


```javascript
//点击手势(长按)(延迟一秒)
$szk.press(500,800,1500,100);
```


### move(x1, y1, x2, y2)

> 滑动
> 

- 参数 : x1 {int} 起点x
- 参数 : y1 {int} 起点y
- 参数 : x2 {int} 终点x
- 参数 : y2 {int} 终点y
- 版本 : 1.0.8


```javascript
//滑动手势
$szk.move(500,0,500,800);
```


### move(x1, y1, x2, y2, dur)

> 滑动
> 

- 参数 : x1 {int} 起点x
- 参数 : y1 {int} 起点y
- 参数 : x2 {int} 终点x
- 参数 : y2 {int} 终点y
- 参数 : dur {int} 时长
- 版本 : 1.0.8


```javascript
//滑动手势
$szk.move(500,0,500,800,1000);
```


### move(x1, y1, x2, y2, dur, delay)

> 滑动
> 

- 参数 : x1 {int} 起点x
- 参数 : y1 {int} 起点y
- 参数 : x2 {int} 终点x
- 参数 : y2 {int} 终点y
- 参数 : dur {int} 时长
- 参数 : delay {int} 延迟
- 版本 : 1.0.8


```javascript
//滑动手势
$szk.move(500,0,500,800,1000,2000);
```


### home()

> 返回手机主页

- 版本 : 1.0.8


```javascript
$szk.home();
```


### back()

> 执行返回按钮

- 版本 : 1.0.8


```javascript
$szk.back();
```


### menu()

> 执行菜单按钮

- 版本 : 1.0.8


```javascript
$szk.menu();
```


### recent()

> 打开最近任务列表
> 
> 效果和'menu()'一样

- 版本 : 1.0.8


```javascript
$szk.recent();
```


### power()

> 执行关机键

- 版本 : 1.0.8


```javascript
$szk.power();
```


### lock()

> 锁屏

- 版本 : 1.0.8


```javascript
$szk.lock();
```


### unlock()

> 唤醒屏幕

- 版本 : 1.0.8


```javascript
$szk.unlock();
```


### input(text)

> 输入文本

- 参数 : text {string} 文本内容
- 版本 : 1.0.8


```javascript
$szk.input("我是文本");
```


### killApp(pkgName)

> 杀死应用

- 参数 : pkgName {string} 包名
- 版本 : 1.0.8


```javascript
$szk.killApp("包名");
```


### setWmSize(width, height)

> 设置手机分辨率

- 参数 : width {int} 宽度 
- 参数 : height {int} 高度 


```javascript
$szk.setWmSize(1080,2200);
```


### setDpi(density)

> 设置手机DPI

- 参数 : density {int} 密度因子 
- 版本 : 1.5.4


```javascript
$szk.setDpi(320);
```


### resetWm()

> 重置手机分辨率与DPI

- 版本 : 1.5.4


```javascript
$szk.resetWm();
```


### exe(cmd)

> 执行一条命令

- 参数 : cmd {string} 需要执行的命令
- 返回 : {string} 执行结果
- 版本 : 1.0.8


```javascript
//等待获取shizuku权限，如果没有权限那么就会一直等待下去
$szk.getPermit();
$szk.exe("input keyevent KEYCODE_POWER");//点击电源按钮
```


### exe(cmd, infoCallback, errorCallback)

> 执行命令

- 参数 : cmd {string} 命令
- 参数 : infoCallback {(info)=>{}} 输出信息回调
- 参数 : errorCallback {(err)=>{}} 错误信息回调
- 版本 : 1.0.8


```javascript
//等待获取shizuku权限，如果没有权限那么就会一直等待下去
$szk.getPermit();
$szk.exe("ls",
    (info)=> {
        //信息输出回调
        log(info);
    },
    (error)=> {
        //异常输出回调
        $log.e(error);
    }
);
```


### exe(cmd, infoCallback, errorCallback, endCallback)

> 执行命令

- 参数 : cmd {string} 命令
- 参数 : infoCallback {(info)=>{}} 输出信息回调
- 参数 : errorCallback {(err)=>{}} 错误信息回调
- 参数 : endCallback {(result)=>{}} 结束执行回调
- 版本 : 1.0.8


```javascript
//等待获取shizuku权限，如果没有权限那么就会一直等待下去
$szk.getPermit();
$szk.exe("ls",
    (info)=> {
        //信息输出回调
        log(info);
    },
    (error)=> {
        //异常输出回调
        $log.e(error);
    },
    (result)=> {
        //结束回调
        log(result)
    }
);
```


### exe(cmd, startCallback, infoCallback, errorCallback, endCallback)

> 执行命令

- 参数 : cmd {string} 命令
- 参数 : startCallback {()=>{}} 开始执行时的回调
- 参数 : infoCallback {(info)=>{}} 输出信息回调
- 参数 : errorCallback {(err)=>{}} 错误信息回调
- 参数 : endCallback {(result)=>{}} 结束执行回调
- 版本 : 1.0.8


```javascript
//等待获取shizuku权限，如果没有权限那么就会一直等待下去
$szk.getPermit();
$szk.exe("ls",
    ()=> {
        //开始执行回调
        log("开始执行");
    },
    (info)=> {
        //信息输出回调
        log(info);
    },
    (error)=> {
        //异常输出回调
        $log.e(error);
    },
    (result)=> {
        //结束回调
        log(result)
    }
);
```


# CdLock - 倒计时锁

- 更新时间:2025-12-13 11:58:47

> 倒计时锁
> 
> 是对CountDownLatch的封装对象，倒计时锁，用于等待多个线程完成。




### ok()

> 完成一个倒计时

- 版本 : 1.8.3


### finish()

> 等待所有倒计时完成

- 版本 : 1.8.3


### finish(timeout)

> 等待所有倒计时完成

- 参数 : timeout {long} 超时时间(ms)
- 返回 : {boolean} 是否完成
- 版本 : 1.8.3


### getCount()

> 获取倒计时数量

- 返回 : {long} 倒计时数量
- 版本 : 1.8.3


# Threadx - 增强线程

- 更新时间:2025-12-13 11:58:47

> 增强线程
> 
> 增强线程名为"Threadx"，它继承自"java.lang.Thread"类，提供了额外的功能和属性，主要允许线程携带一些简单的基础数据。




### name()

> 获取线程名称

- 返回 : {string} 线程名称
- 版本 : 1.2.0


```javascript
//增强线程对象
let tx = $thread.create(()=>{
    //...
});
//获取线程名称
let name = tx.name();
//输出线程名称
alert("线程名称" , name);
```


### hasRun()

> 判断当前线程是否终止

- 返回 : {boolean} 是否停止运行
- 版本 : 1.2.0


```javascript
//增强线程对象
let tx = $thread.create(()=>{
    //...
});
//判断当前线程是否终止
let run = tx.hasRun();
if(run){
     alert("线程正在运行");
}else{
     alert("线程已终止");
}
```


### setStr(str)

> 设置字符类型的标志

- 参数 : str {string} 字符类型的标志
- 版本 : 1.2.0


```javascript
//增强线程对象
let tx = $thread.create(()=>{
    //...
});
//设置字符类型的标志
tx.setStr("携带数据");
```


### getStr()

> 获得字符类型的标志

- 返回 : {string} 字符类型的标志
- 版本 : 1.2.0


```javascript
//增强线程对象
let tx = $thread.create(()=>{
    //...
});
//获得字符类型的标志
let srt = tx.getStr();
```


### setBool(booFlag)

> 设置布尔类型的标志
> 
> 需要注意:当线程(非循环器)被终止时，布尔类型的标志位会被设置为false;

- 参数 : booFlag {boolean} 布尔类型的标志
- 版本 : 1.2.0


```javascript
//增强线程对象
let tx = $thread.create(()=>{
    //...
});
//设置布尔类型的标志
tx.setBool(false);
```


### getBool()

> 获取布尔类型的标志
> 
> 需要注意:当线程(非循环器)被终止时，布尔类型的标志位会被设置为false;

- 返回 : {boolean} 布尔类型的标志
- 版本 : 1.2.0


```javascript
//增强线程对象
let tx = $thread.create(()=>{
    //...
});
//获取布尔类型的标志
let b = tx.getBool();
```


### getInt()

> 获取整数类型的标志

- 返回 : {int} 整数标志值
- 版本 : 1.2.0


```javascript
//增强线程对象
let tx = $thread.create(()=>{
    //...
});
//获取整数类型的标志
let i = tx.getInt();
```


### setInt(flag)

> 设置整数类型的标志

- 参数 : flag {int} 整数标志值
- 版本 : 1.2.0


```javascript
//增强线程对象
let tx = $thread.create(()=>{
    //...
});
//设置整数类型的标志
tx.setInt(0);
```


### getLong()

> 获取长整数类型的标志

- 返回 : {long} 长整数标志值
- 版本 : 1.2.0


```javascript
//增强线程对象
let tx = $thread.create(()=>{
    //...
});
//获取长整数类型的标志
let l = tx.getLong();
```


### setLong(flag)

> 设置长整数类型的标志

- 参数 : flag {long} 长整数标志值
- 版本 : 1.2.0


```javascript
//增强线程对象
let tx = $thread.create(()=>{
    //...
});
//设置长整数类型的标志
tx.setLong(1000);
```


### getObj()

> 获取对象类型的标志

- 返回 : {Object} 对象标志值
- 版本 : 1.2.0


```javascript
//增强线程对象
let tx = $thread.create(()=>{
    //...
});
//获取对象类型的标志
let o = tx.getObj();
```


### setObj(flag)

> 设置对象类型的标志

- 参数 : flag {Object} 对象标志值
- 版本 : 1.2.0


```javascript
//增强线程对象
let tx = $thread.create(()=>{
    //...
});
//设置对象类型的标志
tx.setObj("我是任意数据");
```


### kill()

> 终止线程

- 版本 : 1.5.1


```javascript
//由于interrupt不太好记，所以就写了个'kill()'方便中止线程。
//使用kill方法中止线程
tx.kill();//等价于tx.interrupt();
```


# $thread - 并发编程

- 更新时间:2025-12-13 11:58:47

> 并发编程
> 
> 本平台支持多线程并发编程，并且很多API内部都已经解决了并发问题




### ui(runnable)

> 在UI线程中执行
> 
> 其实也可以使用$ui.run(()=>{});在ui线程中执行

- 参数 : runnable {()=>{}} 任务
- 版本 : 1.0.0


```javascript
$thread.ui(()=>{
    //这里是UI线程
});
```


### run(runnable)

> 创建并且运行线程

- 参数 : runnable {()=>{}} 任务
- 返回 : {Threadx} 增强线程
- 版本 : 1.2.0


```javascript
let t1 = $thread.run(()=>{
    //耗时任务
});
//要想停止或者关闭
t1.interrupt();
```


### create(runnable)

> 创建线程
> 
> 会自动生成线程名称，之后将线程名称和线程对象存储到序列中。

- 参数 : runnable {()=>{}} 线程任务
- 返回 : {Threadx} 增强线程
- 版本 : 1.0.0


```javascript
let t1 = $thread.create(()=> {
    for (let i = 0; i < 10; i++) {
        sleep("300");
        log(t1.getName()+"==>"+i);
    }
    log(t1.getName()+"执行完毕");
});
t1.start();
```


### create(name, runnable)

> 创建线程
> 
> 优先去序列中查找是否存在这个线程名称，如果存在，会提示名称重复并且返回已经存在的线程对象(threadx)

- 参数 : name {()=>{}} 线程任务
- 返回 : {Threadx} 增强线程
- 版本 : 1.0.0


```javascript
let t1 = $thread.create("线程名称",()=> {
    for (let i = 0; i < 10; i++) {
        sleep("300");
        log(t1.getName()+"==>"+i);
    }
    log(t1.getName()+"执行完毕");
});
t1.start();
```


### newCdLock(num)

> 创建一个倒计时锁

- 参数 : num {int} 倒计时数量
- 返回 : {CdLock} 倒计时锁
- 版本 : 1.8.3


### has(name)

> 是否存在线程名称

- 参数 : name {string} 线程名称
- 返回 : {boolean} 是否存在
- 版本 : 1.2.0


```javascript
let has = $thread.has("线程名称");
if(has){
    //存在线程名称
}else{
    //不存在线程名称
}
```


### get(name)

> 获得已存在的线程

- 参数 : name {string} 线程名称
- 版本 : 1.0.0


```javascript
//获得线程对象
let t1 = $thread.get("线程名称");
if(t1!=null){
    //...
}
```


### loop(name, runnable)

> 创建一个循环执行器

- 参数 : name {string} 循环器名称
- 参数 : runnable {()=>{}} 循环体
- 返回 : {Threadx} 增强线程
- 版本 : 1.0.0


```javascript
let t1 = $thread.loop("循环1号",()=>{
    sleep(1000);
    log("我还活着！");
});
t1.start();
```


### hasLoop(name)

> 是否存在循环执行器

- 参数 : name {string} 循环器名称
- 返回 : {boolean} 是否存在
- 版本 : 1.0.0


```javascript
//关闭循环器
let exists = $thread.hasLoop("循环1号");
```


### stopLoop(name)

> 停止循环执行器

- 参数 : name {string} 循环器名称
- 版本 : 1.0.0


```javascript
//关闭循环器
$thread.stopLoop("循环1号");
```


### stop(threadx)

> 停止指定线程
> 
> 如果停止线程成功,会将增强线程中的布尔标识(setBool)设置为false

- 参数 : threadx {Threadx} 增强线程
- 版本 : 1.0.0


### stop(threadName)

> 停止指定线程

- 参数 : threadName {string} 线程名称
- 版本 : 1.0.0


### stopAll()

> 停止所有线程

- 版本 : 1.0.0


```javascript
//停止所有线程(不包括循环器线程)
$thread.stopAll();
```


### stopAllLoop()

> 停止所有循环执行器
> 
> 'setInterval'本质上也是通过循环执行器实现的，因此本函数也可以停止'setInterval'的循环执行

- 版本 : 1.0.0


```javascript
//停止所有循环执行器
$thread.stopAllLoop();
```


# $alert - 原生对话框

- 更新时间:2025-12-13 11:58:47

> 矩形对话框
> 
> 目前我们的对话框有三种:$tip($提示)、$dialog($对话框)、$alert($提示框)，这三种有哪些特点？
> 
> - $tip($提示):阻塞式对话框，很适合流程脚本，当对话框关闭后，下面的代码才会接着运行
> - $dialog($对话框):非阻塞式对话框，采用M3的风格，缺点就是由于遵循了M3布局规则导致显示的视图范围有限。
> - $alert($提示框):非阻塞式对话框，采用安卓默认实体风格，弥补$dialog显示视图小的缺点，可以通过maxWH(true)显示较大的视图区域。




### create()

> 创建一个对话框

- 返回 : {alert} 对话框对象
- 版本 : 1.5.1


```javascript
//创建一个对话框(注意对象名称不要和全局函数alert相同)
let alt = $alert.create();
```


### title(title)

> 设置对话框标题

- 参数 : title {string} 对话框标题
- 返回 : {alert} 自己
- 版本 : 1.5.1


```javascript
//创建一个对话框(注意对象名称不要和全局函数alert相同)
let alt = $alert.create();
//设置对话框标题
alt.title("标题");
```


### isShowing()

> 检查对话框是否正在显示

- 返回 : {boolean} 对话框是否正在显示
- 版本 : 1.5.1


```javascript
//创建一个对话框(注意对象名称不要和全局函数alert相同)
let alt = $alert.create();
//是否显示了
log(alt.isShowing());//false
```


### msg(msg)

> 设置对话框消息

- 参数 : msg {string} 对话框消息
- 返回 : {alert} 自己
- 版本 : 1.5.1


```javascript
//创建一个对话框(注意对象名称不要和全局函数alert相同)
let alt = $alert.create();
//设置内容
alt.msg("内容");
```


### cancelable(cancelable)

> 设置对话框是否可以取消

- 参数 : cancelable {boolean} 是否可以取消
- 返回 : {alert} 自己
- 版本 : 1.5.1


```javascript
//创建一个对话框(注意对象名称不要和全局函数alert相同)
let alt = $alert.create();
//设置是否可以取消
alt.cancelable(true);
```


### icon(icon)

> 设置对话框图标

- 参数 : icon {string} 图标资源路径
- 返回 : {alert} 自己
- 版本 : 1.5.1


```javascript
//创建一个对话框(注意对象名称不要和全局函数alert相同)
let alt = $alert.create();
//设置对话框图标
alt.icon("ag_logo");
```


### view(view)

> 设置对话框视图

- 参数 : view {view} 视图
- 返回 : {alert} 自己
- 版本 : 1.5.1


```javascript
//解析一个布局
let ui = $ui.layout("main.xml");
let view = ui.getView();//获取视图
//创建一个对话框(注意对象名称不要和全局函数alert相同)
let alt = $alert.create();
//设置对话框视图
alt.view(view);
```


### view(view)

> 设置对话框视图

- 参数 : view {xview} 视图
- 返回 : {alert} 自己
- 版本 : 1.5.1


```javascript
//解析一个布局
let ui = $ui.layout("main.xml");
let xview = ui.id("myView");//获取XView组件视图
//创建一个对话框(注意对象名称不要和全局函数alert相同)
let alt = $alert.create();
//设置对话框视图
alt.view(xview);
```


### maxH(max)

> 设置最高显示

- 参数 : max {boolean} 是否最宽高显示
- 返回 : {alert} 自己
- 版本 : 1.5.1


```javascript
//创建一个对话框(注意对象名称不要和全局函数alert相同)
let alt = $alert.create();
//设置最高显示，对话框的高度会显示到最大
alt.maxH(true);
```


### maxW(max)

> 设置最宽显示

- 参数 : max {boolean} 是否最宽显示
- 返回 : {alert} 自己
- 版本 : 1.5.1


```javascript
//创建一个对话框(注意对象名称不要和全局函数alert相同)
let alt = $alert.create();
//设置最宽显示，对话框的宽度会显示到最大
alt.maxW(true);
```


### maxWH(max)

> 设置最大宽高显示

- 参数 : max {xview} 是否最大宽高显示
- 返回 : {alert} 自己
- 版本 : 1.5.1


```javascript
//创建一个对话框(注意对象名称不要和全局函数alert相同)
let alt = $alert.create();
//设置最宽高显示，对话框的宽高会显示到最大
alt.maxWH(true);
```


### but1(text)

> 设置对话框第一个按钮

- 参数 : text {string} 按钮文本
- 返回 : {alert} 自己
- 版本 : 1.5.1


```javascript
//创建一个对话框(注意对象名称不要和全局函数alert相同)
let alt = $alert.create();
//设置按钮
alt.but1("按钮1");
```


### but1(text, callback)

> 设置对话框第一个按钮
> 
> 回调参数：di:{DialogInterface} 接收到点击的对话框 which:{int}被点击的按钮位置

- 参数 : text {string} 按钮文本
- 参数 : callback {(di,which)=>{}} 回调函数
- 返回 : {alert} 自己
- 版本 : 1.5.1


```javascript
//创建一个对话框(注意对象名称不要和全局函数alert相同)
let alt = $alert.create();
//设置按钮
alt.but1("按钮1",(di,which)=>{
    //点击事件
});
```


### but2(text)

> 设置对话框第二个按钮

- 参数 : text {string} 按钮文本
- 返回 : {alert} 自己
- 版本 : 1.5.1


```javascript
//创建一个对话框(注意对象名称不要和全局函数alert相同)
let alt = $alert.create();
//设置按钮
alt.but2("按钮2");
```


### but2(text, callback)

> 设置对话框第二个按钮
> 
> 回调参数：di:{DialogInterface} 接收到点击的对话框 which:{int}被点击的按钮位置

- 参数 : text {string} 按钮文本
- 参数 : callback {(di,which)=>{}} 回调函数
- 返回 : {alert} 自己
- 版本 : 1.5.1


```javascript
//创建一个对话框(注意对象名称不要和全局函数alert相同)
let alt = $alert.create();
//设置按钮
alt.but2("按钮2",(di,which)=>{
    //点击事件
});
```


### but3(text)

> 设置对话框第三个按钮

- 参数 : text {string} 按钮文本
- 返回 : {alert} 自己
- 版本 : 1.5.1


```javascript
//创建一个对话框(注意对象名称不要和全局函数alert相同)
let alt = $alert.create();
//设置按钮
alt.but3("按钮3");
```


### but3(text, callback)

> 设置对话框第三个按钮
> 
> 回调参数：di:{DialogInterface} 接收到点击的对话框 which:{int}被点击的按钮位置

- 参数 : text {string} 按钮文本
- 参数 : callback {(di,which)=>{}} 回调函数
- 返回 : {alert} 自己
- 版本 : 1.5.1


```javascript
//创建一个对话框(注意对象名称不要和全局函数alert相同)
let alt = $alert.create();
//设置按钮
alt.but3("按钮3",(di,which)=>{
    //点击事件
});
```


### items(items, callback)

> 设置对话框选项
> 
> 回调参数：di:{DialogInterface} 接收到点击的对话框 which:{int}被点击的按钮位置

- 参数 : items {string[]} 选项数组
- 参数 : callback {(di,which)=>{}} 回调函数
- 返回 : {alert} 自己
- 版本 : 1.5.1


```javascript
//创建一个对话框(注意对象名称不要和全局函数alert相同)
let alt = $alert.create();
//设置对话框选项
alt.items(["选项1","选项2","选项3"],(di,which)=>{
    //点击事件
});
```


### oneItems(items, checkedItem, callback)

> 设置对话框单选选项
> 
> 回调参数：di:{DialogInterface} 接收到点击的对话框 which:{int}被点击的按钮位置

- 参数 : items {string[]} 选项数组
- 参数 : checkedItem {int} 选中的选项位置
- 参数 : callback {(di,which)=>{}} 回调函数
- 返回 : {alert} 自己
- 版本 : 1.5.1


```javascript
//创建一个对话框(注意对象名称不要和全局函数alert相同)
let alt = $alert.create();
//设置对话框选项
alt.oneItems(["选项1","选项2","选项3"],0,(di,which)=>{
    //点击事件
});
```


### moreItems(items, callback)

> 设置对话框多选选项
> 
> 回调参数：di:{DialogInterface} 接收到点击的对话框 which:{int}被点击的按钮位置 isChecked:{boolean} 是否被选中

- 参数 : items {string[]} 选项数组
- 参数 : callback {(di,which,isChecked)=>{}} 回调函数
- 返回 : {alert} 自己
- 版本 : 1.5.1


```javascript
//创建一个对话框(注意对象名称不要和全局函数alert相同)
let alt = $alert.create();
//设置对话框选项
alt.moreItems(["选项1","选项2","选项3"],(di,which,isChecked)=>{
    //点击事件
});
```


### moreItems(items, checkedItems, callback)

> 设置对话框多选选项
> 
> 回调参数：di:{DialogInterface} 接收到点击的对话框 which:{int}被点击的按钮位置 isChecked:{boolean} 是否被选中

- 参数 : items {string[]} 选项数组
- 参数 : checkedItems {boolean[]} 选中的选项数组
- 参数 : callback {(di,which,isChecked)=>{}} 回调函数
- 返回 : {alert} 自己
- 版本 : 1.5.1


```javascript
//创建一个对话框(注意对象名称不要和全局函数alert相同)
let alt = $alert.create();
//设置对话框选项
alt.moreItems(["选项1","选项2","选项3"],[false,false,true],(di,which,isChecked)=>{
    //点击事件
});
```


### show()

> 显示对话框

- 返回 : {AlertDialog} 对话框对象
- 版本 : 1.5.1


```javascript
$alert.create()
.title("标题")
.msg("我是信息")
.but3("确定",()=>{
    log("我被点击了");
})
.show();//显示对话框
```


### showBefore(callback)

> 对话框显示前回调
> 
> 需要注意的是:该回调是放在UI线程中执行的

- 参数 : callback {()=>{}} 回调函数 
- 返回 : {alert} 自己
- 版本 : 1.5.1


```javascript
$alert.create()
.title("标题")
.msg("我是信息")
.but3("确定",()=>{
    log("我被点击了");
})
.showBefore(()=>{
    log("准备显示对话框啦");
})
.show();//显示对话框
```


### showAfter(callback)

> 对话框显示后回调
> 
> 需要注意的是:该回调是放在UI线程中执行的

- 参数 : callback {()=>{}} 回调函数 
- 返回 : {alert} 自己
- 版本 : 1.5.1


```javascript
//在自定义view中，如果有界面元素需要刷新，那么就最好在alert显示之后再操作
//例如:
let ui = $ui.layout("ui.xml");//解析一个视图
let mAlert = $alert.create();//创建一个对话框
mAlert.showAfter(()=>{
    //如果自定义视图中存在需要操作的ui元素，可以放到这里操作
    let but = ui.id("mButtonClose");
    mButtonClose.click(()=>{
        mAlert.close();//关闭对话框
    });
}).view(ui.getView()).show();//显示自定义视图
```


### onClose(callback)

> 监听提示框关闭

- 参数 : callback {()=>{}} 提示框关闭后回调
- 版本 : 1.8.0


```javascript
let alt = $alert.create()
.title("标题")
.msg("我是信息")
.but3("关闭",()=>{
    //这里关闭提示框
    alt.close();
})
.onClose(()=>{
    log("对话框被关闭了");
})
.show();//显示提示框
```


### close()

> 关闭对话框

- 版本 : 1.5.1


```javascript
let alt = $alert.create()
.title("标题")
.msg("我是信息")
.but3("关闭",()=>{
    //这里关闭对话框
    alt.close();
})
.show();//显示对话框
```


# $dialog - M3对话框

- 更新时间:2025-12-13 11:58:47

> M3对话框
> 
> 与$alert($提示框)不同，$dialog($对话框)是一个Material Design 3风格的对话框。




### create()

> 创建一个对话框

- 返回 : {dialog} 对话框对象


```javascript
// 创建一个对话框
let dlg = $dialog.create()
```


### title(title)

> 设置对话框标题

- 参数 : title {string} 对话框标题
- 返回 : {dialog} 自己


```javascript
// 创建一个对话框
let dlg = $dialog.create()
// 设置对话框标题
dlg.title("标题")
```


### isShowing()

> 检查对话框是否正在显示

- 返回 : {boolean} 对话框是否正在显示


```javascript
// 创建一个对话框
let dlg = $dialog.create()
// 设置对话框标题
if(dlg.isShowing()){
    log("对话框正再显示");
}
```


### msg(msg)

> 设置对话框消息

- 参数 : msg {string} 对话框消息
- 返回 : {dialog} 自己


```javascript
// 创建一个对话框
let dlg = $dialog.create()
// 设置对话框消息
dlg.msg("内容");
```


### cancelable(cancelable)

> 设置对话框是否可以取消

- 参数 : cancelable {boolean} 是否可以取消
- 返回 : {dialog} 自己


```javascript
// 创建一个对话框
let dlg = $dialog.create()
// 设置对话框是否可以取消
dlg.cancelable(true);
```


### icon(icon)

> 设置对话框图标

- 参数 : icon {string} 图标资源路径
- 返回 : {dialog} 自己


```javascript
// 创建一个对话框
let dlg = $dialog.create()
// 设置对话框图标
dlg.icon("ag_logo);
```


### view(view)

> 设置对话框视图

- 参数 : view {view} 视图
- 返回 : {dialog} 自己


```javascript
//解析一个布局
let ui = $ui.layout("main.xml");
let view = ui.getView();//获取视图
//创建一个对话框
let dlg = $dialog.create()
//设置对话框视图
dlg.view(view);
```


### view(view)

> 设置对话框视图

- 参数 : view {xview} 视图
- 返回 : {dialog} 自己


```javascript
//解析一个布局
let ui = $ui.layout("main.xml");
let view = ui.id("myView");//获取XView对象
//创建一个对话框
let dlg = $dialog.create()
//设置对话框视图
dlg.view(view);
```


### but1(text)

> 设置对话框第一个按钮

- 参数 : text {string} 按钮文本
- 返回 : {dialog} 自己


```javascript
//创建一个对话框
let dlg = $dialog.create()
//设置按钮
dlg.but1("按钮1");
```


### but1(text, callback)

> 设置对话框第一个按钮
> 
> 回调参数：di:{DialogInterface} 接收到点击的对话框 which:{int}被点击的按钮位置

- 参数 : text {string} 按钮文本
- 参数 : callback {(di,which)=>{}} 回调函数
- 返回 : {dialog} 自己


```javascript
//创建一个对话框
let dlg = $dialog.create()
//设置按钮
dlg.but1("按钮1",(di,which)=>{
    log("我被点击了");
});
```


### but2(text)

> 设置对话框第二个按钮

- 参数 : text {string} 按钮文本
- 返回 : {dialog} 自己


```javascript
//创建一个对话框
let dlg = $dialog.create()
//设置按钮
dlg.but2("按钮2");
```


### but2(text, callback)

> 设置对话框第二个按钮
> 
> 回调参数：di:{DialogInterface} 接收到点击的对话框 which:{int}被点击的按钮位置

- 参数 : text {string} 按钮文本
- 参数 : callback {(di,which)=>{}} 回调函数
- 返回 : {dialog} 自己


```javascript
//创建一个对话框
let dlg = $dialog.create()
//设置按钮
dlg.but2("按钮2",(di,which)=>{
    log("我被点击了");
});
```


### but3(text)

> 设置对话框第三个按钮

- 参数 : text {string} 按钮文本
- 返回 : {dialog} 自己


```javascript
//创建一个对话框
let dlg = $dialog.create()
//设置按钮
dlg.but3("按钮3");
```


### but3(text, callback)

> 设置对话框第三个按钮
> 
> 回调参数：di:{DialogInterface} 接收到点击的对话框 which:{int}被点击的按钮位置

- 参数 : text {string} 按钮文本
- 参数 : callback {(di,which)=>{}} 回调函数
- 返回 : {dialog} 自己


```javascript
//创建一个对话框
let dlg = $dialog.create()
//设置按钮
dlg.but3("按钮3",(di,which)=>{
    log("我被点击了");
});
```


### items(items, callback)

> 设置对话框选项
> 
> 回调参数：di:{DialogInterface} 接收到点击的对话框 which:{int}被点击的按钮位置

- 参数 : items {string[]} 选项数组
- 参数 : callback {(di,which)=>{}} 回调函数
- 返回 : {dialog} 自己


```javascript
//创建一个对话框
let dlg = $dialog.create()
.items(["选项1","选项2","选项3"],(di,which)=>{
    log("我被点击了");
})
.show();
```


### oneItems(items, checkedItem, callback)

> 设置对话框单选选项
> 
> 回调参数：di:{DialogInterface} 接收到点击的对话框 which:{int}被点击的按钮位置

- 参数 : items {string[]} 选项数组
- 参数 : checkedItem {int} 选中的选项位置
- 参数 : callback {(di,which)=>{}} 回调函数
- 返回 : {dialog} 自己


```javascript
//创建一个对话框
let dlg = $dialog.create()
.oneItems(["选项1","选项2","选项3"],0,(di,which)=>{
    log("我被点击了");
})
.show();
```


### moreItems(items, callback)

> 设置对话框多选选项
> 
> 回调参数：di:{DialogInterface} 接收到点击的对话框 which:{int}被点击的按钮位置 isChecked:{boolean} 是否被选中

- 参数 : items {string[]} 选项数组
- 参数 : callback {(di,which,isChecked)=>{}} 回调函数
- 返回 : {dialog} 自己


```javascript
//创建一个对话框
let dlg = $dialog.create()
.moreItems(["选项1","选项2","选项3"],(di,which)=>{
    log("我被点击了");
})
.show();
```


### moreItems(items, checkedItems, callback)

> 设置对话框多选选项
> 
> 回调参数：di:{DialogInterface} 接收到点击的对话框 which:{int}被点击的按钮位置 isChecked:{boolean} 是否被选中

- 参数 : items {string[]} 选项数组
- 参数 : checkedItems {boolean[]} 选中的选项数组
- 参数 : callback {(di,which,isChecked)=>{}} 回调函数
- 返回 : {dialog} 自己


```javascript
//创建一个对话框
let dlg = $dialog.create()
.moreItems(["选项1","选项2","选项3"],[false,true,false],(di,which,isChecked)=>{
    log("我被点击了");
})
.show();
```


### show()

> 显示对话框

- 返回 : {AlertDialog} 对话框对象


```javascript
//创建一个对话框
let dlg = $dialog.create()
.title("提示")
.msg("我是一个对话框")
.show();//显示对话框
```


### showBefore(callback)

> 对话框显示前回调
> 
> 需要注意的是:该回调是放在UI线程中执行的

- 参数 : callback {()=>{}} 回调函数 
- 返回 : {dialog} 自己
- 版本 : 1.5.0


```javascript
//创建一个对话框
let dlg = $dialog.create()
.title("提示")
.msg("我是一个对话框")
.showBefore(()=>{
    log("对话框显示前回调");
})
.show();//显示对话框
```


### showAfter(callback)

> 对话框显示后回调
> 
> 需要注意的是:该回调是放在UI线程中执行的

- 参数 : callback {()=>{}} 回调函数 
- 返回 : {dialog} 自己
- 版本 : 1.5.0


```javascript
//在自定义view中，如果有界面元素需要刷新，那么就最好在dialog显示之后再操作
//例如:
let ui = $ui.layout("ui.xml");//解析一个视图
let dialog = $dialog.create();//创建一个对话框
dialog.showAfter(()=>{
    //如果自定义视图中存在需要操作的ui元素，可以放到这里操作
    let but = ui.id("mButtonClose");
    mButtonClose.click(()=>{
        dialog.close();//关闭对话框
    });
}).view(ui.getView()).show();//显示自定义视图
```


### onClose(callback)

> 监听对话框关闭

- 参数 : callback {()=>{}} 对话框关闭后回调
- 版本 : 1.8.0


```javascript
let alt = $dialog.create()
.title("标题")
.msg("我是信息")
.but3("关闭",()=>{
    //这里关闭对话框
    alt.close();
})
.onClose(()=>{
    log("对话框被关闭了");
})
.show();//显示对话框
```


### close()

> 关闭对话框


```javascript
//创建一个对话框
let dlg = $dialog.create()
.title("提示")
.msg("我是一个对话框")
.but1("关闭",()=>{
    dlg.close();//关闭对话框
})
.show();//显示对话框
```


# $tip - 阻塞式对话框

- 更新时间:2025-12-13 11:58:47

> 阻塞式对话框
> 
> 什么是阻塞式对话框？
> 
> 答：当对话框发起调用时，阻塞当前线程不向下执行代码，当对话框处理完事件之后，下面的代码才会执行。




### i(msg)

> [信息]对话框

- 参数 : msg {Object...} 信息内容
- 版本 : 1.0.0


```javascript
$tip.i("我是信息");
```


### v(msg)

> [说明]对话框

- 参数 : msg {Object...} 信息内容
- 版本 : 1.0.0


```javascript
$tip.v("我是信息");
```


### w(msg)

> [警告]对话框

- 参数 : msg {Object...} 信息内容
- 版本 : 1.0.0


```javascript
$tip.w("我是信息");
```


### e(msg)

> [异常]对话框

- 参数 : msg {Object...} 信息内容
- 版本 : 1.0.0


```javascript
$tip.e("我是信息");
```


### d(msg)

> [调试]对话框

- 参数 : msg {Object...} 信息内容
- 版本 : 1.0.0


```javascript
$tip.d("我是信息");
```


### input(title, callback)

> 输入对话框

- 参数 : title {string} 标题
- 参数 : callback {(value)=>{}} 确定按钮回调
- 版本 : 1.0.0


```javascript
$tip.input("请输入你的名字",(value)=> {
    toast("输入的内容:"+value);
});
```


### input(title, def, callback)

> 输入对话框(默认值)

- 参数 : title {string} 标题
- 参数 : def {string} 默认值
- 参数 : callback {(value)=>{}} 确定按钮回调
- 版本 : 1.0.0


```javascript
$tip.input("请输入你的名字","张三",(value)=> {
    toast("输入的内容:"+value);
});
```


### input(title, hint, def, callback)

> 输入对话框(默认值)

- 参数 : title {string} 标题
- 参数 : hint {string} 提示
- 参数 : def {string} 默认值
- 参数 : callback {(value)=>{}} 确定按钮回调
- 版本 : 1.0.0


```javascript
$tip.input("你是?","输入名字","张三",(value)=> {
    toast("输入的内容:"+value);
});
```


### inputInt(title, callback)

> 输入整数
> 
> 如果输入的字符串最后无法解析成数字则回调结果为0
> 
> 引导文字默认为标题
> 
> 默认值为0

- 参数 : title {string} 标题
- 参数 : callback {(num)=>{}} 结果回调


```javascript
$tip.inputInt("年龄",(num)=> {
    toast("刚满"+num+"岁~");
});
```


### inputInt(title, def, callback)

> 输入整数
> 
> 如果输入的字符串最后无法解析成数字则回调结果为0
> 
> 引导文字默认为标题

- 参数 : title {string} 标题
- 参数 : def {int} 默认值
- 参数 : callback {(num)=>{}} 结果回调


```javascript
$tip.inputInt("年龄",18,(num)=> {
    toast("刚满"+num+"岁~");
});
```


### inputInt(title, hint, callback)

> 输入整数
> 
> 如果输入的字符串最后无法解析成数字则回调结果为0
> 
> 默认值为0

- 参数 : title {string} 标题
- 参数 : hint {string} 引导文字
- 参数 : callback {(num)=>{}} 结果回调


```javascript
$tip.inputInt("年龄","请输入年龄:",(num)=> {
    toast("刚满"+num+"岁~");
});
```


### inputInt(title, hint, def, callback)

> 输入整数
> 
> 如果输入的字符串最后无法解析成数字则回调结果为0

- 参数 : title {string} 标题
- 参数 : hint {string} 引导文字
- 参数 : def {int} 默认值
- 参数 : callback {(num)=>{}} 结果回调


```javascript
$tip.inputInt("年龄","请输入你的年龄:",18,(num)=> {
    toast("刚满"+num+"岁~");
});
```


### show(title, msg)

> 文本提示对话框

- 参数 : title {string} 标题
- 参数 : msg {string} 信息
- 版本 : 1.0.0


```javascript
$tip.show("你好新人","我是你的AIGame助手");
```


### show(title, msg, click)

> 文本提示对话框(有回调)

- 参数 : title {string} 标题
- 参数 : msg {string} 信息
- 参数 : click {()=>{}} [确定]按钮回调
- 版本 : 1.0.0


```javascript
$tip.show("你好新人","我是你的AIGame助手",()=> {
    toast("你好!");
});
```


### show(title, view)

> 自定义对话框(右上角关闭)

- 参数 : title {string} 标题
- 参数 : view {View} 自定义view
- 版本 : 1.0.0


```javascript
//解析xml并且获得ui对象
let ui = $ui.layout("ag-app-example/$tip - 阻塞式对话框/01.自定义对话框/ui.xml");
//通过ui对象拿到View对象
let view = ui.getView();
//这种方式不会显示底部的按钮
$tip.show("自定义对话框", view);
```


### show(title, view, click)

> 自定义对话框(确定关闭)

- 参数 : title {string} 标题
- 参数 : view {View} 自定义view
- 参数 : click {()=>{}} 点击确定按钮的回调
- 版本 : 1.0.0


```javascript
//解析xml并且获得ui对象
let ui = $ui.layout("ag-app-example/$tip - 阻塞式对话框/01.自定义对话框/ui.xml");
//通过ui对象拿到View对象
let view = ui.getView();
//通过tip显示这个view
$tip.show("自定义对话框", view, ()=> {
    toast("保存成功");
});
```


### one(title, items, callback)

> 单选对话框

- 参数 : title {string} 标题
- 参数 : items {list[string]} 选项
- 参数 : callback {(value)=>{}} 选择回调
- 版本 : 1.0.0


```javascript
let arr = ["小狗","小猫","小猪"];
$tip.one("请选择",arr,(value)=> {
    toast("你选择了:"+value);
});
```


### more(title, items, callback)

> 多选对话框

- 参数 : title {string} 标题
- 参数 : items {list[string]} 选项
- 参数 : callback {(values)=>{}} 选择回调
- 版本 : 1.0.0


```javascript
let arr = ["小狗","小猫","小猪"];
$tip.more("请选择",arr,(values)=> {
    toast("你选择了:"+values);
});
```


### calendar(callback)

> 日期选择对话框

- 参数 : callback {(dateInfo)=>{}} 选择回调
- 版本 : 1.7.0


```javascript
//选择日期
$tip.calendar((info)=> {
    //此回调处于第三方线程
    let year = info.year; //年
    let month = info.month; //月
    let day = info.day; //日
    //显示日期
    alert("日期",year+"-"+month+"-"+day);
});
```


### date(callback)

> 滚轮方式选择日期

- 参数 : callback {(timeInfo)=>{}} 选择回调
- 版本 : 1.2.8


```javascript
//滚轮方式选择日期
$tip.date((info)=> {
    //此回调处于第三方线程
    let year = info.year; //年
    let month = info.month; //月
    let day = info.day; //日
    //显示日期
    alert("日期",year+"-"+month+"-"+day);
});
```


### clock(callback)

> 时间选择对话框

- 参数 : callback {(timeInfo)=>{}} 选择回调
- 版本 : 1.7.0


```javascript
//24小时制:时间选择对话框
$tip.clock((info)=> {
    //此回调处于第三方线程
    let hour = info.hour; //时
    let minute = info.minute; //分
    //显示时间
    alert("时间",hour+":"+minute);
});
```


### time(callback)

> 时间滚动选择对话框

- 参数 : callback {(timeInfo)=>{}} 选择回调
- 版本 : 1.2.8


```javascript
//24小时制:滚轮方式时间选择对话框
$tip.time((info)=> {
    //此回调处于第三方线程
    let hour = info.hour; //时
    let minute = info.minute; //分
    //显示时间
    alert("时间",hour+":"+minute);
});
```


# $touch - 触摸驱动

- 更新时间:2025-12-13 11:58:47

> 触摸驱动
> 
> 需要ROOT权限，部分手机不会与手指触摸冲突。




### hasPermit()

> 是否可用
> 
> 一般如果有root权限，就是可用的状态，本质上这个函数是用来判断设备是否有root权限的。这个函数性能很高，一旦初始化成功了，就会直接返回true，并不会每次都检查root权限。

- 返回 : {boolean} 是否可用
- 版本 : 1.5.2


```javascript
//初始化
if($touch.hasPermit()){
    $touch.init();
}
//之后再操作，否则无效果
```


### init()

> 初始化
> 
> $touch需要初始化才可以使用，初始化大概需要5秒时间，但如果已经初始化过了，就会直接返回true。

- 返回 : {boolean} 是否已经初始化成功


```javascript
//开始初始化
$touch.init();
```


### touchDown(fingerId, x, y)

> 按下手指

- 参数 : fingerId {int} 手指ID 
- 参数 : x {int}  坐标X 
- 参数 : y {int}  坐标Y 
- 版本 : 1.5.2


```javascript
$touch.touchDown(1, 100, 100);
```


### touchMove(fingerId, x, y)

> 移动手指

- 参数 : fingerId {int} 手指ID 
- 参数 : x {int}  坐标X 
- 参数 : y {int}  坐标Y 
- 版本 : 1.5.2


```javascript
$touch.touchMove(1, 300, 500);
```


### touchUp(fingerId)

> 抬起手指

- 参数 : fingerId {int} 手指ID 
- 版本 : 1.5.2


```javascript
$touch.touchUp(1);
```


### click(x, y)

> 点击
> 
> 原理是在C/C++层执行系统命令进行事件注入，因此效率较高

- 参数 : x {int} 坐标X 
- 参数 : y {int} 坐标Y 
- 版本 : 1.5.4


```javascript
$touch.click(300, 500);
```


### click(pointerId, x, y)

> 点击
> 
> 默认按压时长为1毫秒，该函数的本质是touchDown和touchUp的组合，因此效率较慢

- 参数 : pointerId {int} 指针ID 
- 参数 : x {int}  坐标X 
- 参数 : y {int}  坐标Y 
- 版本 : 1.5.2


```javascript
$touch.click(1, 300, 500);
```


### click(pointerId, x, y, dur)

> 点击
> 
> 原理是touchDown和touchUp的组合

- 参数 : pointerId {int} 指针ID 
- 参数 : x {int}  坐标X 
- 参数 : y {int}  坐标Y 
- 参数 : dur {int}  按压时长 
- 版本 : 1.5.2


```javascript
$touch.click(1, 300, 500, 50);
```


### press(x, y)

> 长按
> 
> 原理是touchDown和touchUp的组合，默认按压时间是750毫秒

- 参数 : x {int}  坐标X 
- 参数 : y {int}  坐标Y 
- 版本 : 1.5.2


```javascript
$touch.press(300, 500);
```


### press(pointerId, x, y)

> 长按
> 
> 原理是touchDown和touchUp的组合，默认按压时间是750毫秒

- 参数 : pointerId {int} 指针ID 
- 参数 : x {int}  坐标X 
- 参数 : y {int}  坐标Y 
- 版本 : 1.5.2


```javascript
$touch.press(1, 300, 500);
```


### press(pointerId, x, y, dur)

> 长按
> 
> 原理是touchDown和touchUp的组合

- 参数 : pointerId {int} 指针ID 
- 参数 : x {int}  坐标X 
- 参数 : y {int}  坐标Y 
- 参数 : dur {int}  长按时间 
- 版本 : 1.5.2


```javascript
$touch.press(1, 300, 500, 2000);
```


### move(x, y, x2, y2)

> 滑动
> 
> 默认的滑动时间是1秒

- 参数 : x {int}  起点X 
- 参数 : y {int}  起点Y 
- 参数 : x2 {int}  终点X 
- 参数 : y2 {int}  终点Y 
- 版本 : 1.5.2


```javascript
$touch.move(100, 100, 300, 500);
```


### move(x, y, x2, y2, dur)

> 滑动

- 参数 : x {int}  起点X 
- 参数 : y {int}  起点Y 
- 参数 : x2 {int}  终点X 
- 参数 : y2 {int}  终点Y 
- 参数 : dur {int}  移动时间 
- 版本 : 1.5.2


```javascript
$touch.move(100, 100, 300, 500, 1000);
```


### move(pointerId, x, y, x2, y2, dur)

> 滑动
> 
> 滑动的时间是根据CPU数量来进行计算的，因此并不一定就完全准确，不同手机执行的滑动时间可能有一点误差，但这并没有太大影响。

- 参数 : pointerId {int} 指针ID 
- 参数 : x {int}  起点X 
- 参数 : y {int}  起点Y 
- 参数 : x2 {int}  终点X 
- 参数 : y2 {int}  终点Y 
- 参数 : dur {int}  移动时间 
- 版本 : 1.5.2


```javascript
$touch.move(1, 100, 100, 300, 500, 1000);
```


### swipe(x, y, x2, y2, dur)

> 模拟滑动
> 
> 原理是C/C++层系统调用命令来实现注入滑动

- 参数 : x {int} 起点X 
- 参数 : y {int}  起点Y 
- 参数 : x2 {int} 终点X 
- 参数 : y2 {int} 终点Y 
- 参数 : dur {int} 滑动时间 
- 版本 : 1.5.4


```javascript
$touch.swipe(100,200,600,1200,2000);
```


### key(keyCode)

> 模拟按键
> 
> 原理是C/C++层系统调用命令来实现注入按键事件

- 参数 : keyCode {int} 键值 
- 版本 : 1.5.4


```javascript
$touch.key(4);//返回按钮
```


# TtsOptions - 语音配置

- 更新时间:2025-12-13 11:58:47

> TtsOptions - 语音配置




### const {float} rate;

> 播放倍速


### const {float} pitch;

> 音调


### const {float} volume;

> 音量


### const {String} language;

> 语言
> 
> 可选值有：zh,en,fr,de,it,ja,ko
> 
> 分别意思：中文,英文,法文,德文,意大利文,日文,韩文


### const {String} streamType;

> 播放流类型
> 
> 可选值有：alarm,music,notification,ring,system,call,dtmf
> 
> 分别意思：闹钟,音乐,通知,铃声,系统,通话,DTMF


# $tts - 语音阅读

- 更新时间:2025-12-13 11:58:47

> 语音阅读




### read(text, options)

> 播放文本(配置)
> 
> 对于没有TTS引擎的设备而言，此函数执行后无任何效果

- 参数 : text {string} 文本
- 参数 : options {TtsOptions} 配置
- 版本 : 1.0.0


```javascript
let options = {
    rate: 1,//速度
    pitch: 1,//音调
    volume: 1,//音量
    language: "zh",//语言
    streamType: "system"//播放流('system'播放声音最大)
}
$tts.read("你好呀，早安~",options);
```


### read(text)

> 播放文本
> 
> 对于没有TTS引擎的设备而言，此函数执行后无任何效果

- 参数 : text {string} 文本
- 版本 : 1.0.0


```javascript
$tts.read("你好呀，早安~");
```


# Ws - WS封装对象

- 更新时间:2025-12-13 11:58:47

> 双工通信包装对象
> 
> 对okhttp3.WebSocket对象进行封装的对象




### send(msg)

> 发送字符消息

- 参数 : msg {string} 字符串消息


```javascript
//创建ws对象
let ws = $ws.create("wss://echo.websocket.org");
//发送字符消息
ws.send("hello");
```


### send(bytes)

> 发送字节消息

- 参数 : bytes {byte[]} 字节消息


```javascript
//创建ws对象
let ws = $ws.create("wss://echo.websocket.org");
//发送字节消息
ws.send([10,15,0,1,20]);
```


### send(byteString)

> 发送消息
> 
> ByteString类型是okhttp提供的一种数据类型，具体函数可以参考okhttp文档

- 参数 : byteString {ByteString} byteString对象消息


```javascript
//创建ws对象
let ws = $ws.create("wss://echo.websocket.org");
let byteString = okio.ByteString.encodeUtf8("字符串");
//发送消息
ws.send(byteString);
```


### sendBase64(base64Str)

> 发送base64消息

- 参数 : base64Str {string} base64 字符串


```javascript
//创建ws对象
let ws = $ws.create("wss://echo.websocket.org");
//发送base64消息
ws.sendBase64("QXV0by5qcyBQcm8geXlkcw==");
```


### sendHex(hexStr)

> 发送16进制消息

- 参数 : hexStr {string} 16 进制字符串


```javascript
//创建ws对象
let ws = $ws.create("wss://echo.websocket.org");
//发送16进制消息
ws.sendHex("621172314F60");
```


### cancel()

> 关闭
> 
> 效果和 'stop()' 相同


```javascript
//创建ws对象
let ws = $ws.create("wss://echo.websocket.org");
//立即关闭
ws.cancel();
```


### stop()

> 关闭
> 
> 效果和 'cancel()' 相同


```javascript
//创建ws对象
let ws = $ws.create("wss://echo.websocket.org");
//立即关闭
ws.stop();
```


### close()

> 关闭
> 
> 效果和 stop(),cancel() 相同


```javascript
//创建ws对象
let ws = $ws.create("wss://echo.websocket.org");
//立即关闭
ws.close();
```


### close(code)

> 尝试正常关闭

- 参数 : code {number} 关闭码


```javascript
//创建ws对象
let ws = $ws.create("wss://echo.websocket.org");
//尝试正常关闭(正常关闭退出码一般是1001)
ws.close(1001);
```


### close(code, reason)

> 尝试正常关闭

- 参数 : code {number} 关闭码
- 参数 : reason {string} 关闭原因


```javascript
//创建ws对象
let ws = $ws.create("wss://echo.websocket.org");
//尝试正常关闭(正常关闭退出码一般是1001)
ws.close(1001,"close");
```


### onMsgByte(callback)

> 设置字节字符信息接受回调
> 
> 如果不设置，则使用默认的回调：打印字节数组

- 参数 : callback {(byteString)=>{}}
- 返回 : {Ws} 返回当前对象


```javascript
//创建ws对象
let ws = $ws.create("wss://echo.websocket.org");
//发送消息
ws.onMsgByte((bs)=> {
    //参数说明：
    // bs: okio.ByteString (参考okhttp3文档)
    //接收到字节数据时回调
    console.log("收到二进制消息：大小 ", bs.size());
    console.log("hex: ", bs.hex());
    console.log("base64: ", bs.base64());
    console.log("md5: ", bs.md5());
    console.log("bytes: ", bs.toByteArray());
});
```


### onMsgStr(callback)

> 设置字符串信息接受回调
> 
> 如果不设置，则使用默认的回调：打印字符串

- 参数 : callback {(str)=>{}}
- 返回 : {Ws} 返回当前对象


```javascript
//创建ws对象
let ws = $ws.create("wss://echo.websocket.org");
//设置字符串信息接受回调
ws.onMsgStr((str, ws)=> {
    //参数说明：
    // str: String 字符串数据
    // ws: okhttp3.WebSocket (参考okhttp3文档)
    //接收到字符串信息时回调
    console.log("收到字符串：",str);
});
```


### onOpen(callback)

> 设置连接成功回调
> 
> 如果不设置，则使用默认的回调：打印连接信息

- 参数 : callback {(res,ws)=>{}} 回调
- 返回 : {Ws} 返回当前对象


```javascript
//创建ws对象
let ws = $ws.create("wss://echo.websocket.org");
//设置连接成功回调
ws.onOpen((res,ws)=> {
    //参数说明：
    // res: okhttp3.Response (参考okhttp3文档)
    // ws: okhttp3.WebSocket (参考okhttp3文档)
    console.log("链接成功");
});
```


### onClosed(callback)

> 设置连接关闭回调
> 
> 如果不设置，则使用默认的回调：打印关闭信息

- 参数 : callback {(code,reason,ws)=>{}} 回调
- 返回 : {Ws} 返回当前对象


```javascript
//创建ws对象
let ws = $ws.create("wss://echo.websocket.org");
//设置连接关闭回调
ws.onClosed((code,reason,ws)=>{
    //参数说明：
    // code:   int    数字
    // reason: String 字符串
    // ws: okhttp3.WebSocket (参考okhttp3文档)
    console.log("正在关闭");
});
```


### onClosing(callback)

> 设置连接关闭中回调
> 
> 如果不设置，则使用默认的回调：打印关闭信息

- 参数 : callback {(code,reason,ws)=>{}} 回调
- 返回 : {Ws} 返回当前对象


```javascript
//创建ws对象
let ws = $ws.create("wss://echo.websocket.org");
//设置连接关闭中回调
ws.onClosing((code,reason,ws)=>{
    //参数说明：
    // code:   int    数字
    // reason: String 字符串
    // ws: okhttp3.WebSocket (参考okhttp3文档)
    console.log("正在关闭");
});
```


### onFail(onFailure)

> 设置连接失败回调
> 
> 如果不设置，则使用默认的回调：打印错误信息

- 参数 : onFailure {(err,res,ws)=>{}} 回调
- 返回 : {Ws} 返回当前对象


```javascript
//创建ws对象
let ws = $ws.create("wss://echo.websocket.org");
//设置连接失败回调
ws.onFail((err,res,ws)=>{
    //参数说明：
    // err: Throwable
    // res: okhttp3.Response (参考okhttp3文档)
    // ws: okhttp3.WebSocket (参考okhttp3文档)
    //打印错误信息
    console.log("出现异常",err);
});
```


# $ws - 双工通信:WebSocket

- 更新时间:2025-12-13 11:58:47

> WebSocket工具
> 
> 让客户端和服务器之间建立一条"热线电话"，双方可以随时说话(通信)，不用像以前那样每次都要重新拨号(不用重新建立连接)。




### create(url)

> 创建一个 WebSocket

- 参数 : url {string} 例如:ws://127.0.0.1:8080
- 返回 : Ws


```javascript
//返回的ws是经过封装的WebSocket对象(不是okhttp3.WebSocket原生对象)
let ws = $ws.create("wss://echo.websocket.org");
//设置监听
ws.onOpen((res,ws)=> {
    //当成功连接时回调(此函数可以不用设置，拥有默认回调:打印信息)
    console.log("链接成功");
    //参数说明：
    // res: okhttp3.Response (参考okhttp3文档)
    // ws: okhttp3.WebSocket (参考okhttp3文档)
})
.onClosed((code,reason,ws)=> {
    //当关闭后回调(此函数可以不用设置，拥有默认回调:打印信息)
    console.log("关闭成功");
    //参数说明：
    // code:   int    数字
    // reason: String 字符串
    // ws: okhttp3.WebSocket (参考okhttp3文档)
})
.onClosing((code,reason,ws)=> {
    //处于关闭时回调(此函数可以不用设置，拥有默认回调:打印信息)
    console.log("正在关闭");
    //参数说明：
    // code:   int    数字
    // reason: String 字符串
    // ws: okhttp3.WebSocket (参考okhttp3文档)
})
.onFail((err,res,ws)=> {
    //出现异常时回调(此函数可以不用设置，拥有默认回调:打印信息)
    console.log("出现异常",err);
    //参数说明：
    // err: Throwable
    // res: okhttp3.Response (参考okhttp3文档)
    // ws: okhttp3.WebSocket (参考okhttp3文档)
})
.onMsgStr((str, ws)=> {
    //接收到字符串信息时回调
    console.log("收到字符串：",str);
    //参数说明：
    // str: String 字符串数据
    // ws: okhttp3.WebSocket (参考okhttp3文档)
})
.onMsgByte((bs)=> {
    //接收到字节数据时回调
    console.log("收到二进制消息：大小 ", bs.size());
    console.log("hex: ", bs.hex());
    console.log("base64: ", bs.base64());
    console.log("md5: ", bs.md5());
    console.log("bytes: ", bs.toByteArray());
    //参数说明：
    // bs: okio.ByteString (参考okhttp3文档)
});
//发送字符串消息
ws.send("Hello AIGame!");
//发送二进制消息
//ws.send([10,15,1,1,0,5]);
```


# 训练模型-环境搭建

- 更新时间:2025-12-13 11:58:47

> 训练模型-环境搭建
> 
> 这个教程是适合小白的教程，但是你需要具备如下基础：会下载文件、会安装软件、会打字、会点按钮、会执行命令。




## 下载Python

下载python3.12.0 https://www.python.org/downloads/release/python-3120/

注意：不要下载最新版本，我规定下载这个版本当然是有说法的，不然后面安装依赖的时候报错别怪我。打开连接之后网页滑动到最后，找到适合自己电脑的版本下载安装即可，随便你安装到哪都行，但是你要知道自己安装的路径在哪，后面会用到。
这是专门用来执行python代码的。

[点击前往下载](https://www.python.org/downloads/release/python-3120/)

![](../img/395994874847000.png)


## 打开命令窗口执行一堆命令

当我们安装完python之后，需要安装一堆依赖，不过不用紧张，这个教程是给小白看的，你不需要有编程基础，会用电脑就行。

首先按住电脑快捷键Win+R，看到一个窗口输入"cmd"后回车就能打开黑窗口了。

![](../img/396597681211100.png)


当python安装完之后，打卡cmd黑色窗口直接按照寻徐运行下面的命令：(你不需要担心网速问题，这些命令用的都是国内的仓库地址，速度都很快)

注意：一定要只在一个黑色窗口中依次运行，不要为了方便开多个黑窗口执行命令，否则可能会造成pip安装工具冲突，严重点会损坏pip组件。

下面的命令是训练yolo模型需要的依赖
```bash
pip install -i https://pypi.tuna.tsinghua.edu.cn/simple/ torch torchvision torchaudio
pip install -i https://pypi.tuna.tsinghua.edu.cn/simple/ ultralytics
pip install -i https://pypi.tuna.tsinghua.edu.cn/simple/ PyYAML
pip install -i https://pypi.tuna.tsinghua.edu.cn/simple/ matplotlib
pip install -i https://pypi.tuna.tsinghua.edu.cn/simple/ polars
pip install -i https://pypi.tuna.tsinghua.edu.cn/simple/ scipy
```

下面的命令是将pt模型转换为onnx模型需要的依赖
```bash
pip install onnx==1.16.0 -i https://pypi.tuna.tsinghua.edu.cn/simple
pip install onnxruntime==1.22.0 -i https://pypi.tuna.tsinghua.edu.cn/simple
pip install onnxscript==0.5.7.dev20251113 -i https://pypi.tuna.tsinghua.edu.cn/simple/
pip install onnxslim==0.1.74 -i https://pypi.tuna.tsinghua.edu.cn/simple
```

下面的命令是将onnx模型转换为ncnn模型需要的依赖
```bash
pip install pnnx -i https://pypi.tuna.tsinghua.edu.cn/simple
```

我在安装onnxslim的时候遇到路径长度限制，解决方法：电脑下面搜索 power 就能看到 "Windows PowerShell"

以管理员身份打开PowerShell 执行命令：
```bash
New-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Control\FileSystem" -Name "LongPathsEnabled"
-Value 1 -PropertyType DWORD -Force
```


## 下载PyCharm

下载PyCharm: https://www.jetbrains.com/pycharm/download/?section=windows

下载最新版就行，随便安装在什么位置。这个工具是帮助我们运行python代码的，不过不用担心，我都把代码写好了，你只需要会配置、会点运行按钮即可。

[点击前往下载](https://www.jetbrains.com/pycharm/download/?section=windows)

![](../img/396328945123500.png)


# 输入输出层名称对照表

- 更新时间:2025-12-13 11:58:47

> 输入输出层名称对照表
> 
> 使用任何模型之前，确保param文件的输入层名称和输出层名称一致。




## 输入输出层名称对照表

在onnx转换为ncnn模型文件的时候，如果导出的param文件中输入输出层对应不上，则会出现闪退。为此，我将源码中的输入输出层罗列出来，方便开发者们对照各个版本的输入输出层名称来调整模型转换参数。

| 版本  | input  | output         | 尺寸      |
|-----|--------|----------------|---------|
| V5  | images | output、数字、数字   | 320x320 |
| V6  | images | output         | 640x640 |
| V7  | in0    | out0、out1、out2 | 640x640 |
| V8  | images | output         | 640x640 |
| V9  | images | output0        | 640x640 |
| V10 | in0    | out0、out1、out2 | 640x640 |
| V11 | in0    | out0、out1、out2 | 640x640 |
| V12 | in0    | out0           | 640x640 |
| V13 | in0    | out0           | 640x640 |

YoloV5版本后面输出层的两个"数字"需要看param文件的末尾"Permute"开头的行

例如:

```bash
Permute                  Transpose_590            1 1 780 781 0=1
Convolution              Conv_591                 1 1 741 782 0=255 1=1 5=1 6=130560
Reshape                  Reshape_605              1 1 782 800 0=-1 1=85 2=3
Permute                  Transpose_606            1 1 800 801 0=1
```

两个Permute行的输出层分别是：781、801 (需要你自己找找看，有一定规律，一般在"0=1"这个字段前一个，或者 1 1
800 801 这里的801就是第三个输出层名称)

那么在脚本开发的过程中如何设置yolo的输入输出层的名称呢？仔细观察输入输出层名称对照表，可以发现输入层的名称是固定的，只有一个，而输出层的名称要么是一个，要么就是三个，因此我提供了三个函数用来配置：

```javascript
$yolo.v(5);//指定版本之后才能调用，不然我不知道你要对哪个版本的yolo进行配置
$yolo.input("");//输入层只有一个名称
//输出层
$yolo.output("");//适用于yolo6、8、9(参看对照表)
$yolo.output("", "", "");//适用于yolo5、7、10、11(参看对照表)
//当你指定完输入输出层名称之后再加载模型，模型加载的时候会使用你指定的输入输出层名称
$yolo.init("demo.bin","demo.params","labels.txt");
```

其实将pt或者onnx转为ncnn模型有狠多坑要踩，为了减少一些乱七八糟的坑，我提供了输入输出层名称对照表，方便开发者们配置。


## 默认参数对照表

使用'$yolo.config()'即可配置参数，设计这个函数的主要作用是用来调优的，如果不配置则使用默认配置数据。

```js
//首先指定版本,若不指定版本，默认使用Yolo V8
$yolo.v(5);//指定使用的yolo版本为:Yolo V5
//为Yolo V5设置配置参数
$yolo.config(targetSize, meanVals, normVals, useGpu, probThreshold, nmsThreshold);
```

参数说明：不需要配置的参数填null即可

- targetSize {int} : 期望的输入图像边长（通常为正方形），例如 640 表示 640×640 像素。图像会被缩放至该尺寸后输入网络
- meanVals {float[3]} : 图像通道归一化的均值，格式为[B_mean, G_mean, R_mean] 元素范围:(0-255)
- normVals {float[3]} : 图像通道归一化的标准差，格式为[B_std, G_std, R_std] 元素范围:(0.001-0.1)
- useGpu {boolean} : 是否使用 GPU 加速
- probThreshold {float} : 过滤低置信度预测框的阈值，范围[0,1]
- nmsThreshold {float} : 抑制重叠检测框的阈值，范围[0,1]

但是我在开发yolo系列的时候，发现有些版本对于配置参数的支持也是不一样的，所以我在C/C++中尽可能的完善了所有yolo的配置参数，
不过呢还是存在无法完成的配置参数，具体的配置支持度如下：

打`Y`的表示支持配置此参数,打`N`表示不支持此参数,如果配置了这个参数也不会生效。

| 版本        | targetSize | meanVals     | normVals                          | useGpu | probThreshold | nmsThreshold |
|-----------|------------|--------------|-----------------------------------|--------|---------------|--------------|
| V5        | Y          | Y            | Y                                 | Y      | Y             | Y            |
| V6        | Y          | Y            | Y                                 | Y      | Y             | Y            |
| V7        | Y          | Y            | Y                                 | Y      | Y             | Y            |
| V8        | Y          | Y            | Y                                 | Y      | Y             | Y            |
| V9        | Y          | Y            | Y                                 | Y      | Y             | Y            |
| V10       | Y          | Y            | Y                                 | Y      | Y             | N            |
| V11       | Y          | Y            | Y                                 | Y      | Y             | Y            |
| V12       | Y          | Y            | Y                                 | Y      | Y             | Y            |
| V13       | Y          | Y            | Y                                 | Y      | Y             | Y            |
| VX        | Y          | Y            | Y                                 | Y      | Y             | Y            |
| AIGame默认值 | 640        | [0f, 0f, 0f] | [1 / 255.f, 1 / 255.f, 1 / 255.f] | false  | 0.25          | 0.45         |

总的来说，除了YoloV10不支持NMS阈值配置外，其他版本都支持全部配置。


## 如何查看输出层名称

让我们来学习几个param文件是如何查看输出层名称的吧：

在yolo5的param文件后面几行可以在0=1的地方看到781、801这样的名称作为输出层名称，所以yolo5的坑是最隐蔽的，很多人训练完模型后，高高兴兴的用移动端部署运行模型，结果闪退报错等等。

```bash
Permute                  Transpose_590            1 1 780 781 0=1
Convolution              Conv_591                 1 1 741 782 0=255 1=1 5=1 6=130560
Reshape                  Reshape_605              1 1 782 800 0=-1 1=85 2=3
Permute                  Transpose_606            1 1 800 801 0=1
```

![](../img/407162455999700.png)


在yolo8的param文件中可以找到最后一行看到output这样的输出层名称

```bash
Reshape                  Reshape_287              1 1 405 434 0=-1 1=144
Reshape                  Reshape_288              1 1 420 441 0=-1 1=144
Concat                   Concat_289               3 1 427 434 441 442 0=1
Permute                  Transpose_526            1 1 442 output 0=1
```

![](../img/407224323928300.png)


在yolo11的param文件中：可以看见out0、out1、out2这样的输出层名称

```bash
Permute                  permute_171              1 1 300 301 0=3
Concat                   cat_19                   2 1 291 301 out2 0=2
```

![](../img/407372540692700.png)


# 结果排序规则表

- 更新时间:2025-12-13 11:58:47

> 结果排序规则表




## YOLO识别结果排序规则表

| 参数     | 排序方向/规则    | 描述                           |
|--------|------------|------------------------------|
| -1     | 不排序（默认）    | 不对识别结果集进行任何排序操作（追求效率可选）      |
| 1      | 从左到右       | 按矩形框的x坐标升序排列（x越小，越靠左，排在前面）   |
| 2      | 从右到左       | 按矩形框的x坐标降序排列（x越大，越靠右，排在前面）   |
| 3      | 从上到下       | 按矩形框的y坐标升序排列（y越小，越靠上，排在前面）   |
| 4      | 从下到上       | 按矩形框的y坐标降序排列（y越大，越靠下，排在前面）   |
| 5      | 从左上到右下     | 按矩形框x+y的和升序排列（左上区域值更小，排在前面）  |
| 6      | 从右上到左下     | 按矩形框x-y的差降序排列（右上区域差值更大，排在前面） |
| 7      | 从左下到右上     | 按矩形框x-y的差升序排列（左下区域差值更小，排在前面） |
| 8      | 从右下到左上     | 按矩形框x+y的和降序排列（右下区域值更大，排在前面）  |
| 9      | 从左到右并且从上到下 | 优先按x坐标升序，x相同时按y坐标升序          |
| 10     | 从右到左并且从上到下 | 优先按x坐标降序，x相同时按y坐标升序          |
| 11     | 从左到右并且从下到上 | 优先按x坐标升序，x相同时按y坐标降序          |
| 12     | 从右到左并且从下到上 | 优先按x坐标降序，x相同时按y坐标降序          |
| 13     | 大的面积在前面    | 按矩形框面积降序排列（面积越大，排在前面）        |
| 14     | 小的面积在前面    | 按矩形框面积升序排列（面积越小，排在前面）        |
| 其他（默认） | 从左到右（默认规则） | 按矩形框的x坐标升序排列（与编码1的规则一致）      |


## 具体应用

例如现在我有一个数据集，我主要用来识别数字和一个逗号字符串，我的数据集大多数都是205x30的图片，你觉得我应该用什么样的尺寸比较合适？用什么样的排序规则比较合适？

![](../img/3811231098900.png)

首先我们要知道：yolo输入的图片尺寸必须是32的倍数，我们的图片是高度为30的，因此使用32来作为模型的输入高度，宽度是205，我们找到最近的32的倍数，就是192，因此输入的尺寸就定好了：192x32



```python
//训练模型的py代码 ：
from ultralytics import YOLO
if __name__ == '__main__':
    model = YOLO(r"yolo11n.pt")  # 指定权重 (项目/yolo11n.pt)
    model.train(
        data=r"hydd2.yaml",  # 指定你的数据集配置文件 (项目/ultralytics/cfg/datasets/cm.yaml)
        epochs=50,  # 定义训练的总轮数
        imgsz=[32, 192],  # 指定输入图片的尺寸[高度,宽度]
        batch=2,  # 定义批次大小 每次同时向模型喂送 2 张图片进行处理
        cache=False,  # 不用缓存 避免内存溢出 （如果电脑内存大、可以开启，因为速度会快一点）
        workers=4,  # 指定数据加载时使用的 CPU 线程数 推荐：0、4、8 都是可以的
    )
```



```python
# 导出为ONNX格式（高在前、宽在后）
model.export(format='onnx', imgsz=[32, 192])
```


最终把onnx转为ncnn模型时的参数：高在前、宽在后


```bash
pnnx best.onnx inputshape=[1,3,32,192]f32 device=cpu
```


接下来确定排序方向，由于我制作的是文字识别，排序方向当然就是从左到右的，因此代码这么写：


```javascript
let yolo = $yolo.create(12);
yolo.setSize(192,32);//先宽、后高
yolo.setDir(1);//识别结果按照从左到右排序
//开始加载模型
yolo.init("res/ocr.bin","res/ocr.param",["0","1","2","3","4","5","6","7","8","9",","]);
```


# YoloObject - 目标检测对象

- 更新时间:2025-12-13 11:58:47

> Yolo对象




### init(binPath, paramPath, labelPath)

> 初始化

- 参数 : binPath {string} 模型文件路径
- 参数 : paramPath {string} 参数文件路径
- 参数 : labelPath {string} 标签文件路径
- 返回 : {YoloResult} 结果
- 版本 : 1.8.3


```javascript
let yolo = $yolo.create(12);
yolo.init("res/yolov5s.bin", "res/yolov5s.param", "res/classes.txt")
```


### init(binPath, paramPath, labels)

> 初始化

- 参数 : binPath {string} 模型文件路径
- 参数 : paramPath {string} 参数文件路径
- 参数 : labels {string[]} 标签
- 返回 : {YoloResult} 结果
- 版本 : 1.8.3


```javascript
let yolo = $yolo.create(12);
yolo.init("res/yolov5s.bin", "res/yolov5s.param", ["人","鸟","自行车"])
```


### detect()

> 检测屏幕
> 
> 需要截屏权限

- 返回 : {YoloResult} 结果
- 版本 : 1.8.3


```javascript
let yolo = $yolo.create(12);
yolo.init("res/yolov5s.bin", "res/yolov5s.param", "res/classes.txt");
let res = yolo.detect();
log("检测结果",res);
```


### detect(img)

> 检测图片

- 参数 : img {Image} 图片
- 返回 : {YoloResult} 结果
- 版本 : 1.8.3


```javascript
let yolo = $yolo.create(12);
yolo.init("res/yolov5s.bin", "res/yolov5s.param", "res/classes.txt");
let img = $img.read("res/t01.png");
let res = yolo.detect(img);
log("检测结果",res);
```


### detect(bitmap)

> 检测位图

- 参数 : bitmap {Bitmap} 位图
- 返回 : {YoloResult} 结果
- 版本 : 1.8.3


```javascript
let yolo = $yolo.create(12);
yolo.init("res/yolov5s.bin", "res/yolov5s.param", "res/classes.txt");
let img = $img.read("res/t01.png");
let res = yolo.detect(img.getBitmap());
log("检测结果",res);
```


### detect(imgPath)

> 检测路径中的图片

- 参数 : imgPath {string} 图片路径
- 返回 : {YoloResult} 结果
- 版本 : 1.8.3


```javascript
let yolo = $yolo.create(12);
yolo.init("res/yolov5s.bin", "res/yolov5s.param", "res/classes.txt");
let res = yolo.detect("res/test.jpg");
```


### isInit()

> 是否初始化
> 
> 只有成功加载模型之后才会返回true

- 返回 : {boolean} 是否初始化了
- 版本 : 1.8.3


```javascript
let yolo = $yolo.create(12);
yolo.init("res/yolov5s.bin", "res/yolov5s.param", "res/classes.txt");
if(yolo.isInit()) {
    log("初始化成功");
}
```


### setDir(dir)

> 设置排序方向
> 
> 排序方向一共有15种，默认是不排序，具体排序顺序请参考：结果排序规则表

- 参数 : dir {int} 排序方向(默认:-1)
- 版本 : 1.8.3


```javascript
let yolo = $yolo.create(12);
yolo.setDir(-1);//如果不需要排序就不排序，以免影响速度
```


### setSize(w, h)

> 设置输入尺寸

- 参数 : w {int} 宽
- 参数 : h {int} 高
- 版本 : 1.8.3


```javascript
let yolo = $yolo.create(12);
yolo.setSize(640,640);
```


### setUseGpu(use)

> 设置是否使用GPU

- 参数 : use {boolean} 是否使用GPU
- 版本 : 1.8.3


```javascript
let yolo = $yolo.create(12);
yolo.setUseGpu(true);
```


### setProbThreshold(pt)

> 设置相似度阈值

- 参数 : pt {float} 相似度阈值
- 版本 : 1.8.3


```javascript
let yolo = $yolo.create(12);
yolo.setProbThreshold(0.5f);
```


### setNmsThreshold(nt)

> 设置抑制阈值

- 参数 : nt {float} 抑制阈值
- 版本 : 1.8.3


```javascript
let yolo = $yolo.create(12);
yolo.setNmsThreshold(0.5f);
```


### setMeanVals(meanVals)

> 设置均值

- 参数 : meanVals {float[]} 均值
- 版本 : 1.8.3


```javascript
let yolo = $yolo.create(12);
yolo.setMeanVals([0.485f, 0.456f, 0.406]);
```


### setNormVals(normVals)

> 设置归一化

- 参数 : normVals {float[]} 归一化
- 版本 : 1.8.3


```javascript
let yolo = $yolo.create(12);
yolo.setNormVals([0.00392157f, 0.00392157f, 0.00392157f]);
```


### setInputName(inputName)

> 设置输入层名称
> 
> 输入层一般只有一个

- 参数 : inputName {string} 输入层名称
- 版本 : 1.8.3


```javascript
let yolo = $yolo.create(12);
yolo.setInputName("images");
```


### setOutputName(outputName1)

> 设置输出层名称
> 
> 有些版本的模型输出层可能有多个，当模型输出层只有一个的时候可以使用这个函数。

- 参数 : outputName1 {string} 输出层名称1
- 版本 : 1.8.3


```javascript
let yolo = $yolo.create(12);
yolo.setOutputName("output1");
```


### setOutputName(outputName1, outputName2, outputName3)

> 设置输出层名称
> 
> 有些版本的模型有多个输出层，但是有些输出层只有一个，即便你设置了三个，也只会生效第一个。

- 参数 : outputName1 {string} 输出层名称1
- 参数 : outputName2 {string} 输出层名称2
- 参数 : outputName3 {string} 输出层名称3
- 版本 : 1.8.3


```javascript
let yolo = $yolo.create(12);
yolo.setOutputName("output1", "output2", "output3");
```


### getId()

> 获取id

- 返回 : {String} id
- 版本 : 1.8.3


```javascript
let yolo = $yolo.create(12);
log(yolo.getId());
```


### recycle()

> 释放资源
> 
> 释放资源，效果和 'close()' 等价

- 版本 : 1.8.3


```javascript
let yolo = $yolo.create(12);
yolo.recycle();
```


### close()

> 关闭
> 
> 释放资源，效果和 'recycle()' 等价

- 版本 : 1.8.3


```javascript
let yolo = $yolo.create(12);
yolo.close();
```


# $yolo - 目标检测

- 更新时间:2025-12-13 11:58:47

> 目标检测
> 
> $yolo支持全系列的yolo版本：yoloV5、yoloV6、yoloV7、yoloV8、yoloV9、yoloV10、yoloV11、yoloV12、yoloV13；




### create(version)

> 创建yolo对象
> 
> 当前支持的Yolo版本有：YoloX、YoloV5、YoloV6、YoloV7、YoloV8、YoloV9、YoloV10、YoloV11、YoloV12、YoloV13，
> 当你传入版本号为0，则创建一个YoloX对象；当你传入版本号为5，则创建一个YoloV5对象；为11，则创建一个YoloV11对象，以此类推。
> 
> 每当创建一个yolo对象的时候，我会存储一个键值对[yoloId,yolo对象]，因此你可以在任何脚本中通过这个id拿到对象。

- 参数 : version {int} yolo版本
- 返回 : {YoloObject} yolo对象
- 版本 : 1.8.3


```javascript
//首选创建一个对象
let yolo12 = $yolo.create(12);
//接下来就可以设置一些基础配置了
//使用gpu这个配置必须在初始化之前调用才能生效，其他的配置可以在任何地方调用
yolo12.setUseGpu(true);//是否使用GPU加速
yolo12.setSize(192,64);//注意尺寸必须是32的倍数
yolo12.setProbThreshold(0.5);//设置相似度
```


### has(id)

> 是否有yolo对象

- 参数 : id {string} yoloID
- 返回 : {boolean} 是否有
- 版本 : 1.8.3


```javascript
let yolo = $yolo.create(12);
log($yolo.has(yolo.getId()));//true
```


### get(id)

> 获取yolo对象

- 参数 : id {string} yoloID
- 返回 : {YoloObject} yolo对象
- 版本 : 1.8.3


```javascript
//[初始化脚本.js]:
let storage = $storage.create("我的YOLO");
let yolo = $yolo.create(12);
yolo.setSize(192,64);
yolo.setUseGpu(true);
storage.putStr("mYoloId",yolo.getId());//保存yolo对象id
//[其他脚本.js]:
let storage = $storage.create("我的YOLO");
let yolo = $yolo.get(storage.getStr("mYoloId","null"));
yolo.detect(img);//使用yolo对象进行检测
```


### close(id)

> 关闭yolo对象
> 
> 由于java端只是持有了C端的(yolo对象)对象句柄，双端的回收机制无法相互干涉，如果java端回收了对象，并不会回收C端的对象，因此需要手动释放资源。
> 
> 因此在使用yolo的时候，在初始化阶段就先存好一个yolo对象的ID，之后就可以在任何脚本中获取这个对象了。

- 参数 : id {string} yoloID
- 版本 : 1.8.3


```javascript
let yolo = $yolo.create(12);
//拿到id
let id = yolo.getId();
//释放(C端)yolo对象
$yolo.close(id);
```


### closeAll()

> 释放所有yolo对象
> 
> 由于java端只是持有了C端的(yolo对象)对象句柄，双端的回收机制无法相互干涉，如果java端回收了对象，并不会回收C端的对象，因此需要手动释放资源。
> 
> 因此在使用yolo的时候，在初始化阶段就先存好一个yolo对象的ID，之后就可以在任何脚本中获取这个对象了。

- 版本 : 1.8.3


```javascript
//释放所有(C端)yolo对象
$yolo.closeAll();
```


# Node - 节点信息

- 更新时间:2025-12-13 11:58:42

> 节点信息
> 
> 该节点信息由本应用进行封装，提供了大量便捷的操作，例如可以直接绘制出节点在屏幕上的位置、可以直接调用点击、滑动、输入文字等操作。



```javascript
//首先创建节点选择器
let selector = $act.selector();
//接下来可以通过selector进行界面ui的选择，不过要先进行条件筛选和过滤，因此可以先调用一些筛选类的方法：
selector = selector
.text("登录") //筛选控件文本必须是"登录"的节点
.cls("android.widget.Button");//筛选控件类必须是"android.widget.Button"的节点
//接下来可以调用一些选择类的方法选择节点
let node = selector.waitLast();//在筛选完毕的列表中选择最后一个节点
//接下来就可以使用{Node}中封装的函数了，例如绘制出节点在屏幕的位置：
if(node!=null){
    node.draw();
}
```




# UiSelector - UI选择器

- 更新时间:2025-12-13 11:58:43

> UI选择器
> 
> 界面的元素有很多，但不一定都是我们要找的那个节点，因此我们需要一些筛选条件过滤掉这些节点。
> 
> UI选择器主要用来过滤界面元素，并且选中我们想要的元素。所以在使用的时候我们需要两类方法：(1).筛选元素;(2).选中元素;



```javascript
//(1)筛选元素
let selector = $act.selector() // 创建UI选择器
     .text("登录") //筛选文本是"登录"的元素
     .cls("android.widget.Button") //筛选类名为"android.widget.Button"的元素
     .pkg("org.aigame.pro") //筛选包名为"org.aigame.pro"的元素
     .desc("点击登录"); //筛选描述是"点击登录"的元素
//(2)选中节点
let node = selector.findFirst(); // 查找一个节点
//其实上面的代码可以直接写成：
let node = $act.selector()
     .text("登录") //筛选文本是"登录"的元素
     .cls("android.widget.Button") //筛选类名为"android.widget.Button"的元素
     .pkg("org.aigame.pro") //筛选包名为"org.aigame.pro"的元素
     .desc("点击登录") //筛选描述是"点击登录"的元素
     .findFirst(); // 查找一个节点
```




# $act - 手势动作

- 更新时间:2025-12-13 11:58:43

> 手势动作
> 
> $act是一个高度封装的框架，其中集成了无障碍、$root、$szk触摸方案，优先级为：$root>$szk>无障碍
> 
> $act中所有click、press、move函数都会优先判断是否有ROOT权限，如果有，则使用$root进行点击；之后判断是否有Shizuku权限，如果有，则使用$szk进行手势操作；之后判断是否有无障碍权限，如果有，则使用无障碍执行。




# $ag - 图色框架

- 更新时间:2025-12-13 11:58:43

> 图色框架




### setDebug(debug)

> 开启调试模式
> 
> 默认是开启调试模式的(推荐开启:更加直观的看到执行效果),找到图片则会在屏幕上绘制图片的位置,找到颜色则绘制点

- 参数 : debug {boolean} 是否开启调试模式 


### findImg(options)

> 寻找图片
> 
> 自动截屏一次,然后在传入的region(范围)中找图片，如果region为空则全屏寻找,不管找没找到,都会回收掉资源,并且返回结果

- 参数 : options 参数 {object} 配置参数 
- 返回 : 位置 {point} 返回找到位置的中心点
- 版本 : 1.0.0


```javascript
//参数:
let options = {
    path:"",//图片路径
    region:[],//(可选)找图的范围:必须是4位,且后两位不能为0
    similar:0.8,//(可选)找图的相似值:不能低于(最小值:0.3)
    trans:false,//(可选)是否找透明背景的图片
};
//使用:
let point = $ag.findImg({
    path:"/sdcard/Pictures/t01.png",
    region:[200,200,300,500],
});
```


### findImgClick(options)

> 寻找图片并且点击
> 
> 先截屏一次,如果图片找到了,那么就点击这个图片位置中心点

- 参数 : options {obj} 参数 
- 返回 : {point} 位置
- 版本 : 1.0.0


```javascript
//参数:
let options = {
    path:"",//图片路径
    region:[],//(可选)找图的范围:必须是4位,且后两位不能为0
    similar:0.8,//(可选)找图的相似值:不能低于(最小值:0.3)
    trans:false,//(可选)是否找透明背景的图片
    px: 0, //(可选)点击位置相对于中点的x偏移量
    py: 0, //(可选)点击位置相对于中点的y偏移量
};
//使用:
let point = $ag.findImgClick({
    path:"/sdcard/Pictures/t01.png",
    region:[200,200,300,500],
});
```


### waitImg(options, failCallback)

> 等待图片
> 
> 截屏后找图没找到就会执行回调一次,然后就继续截屏并且找图
> 
> 值得注意的是ensure如果设置了true,那么你就要了解ensureMode的含义：
> 
> 1.ensureMode:"once"：假如传入的ensureTimes是3,那么就会循环截屏3次,只要其中有1次成功,那么就会返回找到的位置
> 2.ensureMode:"more"：假如传入的ensureTimes是3,那么就会循环截屏3次,必须保证3次全部都成功,那么就会返回找到的位置
> 
> 确认执行完毕之后,会返回找到的位置,如果没有找到,则继续等待图片,每次找图都会执行确认流程。
> 
> 整体流程是：
> 1.先截屏一次
> 2.执行确认流程(如果设置确认流程ensure为false,就执行正常找图流程)
> 3.如果确认流程通过(确认流程会重复截屏ensureTimes次,并且按照ensureMode处理结果),那么就返回找到的位置
> 4.如果确认流程没有通过(执行回调),那么就继续截屏并且执行回到1

- 参数 : options {object} 参数 
- 参数 : failCallback {(curTimes)=>{}} 找图失败(或确认流程失败)后回调 
- 返回 : {point} 找到图片的中点位置


```javascript
let options = {
    path:"",
    region:[],//(可选)
    similar:0.8,//(可选)
    trans:false,//(可选)是否寻找透明背景的图片
    ensure:false,//(可选)找到后是否要进行确认
    ensureMode:"once",//(可选)确认的模式是多次(more)还是一次
    ensureTimes:3,//(可选)确认找到的次数
    ensureDur:300,//(可选)每次确认的间隔时间
    waitTimes:75,//(可选)等待次数
    waitDur:800 //(可选)等待延迟
}
//使用:
let point = $ag.waitImg({
    path:"/sdcard/Pictures/t01.png",
    region:[200,200,300,500],
});
```


### waitImg(options)

> 等待图片

- 参数 : options {object} 参数 
- 返回 : {point} 中点位置


```javascript
let options = {
    path:"",
    region:[],//(可选)
    similar:0.8,//(可选)
    trans:false,//(可选)是否寻找透明背景的图片
    ensure:false,//(可选)找到后是否要进行确认
    ensureMode:"once",//(可选)确认的模式是多次(more)还是一次
    ensureTimes:3,//(可选)确认找到的次数
    ensureDur:300,//(可选)每次确认的间隔时间
    waitTimes:75,//(可选)等待次数
    waitDur:800 //(可选)等待延迟
}
```


### waitImgClick(options, failCallback)

> 等待图片并点击

- 参数 : options {obj} 参数 
- 参数 : failCallback {(curTimes)=>{}} 找图失败后回调 
- 返回 : {point} 中点位置


```javascript
let options = {
    path:"",
    region:[],//(可选)
    similar:0.8,//(可选)
    trans:false,//(可选)是否寻找透明背景的图片
    ensure:false,//(可选)找到后是否要进行确认
    ensureMode:"once",//(可选)确认的模式是多次(more)还是一次
    ensureTimes:3,//(可选)确认找到的次数
    ensureDur:300,//(可选)每次确认的间隔时间
    waitTimes:75,//(可选)等待次数
    waitDur:800, //(可选)等待延迟
    px: 0, //(可选)点击位置相对于中点的x偏移量
    py: 0, //(可选)点击位置相对于中点的y偏移量
}
```


### waitImgClick(options)

> 等待图片并点击

- 参数 : options {object} 配置 
- 返回 : {point} 中点位置


```javascript
let options = {
    path:"",
    region:[],
    similar:0.8,
    trans:false,//(可选)是否寻找透明背景的图片
    ensure:true,//可选
    ensureMode:"once",//可选
    ensureTimes:3,//可选
    ensureDur:300,//可选
    waitTimes:75,//可选
    waitDur:800, //可选
    px: 0, //(可选)点击位置相对于中点的x偏移量
    py: 0, //(可选)点击位置相对于中点的y偏移量
}
```


### findImgInRegions(options)

> 寻找图片
> 
> 给定一个范围数组,只能在指定的范围数组当中查找对应的图片,找到后,返回图片的位置和数组下标
> 
> 执行流程:先截屏,然后循环每个范围数组,对小图片进行查找，找到之后就立马返回
> 
> 使用场景:比如关闭广告的[关闭按钮],有时候这个关闭按钮出现在右上角,有时候出现在中间下方的位置,在这种不确定关闭图片位置的情况下，使用此函数，将可能出现关闭按钮的位置全部传入，找到后即可返回位置。

- 参数 : options 参数 
- 返回 : {point point,int index} 位置与范围下标


```javascript
let options = {
    path:"", //必填:图片路径
    region:[[],[],[]], //必填:多个范围数组
    similar:0.8, //可选
    trans:false, //可选(是否寻找透明图)
}
```


### findImgsOne(options)

> 寻找图片
> 
> 传入多组图片数据,截屏后找图,只要其中有一组数据成功找到,则直接返回结果
> 
> 适用的场景：比如我们每次打开游戏或者应用界面的时候，我们并不知道它会不会弹出来一个更新界面或者广告界面,此时我们可以使用次函数,把可能出现的界面情况都传入进去,只要找到了,那么就会返回执行结果,我们就能知道是哪一个界面了。

- 参数 : options {obj} 参数 
- 返回 : {point point,int index} 结果是一个对象,其中包含point和index两个属性,point是图片中点位置,index是图片下标


```javascript
let options = {
    data:[
    {
        path:"",//必填
        region:[],//必填
        similar:0.8,//可选(默认0.8)
        trans:false,//可选(是否寻找透明图)
    },
    {
        //...多个这样的数据
    }
    ]
}
```


### waitImgsOne(options)

> 等待图片
> 
> 传入多组图片数据,截屏后找图,只要其中有一组数据成功找到,则直接返回结果
> 
> 适用的场景：比如我们每次打开游戏或者应用界面的时候，我们并不知道它会不会弹出来一个更新界面或者广告界面,此时我们可以使用次函数,把可能出现的界面情况都传入进去,只要找到了,那么就会返回执行结果,我们就能知道是哪一个界面了。

- 参数 : options {obj} 参数 
- 返回 : {point point,int index} 图片中点位置和下标


```javascript
let options = {
    data:[
    {
        path:"",//必填
        region:[],//必填
        similar:0.8,//可选(默认0.8)
        trans:false,//可选(是否寻找透明图)
    },
    {
        //...多个这样的数据
    }
    ],
    waitTimes:75,//选填(默认75)
    waitDur:800 //选填(默认800)
}
```


### waitImgsOne(options, failCallback)

> 等待图片

- 参数 : options {obj} 参数 
- 参数 : failCallback {(curTimes)=>{}} 找图失败后回调 
- 返回 : {point point,int index} 图片中点位置和下标


```javascript
let options = {
    data:[
    {
        path:"",//必填
        region:[],//必填
        similar:0.8,//可选(默认0.8)
        trans:false,//可选(是否寻找透明图)
    },
    {
        //...多个这样的数据
    }
    ],
    waitTimes:75,//选填(默认75)
    waitDur:800 //选填(默认800)
}
```


### clickImgWhileNot(options)

> 循环点击图片(直到图片消失)
> 
> 使用场景：比如在一些比较卡顿的应用或游戏中,我希望点击关闭按钮,但是游戏界面比较卡顿,可以使用此函数不断的点击,直到关闭成功

- 参数 : options {obj} 参数 
- 返回 : {point} 中点位置


```javascript
let options = {
    path:"",
    region:[],//(可选)
    similar:0.8,//(可选)
    trans:false,//(可选)是否寻找透明背景的图片
    ensure:false,//(可选)找到后是否要进行确认
    ensureMode:"once",//(可选)确认的模式是多次(more)还是一次
    ensureTimes:3,//(可选)确认找到的次数
    ensureDur:300,//(可选)每次确认的间隔时间
    waitTimes:75,//(可选)等待次数
    waitDur:800, //(可选)等待延迟
    px: 0, //(可选)点击位置相对于中点的x偏移量
    py: 0, //(可选)点击位置相对于中点的y偏移量
}
```


### clickImgWhileNot(options, failCallback)

> 循环点击图片(直到图片消失)
> 
> 使用场景：比如游戏人物打开背包后要存放苹果,此时我们可以使用此函数不断的点击苹果,把它存放到背包中

- 参数 : options {obj} 参数 
- 参数 : failCallback {(curTimes)=>{}} 找图失败后回调 
- 返回 : {point} 中点位置


```javascript
let options = {
    path:"",
    region:[],//(可选)
    similar:0.8,//(可选)
    trans:false,//(可选)是否寻找透明背景的图片
    ensure:false,//(可选)找到后是否要进行确认
    ensureMode:"once",//(可选)确认的模式是多次(more)还是一次
    ensureTimes:3,//(可选)确认找到的次数
    ensureDur:300,//(可选)每次确认的间隔时间
    waitTimes:75,//(可选)等待次数
    waitDur:800, //(可选)等待延迟
    px: 0, //(可选)点击位置相对于中点的x偏移量
    py: 0, //(可选)点击位置相对于中点的y偏移量
}
```


### featureWaitImg(options)

> 等待图片特征

- 参数 : options {object} 配置 
- 返回 : {point} 找到的中心位置


```javascript
let options = {
    path:"",
    region:[],//(可选)
    similar:0.8,//(可选)
    ensure:false,//(可选)找到后是否要进行确认
    ensureMode:"once",//(可选)确认的模式是多次(more)还是一次
    ensureTimes:3,//(可选)确认找到的次数
    ensureDur:300,//(可选)每次确认的间隔时间
    waitTimes:75,//(可选)等待次数
    waitDur:800, //(可选)等待延迟
}
```


### featureWaitImg(options, failCallback)

> 等待图片特征

- 参数 : options {obj} 参数 
- 参数 : failCallback {(curTimes)=>{}} 找图失败后回调 
- 返回 : {point} 中点位置


```javascript
let options = {
    path:"",
    region:[],//(可选)
    similar:0.8,//(可选)
    ensure:false,//(可选)找到后是否要进行确认
    ensureMode:"once",//(可选)确认的模式是多次(more)还是一次
    ensureTimes:3,//(可选)确认找到的次数
    ensureDur:300,//(可选)每次确认的间隔时间
    waitTimes:75,//(可选)等待次数
    waitDur:800, //(可选)等待延迟
}
```


### featureImgClick(options)

> 等待图片特征并点击

- 参数 : options {object} 配置 
- 返回 : {point} 返回位置


```javascript
let options = {
    path:"",
    region:[],
    similar:0.8,
    px: 0, //(可选)点击位置相对于中点的x偏移量
    py: 0, //(可选)点击位置相对于中点的y偏移量
}
```


### featureWaitImgClick(options, failCallback)

> 等待图片特征并点击

- 参数 : options {obj} 参数 
- 参数 : failCallback {(curTimes)=>{}} 找图失败后回调 
- 返回 : {point} 中点位置


```javascript
let options = {
    path:"",
    region:[],
    similar:0.8,
    px: 0, //(可选)点击位置相对于中点的x偏移量
    py: 0, //(可选)点击位置相对于中点的y偏移量
}
```


### featureWaitImgClick(options)

> 等待图片并点击

- 参数 : options {object} 配置 
- 返回 : {point} 找到的位置中点


```javascript
let options = {
    path:"",
    region:[],
    similar:0.8,
    ensure:true,//可选
    ensureMode:"once",//可选
    ensureTimes:3,//可选
    ensureDur:300,//可选
    waitTimes:75,//可选
    waitDur:800, //可选
    px: 0, //(可选)点击位置相对于中点的x偏移量
    py: 0, //(可选)点击位置相对于中点的y偏移量
}
```


### featureImgsOne(options)

> 多图中找一个
> 
> 传入多个特征图片参数,如果找到了其中的一个就会返回结果

- 参数 : options {object} 配置 
- 返回 : {point:point,index:index} 位置与下标


```javascript
let options = {
    data:[
    {
        path:"",//必填
        region:[],//必填
        similar:0.8,//可选(默认0.8)
    },
    {
        //...多个这样的数据
    }
    ]
}
```


### featureWaitImgsOne(options)

> 等待多个特征中的一个

- 参数 : options {object} 配置 
- 返回 : {point:point,index:index} 特征结果位置中点和下标


```javascript
let options = {
    data:[
    {
        path:"",//必填
        region:[],//必填
        similar:0.8,//可选(默认0.8)
    },
    {
        //...多个这样的数据
    }
    ],
    waitTimes:75,//(选填)等待次数
    waitDur:800,//(选填)每次等待延迟
}
```


### featureWaitImgsOne(options, failCallback)

> 等待图片

- 参数 : options {obj} 参数 
- 参数 : failCallback {(curTimes)=>{}} 找图失败后回调 
- 返回 : {point} 中点位置


### featureImgInRegions(options)

> 点击图片特征直到消失

- 参数 : options {object} 配置 
- 返回 : {point} 找到的中点位置


```javascript
let options = {
    path:"",
    region:[],//(可选)
    similar:0.8,//(可选)
    ensure:false,//(可选)找到后是否要进行确认
    ensureMode:"once",//(可选)确认的模式是多次(more)还是一次
    ensureTimes:3,//(可选)确认找到的次数
    ensureDur:300,//(可选)每次确认的间隔时间
    waitTimes:75,//(可选)等待次数
    waitDur:800, //(可选)等待延迟
    px: 0, //(可选)点击位置相对于中点的x偏移量
    py: 0, //(可选)点击位置相对于中点的y偏移量
}
```


### clickImgWhileFeatureNot(options)

> 点击图片特征直到消失

- 参数 : options {object} 配置 
- 返回 : {point} 找到的中点位置


```javascript
let options = {
    path:"",
    region:[],//(可选)
    similar:0.8,//(可选)
    ensure:false,//(可选)找到后是否要进行确认
    ensureMode:"once",//(可选)确认的模式是多次(more)还是一次
    ensureTimes:3,//(可选)确认找到的次数
    ensureDur:300,//(可选)每次确认的间隔时间
    waitTimes:75,//(可选)等待次数
    waitDur:800, //(可选)等待延迟
    px: 0, //(可选)点击位置相对于中点的x偏移量
    py: 0, //(可选)点击位置相对于中点的y偏移量
}
```


### bloodPercent(options)

> 血条检测
> 
> 主要根据传入的颜色(可传入多个颜色以,分割)和血条的范围来计算出血条的百分比

- 参数 : options {object} 参数 
- 返回 : {int} -1-100的值(为-1则表示没有血量)


```javascript
let options = {
    region: [], //(必填)血条范围
    color: "#ff0000,#ff0000", //(必填)可传入多个
    threshold:5 //(可选)偏差值(默认5)
}
let p = $ag.bloodPercent(options);
```


### findColor(options)

> 找色
> 

- 参数 : options {object} 参数 
- 返回 : {Point} 坐标


```javascript
let options = {
    region: [], //(必填)范围
    color: "#ff0000,#ff0000", //(必填)颜色(多个用,分割)
    threshold:5 //(可选)偏差值(默认5)
}
```


### findMultiColors(options)

> 多点找色
> 
> 多点找色并不能很好的适配全分辨率,因为把颜色点相对位置写死了,而不同的设备中,相对点位不同

- 参数 : options {object} 参数 
- 返回 : {point} 位置


```javascript
let options = {
    multiColors:[
        [1,2,"#FF0000",5],//每个数据元都是px,py,color,threshold组成的
        [1,2,"#FF0000",5],//px,py是相对于传入的主颜色的偏移位置
        //...多个点色
    ],
    color:"#000000",
    threshold:5,
    region:[],
}
```


### findMultiColorsClick(options)

> 多点找色

- 参数 : options {object} 参数 
- 返回 : {point} 位置


```javascript
let options = {
    multiColors:[
        [1,2,"#FF0000",5],//每个数据元都是px,py,color,threshold组成的
        [1,2,"#FF0000",5],//px,py是相对于传入的主颜色的偏移位置
        //...多个点色
    ],
    color:"#000000",
    threshold:5,
    region:[],
    px:0, //(可选)点击位置x偏移量
    py:0 //(可选)点击位置y偏移量
}
```


### waitMultiColors(options)

> 等待多点色

- 参数 : options {object} 参数 
- 返回 : {point} 位置


### waitMultiColorsClick(options)

> 等待多点色

- 参数 : options {object} 参数 
- 返回 : {point} 位置


### waitMultiColors(options, failCallback)

> 等待多点色

- 参数 : options {object} 参数 
- 参数 : failCallback {(curTimes)=>{}}回调 
- 返回 : {point} 位置


```javascript
let options = {
    multiColors:[],
    color:"#000000",
    threshold:5,
    rect:null,
    ensure:false,
    ensureMode:"once",
    ensureTimes:3,
    ensureDur:1000,
    waitTimes:50,
    waitDur:1000,
}
```


### waitMultiColorsClick(options, failCallback)

> 等待图片

- 参数 : options {obj} 参数 
- 参数 : failCallback {(curTimes)=>{}} 找图失败后回调 
- 返回 : {point} 中点位置


### findColorClick(options)

> 找色点击

- 参数 : options {object} 参数 
- 返回 : {point} 位置


### waitColor(options, failCallback)

> 等待颜色

- 参数 : options {obj} 参数 
- 参数 : failCallback {(curTimes)=>{}} 找图失败后回调 
- 返回 : {point} 中点位置


```javascript
let options = {
    color:"",
    region: [],//(可选)找色的范围,建议填写上
    threshold:5,
    ensure:false,
    ensureMode:"once",
    ensureTimes:3,
    ensureDur:1000,
    waitTimes:50,
    waitDur:1000,
}
```


### waitColor(options)

> 等待颜色

- 参数 : options {obj} 参数 
- 返回 : {point} 中点位置


```javascript
let options = {
    color:"",
    region: [],//(可选)找色的范围,建议填写上
    threshold:5,
    ensure:false,
    ensureMode:"once",
    ensureTimes:3,
    ensureDur:1000,
    waitTimes:50,
    waitDur:1000,
}
```


### waitColorWhileNot(options, failCallback)

> 等待颜色消失

- 参数 : options {obj} 参数 
- 参数 : failCallback {(curTimes)=>{}} 找图失败后回调 


```javascript
let options = {
    color:"",
    region: [],//(可选)找色的范围,建议填写上
    threshold:5,
    ensure:false,
    ensureMode:"once",
    ensureTimes:3,
    ensureDur:1000,
    waitTimes:50,
    waitDur:1000,
}
```


### waitColorClick(options, failCallback)

> 等待颜色

- 参数 : options {obj} 参数 
- 参数 : failCallback {(curTimes)=>{}} 找图失败后回调 
- 返回 : {point} 中点位置


### waitColorClick(options)

> 等待颜色

- 参数 : options {obj} 参数 
- 返回 : {point} 中点位置


### findColorInRegions(options)

> 在多个区域中找色

- 参数 : options {object} 参数 
- 返回 : {point} 中点位置


```javascript
let options = {
    color:"",
    threshold: 5,
    region:[[],[],[]],//多个范围
}
let result = $ag.findColorInRegions(options);
```


### findColorsOne(options)

> 找到一种颜色

- 参数 : options {object} 参数 
- 返回 : {point} 中点位置


### setScreen(w, h)

> 设置屏幕信息(开发者环境)

- 参数 : w {int} 宽度 
- 参数 : h {int} 高度 


### closeDraw()

> 关闭绘制的图案


### screenInfo()

> 获得当前屏幕信息

- 返回 : {string} 屏幕信息


### setDevDensity(devDensity)

> 设置开发环境屏幕密度
> 
> 注意:此函数用于分辨率适配

- 参数 : devDensity 开发环境下的屏幕密度  


### setAdapt(usable)

> 是否启动分辨率适配

- 参数 : usable {boolean} 启用分辨率适配 


# AppInfo - 应用信息

- 更新时间:2025-12-13 11:58:44

> 应用信息
> 
> 通过 $app.ls(); 方法返回的列表元素类型




### const {String} 应用名称;

> 应用名称


### const {String} 包名;

> 包名


### const {Image} 图标;

> 图标


### const {ApplicationInfo} 原生信息;

> 安卓原生应用信息
> 
> 类名：android.content.pm.ApplicationInfo


### 获取应用名称()

> 获取应用名称

- 返回 : {字符串} 应用名称


### 获取包名()

> 获取包名

- 返回 : {字符串} 包名


### 获取图标()

> 获取图标

- 返回 : {Image} 图标


### 获取原生信息()

> 获取安卓原生应用信息

- 返回 : {ApplicationInfo} 安卓原生应用信息


### json()

> 转成json字符串

- 返回 : {string} json字符串
- 版本 : 1.7.0


# AppTaskInfo - 任务信息

- 更新时间:2025-12-13 11:58:44

> 应用任务信息
> 
> 通过 $app.lsRecent(); 方法返回的列表元素类型




### const {String} 应用名称;

> 应用名称


### const {String} 包名;

> 包名


### const {String} 最后使用时间;

> 最后使用时间


### const {long} 最后使用的时间;

> 最后使用时间


### const {ApplicationInfo} 原生信息;

> 安卓原生应用信息
> 
> 类型：{android.content.pm.ApplicationInfo}


### 获取时间戳()

> 最后使用时间

- 返回 : {long} 最后使用时间
- 版本 : 1.7.0


### 获取应用名()

> 获取应用名称

- 返回 : {字符串} 应用名称
- 版本 : 1.7.0


### 获取包名()

> 获得包名

- 返回 : {字符串} 包名
- 版本 : 1.7.0


### 获取时间()

> 获得最后时间格式化字符串

- 返回 : {字符串} 最后使用时间
- 版本 : 1.7.0


### 获取原生对象()

> 获取安卓原生应用信息

- 返回 : {android.content.pm.ApplicationInfo} 安卓原生应用信息
- 版本 : 1.7.0


### json()

> 将当信息对象转为json字符串

- 返回 : {String} json字符串
- 版本 : 1.7.0


# $app - 应用操作

- 更新时间:2025-12-13 11:58:44

> 应用操作
> 
> 这里包含了一写常用的应用操作、意图操作、或者一些拓展操作：发送短信等等。




### 获取图标(名称)

> 获取应用图标

- 参数 : 名称 {字符串} 应用名称或包名 
- 返回 : {Image} 图标
- 版本 : 1.6.8


```javascript
//获取悬浮窗权限
$悬浮窗.获取权限();
//获取图标
定义 图标 = $应用.获取图标("QQ");//应用名称或者包名
//显示图片
$图片.显示(图标);//(需要用悬浮窗权限) 也可以直接调用 图标.显示(); //图标是{Image}类对象，因此可以世界调用'显示()'方法。
```


### 运行应用(应用名称)

> 运行应用

- 参数 : 应用名称 {字符串} 应用名 
- 返回 : {布尔值} 是否运行成功
- 版本 : 1.6.8


```javascript
$应用.运行应用("QQ");//应用名
```


### 启动应用(应用名称)

> 运行应用
> 
> 这个函数的效果和 $应用.运行应用("应用"); 相同

- 参数 : 应用名称 {字符串} 应用名称 
- 返回 : {布尔值} 是否运行成功
- 版本 : 1.6.8


```javascript
$应用.启动应用("QQ");//应用名
```


### 启动(应用名称)

> 运行应用
> 
> 这个函数的效果和$应用.运行应用("应用");相同

- 参数 : 应用名称 {字符串} 应用名称 
- 返回 : {布尔值} 是否运行成功
- 版本 : 1.6.8


```javascript
$应用.启动("QQ");//应用名或包名
```


### 启动包(包名)

> 运行包名
> 
> 此函数和$应用.运行包("包名");效果相同

- 参数 : 包名 {字符串} 程序包名 
- 返回 : {布尔值} 是否跳转成功
- 版本 : 1.6.8


```javascript
$应用.启动包("com.tencent.mobileqq");//传入包名
```


### 运行包(包名)

> 运行包名

- 参数 : 包名 {字符串} 程序包名 
- 返回 : {布尔值} 是否跳转成功
- 版本 : 1.6.8


```javascript
$应用.运行包("com.tencent.mobileqq");//传入包名
```


### 运行(名称)

> 打开应用(推荐)
> 
> 最简洁的启动应用函数，推荐使用

- 参数 : 名称 {字符串} 包名或程序名称 
- 返回 : {布尔值} 是否打开成功
- 版本 : 1.6.8


```javascript
$应用.运行("QQ");//可传入包名或者应用名
```


### 罗列()

> 获得应用列表

- 返回 : {AppInfo[]} 应用信息列表
- 版本 : 1.6.8


```javascript
//获得所有应用信息
定义 应用信息列表 = $应用.罗列();//返回一个AppInfo的列表
//打印所应用信息
循环(定义 下标 = 0 ; 下标 < 应用信息列表.size() ; i++){
    定义 应用信息 = 应用信息列表.get(下标);//获得{AppInfo}对象(注意{AppInfo}是由本平台封装的对象)
    //一些常用属性
    定义 应用名 = 应用信息.应用名称;//应用名称{字符串}
    定义 包名 = 应用信息.包名;//包名{字符串}
    定义 图标 = 应用信息.图标;//图标{Image} 可以直接调用 图标.显示(); 显示出来(注意{Image}是由本平台封装的对象)
    定义 原生信息 = 应用信息.原生信息;//安卓原生应用信息{android.content.pm.ApplicationInfo}
    //{ApplicationInfo}常用属性(安卓自带的对象:需要参考安卓API)
    定义 应用安装路径 = 原生信息.sourceDir; // {字符串}应用APK文件的路径
    定义 应用的类名 = 原生信息.className; // {字符串}应用的主Application类名
    定义 应用的包名 = 原生信息.packageName; // {字符串}应用的包名
    定义 应用组件工厂 = 原生信息.appComponentFactory; // {字符串}应用组件工厂类，用于创建Activity、Service等组件
    定义 sdk代号 = 原生信息.compileSdkVersion; // {整数}应用编译时使用的SDK版本号
    定义 sdk名称 = 原生信息.compileSdkVersionCodename; // {字符串}应用编译时使用的SDK版本代号，如"Q"、"R"等
    定义 数据目录 = 原生信息.dataDir; // {字符串}应用的数据目录，一般为/data/data/包名
    定义 数据保护目录 = 原生信息.deviceProtectedDataDir; // {字符串}设备受保护存储中的应用数据目录
}
```


### 罗列用户应用()

> 获得用户应用列表

- 返回 : {AppInfo[]} 应用列表
- 版本 : 1.6.8


```javascript
//获得用户应用列表
定义 应用列表 = $应用.罗列用户应用();
//打印所应用信息
循环(定义 信息 关于 应用列表){
    打印(信息);
}
```


### 罗列系统应用()

> 获得系统应用列表

- 返回 : {AppInfo[]} 应用列表
- 版本 : 1.6.8


```javascript
//获得系统应用列表
定义 应用列表 = $应用.罗列系统应用();
//打印所应用信息
循环(定义 信息 关于 应用列表){
    打印(信息);
}
```


### 罗列最近应用()

> 获得最近运行的应用

- 返回 : {AppTaskInfo[]} 应用信息列表
- 版本 : 1.6.8


```javascript
//获得最近运行的应用(需要用到查询应用使用情况的权限)
如果 ($应用.有使用情况权限()) {
    定义 应用列表 = $应用.罗列最近应用();
    如果 (应用列表 !== 空) {
        循环 (定义 信息 关于 应用列表) {
            //常用属性：(可参考AppTaskInfo文档)
            定义 应用名 = 信息.应用名称; //{字符串}应用名称
            定义 包名 = 信息.包名; //{字符串}包名
            定义 最后使用时间 = 信息.最后使用时间; //{字符串}最后使用时间 对lastUsedTime进行格式化日期的字符串
            定义 最后使用的时间 = 信息.最后使用的时间; //{long}最后使用时间
            定义 原生信息 = 信息.原生信息; //{android.content.pm.ApplicationInfo}应用信息(安卓类对象)
        }
    }
} 否则 {
    //获取查询应用使用情况的权限
    $应用.获取使用情况权限();
}
```


### 启动活动(名称)

> 打开AIGame中的界面
> 
> 允许用户打开本应用中集成的各种调试界面：Log日志、Device设备信息、Ocr文字识别、Yolo目标检测、Shizuku高级权限等。

- 参数 : 名称 {字符串} 界面名称 
- 版本 : 1.6.9


```javascript
//打开日志界面
$应用.启动活动("log");//推荐写法
$应用.启动活动("console");//兼容auto.js写法
//打开设备信息界面
$应用.启动活动("device");
//打开OCR调试界面
$应用.启动活动("ocr");
//打开Yolo调试界面
$应用.启动活动("yolo");
//打开Shizuku调试界面
$应用.启动活动("shizuku");
```


### 启动活动(包名或应用名, 活动名)

> 启动活动

- 参数 : 包名或应用名 {字符串} 包名或应用名 
- 参数 : 活动名 {字符串} activity地址 
- 返回 : {布尔值} 是否跳转成功
- 版本 : 1.6.8


```javascript
//打开QQ
$应用.启动活动("QQ","com.tencent.mobileqq.activity.SplashActivity");
```


### 包存在(包名)

> 包名是否存在

- 参数 : 包名 {字符串} 包名 
- 返回 : {布尔值} 是否存在
- 版本 : 1.6.8


```javascript
定义 包名 = "org.aigame.pro";
如果 ($应用.包存在(包名)) {
    提示(包名,"存在");
} 否则 {
    提示(包名,"不存在");
}
```


### 获取包名(应用名)

> 获得包名名称
> 
> 效果和$应用.包名("QQ");相同

- 参数 : 应用名 {字符串} app名称 
- 返回 : {字符串} 包名
- 版本 : 1.6.8


```javascript
//获得包名
定义 包名 = $应用.获取包名("QQ");
提示("应用包名",包名);
```


### 包名(应用名)

> 获得包名名称

- 参数 : 应用名 {字符串} app名称 
- 返回 : {字符串} 包名
- 版本 : 1.6.8


```javascript
//获得包名
定义 包名 = $应用.包名("QQ");
提示("应用包名",包名);
```


### 应用名(包名)

> 根据包名拿应用名

- 参数 : 包名 {字符串} 包名 
- 返回 : {字符串} app名称
- 版本 : 1.6.8


```javascript
//获得应用名
定义 应用名 = $应用.应用名("com.android.settings");
提示("应用名称",应用名);//设置
```


### 安装应用(apk路径)

> 安装apk文件
> 
> 此函数会获取系统的安装意图，然后尝试安装apk文件，前提是apk文件必须存在

- 参数 : apk路径 {字符串} 路径(支持相对路径) 
- 返回 : {布尔值} 是否成功获取安装意图
- 版本 : 1.6.8


```javascript
//安装本地apk文件
$应用.安装应用("./apk/qq.apk");
```


### 卸载应用(应用名)

> 卸载应用

- 参数 : 应用名 {字符串} 应用名称 
- 版本 : 1.6.8


```javascript
//此函数部分手机不支持
//卸载QQ
$应用.卸载应用("QQ");
```


### 卸载包(包名)

> 卸载包名
> 
> 部分手机不支持

- 参数 : 包名 {字符串} 应用名称或包名 
- 版本 : 1.6.8


```javascript
//此函数部分手机不支持
//卸载QQ
$应用.卸载包("com.tencent.mobileqq");
```


### 卸载(包名或应用名)

> 卸载

- 参数 : 包名或应用名 {字符串} 应用名称或包名 
- 版本 : 1.6.8


```javascript
//此函数部分手机不支持
//卸载QQ
$应用.卸载("QQ");//应用名或包名
```


### 打开链接(url)

> 打开链接
> 
> 如果传入的网址不是以"http"开头的，则默认追加"http://"到连接前面

- 参数 : url {字符串} 网页链接 
- 版本 : 1.6.8


```javascript
//打开网址
定义 链接 = "www.baidu.com";
$应用.打开链接(链接);//http://www.baidu.com
```


### 分享图片(图片路径)

> 分享图片

- 参数 : 图片路径 {字符串} 图片路径 
- 版本 : 1.6.8


```javascript
//分享本地图片
定义 路径 = "/sdcard/Pictures/t01.png";
$应用.分享图片(路径);
```


### 分享文本(文本内容)

> 分享文本

- 参数 : 文本内容 {字符串} 内容 
- 版本 : 1.6.8


```javascript
//分享文本
定义 文本 = "你好";
$应用.分享文本(文本);
```


### 发送短信(电话号码, 短信内容)

> 发送短信
> 
> 跳转到发送短信的界面

- 参数 : 电话号码 {字符串} 电话号码 
- 参数 : 短信内容 {字符串} 短信内容 
- 版本 : 1.6.8


```javascript
$应用.发送短信("13593749477","你好我是xxx");
```


### 打电话(号码)

> 拨打电话
> 
> 如果拥有电话权限会直接拨通电话

- 参数 : 号码 {字符串} 电话号码 
- 版本 : 1.6.8


```javascript
$应用.打电话("13593749477");
```


### 发送邮件(收件邮箱地址, 标题, 内容)

> 发送邮件
> 
> 需要手机有自带的邮箱功能或应用

- 参数 : 收件邮箱地址 {字符串} 收件邮箱 
- 参数 : 标题 {字符串} 标题 
- 参数 : 内容 {字符串} 内容 
- 返回 : {布尔值} 是否发送成功
- 版本 : 1.6.8


```javascript
$应用.发送邮件("3502037911@qq.com","标题","内容");
```


### 打开应用设置(应用名或包名)

> 打开应用设置
> 
> 和$应用.appSetting("AIGame Pro");效果相同
> 
> 会打开应用详情设置界面

- 参数 : 应用名或包名 {字符串} 应用名称或包名 
- 返回 : {布尔值} 是否打开成功
- 版本 : 1.6.8


```javascript
//前往权限设置界面
$应用.打开应用设置("AIGame");
```


### 应用设置(应用名或包名)

> 打开应用设置
> 
> 会打开应用详情设置界面

- 参数 : 应用名或包名 {字符串} 应用名称或包名 
- 返回 : {布尔值} 是否打开成功
- 版本 : 1.6.8


```javascript
//前往权限设置界面
$应用.应用设置("AIGame");
```


### 查看文件(文件路径)

> 查看文件

- 参数 : 文件路径 {字符串} 文件路径 
- 返回 : {布尔值} 是否打开成功
- 版本 : 1.6.8


```javascript
//打开文件
$应用.查看文件("/sdcard/Pictures/test.text");
```


### 编辑文件(文件路径)

> 编辑文件

- 参数 : 文件路径 {字符串} 文件路径 
- 返回 : {布尔值} 是否打开成功
- 版本 : 1.6.8


```javascript
//编辑文件
$应用.编辑文件("/sdcard/Pictures/test.text");
```


### 有使用情况权限()

> 是否有使用情况权限

- 返回 : {布尔值} 是否有使用情况权限
- 版本 : 1.6.8


```javascript
$应用.有使用情况权限();
```


### 获取使用情况权限()

> 获取使用情况权限

- 返回 : {布尔值} 是否打开成功
- 版本 : 1.6.8


```javascript
$应用.获取使用情况权限();
```


### 意图(options)

> 创建意图

- 参数 : options {Object} 配置参数 
- 返回 : {Intent} 意图
- 版本 : 1.6.8


```javascript
//写必要的参数
定义 配置 = {
    action: "android.intent.action.VIEW",//只写VIEW也可以(自动追加前缀:"android.intent.action.")
    data: "https://www.baidu.com",//数据内容
    pkg: "com.baidu.BaiduMap",//包名
    type: "text/plain",//数据类型
    flags: ["FLAG_ACTIVITY_NEW_TASK","..."],//标志
    component: {
        cls: "org.aigame.pro.ActivityMain",
        pkg: "org.aigame.pro"
    },//组件
    categories: ["CATEGORY_DEFAULT","..."],//类别
    extras:[{
        name:"",
        value:""
    },{
        name:"",
        value:""
    }]//额外内容
}
//创建意图
定义 意图 = $应用.意图(配置);
```


### 发送广播(意图对象)

> 发送异步广播

- 参数 : 意图对象 {Intent} 意图 
- 版本 : 1.6.8


### 发送广播(意图对象, 权限)

> 发送异步广播(含权限)

- 参数 : 意图对象 {Intent} 意图 
- 参数 : 权限 {字符串} 权限 
- 版本 : 1.6.8


### 发送有序广播(意图对象, 权限)

> 发送同步广播

- 参数 : 意图对象 {Intent} 意图 
- 参数 : 权限 {字符串} 权限 
- 版本 : 1.6.8


### 启动活动(意图对象)

> 用意图启动Activity

- 参数 : 意图对象 {Intent} 意图 
- 版本 : 1.6.8


### 启动活动(配置)

> 启动Activity

- 参数 : 配置 {Object} 意图配置 
- 版本 : 1.6.8


### 获取前台应用()

> 获取前台应用
> 
> 此方法只在低版本安卓中有明显效果，建议使用 $root.lsRunningApps((pkg)=>{}); 来获取前台应用

- 返回 : {字符串数组[]} 前台应用包名列表
- 版本 : 1.6.8


### 杀死应用(应用名或包名)

> 杀死应用
> 
> 如果有root权限，优先使用root权限来杀死应用,如果有shizuku则使用shizuku来杀死应用
> 
> 在低版本的安卓中，直接就可以通过活动管理器杀死应用，但是在较高版本的安卓中(安卓9+)很可能无法直接杀死应用进程。

- 参数 : 应用名或包名 {字符串} 应用名或包名 
- 版本 : 1.6.8


```javascript
//结束应用
$应用.杀死应用("QQ");
```


### 发送彩信(电话号码, 标题, 短信内容, 图片路径)

> 发送彩信

- 参数 : 电话号码 {字符串} 电话号码
- 参数 : 标题 {字符串} 主题(可为null)
- 参数 : 短信内容 {字符串} 短信内容
- 参数 : 图片路径 {字符串} 图片全路径(无法支持相对路径)
- 版本 : 1.6.8


```javascript
//发送彩信
$应用.发送彩信("13800000000", "测试彩信", "这是一条彩信", "/sdcard/DCIM/100ANDRO/IMG_20230801_100000.jpg");
```


### 打开自己()

> 打开自身
> 
> 打开自身的主活动（通常是启动器图标点击后的活动）。
> 
> 此方法尝试使用启动器意图来打开应用。如果失败（例如，应用未安装），则会创建一个新的意图来启动主活动。
> 
> 如果是打包后的apk则会打开打包后的apk主界面

- 版本 : 1.6.8


```javascript
//打开自身应用
$应用.打开自己();
```


# MenuBody - 按钮容器

- 更新时间:2025-12-13 11:58:44

> 按钮容器
> 
> 用于装载多个悬浮按钮的容器，并控制显示与关闭。




### 添加(小按钮)

> 添加悬浮按钮
> 
> 可以向按钮容器中添加多个悬浮小按钮

- 参数 : 小按钮 {MenuItem} 悬浮按钮
- 返回 : {MenuBody} 自己
- 版本 : 1.6.9


```javascript
//创建按钮容器(用来装小按钮(MenuItem))
定义 按钮容器 = $悬浮球.容器("我的悬浮球1号"); //指定容器名称
//添加按钮
按钮容器.添加($悬浮球.按钮("logo_ag"));
//之后就可以显示出来了
按钮容器.显示();
```


### 显示()

> 显示悬浮按钮
> 
> 会优先判断是否存在悬浮球名称了，如果存在则不显示，如果不存在则记录悬浮球名称并且显示。

- 版本 : 1.6.9


```javascript
//创建按钮容器(用来装小按钮(MenuItem))
定义 按钮容器 = $悬浮球.容器("我的悬浮球1号");
//创建小按钮(自定义按钮的各种样式)
定义 按钮1 = $悬浮球.按钮("logo_ag").背景("#55FFFFFF"); //指定按钮图标
定义 按钮2 = $悬浮球.按钮("ic_close").风格("outline").图标颜色("#FF0000"); //可以这样指定样式[方法1]
定义 按钮3 = $悬浮球.按钮("ic_code_run");
定义 按钮4 = $悬浮球.按钮("ic_cloud");
定义 按钮5 = $悬浮球.按钮("ic_color");
//连续添加小按钮并且显示
按钮容器.添加(按钮1) //添加小按钮1
        .添加(按钮2) //添加小按钮2
        .添加(按钮3) //添加小按钮3
        .添加(按钮4) //添加小按钮4
        .添加(按钮5) //添加小按钮5
        .显示(); //这里直接调用显示
```


### 名称(名称)

> 设置悬浮球名称
> 
> 每个悬浮球被显示之前都会判断当前悬浮球的名称是否已经存在了，如果存在了，就不显示。

- 参数 : 名称 {字符串} 悬浮窗名称
- 返回 : {MenuBody} 自己
- 版本 : 1.6.9


```javascript
//创建按钮容器(用来装小按钮(MenuItem))
定义 按钮容器 = $悬浮球.容器("我的悬浮球1号") //创建悬浮球按钮容器
.名称("悬浮球1号"); //为容器设置一个名称
```


### 边距(左贴边边距, 右贴边边距)

> 设置贴边边距

- 参数 : 左贴边边距 {整数} 左边距，默认为 0
- 参数 : 右贴边边距 {整数} 右边距，默认为 0
- 返回 : {MenuBody} 自己
- 版本 : 1.6.9


```javascript
//创建按钮容器(用来装小按钮(MenuItem))
定义 按钮容器 = $悬浮球.容器("我的悬浮球1号") //创建悬浮球按钮容器
.边距(50,50); //设置左右两边的贴边边距
```


### 半径(半径)

> 设置圆弧半径
> 
> 圆弧半径决定了容器中每个小按钮展开时的距离

- 参数 : 半径 {整数} 半径
- 返回 : {MenuBody} 自己
- 版本 : 1.6.9


```javascript
//创建按钮容器(用来装小按钮(MenuItem))
定义 按钮容器 = $悬浮球.容器("我的悬浮球1号") //创建悬浮球按钮容器
.半径(25); //设置圆弧半径
```


### 全局显示(是否全局显示)

> 设置是否全局显示
> 
> 默认就是全局显示的（需要悬浮窗权限），任何应用都能够看到这个悬浮球，如果不是全局显示的，那么就只能在当前应用中显示。

- 参数 : 是否全局显示 {布尔值} 是否全局显示(默认:true)
- 返回 : {MenuBody} 自己
- 版本 : 1.6.9


```javascript
//创建按钮容器(用来装小按钮(MenuItem))
定义 按钮容器 = $悬浮球.容器("我的悬浮球1号") //创建悬浮球按钮容器
.全局(是); //设置为全局显示(需要悬浮窗权限)
```


### 动画时长(动画时长)

> 设置展开动画时间
> 
> 默认是 250 毫秒

- 参数 : 动画时长 {整数} 展开动画时长
- 返回 : {MenuBody} 自己
- 版本 : 1.6.9


```javascript
//创建按钮容器(用来装小按钮(MenuItem))
定义 按钮容器 = $悬浮球.容器("我的悬浮球1号") //创建悬浮球按钮容器
.动画时长(500); //设置展开动画时间
```


### X(x)

> 设置初始位置
> 
> 初始位置决定了悬浮球最开始显示时的位置

- 参数 : x {整数} x坐标
- 返回 : {MenuBody} 自己
- 版本 : 1.6.9


```javascript
//创建按钮容器(用来装小按钮(MenuItem))
定义 按钮容器 = $悬浮球.容器("我的悬浮球1号") //创建悬浮球按钮容器
.X(300); //设置初始位置
```


### Y(y)

> 设置初始位置
> 
> 初始位置决定了悬浮球最开始显示时的位置

- 参数 : y {整数} y坐标
- 返回 : {MenuBody} 自己
- 版本 : 1.6.9


```javascript
//创建按钮容器(用来装小按钮(MenuItem))
定义 按钮容器 = $悬浮球.容器("我的悬浮球1号") //创建悬浮球按钮容器
.Y(500); //设置初始位置
```


# MenuItem - 悬浮按钮

- 更新时间:2025-12-13 11:58:44

> 悬浮按钮
> 
> 一个悬浮球中只能有一个容器，而一个容器可以添加多个悬浮小按钮，容器用来控制按钮的展开与关闭动画，而按钮主要是用于功能交互。




### 样式(样式)

> 设置样式
> 
> 注意：此方法必须要优先调用!因为会重置其他设置的所有属性

- 参数 : 样式 {字符串} 按钮样式可选值:默认,边框,色调
- 返回 : {MenuItem} 自己
- 版本 : 1.6.9


```javascript
//先创建小按钮
定义 小按钮 = $悬浮球.按钮("logo_ag") //创建一个按钮
.样式("边框"); //(优先调用)设置样式
```


### 点击(点击事件)

> 设置点击事件
> 
> 当小按钮被点击的时候会执行其中的回调函数

- 参数 : 点击事件 {()=>{}} 回调函数
- 返回 : {MenuItem} 自己
- 版本 : 1.6.9


```javascript
//先创建小按钮
定义 小按钮 = $悬浮球.按钮("logo_ag");//图标资源名称或者图标的相对路径
//设置点击事件
小按钮.点击(()=>{
    //点击事件
    信息("我被点击了");
});
```


### 涟漪(颜色字符串)

> 设置涟漪颜色
> 
> 小按钮被点击时背景阴影会有水波涟漪的效果

- 参数 : 颜色字符串 {字符串} 颜色
- 返回 : {MenuItem} 自己
- 版本 : 1.6.9


```javascript
//先创建小按钮
定义 小按钮 = $悬浮球.按钮("logo_ag") //创建一个按钮(图标资源名称或者图标的相对路径)
.涟漪("#FF0000");//设置涟漪颜色
```


### 涟漪(颜色值)

> 设置涟漪颜色

- 参数 : 颜色值 {整数} 颜色值
- 返回 : {MenuItem} 自己
- 版本 : 1.6.9


```javascript
//先创建小按钮
定义 小按钮 = $悬浮球.按钮("logo_ag") //创建一个按钮
.涟漪($颜色.红色);//设置涟漪颜色
```


### 提示(提示)

> 设置提示
> 
> 按钮被长按的时候就会显示提示文字

- 参数 : 提示 {字符串} 提示文字
- 返回 : {MenuItem} 自己
- 版本 : 1.6.9


```javascript
//先创建小按钮
定义 小按钮 = $悬浮球.按钮("logo_ag") //创建一个按钮
.提示("提示文字");//设置长按提示文字
```


### 背景(颜色字符串)

> 设置背景颜色

- 参数 : 颜色字符串 {字符串} 背景颜色
- 返回 : {MenuItem} 自己
- 版本 : 1.6.9


```javascript
//先创建小按钮
定义 小按钮 = $悬浮球.按钮("logo_ag") //创建一个按钮
.背景("#FF0000");//设置按钮背景颜色
```


### 背景(颜色值)

> 设置背景颜色

- 参数 : 颜色值 {整数} 背景颜色值
- 返回 : {MenuItem} 自己
- 版本 : 1.6.9


```javascript
//先创建小按钮
定义 小按钮 = $悬浮球.按钮("logo_ag") //创建一个按钮
.背景($颜色.红色); //设置背景颜色值
```


### 弧度(弧度)

> 设置圆角大小

- 参数 : 弧度 {小数} 圆角大小
- 返回 : {MenuItem} 自己
- 版本 : 1.6.9


```javascript
//先创建小按钮
定义 小按钮 = $悬浮球.按钮("logo_ag") //创建一个按钮
.弧度(15); //设置圆角弧度大小
```


### 图标(资源名称)

> 设置图标
> 
> 支持内置的图标设置
> 
> 支持路径中的图片(最好是相对于项目路径的)

- 参数 : 资源名称 {字符串} 资源名称或者本地路径
- 返回 : {MenuItem} 自己
- 版本 : 1.6.9


```javascript
//创建一个按钮
定义 小按钮 = $悬浮球.按钮("ic_code_run"); //创建一个按钮
//设置点击事件
小按钮.点击(()=>{
    //点击时我们切换图标(设置图标)
    小按钮.图标("ic_stop");//图标资源名称或者图标的相对路径
});
```


### 图标内边距(内边距)

> 设置图标内边距

- 参数 : 内边距 {整数} 边距
- 返回 : {MenuItem} 自己
- 版本 : 1.6.9


```javascript
//先创建小按钮
定义 小按钮 = $悬浮球.按钮("logo_ag") //创建一个按钮
.图标内边距(10); //设置图标内边距
```


### 图标大小(大小)

> 设置图标尺寸

- 参数 : 大小 {整数} 尺寸
- 返回 : {MenuItem} 自己
- 版本 : 1.6.9


```javascript
//先创建小按钮
定义 小按钮 = $悬浮球.按钮("logo_ag") //创建一个按钮
.图标大小(30); //设置按钮大小
```


### 取消图标颜色()

> 取消填充颜色
> 
> 此函数等价于：图标颜色(空);

- 返回 : {MenuItem} 自己
- 版本 : 1.6.9


```javascript
//先创建小按钮
定义 小按钮 = $悬浮球.按钮("logo_ag") //创建一个按钮
.取消图标颜色(); //清空图标的颜色
```


### 图标颜色(颜色字符串)

> 设置图标填充颜色
> 
> 当颜色值为空时，会取消填充颜色

- 参数 : 颜色字符串 {字符串} 颜色
- 返回 : {MenuItem} 自己
- 版本 : 1.6.9


```javascript
//先创建小按钮
定义 小按钮 = $悬浮球.按钮("logo_ag") //创建一个按钮
.图标颜色("#000000"); //设置图标颜色
```


### 图标颜色(颜色值)

> 设置图标填充颜色

- 参数 : 颜色值 {数字} 颜色
- 返回 : {MenuItem} 自己
- 版本 : 1.6.9


```javascript
//先创建小按钮
定义 小按钮 = $悬浮球.按钮("logo_ag") //创建一个按钮
.图标颜色($颜色.红色); //设置图标颜色值
```


### 获取宽度()

> 获取按钮宽度

- 返回 : {整数} 宽度
- 版本 : 1.6.9


```javascript
//先创建小按钮
定义 小按钮 = $悬浮球.按钮("logo_ag");  //创建一个按钮
//获取宽度
小按钮.获取宽度();
//一般获取宽度可以用来设置弧度，例如：
小按钮.设置弧度(小按钮.获取宽度()/2);
//这样就能设置成圆形了
```


### 获取高度()

> 获取按钮高度

- 返回 : {整数} 高度
- 版本 : 1.6.9


```javascript
//先创建小按钮
定义 小按钮 = $悬浮球.按钮("logo_ag");  //创建一个按钮
//获取高度
小按钮.获取高度();
```


# $arc - 悬浮球

- 更新时间:2025-12-13 11:58:44

> 悬浮球
> 
> 轻松的实现悬浮球菜单效果，并且可以定制每个按钮的样式。




![](./img/407372540692722.gif)

### 按钮(图标路径)

> 创建悬浮按钮
> 
> 我们必须要先了解两个概念：容器(MenuBody)和悬浮按钮(MenuItem)；
> 
> 容器可以装多个悬浮按钮，并且可以显示出来。
> 
> 而悬浮按钮中每个按钮都有不一样的样式，所以悬浮按钮用来控制自身的样式。

- 参数 : 图标路径 {字符串} 图标资源名或本地相对路径 
- 返回 : {MenuItem} 悬浮按钮
- 版本 : 1.6.9


```javascript
//创建悬浮小按钮,可以被容器添加进去
定义 按钮1 = $悬浮球.按钮("logo_ag");//内置图标资源名称或者本地自定义图片相对路径
//之后可以创建容器并且显示，例如：
$悬浮球.容器("悬浮球1号").添加(按钮1).显示();
//如果有多个悬浮小按钮：
定义 按钮01 = $悬浮球.按钮("logo_ag");
定义 按钮02 = $悬浮球.按钮("ic_color");
$悬浮球.容器("悬浮球2号").添加(按钮01).添加(按钮02).显示();
```


### 容器(容器名称)

> 创建容器
> 
> 容器主要用来控制显示和关闭的，它可以装入多个悬浮按钮，之后显示出来。
> 
> 需要注意：如果悬浮球菜单已经存在了，那么将无法显示第二个名称相同的悬浮球。

- 参数 : 容器名称 {字符串} 名称 
- 返回 : {MenuBody} 容器
- 版本 : 1.6.9


```javascript
//创建悬浮按钮容器,用于存放多个小按钮，并且显示
定义 容器 = $悬浮球.容器("悬浮球1号");//指定一个名称，方便后面根据名称关闭
//添加一个按钮并且显示，例如：
容器.添加($悬浮球.按钮("logo_ag"));
```


### 有(容器名称)

> 判断悬浮球是否存在

- 参数 : 容器名称 {字符串} 名称 
- 返回 : {布尔值} 是否存在
- 版本 : 1.6.9


```javascript
如果($悬浮球.有("悬浮球1号")){
    信息("悬浮球1号存在");
}
```


### 关闭(悬浮球名称)

> 关闭
> 
> 根据容器的名称来关闭容器

- 参数 : 悬浮球名称 {字符串} 名称 
- 版本 : 1.6.9


```javascript
$悬浮球.关闭("悬浮球1号");
```


### 关闭所有()

> 关闭全部
> 
> 将所有创建的悬浮球都关闭掉

- 版本 : 1.6.9


```javascript
//关闭全部悬浮球(容器)
$悬浮球.关闭所有();
```


# $bus - 消息总线

- 更新时间:2025-12-13 11:58:44

> 消息总线
> 
> 在全局中发送消息，任意位置获取并且处理消息




### 罗列()

> 列出所有监听器

- 返回 : {字符串数组[]} 监听器列表
- 版本 : 1.8.9


```javascript
//获得所有监听器列表
定义 监听器列表 = $消息.罗列();
日志(监听器列表);//[我的监听器1号]
```


### 发送(监听器名称, 数据)

> 发送一条信息

- 参数 : 监听器名称 {字符串} 监听器名称 
- 参数 : 数据 {对象} 信息内容 
- 版本 : 1.6.8


```javascript
$消息.发送("我的监听器1号","我是数据");
```


### 监听(监听器名称, 监听回调)

> 添加监听

- 参数 : 监听器名称 {字符串} 监听器名称 
- 参数 : 监听回调 {(数据)=>{}} 监听器 
- 版本 : 1.6.8


```javascript
$消息.监听("我的监听器1号",(数据)=>{
    日志("获得数据:",数据);
    土司(数据);
});
```


### 关闭(监听器名称)

> 移除监听器

- 参数 : 监听器名称 {字符串} 名称 
- 版本 : 1.6.8


```javascript
//指定关闭监听器
$消息.关闭("我的监听器1号");
```


### 清空()

> 移除所有监听器

- 版本 : 1.6.8


```javascript
$消息.清空();//关闭所有监听器
```


### 停止所有()

> 关闭所有监听器

- 版本 : 1.6.8


```javascript
$消息.停止所有();//关闭所有监听器效果和'清空()'一样
```


# $canvas - 画布

- 更新时间:2025-12-13 11:58:44

> 画布




### paint()

> 获得一个画笔对象

- 返回 : {paint} 画笔对象
- 版本 : 1.3.1


### paint(color)

> 获得一个画笔对象

- 参数 : color {int} 颜色值，例如：$color.RED
- 返回 : {paint} 画笔对象
- 版本 : 1.3.1


### paint(color)

> 获得一个画笔对象

- 参数 : color {String} 颜色字符串，例如：#ff0000
- 返回 : {paint} 画笔对象
- 版本 : 1.3.1


### rect()

> 创建整数类型矩形

- 返回 : {Rect} 矩形对象


### rect(left, top, right, bottom)

> 创建整数类型矩形

- 参数 : left {int} 左
- 参数 : top {int} 上
- 参数 : right {int} 右
- 参数 : bottom {int} 下
- 返回 : {Rect} 矩形对象


### rectf()

> 创建浮点类型矩形

- 返回 : {RectF} 矩形对象


### rectf(left, top, right, bottom)

> 创建浮点类型矩形

- 参数 : left {float} 左
- 参数 : top {float} 上
- 参数 : right {float} 右
- 参数 : bottom {float} 下
- 返回 : {RectF} 矩形对象


### matrix()

> 获得一个矩阵对象

- 返回 : {Matrix} 路径对象


### matrix(src)

> 获得一个矩阵对象

- 参数 : src {Matrix} 源矩阵对象
- 返回 : {Matrix} 矩阵对象


### create()

> 创建一个画布对象

- 返回 : {XCanvas} 画布对象
- 版本 : 1.3.1


### create(image)

> 创建一个画布对象

- 参数 : image {Image} 图片对象
- 返回 : {XCanvas} 画布对象
- 版本 : 1.3.1


### create(path)

> 创建一个画布对象

- 参数 : path {string} 图片路径
- 返回 : {XCanvas} 画布对象
- 版本 : 1.3.1


### create(image)

> 创建一个画布对象

- 参数 : image {Bitmap} 图片对象
- 返回 : {XCanvas} 画布对象
- 版本 : 1.3.1


### create(w, h)

> 创建一个画布对象

- 参数 : w {int} 画布宽度
- 参数 : h {int} 画布高度
- 返回 : {XCanvas} 画布对象
- 版本 : 1.3.1


# $color - 颜色操作

- 更新时间:2025-12-13 11:58:44

> 颜色操作
> 
> 在$color中内置了很多常用的颜色，并且也有依据当前app主题动态获取对应颜色值的函数，尤其是在ui开发的过程中使用较多。
> 
> $color主要用来解析颜色，对比颜色，获取亮色暗色，为颜色设置透明度等等功能。




### const {int} 黑色;

> 黑色


### const {int} 深灰色;

> 深灰色


### const {int} 灰色;

> 灰色


### const {int} 浅灰色;

> 浅灰色


### const {int} 白色;

> 白色


### const {int} 红色;

> 红色


### const {int} 绿色;

> 绿色


### const {int} 蓝色;

> 蓝色


### const {int} 黄色;

> 黄色


### const {int} 青色;

> 青色


### const {int} 品红;

> 品红


### const {int} 透明;

> 透明


### 找色(图片, 颜色, 阈值, 范围)

> 查找颜色的位置

- 参数 : 图片 {Image} 在指定图片中找色 
- 参数 : 颜色 {字符串} 颜色 
- 参数 : 阈值 {整数} 阈值 
- 参数 : 范围 {double[]} 范围 
- 返回 : {Point} 找到颜色的位置
- 版本 : 1.6.8


```javascript
//(1)截屏
定义 截屏 = $截屏.获取截屏();
//(2)在屏幕上找到颜色
定义 位置 = $颜色.找色(截屏, "#a55978", 5 , [100,200,400,400]);
如果 (位置 != 空) {
    //绘制出颜色的位置
    $绘制.准心(位置);
    睡觉(3000);
}
截屏.关闭(); //回收截屏图片
$绘制.关闭所有(); //关闭绘制
```


### 找色(图片, 颜色, 阈值)

> 查找颜色的位置

- 参数 : 图片 {Image} 在指定图片中找色 
- 参数 : 颜色 {字符串} 颜色 
- 参数 : 阈值 {整数} 阈值 
- 返回 : {Point} 找到颜色的位置
- 版本 : 1.6.8


```javascript
//(1)截屏
定义 截屏 = $截屏.获取截屏();
//(2)在屏幕上找到颜色
定义 位置 = $颜色.找色(截屏, "#a55978", 5);
如果 (位置 != 空) {
    //绘制出颜色的位置
    $绘制.准心(位置);
    睡觉(3000);
}
截屏.关闭(); //回收截屏图片
$绘制.关闭所有(); //关闭绘制
```


### 找色(图片, 颜色)

> 查找颜色的位置

- 参数 : 图片 {Image} 在指定图片中找色 
- 参数 : 颜色 {字符串} 颜色值 
- 返回 : {Point} 找到颜色的位置
- 版本 : 1.6.8


```javascript
//(1)截屏
定义 截屏 = $屏幕.获取截屏();
//(2)在屏幕上找到颜色
定义 位置 = $颜色.找色(截屏, "#a55978");
如果 (位置 != 空) {
    //绘制出颜色的位置
    $绘制.准心(位置);
    睡觉(3000);
}
图片.关闭(); //回收截屏图片
$绘制.关闭全部(); //关闭绘制
```


### 找到全部(图片, 颜色, 阈值, 范围)

> 查找颜色所有的位置

- 参数 : 图片 {Image} 在指定图片中找色 
- 参数 : 颜色 {字符串} 颜色值 
- 参数 : 阈值 {整数} 阈值 
- 参数 : 范围 {double[]} 范围 
- 返回 : {Point[]} 找到颜色的位置
- 版本 : 1.6.8


```javascript
定义 截屏 = $屏幕.获取截屏();
定义 结果集 = $颜色.找到全部(截屏,"#d28384",5,[100,200,400,500]);
如果结果集!=空){
    循环(定义 位置 关于 结果集){
        $绘制.点(位置);//绘制位置的点
        $绘制.日志(位置);//屏幕显示位置
        睡觉(300);
    }
    //3秒后关闭悬浮绘制
    睡觉(5000);
    $绘制.关闭全部();
}
```


### 找到全部(图片, 颜色, 阈值)

> 查找颜色所有的位置

- 参数 : 图片 {Image} 在指定图片中找色 
- 参数 : 颜色 {字符串} 颜色值 
- 参数 : 阈值 {整数} 阈值 
- 返回 : {Point[]} 找到颜色的位置
- 版本 : 1.6.8


```javascript
定义 截屏 = $屏幕.获取截屏();
定义 结果集 = $颜色.找到全部(截屏,"#d28384",5);
如果结果集!=空){
    循环(定义 位置 关于 结果集){
        $绘制.点(位置);//绘制位置的点
        $绘制.日志(位置);//屏幕显示位置
        睡觉(300);
    }
    //3秒后关闭悬浮绘制
    睡觉(5000);
    $绘制.关闭全部();
}
```


### 找到全部(图片, 颜色)

> 查找颜色所有的位置

- 参数 : 图片 {Image} 在指定图片中找色 
- 参数 : 颜色 {字符串} 颜色值 
- 返回 : {Point[]} 找到颜色的位置
- 版本 : 1.6.8


```javascript
定义 截屏 = $屏幕.获取截屏();
定义 结果集 = $颜色.找到全部(截屏,"#d28384");
如果结果集!=空){
    循环(定义 位置 关于 结果集){
        $绘制.点(位置);//绘制位置的点
        $绘制.日志(位置);//屏幕显示位置
        睡觉(300);
    }
    //3秒后关闭悬浮绘制
    睡觉(5000);
    $绘制.关闭全部();
}
```


### 相似度(颜色1, 颜色2)

> 计算相似度

- 参数 : 颜色1 {string|int} 颜色1 
- 参数 : 颜色2 {string|int} 颜色2 
- 返回 : {double} 相似度
- 版本 : 1.6.8


```javascript
//计算相似度
定义 相似度 = $颜色.相似度("#1E1F22","#2B2D30");
日志("相似度",相似度);
```


### 相似度(颜色1, 颜色2)

> 计算相似度

- 参数 : 颜色1 {string|int} 颜色1 
- 参数 : 颜色2 {string|int} 颜色2 
- 返回 : {double} 相似度
- 版本 : 1.6.8


```javascript
//计算相似度
定义 相似度 = $颜色.相似度("#1E1F22","#2B2D30");
日志("相似度",相似度);
```


### 相似度(颜色1, 颜色2)

> 计算相似度

- 参数 : 颜色1 {string|int} 颜色1 
- 参数 : 颜色2 {string|int} 颜色2 
- 返回 : {double} 相似度
- 版本 : 1.6.8


```javascript
//计算相似度
定义 相似度 = $颜色.相似度("#1E1F22","#2B2D30");
日志("相似度",相似度);
```


### 相似度(颜色1, 颜色2)

> 计算相似度

- 参数 : 颜色1 {string|int} 颜色1 
- 参数 : 颜色2 {string|int} 颜色2 
- 返回 : {double} 相似度
- 版本 : 1.6.8


```javascript
//计算相似度
定义 相似度 = $颜色.相似度("#1E1F22","#2B2D30");
日志("相似度",相似度);
```


### 转字符(颜色值)

> 颜色值转6位字符

- 参数 : 颜色值 {整数} 颜色值 
- 返回 : {字符串} 颜色
- 版本 : 1.6.8


```javascript
//转为#000000
定义 颜色 = $颜色.转字符(-166780);
```


### 解析(r, g, b)

> 解析rgb的颜色值

- 参数 : r {整数} 红 
- 参数 : g {整数} 绿 
- 参数 : b {整数} 蓝 
- 返回 : {整数} 颜色值
- 版本 : 1.6.8


```javascript
定义 颜色 = $颜色.解析(105,78,230);
```


### 解析(颜色)

> 解析颜色值
> 
> 该函数内置了M3风格主题的动态主题颜色，可以通过传入对应的主题字符串来获取对应的颜色值

- 参数 : 颜色 {字符串} 颜色 
- 返回 : {整数} 颜色值
- 版本 : 1.6.8


```javascript
//解析颜色值
定义 颜色值 = $颜色.解析("#1E1F22");
日志("颜色值",颜色值);
//除了上面的常规使用方法你也可以用$颜色动态获取主题颜色
//获取颜色值(返回int类型的颜色值)
定义 颜色 = $颜色.解析("白色");
定义 颜色 = $颜色.解析("黑色");
定义 颜色 = $颜色.解析("透明");
定义 颜色 = $颜色.解析("无");
定义 颜色 = $颜色.解析("绿色");
定义 颜色 = $颜色.解析("红色");
定义 颜色 = $颜色.解析("蓝色");
定义 颜色 = $颜色.解析("黄色");
//主题颜色值(返回int类型的颜色值)
定义 颜色 = $颜色.解析("主题主颜色");//(常用)一般是主题最明显的颜色：蓝色主题一般呈现蓝色
定义 颜色 = $颜色.解析("主题中性颜色");//(常用)一般是布局背景
定义 颜色 = $颜色.解析("主题中性反色");//(常用)一般是文字颜色
定义 颜色 = $颜色.解析("主题主反色");
定义 颜色 = $颜色.解析("主题主容器颜色");
定义 颜色 = $颜色.解析("主题主容器反色");
定义 颜色 = $颜色.解析("主题次颜色");
定义 颜色 = $颜色.解析("主题次反色");
定义 颜色 = $颜色.解析("主题次容器颜色");
定义 颜色 = $颜色.解析("主题次容器反色");
定义 颜色 = $颜色.解析("主题错误颜色");
定义 颜色 = $颜色.解析("主题错误反色");
定义 颜色 = $颜色.解析("主题错误容器颜色");
定义 颜色 = $颜色.解析("主题错误容器反色");
定义 颜色 = $颜色.解析("主题背景反色");
定义 颜色 = $颜色.解析("主题中性容器颜色");
定义 颜色 = $颜色.解析("主题中性容器反色");
定义 颜色 = $颜色.解析("主题中性轮廓颜色");
定义 颜色 = $颜色.解析("主题中性轮廓反色");
定义 颜色 = $颜色.解析("主题主状态反色");
```


### 设置透明度(颜色值, 透明度)

> 设置颜色的透明度

- 参数 : 颜色值 {整数} 颜色值 
- 参数 : 透明度 {整数} 透明度(0-255)  
- 返回 : {整数} 颜色值
- 版本 : 1.6.8


```javascript
//解析颜色值
定义 颜色值 = $颜色.解析("#1E1F22");
//设置颜色的透明度
定义 半透明颜色 = $颜色.设置透明度(颜色值,100);//1-255
```


### 变亮(颜色值)

> 获取较亮颜色

- 参数 : 颜色值 {整数} 颜色值 
- 返回 : {整数} 颜色值
- 版本 : 1.6.8


```javascript
//解析颜色值
定义 颜色值 = $颜色.解析("#1E1F22");
//获取较亮颜色
定义 新颜色 = $颜色.变亮(颜色值);
```


### 变暗(颜色值)

> 获取较暗颜色值

- 参数 : 颜色值 {整数} 颜色值 
- 返回 : {整数} 颜色值
- 版本 : 1.6.8


```javascript
//解析颜色值
定义 颜色值 = $颜色.解析("#1E1F22");
//获取较暗颜色值
定义 新颜色 = $颜色.变暗(颜色值);
```


### rgb(red, green, blue)

> 通过RGB通道获得颜色值

- 参数 : red {int} R通道 
- 参数 : green {int} G通道 
- 参数 : blue {int} B通道 
- 返回 : {int} 颜色值
- 版本 : 1.0.0


```javascript
let color = $color.rgb(105,78,230);
```


### argb(alpha, red, green, blue)

> 通过ARGB通道获得颜色值

- 参数 : alpha {int} A通道 
- 参数 : red {int} R通道 
- 参数 : green {int} G通道 
- 参数 : blue {int} B通道 
- 返回 : {int} 颜色值
- 版本 : 1.0.0


```javascript
let color = $color.argb(255,105,78,230);
```


### a(color)

> 计算[A通道]的值

- 参数 : color {String} 颜色 
- 返回 : {int} 数值
- 版本 : 1.0.0


```javascript
let a = $color.a("#357C94");
```


### r(color)

> 计算[R通道]的值

- 参数 : color {String} 颜色 
- 返回 : {int} 数值
- 版本 : 1.0.0


```javascript
let r = $color.r("#357C94");
```


### g(color)

> 计算[G通道]的值

- 参数 : color {String} 颜色 
- 返回 : {int} 数值
- 版本 : 1.0.0


```javascript
let g = $color.g("#357C94");
```


### b(color)

> 计算[B通道]的值

- 参数 : color {String} 颜色 
- 返回 : {int} 数值
- 版本 : 1.0.0


```javascript
let b = $color.b("#357C94");
```


### 比较(颜色1, 颜色2)

> 比较两个颜色

- 参数 : 颜色1 {string|int} 颜色1 
- 参数 : 颜色2 {string|int} 颜色2 
- 返回 : {布尔值} 是否相等
- 版本 : 1.6.8


```javascript
定义 颜色字符 = "#1E1F22";
定义 颜色值 =-14803166;
定义 颜色相同 = $颜色.比较(颜色字符,颜色值);
如果(颜色相同){
    信息("颜色相同");
}否则{
    信息("颜色不同");
}
```


### 比较(颜色1, 颜色2)

> 比较两个颜色

- 参数 : 颜色1 {string|int} 颜色1 
- 参数 : 颜色2 {string|int} 颜色2 
- 返回 : {布尔值} 是否相等
- 版本 : 1.6.8


```javascript
定义 颜色字符 = "#1E1F22";
定义 颜色值 =-14803166;
定义 颜色相同 = $颜色.比较(颜色字符,颜色值);
如果(颜色相同){
    信息("颜色相同");
}否则{
    信息("颜色不同");
}
```


### 比较(颜色1, 颜色2)

> 比较两个颜色

- 参数 : 颜色1 {string|int} 颜色1 
- 参数 : 颜色2 {string|int} 颜色2 
- 返回 : {布尔值} 是否相等
- 版本 : 1.6.8


```javascript
定义 颜色字符 = "#1E1F22";
定义 颜色值 =-14803166;
定义 颜色相同 = $颜色.比较(颜色字符,颜色值);
如果(颜色相同){
    信息("颜色相同");
}否则{
    信息("颜色不同");
}
```


### 比较(颜色1, 颜色2)

> 比较两个颜色

- 参数 : 颜色1 {string|int} 颜色1 
- 参数 : 颜色2 {string|int} 颜色2 
- 返回 : {布尔值} 是否相等
- 版本 : 1.6.8


```javascript
定义 颜色字符 = "#1E1F22";
定义 颜色数值 =-14803166;
定义 颜色相同 = $颜色.比较(颜色字符,颜色数值);
如果(颜色相同){
    信息("颜色相同");
}否则{
    信息("颜色不同");
}
```


### 是暗主题()

> 是否是黑暗主题
> 

- 返回 : {布尔值} 是否是深色主题
- 版本 : 1.6.8


```javascript
如果($颜色.是暗主题()){
    信息("黑暗主题");
}否则{
    信息("亮色主题");
}
```


### 是颜色(颜色字符串)

> 判断颜色格式是否正确

- 参数 : 颜色字符串 {字符串} 颜色字符串 
- 返回 : {布尔值} 是否是正确的颜色格式
- 版本 : 1.6.8


```javascript
如果($颜色.是颜色("#1E1F22")){
    信息("颜色格式正确");
}否则{
    信息("颜色格式错误");
}
```


# $crypt - 加密算法

- 更新时间:2025-12-13 11:58:44

> 加密算法




### fromBase64(data)

> base64解码

- 参数 : data {string} base64编码的字符串
- 返回 : {string} 解码后的字符串
- 版本 : 1.0.0


### toBase64(data)

> base64编码

- 参数 : data {byte[]} 要编码的字节
- 返回 : {string} 编码后的字符串
- 版本 : 1.0.0


### toBase64(data)

> base64编码

- 参数 : data {string} 要编码的字符串
- 返回 : {string} 编码后的字符串
- 版本 : 1.0.0


### toBase64(data, encoding)

> base64编码

- 参数 : data {string} 要编码的字符串
- 参数 : encoding {string} 编码格式
- 返回 : {string} 编码后的字符串
- 版本 : 1.0.0


### aesKey()

> 生成一个AES加密的key

- 返回 : {string} key
- 版本 : 1.0.0


### aesJiami(data, key)

> AES加密字符串

- 参数 : data {string} 要加密的字符串
- 参数 : key {string} aes的密钥
- 返回 : {string} 加密后的字符串
- 版本 : 1.0.0


### aesJiemi(data, key)

> AES解密字符串

- 参数 : data {string} 要解密的字符串
- 参数 : key {string} aes的密钥
- 返回 : {string} 解密后的字符串
- 版本 : 1.0.0


### md5Key(size)

> 生成一个MD5加密的salt(盐值)

- 参数 : size {int} 长度
- 返回 : {byte[]} salt
- 版本 : 1.0.0


### md516(salt, data)

> md5加密

- 参数 : salt {byte[]} 盐值
- 参数 : data {string} 数据
- 返回 : 16位的MD5值
- 版本 : 1.0.0


### md532(salt, data)

> md5加密

- 参数 : salt {byte[]} 盐值
- 参数 : data {string} 数据
- 返回 : 32位的MD5值
- 版本 : 1.0.0


### digest(message, algorithm, options)

> 摘要

- 参数 : message {File|String|byte[]} 消息
- 参数 : algorithm {string} 算法
- 参数 : options {object} 选项
- 返回 : 摘要
- 版本 : 1.0.0


```javascript
//MD5加密
let result = $crypt.digest("我是你爸爸","md5",{
    input:"string",
    output:"hex"
});
log(result);
```


### md5(message, options)

> 摘要

- 参数 : message {File|String|byte[]} 消息
- 参数 : options {object} 选项
- 返回 : 摘要
- 版本 : 1.0.0


```javascript
//MD5加密
let result = $crypt.md5("我是加密的内容",{
    input:"string",
    output:"hex"
});
log(result);//a4f2086496066b767f9667d4737047b7
```


### sign(data, key, algorithm, options)

> 签名

- 参数 : data {File|String|byte[]}  签名的输入数据
- 参数 : key {CryptKey}   签名的密钥
- 参数 : algorithm {string} 签名的算法
- 参数 : options {object} 签名的选项
- 返回 : {object} 签名结果
- 版本 : 1.0.0


```javascript
//生成密钥对
let keyPair = $crypt.generateKeyPair("DSA", 1024);
log(keyPair)
log("签名:"); //数字签名只能用私钥进行签名
let signData = $crypt.sign("我是被签名的内容", keyPair.privateKey, "DSA", {
    input: "string",
    output: "byte"
});
log("验证:"); //数字签名只能用公钥进行验证
let verified = $crypt.verify("我是被签名的内容",signData, keyPair.publicKey, "DSA", {
    //输入文本的类型
    input: "string",
    output: "byte"
},{
    //输入签名的类型
    input: "byte",
});
log("验证结果:", verified);
```


### verify(msg_data, msg_sign, key, algorithm, optionsObj_data, optionsObj_sign)

> 验证

- 参数 : msg_data {object}   签名数据
- 参数 : msg_sign {object}  签名结果
- 参数 : key {CryptKey}    密钥
- 参数 : algorithm {string}   算法
- 参数 : optionsObj_data {object} 验证选项
- 参数 : optionsObj_sign {object}签名选项
- 返回 : 验证结果
- 版本 : 1.0.0


### digests()

> 获得所有摘要算法的名称

- 返回 : {string[]} 摘要算法的名称
- 版本 : 1.0.0


```javascript
//获得所有哈希算法的名称
let digests = $crypt.digests();
//每个算法都用一遍
for (let i = 0; i < digests.size(); i ++) {
    let result = $crypt.digest("我是加密的内容", digests.get(i), {
        input: "string",
        output: "hex"
    });
    log(result);
}
```


### digestFile(path, algorithm, options)

> 摘要文件

- 参数 : path {string} 文件路径
- 参数 : algorithm {string} 算法
- 参数 : options {object} 选项
- 返回 : {string|byte[]} 摘要
- 版本 : 1.0.0


### jiami(data, key, algorithm, options)

> 加密

- 参数 : data {object} 数据
- 参数 : key {object} 密钥
- 参数 : algorithm {string} 算法
- 参数 : options {object} 选项
- 返回 : {string|byte[]} 加密结果
- 版本 : 1.0.0


```javascript
//对称加密算法
//准备一个长度为16的密钥
let key = "ACSDFGHJUYDLOPSD";
let text = "我是被加密的明文";
log("AES加密");
let result = $crypt.jiami(text,key,"AES",{
input:"string",
output:"base64"
});
log("加密后：",result)
result = $crypt.jiemi(result,key,"AES",{
input:"base64",
output:"string"
});
log("解密后：",result)
```


### jiami(data, key, algorithm)

> 加密

- 参数 : data {object} 数据
- 参数 : key {object} 密钥
- 参数 : algorithm {string} 算法
- 返回 : {string|byte[]} 加密结果
- 版本 : 1.0.0


### jiemi(data, key, algorithm, options)

> 解密

- 参数 : data {object} 数据
- 参数 : key {object} 密钥
- 参数 : algorithm {string} 算法
- 参数 : options {object} 选项
- 返回 : {string|byte[]} 解密结果
- 版本 : 1.0.0


### jiemi(data, key, algorithm)

> 解密

- 参数 : data {object} 数据
- 参数 : key {object} 密钥
- 参数 : algorithm {string} 算法
- 返回 : {string|byte[]}  解密结果
- 版本 : 1.0.0


### key(data)

> 构建密钥对象

- 参数 : data {string|byte[]} 密钥数据
- 返回 : {CryptKey} 密钥
- 版本 : 1.0.0


### key(data)

> 生成密钥

- 参数 : data {String} 密钥数据
- 返回 : {CryptKey} 密钥
- 版本 : 1.0.0


### key(data)

> 生成密钥

- 参数 : data {byte[]} 密钥数据
- 返回 : {CryptKey} 密钥
- 版本 : 1.0.0


### keyPair(publicKey, privateKey)

> 构造密钥对

- 参数 : publicKey {byte[] | base64} 公钥
- 参数 : privateKey {byte[] | base64} 私钥
- 返回 : {CryptKeyPair}  密钥对
- 版本 : 1.0.0


### keyPair(publicKey, privateKey)

> 从字节数组当中构造一个keyPair

- 参数 : publicKey {byte[] | base64}  公钥
- 参数 : privateKey {byte[] | base64}  私钥
- 返回 : 密钥对
- 版本 : 1.0.0


### generateKeyPair(algorithm)

> 生成密钥对

- 参数 : algorithm {string} 算法
- 返回 : {CryptKeyPair} 密钥对
- 版本 : 1.0.0


### generateKeyPair(algorithm, length)

> 生成密钥对

- 参数 : algorithm {string} 算法
- 参数 : length {int}  长度
- 返回 : {CryptKeyPair} 密钥对
- 版本 : 1.0.0


# DateInfo - 日期信息

- 更新时间:2025-12-13 11:58:44

> 日期信息




### const {long} 时间戳;

> 时间戳


```javascript
//获取日期信息
定义 信息 = $日期.信息();
日志(信息.时间戳);//时间戳
日志(信息.年);//年
日志(信息.月);//月
日志(信息.日);//日
日志(信息.星期);//星期
日志(信息.时);//时
日志(信息.分);//分
日志(信息.秒);//秒
日志(信息.毫秒);//毫秒
```


### const {int} 年;

> 年


### const {int} 月;

> 月


### const {int} 日;

> 日


### const {int} 星期;

> 星期


### const {int} 时;

> 时


### const {int} 分;

> 分


### const {int} 秒;

> 秒


### const {int} 毫秒;

> 毫秒


### 获取时间戳()

> 获得时间戳

- 返回 : {长整数} 时间戳
- 版本 : 1.7.0


```javascript
定义 信息 = $日期.信息("2025/12/08 12-35-24");
日志(信息.获取时间戳());
```


### 获取年()

> 获得年

- 返回 : {整数} 年
- 版本 : 1.7.0


```javascript
定义 信息 = $日期.信息("2025/12/08 12-35-24");
日志(信息.获取年());
```


### 获取月()

> 获得月

- 返回 : {整数} 月
- 版本 : 1.7.0


```javascript
定义 信息 = $日期.信息("2025/12/08 12-35-24");
日志(信息.获取月());
```


### 获取日()

> 获得日

- 返回 : {整数} 日
- 版本 : 1.7.0


```javascript
定义 信息 = $日期.信息("2025/12/08 12-35-24");
日志(信息.获取日());
```


### 获取星期()

> 获得星期

- 返回 : {整数} 星期
- 版本 : 1.7.0


```javascript
定义 信息 = $日期.信息("2025/12/08 12-35-24");
日志(信息.获取星期());
```


### 获取时()

> 获得时

- 返回 : {整数} 时
- 版本 : 1.7.0


```javascript
定义 信息 = $日期.信息("2025/12/08 12-35-24");
日志(信息.获取时());
```


### 获取分()

> 获得分

- 返回 : {整数} 分
- 版本 : 1.7.0


```javascript
定义 信息 = $日期.信息("2025/12/08 12-35-24");
日志(信息.获取分());
```


### 获取秒()

> 获得秒

- 返回 : {整数} 秒
- 版本 : 1.7.0


```javascript
定义 信息 = $日期.信息("2025/12/08 12-35-24");
日志(信息.获取秒());
```


### 获取毫秒()

> 获得毫秒

- 返回 : {整数} 毫秒
- 版本 : 1.7.0


```javascript
定义 信息 = $日期.信息("2025/12/08 12-35-24");
日志(信息.获取毫秒());
```


### json()

> 转换为JSON字符串

- 返回 : {string} JSON字符串


# $date - 日期工具

- 更新时间:2025-12-13 11:58:44

> 日期工具




### 日期时间()

> 当前日期时间字符串

- 返回 : {字符串} 日期时间字符串,格式为:yyyy-MM-dd HH:mm:ss
- 版本 : 1.6.8


```javascript
定义 日期时间字符串 = $日期.日期时间();
提示("日期",日期时间字符串);//2025-10-25 18:32:53
```


### 日期时间(时间戳)

> 当前日期时间字符串
> 
> 指定时间戳,获得日期和时间的字符串

- 参数 : 时间戳 {数字} 时间戳
- 返回 : {字符串} 日期时间字符串,格式为:yyyy-MM-dd HH:mm:ss
- 版本 : 1.6.8


```javascript
定义 日期时间字符串 = $日期.日期时间(1747985594110);
提示("日期",日期时间字符串);
```


### 日期时间(时间字符串)

> 当前日期时间字符串
> 
> 指定时间字符串,获得日期和时间的字符串

- 参数 : 时间字符串 {字符串} 时间字符串
- 返回 : {字符串} 日期时间字符串,格式为:yyyy-MM-dd HH:mm:ss
- 版本 : 1.6.8


```javascript
定义 日期时间字符串 = $日期.日期时间("2025/12/08 12/35/24");
提示("日期",日期时间字符串);//2025-12-08 12:35:24
```


### 日期()

> 当前日期字符串

- 返回 : {字符串} 日期字符串,格式为:yyyy-MM-dd
- 版本 : 1.6.8


```javascript
定义 日期字符串 = $日期.日期();
提示("日期",日期字符串);//2025-05-23
```


### 日期(时间戳)

> 当前日期字符串
> 
> 指定时间戳,获得日期的字符串

- 参数 : 时间戳 {数字} 时间戳
- 返回 : {字符串} 日期字符串,格式为:yyyy-MM-dd
- 版本 : 1.6.8


```javascript
定义 日期字符串 = $日期.日期(1747985594110);
提示("日期",日期字符串);//2025-05-23
```


### 解析(时间字符串, 模板字符串)

> 解析日期

- 参数 : 时间字符串 {字符串} 日期字符串
- 参数 : 模板字符串 {字符串} 日期格式
- 返回 : {Date} 日期对象
- 版本 : 1.6.8


```javascript
//时间字符串的格式和后面解析模板的格式保持一致
//这样才能解析成功
定义 日期对象 = $日期.解析("2025/12/08 12/35/24","yyyy/MM/dd HH/mm/ss");
提示("日期",日期对象);//Mon Dec 08 12:35:24 GMT+08:00 2025
```


### 解析(日期字符串)

> 解析日期
> 
> 内部预制了27种字符串的情况,自动使用这些情况的模板去匹配日期字符串
> 
> 如果解析失败,返回null

- 参数 : 日期字符串 {字符串} 日期字符串
- 返回 : {Date} 日期对象
- 版本 : 1.6.8


```javascript
//自动解析
定义 日期对象 = $日期.解析("2025/12/08 12/35/24");
提示("日期",日期对象);//Mon Dec 08 12:35:24 GMT+08:00 2025
```


### 信息()

> 获取日期信息
> 
> 将当前日期的各个字段都分析出来,并且返回

- 返回 : {DateInfo} 日期信息对象
- 版本 : 1.6.8


```javascript
//获取当前日期信息
定义 信息 = $日期.信息();
提示("日期",信息);
```


### 信息(时间戳)

> 获取指定时间日期信息
> 
> 指定时间戳,并且获得这个时间的所有信息

- 参数 : 时间戳 {数字}  时间戳
- 返回 : {DateInfo} 日期信息对象
- 版本 : 1.6.8


```javascript
//解析指定时间戳的日期信息
定义 信息 = $日期.信息(1747985594110);
提示("日期",信息);
```


### 信息(时间字符串)

> 获取指定时间日期信息
> 
> 指定字符串时间,并且获得这个时间的所有信息

- 参数 : 时间字符串 {字符串}  时间字符串
- 返回 : {DateInfo} 日期信息对象
- 版本 : 1.6.8


```javascript
//解析指定时间戳的日期信息
定义 信息 = $日期.信息("2025/12/08 12-35-24");
提示("日期",信息);
```


### 格式化(时间戳, 模板字符串)

> 格式化日期

- 参数 : 时间戳 {数字} 时间戳
- 参数 : 模板字符串 {字符串} 日期格式
- 返回 : {字符串} 日期字符串
- 版本 : 1.6.8


```javascript
//第一个参数:日期时间戳
//第二个参数:自己想要的格式
定义 信息 = $日期.格式化(1747985594110,"yyyy年MM月dd日 HH时mm分ss秒");
提示("日期",信息);//2025年05月23日 15时33分14秒
```


### 格式化(日期对象, 模板字符串)

> 格式化日期

- 参数 : 日期对象 {Date} 日期
- 参数 : 模板字符串 {字符串} 日期格式
- 返回 : {字符串} 日期字符串
- 版本 : 1.6.8


```javascript
//获取java中的日期对象
定义 日期 = 新建 java.util.Date();
//转为字符串
定义 信息 = $日期.格式化(日期,"yyyy年MM月dd日 HH时mm分ss秒");
提示("日期",信息);//2025年05月23日 15时59分50秒
```


### 格式化(日期字符串, 模板格式)

> 格式化日期

- 参数 : 日期字符串 {字符串} 标准日期字符串
- 参数 : 模板格式 {字符串} 日期格式,自定义的字符串
- 返回 : {字符串} 日期字符串
- 版本 : 1.6.8


```javascript
//第一个参数:比较乱的日期字符串
//第二个参数:自己想要的格式
定义 信息 = $日期.格式化("2025/12/08 12-35-24","yyyy年MM月dd日 HH时mm分ss秒");
提示("日期",信息);//2025年12月08日 12时35分24秒
```


### 创建日期()

> 创建日期
> 
> 从当前时间创建一个日期对象

- 返回 : {Date} 当前日期
- 版本 : 1.6.8


```javascript
定义 信息 = $日期.创建日期();
提示("日期",信息);//Fri May 23 15:56:07 GMT+08:00 2025
```


### 创建日期(时间戳)

> 创建日期
> 
> 从指定时间戳中创建日期对象

- 参数 : 时间戳 {数字} 时间戳
- 返回 : {Date} 当前日期
- 版本 : 1.6.8


```javascript
定义 信息 = $日期.创建日期(1747985594110);
提示("日期",信息);//Fri May 23 15:33:14 GMT+08:00 2025
```


### 创建日期(日期字符串)

> 创建日期
> 
> 从字符串中创建日期对象，效果和'解析(日期字符串)'函数一样，内部预制了27种字符串的情况,自动使用这些情况的模板去匹配日期字符串，如果解析失败,返回null

- 参数 : 日期字符串 {字符串} 日期字符串
- 返回 : {Date} 日期对象
- 版本 : 1.6.8


```javascript
定义 信息 = $日期.创建日期("2025/12/08 12-35-24");
提示("日期",信息);//Mon Dec 08 12:35:24 GMT+08:00 2025
```


### 时间字符串(毫秒)

> 将毫秒数转换为时间字符串 "x天x时x分x秒"

- 参数 : 毫秒 {数字}  毫秒数
- 返回 : {字符串} 格式化的时间字符串
- 版本 : 1.6.8


```javascript
定义 时间字符串 = $日期.时间字符串(1234567890);
提示("时间",时间字符串);//14天6时56分7秒
```


### 当前时间()

> 获取当前时间戳

- 返回 : {长整数} 时间戳
- 版本 : 1.7.8


```javascript
定义 时间戳 = $日期.当前时间();
提示("时间戳",时间戳);
```


# $device - 设备信息

- 更新时间:2025-12-13 11:58:44

> 设备信息




### const {int} 宽度;

> 屏幕的宽度


### const {int} 高度;

> 屏幕的高度


### const {String} buildId;

> Build ID


### const {String} buildDisplay;

> Build Display


### const {String} 产品;

> 产品名称


### const {String} 主板;

> 主板名称


### const {String} 品牌;

> 品牌名称


### const {String} 设备;

> 设备名称


### const {String} 型号;

> 型号名称


### const {String} 引导程序;

> 引导加载程序名称


### const {String} 硬件;

> 硬件名称


### const {String} 指纹;

> 指纹信息


### const {int} sdk版本号;

> SDK版本号


### const {String} 内部版本;

> 内部版本号


### const {String} 发行版;

> Android版本号


### const {String} 开发代号;

> 开发代号


### const {String} 序列号;

> 序列号


### const {String} 操作系统版本;

> 基础操作系统版本
> 
> 仅在Android 6.0及更高版本中有效


### const {String} 安全补丁版本;

> 安全补丁版本
> 
> 仅在Android 6.0及更高版本中有效


### 获取imei()

> 获取IMEI号码

- 返回 : {字符串} IMEI号码
- 版本 : 1.7.0


```javascript
日志("IMEI:", $设备.获取imei());
```


### 获取安卓id()

> 获取Android ID

- 返回 : {字符串} Android ID
- 版本 : 1.7.0


```javascript
日志("Android ID:", $设备.获取安卓id());
```


### 获取屏幕亮度()

> 获取屏幕亮度

- 返回 : {整数} 屏幕亮度
- 版本 : 1.7.0


```javascript
日志("屏幕亮度:", $设备.获取屏幕亮度());
```


### 获取屏幕亮度模式()

> 获取屏幕亮度模式

- 返回 : {整数} 亮度模式
- 版本 : 1.7.0


```javascript
日志("屏幕亮度模式:", $设备.获取屏幕亮度模式());
```


### 获取音乐音量()

> 获取音乐音量

- 返回 : {整数} 音乐音量值
- 版本 : 1.7.0


```javascript
日志("音乐音量:", $设备.获取音乐音量());
```


### 获取通知音量()

> 获取通知音量

- 返回 : {整数} 通知音量值
- 版本 : 1.7.0


```javascript
日志("通知音量:", $设备.获取通知音量());
```


### 获取闹钟音量()

> 获取闹钟音量

- 返回 : {整数} 闹钟音量值
- 版本 : 1.7.0


```javascript
日志("闹钟音量:", $设备.获取闹钟音量());
```


### 获取音乐最大音量()

> 获取音乐最大音量

- 返回 : {整数} 音乐最大音量值
- 版本 : 1.7.0


```javascript
日志("音乐最大音量:", $设备.获取音乐最大音量());
```


### 获取通知最大音量()

> 获取通知最大音量

- 返回 : {整数} 通知最大音量值
- 版本 : 1.7.0


```javascript
日志("通知最大音量:", $设备.获取通知最大音量());
```


### 获取闹钟最大音量()

> 获取闹钟最大音量

- 返回 : {整数} 闹钟最大音量值
- 版本 : 1.7.0


```javascript
日志("闹钟最大音量:", $设备.获取闹钟最大音量());
```


### 获取电量百分比()

> 电池电量百分比

- 返回 : {整数} 电池电量百分比
- 版本 : 1.7.0


```javascript
日志("电池电量百分比:", $设备.获取电量百分比());
```


### 获取总内存()

> 获取总内存

- 返回 : {长整数} 总内存大小，单位为字节
- 版本 : 1.7.0


```javascript
日志("总内存:", $设备.获取总内存());
```


### 获取可用内存()

> 获取可用内存

- 返回 : {长整数} 可用内存大小，单位为字节
- 版本 : 1.7.0


```javascript
日志("可用内存:", $设备.获取可用内存());
```


### 是充电中()

> 是否正在充电

- 返回 : {布尔值} 如果设备正在充电则返回true，否则返回false
- 版本 : 1.7.0


```javascript
日志("是否正在充电:", $设备.是充电中());
```


### 是亮屏的()

> 判断设备屏幕是否亮起

- 返回 : {布尔值} true:亮起
- 版本 : 1.7.0


```javascript
日志("是否亮起:", $设备.是亮屏的());
```


### 是息屏的()

> 判断设备屏幕是否熄灭

- 返回 : {布尔值} true:熄灭
- 版本 : 1.7.0


```javascript
日志("是否熄灭:", $设备.是息屏的());
```


### 唤醒设备()

> 唤醒设备屏幕

- 版本 : 1.7.0


```javascript
// 唤醒设备屏幕
$设备.唤醒设备();
```


### 保持屏幕常亮()

> 保持设备屏幕常亮

- 版本 : 1.7.0


```javascript
// 保持屏幕常亮
$设备.保持屏幕常亮();
```


### 保持屏幕常亮(timeout)

> 保持设备屏幕常亮一段时间

- 参数 : timeout {长整数} 保持屏幕常亮的超时时间，单位为毫秒
- 版本 : 1.7.0


```javascript
// 保持屏幕常亮
$设备.保持屏幕常亮(1000);
```


### 保持屏幕低亮()

> 保持设备屏幕处于低亮度状态

- 版本 : 1.7.0


```javascript
// 保持屏幕低亮
$设备.保持屏幕低亮();
```


### 保持屏幕低亮(timeout)

> 保持设备屏幕处于低亮度状态

- 版本 : 1.7.0


```javascript
// 保持屏幕低亮
$设备.保持屏幕低亮(1000);
```


### 取消唤醒()

> 取消保持唤醒

- 版本 : 1.7.0


```javascript
// 取消唤醒
$设备.取消唤醒();
```


### 震动(时长)

> 震动指定时长

- 参数 : 时长 {长整数} 震动的时长，单位:ms
- 版本 : 1.7.0


```javascript
// 震动
$设备.震动(1000);
```


### 取消震动()

> 取消震动

- 版本 : 1.7.0


```javascript
// 取消震动
$设备.取消震动();
```


### 获取mac地址()

> 获取 MAC 地址
> 首先尝试从 WifiManager 获取，如果获取到的是伪造的 MAC 地址则视为无效
> 若无效则尝试通过网络接口获取，若还是无效且系统版本大于等于 Android 7.0（N），
> 则尝试从文件中读取

- 返回 : MAC 地址，如果无法获取则返回 null
- 版本 : 1.7.0


```javascript
// 获取mac地址
日志("mac地址:",$设备.获取mac地址());
```


### 有导航栏()

> 是否存在导航栏

- 返回 : {布尔值} 是否存在NavigationBar
- 版本 : 1.7.0


```javascript
// 是否存在导航栏
日志("是否存在导航栏:",$设备.有导航栏());
```


### 获取导航栏高度()

> 获取虚拟功能键高度

- 返回 : {整数} 虚拟功能键高度
- 版本 : 1.7.0


```javascript
// 导航栏高度
日志("导航栏高度:",$设备.获取导航栏高度());
```


### 是锁定的()

> 判断设备是否锁定

- 返回 : {布尔值} 是否锁定
- 版本 : 1.7.0


```javascript
// 设备是否锁定
日志("设备是否锁定:",$设备.是锁定的());
```


# $draw - 全屏绘制

- 更新时间:2025-12-13 11:58:44

> 全屏绘制




### 系统限制

在全局绘制框架中，绝大多数情况都会使用到全屏悬浮窗，但是这种方式在部分手机上用户手势会被拦截，这一类现象被称为"卡悬浮"。

```javascript
//这种悬浮窗是小型的，因此不会阻碍到用户手势(无论在任何系统中都适用)
$draw.i("信息");
$draw.d("调试");
$draw.w("警告");
```

经过测试，在MIUI系列的手机中，手机厂家会拦截悬浮窗手势，无论用何种悬浮窗类型，都无效，这是厂家在系统中刻下的基因。

```javascript
//这种悬浮窗是全屏的，对于MIUI的手机(小米红米之类的)会导致拦截用户手势而无法操作界面
$draw.i("信息",100,100);
$draw.d("调试",100,100);
$draw.w("警告",100,100);
$draw.rect(100,100,200,200); //绘制方框
$draw.line(100,100,200,200); //绘制线条
```

全屏绘制类的函数：例如：绘制线、文本、方框等，在ColorOS下(或者大多数国产安卓模拟器)，系统会提示是否允许显示在上层(安卓模拟器大多数默认允许)，经过用户允许之后就可以正常绘制并且不阻碍用户使用手机，
但是在MIUI系统中，没有任何提示，经调试发现该类系统会直接拦截所有用户手势，据了解是为了安全才如此设计。

作为开发者，你必须谨慎使用全局绘制，并不是所有手机都开放了全屏悬浮窗时的触摸事件。

:::tip
在1.8.0版本后，支持在root或者shizuku授权下，会自动尝试解锁卡悬浮，允许悬浮窗的触摸事件到达底层。
:::


### 获取权限()

> 获取悬浮窗权限

- 返回 : {布尔值} 是否有权限
- 版本 : 1.6.8


```javascript
$绘制.获取权限();
```


### 方框(矩形)

> 绘制一个方框

- 参数 : 矩形 {Rect} opencv的Rect对象
- 版本 : 1.6.8


```javascript
//绘制矩形
定义 矩形 = new org.opencv.core.Rect(0,0,100,100);
$绘制.方框(矩形);
```


### 方框(节点)

> 绘制一个方框

- 参数 : 节点 {Node} 节点信息
- 版本 : 1.6.8


```javascript
//绘制矩形
$绘制.方框(node);
```


### 方框(x, y, 宽, 高)

> 绘制一个方框

- 参数 : x {int} 起点x
- 参数 : y {int} 起点y
- 参数 : 宽 {int} 宽度
- 参数 : 高 {int} 高度
- 版本 : 1.6.8


```javascript
//绘制矩形
$绘制.方框(200,200,200,100);
```


### 方框(x, y, 宽, 高, 颜色)

> 绘制一个方框

- 参数 : x {int} 起点x
- 参数 : y {int} 起点y
- 参数 : 宽 {int} 宽度
- 参数 : 高 {int} 高度
- 参数 : 颜色 {字符串} 颜色
- 版本 : 1.6.8


```javascript
//绘制矩形
$绘制.方框(200,200,200,100,"#FF0000");
```


### 方框(x, y, 宽, 高, 拓展宽度)

> 绘制方框

- 参数 : x {int} 起点x
- 参数 : y {int} 起点y
- 参数 : 宽 {int} 宽度
- 参数 : 高 {int} 高度
- 参数 : 拓展宽度 {int} 向四周拓展
- 版本 : 1.6.8


```javascript
//绘制一个向外拓展50像素的矩阵
$绘制.方框(200,200,200,100,50);
```


### 方框(x, y, 宽, 高, 拓展宽度, 颜色)

> 绘制方框

- 参数 : x {int} 起点x
- 参数 : y {int} 起点y
- 参数 : 宽 {int} 宽度
- 参数 : 高 {int} 高度
- 参数 : 拓展宽度 {int} 向四周拓展
- 参数 : 颜色 {字符串} 颜色
- 版本 : 1.6.8


```javascript
//绘制一个向外拓展50像素的矩阵
$绘制.方框(200,200,200,100,50,"#FF0000");
```


### 方框(x, y, 宽, 高, 拓展宽度, 颜色)

> 绘制方框

- 参数 : x {int} 起点x
- 参数 : y {int} 起点y
- 参数 : 宽 {int} 宽度
- 参数 : 高 {int} 高度
- 参数 : 拓展宽度 {int} 向四周拓展
- 参数 : 颜色 {int} 颜色
- 版本 : 1.6.8


```javascript
//绘制一个向外拓展50像素的矩阵
$绘制.方框(200,200,200,100,50,$颜色.红色);
```


### 方框(数组, 拓展宽度, 颜色)

> 绘制方框

- 参数 : 数组 {数字[]} 范围数组
- 参数 : 拓展宽度 {数字} 向四周拓展
- 参数 : 颜色 {数字} 颜色
- 版本 : 1.8.2


```javascript
//绘制一个向外拓展50像素的矩阵
$绘制.方框([200,200,200,100],50,$颜色.红色);
```


### 方框(数组, 拓展宽度, 颜色)

> 绘制方框

- 参数 : 数组 {数字[]} 范围数组
- 参数 : 拓展宽度 {数字} 向四周拓展
- 参数 : 颜色 {字符串} 颜色
- 版本 : 1.8.2


```javascript
//绘制一个向外拓展50像素的矩阵
$绘制.方框([200,200,200,100],50,"#FF0000");
```


### 准心(位置)

> 绘制一个十字准心

- 参数 : 位置 {point} opencv的位置
- 版本 : 1.6.8


```javascript
定义 位置 = new org.opencv.core.Point(100,100);
//绘制准心
$绘制.准心(位置);
```


### 准心(位置)

> 绘制一个十字准心

- 参数 : 位置 {int[]} 位置
- 版本 : 1.6.8


```javascript
//绘制准心
$绘制.准心([400,500]);
```


### 准心(节点)

> 绘制一个十字准心

- 参数 : 节点 {AccessibilityNodeInfo} 节点信息
- 版本 : 1.6.8


```javascript
//绘制准心
$绘制.准心(原生节点对象);
```


### 准心(节点)

> 绘制一个十字准心

- 参数 : 节点 {Node} 节点信息
- 版本 : 1.6.8


```javascript
//绘制准心
$绘制.准心(封装节点对象);
```


### 准心(x, y)

> 绘制一个十字准心

- 参数 : x {int} 中心x
- 参数 : y {int} 中心y
- 版本 : 1.6.8


```javascript
//绘制准心
$绘制.准心(400,500);
```


### 准心(x, y, 颜色)

> 绘制一个十字准心

- 参数 : x {int} 中心x
- 参数 : y {int} 中心y
- 参数 : 颜色 {字符串} 颜色
- 版本 : 1.6.8


```javascript
//绘制准心
$绘制.准心(400,500,"#FF0000");
```


### 准心(x, y, 颜色)

> 绘制一个十字准心

- 参数 : x {int} 中心x
- 参数 : y {int} 中心y
- 参数 : 颜色 {int} 颜色值
- 版本 : 1.6.8


```javascript
//绘制准心
$绘制.准心(400,500,$颜色.红色);
```


### 点(位置)

> 绘制一个点

- 参数 : 位置 {int[]} 点
- 版本 : 1.6.8


```javascript
$绘制.点([400,500]);
```


### 点(位置)

> 绘制一个点

- 参数 : 位置 {point} 点
- 版本 : 1.6.8


```javascript
$绘制.点(point);
```


### 点(x, y)

> 绘制一个点

- 参数 : x {int} 点x
- 参数 : y {int} 点y
- 版本 : 1.6.8


```javascript
//绘制一个点
$绘制.点(400,500);
```


### 点(x, y, 颜色)

> 绘制一个点

- 参数 : x {int} 点x
- 参数 : y {int} 点y
- 参数 : 颜色 {字符串} 颜色
- 版本 : 1.6.8


```javascript
//绘制一个点
$绘制.点(400,500);
```


### 点(x, y, 颜色)

> 绘制一个点

- 参数 : x {int} 点x
- 参数 : y {int} 点y
- 参数 : 颜色 {int} 颜色值
- 版本 : 1.6.8


```javascript
//绘制一个点
$绘制.点(400,500,$颜色.红色);
```


### 文字(文本, x, y)

> 绘制文字

- 参数 : 文本 {String} 文字
- 参数 : x {int} 起点x
- 参数 : y {int} 起点y
- 版本 : 1.6.8


```javascript
//绘制文字(默认字体大小:15dp)
$绘制.文字("Hello aigame !",400,300);
```


### 文字(文字, x, y, 字体大小)

> 绘制文字

- 参数 : 文字 {String} 文字
- 参数 : x {int} 起点x
- 参数 : y {int} 起点y
- 参数 : 字体大小 {float} 字体大小
- 版本 : 1.6.8


```javascript
//绘制文字(大小为16dp)
$绘制.文字("Hello aigame !",400,400,16);
```


### 文字(文字, x, y, 字体大小, 颜色)

> 绘制文字

- 参数 : 文字 {字符串} 文字
- 参数 : x {int} 起点x
- 参数 : y {int} 起点y
- 参数 : 字体大小 {int} 字体大小
- 参数 : 颜色 {字符串} 颜色
- 版本 : 1.6.8


```javascript
//绘制文字(大小为16dp)
$绘制.文字("Hello aigame !",400,400,16,"#FF0000");
```


### 文字(文字, x, y, 字体大小, 颜色)

> 绘制文字

- 参数 : 文字 {String} 文字
- 参数 : x {int} 起点x
- 参数 : y {int} 起点y
- 参数 : 字体大小 {int} 字体大小
- 参数 : 颜色 {int} 颜色值
- 版本 : 1.6.8


```javascript
//绘制文字(大小为16dp)
$绘制.文字("Hello aigame !",400,400,16,$颜色.红色);
```


### 圆(x, y)

> 绘制一个圆形
> 
> 半径默认为50像素

- 参数 : x {int} 圆心x
- 参数 : y {int} 圆心y
- 版本 : 1.6.8


```javascript
//绘制半径为50像素的圆形
$绘制.圆(350,400);
```


### 圆(x, y, 半径)

> 绘制一个圆形

- 参数 : x {int} 圆心x
- 参数 : y {int} 圆心y
- 参数 : 半径 {int} 圆形半径
- 版本 : 1.6.8


```javascript
//绘制半径为100像素的圆形
$绘制.圆(350,400,100);
```


### 圆(x, y, 半径, 拓展宽度)

> 绘制一个圆形

- 参数 : x {int} 圆心x
- 参数 : y {int} 圆心y
- 参数 : 半径 {int} 圆形半径
- 参数 : 拓展宽度 {int} 圆形向四周拓展
- 版本 : 1.6.8


```javascript
//向外拓展50像素
$绘制.圆(350,400,100,50);
```


### 圆(x, y, r, 拓展宽度, 颜色)

> 绘制一个圆形

- 参数 : x {int} 圆心x
- 参数 : y {int} 圆心y
- 参数 : r {int} 圆形半径
- 参数 : 拓展宽度 {int} 圆形向四周拓展
- 参数 : 颜色 {字符串} 颜色
- 版本 : 1.6.8


```javascript
//向外拓展50像素
$绘制.圆(350,400,100,50,"#FF0000");
```


### 圆(x, y, 半径, 拓展宽度, 颜色值)

> 绘制一个圆形

- 参数 : x {int} 圆心x
- 参数 : y {int} 圆心y
- 参数 : 半径 {int} 圆形半径
- 参数 : 拓展宽度 {int} 圆形向四周拓展
- 参数 : 颜色值 {int} 颜色值
- 版本 : 1.1.1


```javascript
//向外拓展50像素
$绘制.圆(350,400,100,50,$颜色.红色);
```


### 图片(图片, x, y, 宽, 高)

> 绘制图片

- 参数 : 图片 {Image} 图片对象
- 参数 : x {int} 起点x
- 参数 : y {int} 起点y
- 参数 : 宽 {int} 宽度(绘制后的图片宽度)
- 参数 : 高 {int} 高度(绘制后的图片宽度)
- 版本 : 1.6.8


```javascript
定义 图片 = $图片.读取("小猫.png");
//绘制图片
$绘制.图片(图片,200,200,100,150);
```


### 直线(起点x, 起点y, 目标x, 目标y)

> 绘制一条线

- 参数 : 起点x {int} 起点x
- 参数 : 起点y {int} 起点y
- 参数 : 目标x {int} 目标x
- 参数 : 目标y {int} 目标y
- 版本 : 1.6.8


```javascript
//绘制一条线
$绘制.直线(300,0,100,1000);
```


### 直线(起点x, 起点y, 目标x, 目标y, 颜色)

> 绘制一条线

- 参数 : 起点x {int} 起点x
- 参数 : 起点y {int} 起点y
- 参数 : 目标x {int} 目标x
- 参数 : 目标y {int} 目标y
- 参数 : 颜色 {字符串} 颜色
- 版本 : 1.6.8


```javascript
//绘制一条线
$绘制.直线(300,0,100,1000,"#FF0000");
```


### 直线(起点x, 起点y, 目标x, 目标y, 颜色)

> 绘制一条线

- 参数 : 起点x {int} 起点x
- 参数 : 起点y {int} 起点y
- 参数 : 目标x {int} 目标x
- 参数 : 目标y {int} 目标y
- 参数 : 颜色 {int} 颜色值
- 版本 : 1.6.8


```javascript
//绘制一条线
$绘制.直线(300,0,100,1000,$颜色.红色);
```


### 路径(路径数据)

> 绘制路径，传入的就是x和y的数组

- 参数 : 路径数据 {int[][]} 二维数组，第二维数组是坐标
- 版本 : 1.6.8


```javascript
//国际通用手势
$绘制.路径([
    [100, 800],
    [120, 750],
    [150, 720],
    [180, 750],
    [200, 800],
    [200, 800],
    [220, 700],
    [250, 680],
    [280, 700],
    [300, 800],
    [300, 800],
    [320, 250],
    [350, 200],
    [380, 250],
    [400, 800],
    [400, 800],
    [420, 740],
    [450, 730],
    [480, 740],
    [500, 800],
    [500, 800],
    [520, 770],
    [550, 760],
    [580, 770],
    [600, 800]
]);
```


### 路径(路径数据, 颜色)

> 绘制路径，传入的就是x和y的数组

- 参数 : 路径数据 {int[][]} 二维数组，第二维数组是坐标
- 参数 : 颜色 {字符串} 颜色
- 版本 : 1.6.8


```javascript
//国际通用手势
$绘制.路径([
    [100, 800],
    [120, 750],
    [150, 720],
    [180, 750],
    [200, 800],
    [200, 800],
    [220, 700],
    [250, 680],
    [280, 700],
    [300, 800],
    [300, 800],
    [320, 250],
    [350, 200],
    [380, 250],
    [400, 800],
    [400, 800],
    [420, 740],
    [450, 730],
    [480, 740],
    [500, 800],
    [500, 800],
    [520, 770],
    [550, 760],
    [580, 770],
    [600, 800]
],"#FF0000");
```


### 路径(路径数据, 颜色值)

> 绘制路径，传入的就是x和y的数组

- 参数 : 路径数据 {int[][]} 二维数组，第二维数组是坐标
- 参数 : 颜色值 {int} 颜色值
- 版本 : 1.6.8


```javascript
//国际通用手势
$绘制.路径([
    [100, 800],
    [120, 750],
    [150, 720],
    [180, 750],
    [200, 800],
    [200, 800],
    [220, 700],
    [250, 680],
    [280, 700],
    [300, 800],
    [300, 800],
    [320, 250],
    [350, 200],
    [380, 250],
    [400, 800],
    [400, 800],
    [420, 740],
    [450, 730],
    [480, 740],
    [500, 800],
    [500, 800],
    [520, 770],
    [550, 760],
    [580, 770],
    [600, 800]
],$颜色.红色);
```


### 信息(文本, x, y, 字体大小)

> 绘制日志文字

- 参数 : 文本 {字符串} 文字
- 参数 : x {小数} 字体大小
- 版本 : 1.6.8


```javascript
$绘制.信息("信息",400,300,40);
```


### 信息(文字, x, y)

> 绘制日志文字

- 参数 : 文字 {字符串} 文字
- 版本 : 1.0.0


```javascript
$绘制.信息("信息",400,300);
```


### 信息(文字)

> 绘制日志文字

- 参数 : 文字 {字符串} 文字
- 版本 : 1.6.8


```javascript
$绘制.信息("信息");
```


### 调试(文字, x, y, 字体大小)

> 绘制日志文字

- 参数 : 文字 {字符串} 文字
- 参数 : x {小数} 字体大小
- 版本 : 1.6.8


```javascript
$绘制.调试("调试",400,300,40);
```


### 调试(文字, x, y)

> 绘制日志文字

- 参数 : 文字 {字符串} 文字
- 版本 : 1.6.8


```javascript
$绘制.调试("调试",400,300);
```


### 调试(文字)

> 绘制日志文字

- 参数 : 文字 {字符串} 文字
- 版本 : 1.6.8


```javascript
$绘制.调试("调试");
```


### 警告(文字, x, y, 字体大小)

> 绘制日志文字

- 参数 : 文字 {字符串} 文字
- 参数 : x {小数} 字体大小
- 版本 : 1.6.8


```javascript
$绘制.警告("警告",400,300,40);
```


### 警告(文字, x, y)

> 绘制日志文字

- 参数 : 文字 {字符串} 文字
- 版本 : 1.6.8


```javascript
$绘制.警告("警告",400,300);
```


### 警告(文字)

> 绘制日志文字

- 参数 : 文字 {字符串} 文字
- 版本 : 1.6.8


```javascript
$绘制.警告("警告");
```


### 异常(文字, x, y, 字体大小)

> 绘制日志文字

- 参数 : 文字 {字符串} 文字
- 参数 : x {小数} 字体大小
- 版本 : 1.6.8


```javascript
$绘制.异常("错误",400,300,40);
```


### 异常(文字, x, y)

> 绘制日志文字

- 参数 : 文字 {字符串} 文字
- 版本 : 1.6.8


```javascript
$绘制.异常("错误",400,300);
```


### 异常(文字)

> 绘制日志文字

- 参数 : 文字 {字符串} 文字
- 版本 : 1.6.8


```javascript
$绘制.异常("错误");
```


### 忽略(文字, x, y, 字体大小)

> 绘制日志文字

- 参数 : 文字 {字符串} 文字
- 参数 : x {小数} 字体大小
- 版本 : 1.6.8


```javascript
$绘制.忽略("信息",400,300,40);
```


### 忽略(文字, x, y)

> 绘制日志文字

- 参数 : 文字 {字符串} 文字
- 版本 : 1.6.8


```javascript
$绘制.忽略("信息",400,300);
```


### 忽略(文字)

> 绘制日志文字

- 参数 : 文字 {字符串} 文字
- 版本 : 1.6.8


```javascript
$绘制.忽略("信息");
```


### 日志(文字, 颜色, x, y, 字体大小)

> 绘制日志文字

- 参数 : 文字 {字符串} 文字
- 参数 : 颜色 {字符串} 颜色
- 参数 : x {int} 位置x
- 参数 : y {int} 位置y
- 参数 : 字体大小 {float} 字体大小
- 版本 : 1.6.8


```javascript
//字体大小单位:dp
$绘制.日志("信息","#57965C",400,300,20);
```


### 日志(文字, 颜色, x, y)

> 绘制日志文字

- 参数 : 文字 {字符串} 文字
- 参数 : 颜色 {字符串} 颜色
- 参数 : x {int} 位置x
- 参数 : y {int} 位置y
- 版本 : 1.6.8


```javascript
$绘制.日志("信息","#57965C",400,300);
```


### 日志(文字, 颜色)

> 绘制日志文字

- 参数 : 文字 {字符串} 文字
- 参数 : 颜色 {字符串} 颜色
- 版本 : 1.6.8


```javascript
$绘制.日志("信息","#57965C");
```


### 日志(文字)

> 绘制日志文字

- 参数 : 文字 {字符串} 文字
- 版本 : 1.6.8


```javascript
$绘制.日志("信息");
```


### 日志(文字, x, y)

> 绘制日志文字

- 参数 : 文字 {字符串} 文字
- 参数 : x {int} 位置x
- 参数 : y {int} 位置y
- 版本 : 1.6.8


```javascript
$绘制.日志("信息",400,300);
```


### 关闭全部()

> 关闭绘制日志的悬浮窗

- 版本 : 1.6.8


```javascript
//关闭所有绘制图案
$绘制.关闭全部();
```


### 关闭全部(延迟)

> 关闭绘制日志的悬浮窗

- 参数 : 延迟 {长整数} 延迟关闭时间
- 版本 : 1.6.8


```javascript
$绘制.关闭全部(1000);
```


### 关闭日志(延迟)

> 关闭绘制日志的悬浮窗

- 参数 : 延迟 {长整数} 延迟关闭时间
- 版本 : 1.6.8


```javascript
$绘制.关闭日志(1000);
```


### 关闭日志()

> 关闭绘制日志的悬浮窗

- 版本 : 1.6.8


```javascript
$绘制.关闭日志();
```


### 清空()

> 清空所有绘制
> 
> 清空绘制本质上也是绘制的一种，因此它和其他绘制函数一样，会优先判断当前悬浮窗是否开启，
> 如果悬浮窗没有开启，则创建一个全局悬浮窗至于屏幕最上层，之后绘制透明颜色以达到清空的效果。
> 
> 如果你已经绘制过图案了，那么此时是存在顶层悬浮窗的，调用次函数的时候会直接绘制透明颜色以达到清空的效果。
> 
> 如果你不理解什么是绘制透明颜色，可以理解为：画布中的橡皮擦（本质上是把橡皮经过的位置绘制成透明颜色）

- 版本 : 1.6.8


```javascript
//清空全局绘制
$绘制.清空();
```


# JsTaskInfo - 脚本任务信息

- 更新时间:2025-12-13 11:58:45

> 脚本任务信息




### const {String} ID;

> 任务ID


### const {String} 开始时间;

> 开始执行的时间


### const {String} 结束时间;

> 执行结束时的时间


### const {String} 运行时长;

> 执行时常


### const {String} 名称;

> 脚本名称


### const {String} 路径;

> 脚本路径


### 获取id()

> 任务ID

- 返回 : {字符串} 任务ID
- 版本 : 1.7.0


### 获取开始时间()

> 执行结束时的时间

- 返回 : {字符串} 执行结束时的时间
- 版本 : 1.7.0


### 获取名称()

> 执行结束时的时间

- 返回 : {字符串} 执行结束时的时间
- 版本 : 1.7.0


### 获取路径()

> 执行结束时的时间

- 返回 : {字符串} 执行结束时的时间
- 版本 : 1.7.0


# $task - 脚本任务

- 更新时间:2025-12-13 11:58:45

> 脚本任务
> 
> 每个正在执行的代码文件中都会内置一个专属对象：任务对象($task)
> 
> 你可以通过任务对象($task)来控制当前任务的执行
> 
> 你也可以通过任务对象($task)来获取当前任务的信息




### const {String} id;

> 任务唯一序列
> 
> 该序列会和当前线程名称保持一致

- 版本 : 1.7.0


```javascript
日志("当前任务唯一序列:",$任务.id);
```


### const {long} 开始时间;

> 当前任务的开始执行时间

- 版本 : 1.7.0


```javascript
日志("当前任务的开始执行时间:",$任务.开始时间);
```


### const {String} 名称;

> 当前任务名称
> 
> 有时也指路径或文件名称

- 版本 : 1.7.0


```javascript
日志("当前任务名称:",$任务.名称);
```


### const {String} 线程名称;

> 当前任务线程名称
> 
> 线程名称通常与ID相同

- 版本 : 1.7.0


```javascript
日志("当前任务线程名称:",$任务.线程名称);
```


### const {String} 路径;

> 当前脚本路径
> 
> 此属性并不重要，取决于执行脚本时传入的路径参数值，如果是临时文件，则路径是随机生成的。

- 版本 : 1.7.0


```javascript
日志("当前脚本路径:",$任务.路径);
```


### 停止()

> 停止任务
> 
> 每个任务($任务)都是一条新的线程，如果你的代码中存在死循环，则循环不会停止(因为循环会被当作一条命令执行，表示执行完毕这个命令了)，请处理好脚本逻辑。

- 版本 : 1.7.0


```javascript
$任务.停止();
```


### 获取信息()

> 获取脚本任务信息

- 返回 : {JsTaskInfo} 任务信息
- 版本 : 1.7.0


```javascript
定义 信息 = $任务.获取信息();
提示("任务信息",信息);
```


### 是运行的()

> 是否正在运行

- 返回 : {布尔值} 返回是否正在运行
- 版本 : 1.7.0


```javascript
如果($任务.是运行的()){
    提示("任务正在运行");
}否则{
    提示("任务已经停止运行");
}
```


### 获取id()

> 获取当前任务的ID

- 返回 : {字符串} 返回当前任务的ID
- 版本 : 1.7.0


```javascript
定义 id = $任务.获取id();
提示("任务ID",id);
```


### 获取开始时间()

> 获取当前任务的开始时间

- 返回 : {long} 返回当前任务的开始时间
- 版本 : 1.7.0


```javascript
定义 时间 = $任务.获取开始时间();
提示("任务开始时间",时间);
```


### 获取名称()

> 获取当前任务的名称

- 返回 : {字符串} 返回当前任务的名称
- 版本 : 1.7.0


```javascript
定义 线程名称 = $任务.获取名称();
提示("任务名称",线程名称);
```


### 获取线程名称()

> 获取当前任务的线程名称

- 返回 : {字符串} 返回当前任务的线程名称
- 版本 : 1.7.0


```javascript
定义 线程名称 = $任务.获取线程名称();
提示("线程名称",线程名称);
```


### 获取路径()

> 获取当前任务的脚本路径

- 返回 : {字符串} 返回当前任务的脚本路径
- 版本 : 1.7.0


```javascript
定义 路径 = $任务.获取路径();
提示("脚本路径",路径);
```


### 获取路径(相对路径)

> 获取相对当前脚本路径的绝对路径

- 参数 : 相对路径 {字符串} 相对路径
- 返回 : {字符串} 返回绝对路径
- 版本 : 1.7.0


```javascript
定义 路径 = $任务.获取路径("../res");
提示("相对路径",路径);
```


### 暂停()

> 暂停当前任务

- 版本 : 1.7.0


```javascript
//我演示一个错误的用法：
$任务.暂停();//当暂停以后，下面的代码不会被执行
//...其他代码
$任务.开始();//这行代码不被执行到，因此这样调用毫无意义
```


### 开始()

> 继续运行暂停的任务

- 版本 : 1.7.0


```javascript
$任务.开始();
```


### 是暂停的()

> 任务是否暂停

- 返回 : {布尔值} 是否暂停
- 版本 : 1.7.0


```javascript
日志("是否暂停",$任务.是暂停的());
```


### 是停止的()

> 判断任务是否停止
> 
> 只有当调用了'$任务.停止()'或者'$引擎.停止(ID)'或'$引擎.停止全部()'才会返回'真'

- 返回 : {布尔值} 是否停止
- 版本 : 1.7.0


```javascript
//因此，在多线程中正确书写死循环的方式：
$线程.运行(()=>{
    当(!$任务.是停止的()){
        日志("正在运行...");
        睡觉(1000);
    }
    日志("脚本停止");
});
```


# $engine - 脚本引擎

- 更新时间:2025-12-13 11:58:45

> 脚本引擎
> 
> 脚本引擎是全局唯一的对象，主要负责调度脚本的运行，脚本任务创建、运行、暂停、继续等操作都可以通过脚本引擎对象完成。




### 运行(脚本路径)

> 运行路径中的代码

- 参数 : 脚本路径 {字符串} 脚本路径
- 返回 : {字符串} 任务ID
- 版本 : 1.6.8


```javascript
定义 任务ID = $引擎.运行("/sdcard/脚本.js");
```


### 运行(js文件)

> 运行路径中的代码

- 参数 : js文件 {File} 代码文件
- 返回 : {字符串} 任务ID
- 版本 : 1.6.8


```javascript
定义 任务ID = $引擎.运行($文件.打开("/sdcard/脚本.js"));
```


### 运行代码(代码)

> 运行代码

- 参数 : 代码 {字符串} 代码 
- 返回 : {字符串} 任务ID
- 版本 : 1.6.8


```javascript
定义 任务ID = $引擎.运行代码(`
    提示("提示","我被运行了");
`);
```


### 运行代码(脚本路径, 代码)

> 运行代码
> 
> 此处传入的路径只是决定了$task中的上下文环境路径，但不是通过该路径读取文件内容，因此可以随意填写。

- 参数 : 脚本路径 {字符串} 路径(决定了$task的路径:$task.getPath()) 
- 参数 : 代码 {字符串} 代码 
- 返回 : {字符串} 任务ID
- 版本 : 1.6.8


```javascript
定义 任务ID = $引擎.运行代码("/sdcard/main.js",`
    提示("提示","我被运行了");
`);
```


### 暂停(任务ID)

> 暂停运行
> 
> 该方法会暂停未执行完毕的所有脚本

- 参数 : 任务ID {字符串} 任务ID 
- 版本 : 1.6.8


```javascript
定义 任务ID = $引擎.运行("/sdcard/脚本.js");
//暂停运行
$引擎.暂停(任务ID);
睡觉(2000);
//继续运行
$引擎.开始(任务ID);
```


### 暂停了(任务ID)

> 判断任务是否处于暂停状态
> 
> 遍历所有任务列表，查询这个id的任务是否处于暂停状态

- 参数 : 任务ID {字符串} 任务id 
- 返回 : {布尔值} false:运行态; true:暂停态; null:未找到;
- 版本 : 1.6.8


```javascript
定义 暂停了 = $引擎.暂停了(任务ID);
如果(暂停了!=空){
    如果(暂停了){
        信息("任务已暂停");
    }否则{
        信息("任务正在跑");
    }
}否则{
    信息("未找到任务");
}
```


### 开始(任务ID)

> 开始运行
> 
> 该方法会继续运行暂停的脚本

- 参数 : 任务ID {字符串} 任务ID 
- 版本 : 1.6.8


```javascript
定义 任务ID = $引擎.运行("/sdcard/脚本.js");
//暂停运行
$引擎.暂停(任务ID);
睡觉(2000);
//继续运行
$引擎.开始(任务ID);
```


### 罗列()

> 列出所有的任务信息

- 返回 : {JsTaskInfo[]} 任务列表信息
- 版本 : 1.6.8


```javascript
定义 任务列表 = $引擎.罗列();
循环(定义 任务 关于 任务列表){
    日志(任务);
}
```


### 停止(任务ID)

> 停止指定任务

- 参数 : 任务ID {字符串} 任务id 
- 版本 : 1.6.8


```javascript
定义 任务ID = $引擎.运行("/sdcard/脚本.js");
$引擎.停止(任务ID);
```


### 停止所有(是否退出系统)

> 停止所有任务

- 参数 : 是否退出系统 {布尔值} 是否退出系统 
- 版本 : 1.6.8


```javascript
$引擎.停止所有(真);//会杀死app
```


### 停止所有()

> 停止所有任务

- 版本 : 1.7.0


```javascript
$引擎.停止所有();
```


### 罗列任务()

> 获得任务列表信息

- 返回 : {$任务[]} 任务列表信息
- 版本 : 1.6.8


```javascript
定义 任务列表 = $引擎.罗列任务();
循环(定义 任务 关于 任务列表){
    日志(任务);
}
```


### 有(任务ID)

> 停止指定任务

- 参数 : 任务ID {字符串} 任务id 
- 版本 : 1.6.8


```javascript
//运行脚本的时候会返回任务ID
定义 任务ID = $引擎.运行("/sdcard/脚本.js");
//怕判断任务是否存在(任务结束后会自动销毁)
定义 有任务 = $引擎.有(任务ID);
如果(有任务){
    $引擎.停止(任务ID);
}
```


# $event - 事件监听

- 更新时间:2025-12-13 11:58:45

> 事件监听
> 
> $event主要用来监听一些系统级别的事件,也会处理一些基础的应用事件,这些事件部分会依赖无障碍权限才可以监听得到。
> 
> 此对象是一个线程安全的对象,内部已经处理好了线程并发情况,因此可以在任何线程中调用。




### 监听(类型, 回调)

> 挂载事件监听
> 
> 此函数是[唯一监听器]，全局只会被设置一次(用户调用)，当调用多次该函数时，后者将覆盖前者的数据。
> 
> 如果想要取消[唯一监听器]，只需要将第二个参数设置为null即可，例如：$事件.监听("lock",null);//取消锁屏事件
> 
> 在$事件中，事件分为好几个大类，一般有：(1)系统事件 (2)无障碍事件 (3)软件内部事件
> 
> 一般情况下:(1)系统事件:不需要任何权限，但也有个例(比如：蓝牙需要附近设备权限以及位置权限)，
> 但在(2)无障碍事件中:需要开启无障碍权限，否则无法监听得到。

- 参数 : 类型 {字符串} 事件类型名称
- 参数 : 回调 {(数据)=>{日志(数据);};} 回调函数


```javascript
//如果你想监听某些事件，必须要知道这些事件的名称，请参考{EventType}文档
//监听WIFI事件
$事件.监听("wifi",(数据)=>{
    //数据中包含着非常详细的描述信息，通过日志就能打印获取
    日志(数据);
});
```


### 添加(类型, 回调)

> 添加事件监听
> 
> 每次调用该函数，否会增加一个监听器，即使是相同的名称，也会添加到监听器列表中。
> 
> 在$事件对象中，存在两种事件触发机制：[唯一监听器]和[监听器列表]
> 
> [唯一监听器]是通过'监听(类型,回调)'函数来进行设置的，它是全局唯一的，当事件触发的时候，只会被调用一次。
> 
> [监听器列表]是通过'添加(类型,回调)'函数来进行添加的，你可以多次添加多个监听器，甚至允许名称相同，当事件触发时，会调用你添加的所有监听器(软件重启后，监听器列表会被重置清空)。
> 
> 当系统事件触发的时候，会先触发[唯一监听器]，然后再触发[监听器列表]中的所有监听器。

- 参数 : 类型 {字符串} 事件类型名称
- 参数 : 回调 {(数据)=>{日志(数据);};} 回调函数


### 罗列()

> 获取监听器列表名

- 返回 : {字符串数组[]} 监听器列表名


### 清空()

> 清空监听器列表


# $excel - 表格操作

- 更新时间:2025-12-13 11:58:45

> 表格操作
> 
> 用于读取和写入二维数组到表格中，这个库需要在安卓8+的系统上才能完美运行。




### 读取(路径)

> 读取第一个表格

- 参数 : 路径 {字符串} 路径(支持相对路径)
- 返回 : {字符串[][]} 表格数据
- 版本 : 1.7.8


```javascript
//读取第一个表格数据
定义 数据 = $表格.读取("data.xlsx");//相对路径
日志(数据);
// 输出:
// [
//    ["学号","姓名","年龄","性别","入学日期"],
//    ["2023001","张三","20","男","2023-09-01"],
//    ["2023002","李四","19","女","2023-09-01"],
//    ["2023003","王五","21","男","2022-09-01"],
//    ["2023004","赵六","20","女","2023-09-01"]
// ]
```


![](./img/228115506309900.png)

### 读取(路径, 下标)

> 读取表格

- 参数 : 路径 {字符串} 路径(支持相对路径)
- 参数 : 下标 {整数} 表格索引
- 返回 : {String[][]} 表格数据
- 版本 : 1.7.8


```javascript
//读取第2个表格数据
定义 数据 = $表格.读取("data.xlsx", 1);//相对路径
日志(数据);
// 输出:
// [
//    ["商品ID","商品名称","商品单价","库存"],
//    ["P001","笔记本电脑","4999","10"],
//    ["P002","智能手机","3999","25"],
//    ["P003","平板电脑","2499","18"],
//    ["P004","无线耳机","799","50"]
// ]
```


![](./img/228156133564800.png)

### 数量(路径)

> 表格数量

- 参数 : 路径 {字符串} 路径(支持相对路径)
- 返回 : {整数} 表格数量
- 版本 : 1.7.8


```javascript
//获取表格的数量
定义 表格数量 = $表格.数量("data.xlsx");//相对路径
日志(表格数量);//输出:3
```


### 罗列(路径)

> 列表

- 参数 : 路径 {字符串} 路径(支持相对路径)
- 返回 : {字符串数组[]} 表格名称列表
- 版本 : 1.7.8


```javascript
//获取表格的数量
定义 表格列表 = $表格.罗列("data.x罗列x");//相对路径
日志(表格列表);//输出:["班级表","商品表","部门表"]
```


### 遍历(表格路径, 数据回调)

> 遍历所有表格

- 参数 : 表格路径 {字符串} 路径(支持相对路径)
- 参数 : 数据回调 {(名称,数据)=>{}} 数据回调
- 版本 : 1.7.8


```javascript
//遍历所有表格数据
$表格.遍历("data.xlsx", (名称, 数据) => {
    提示(名称,数据);
});
```


### 写入(表格名称, 表格数据, 保存路径)

> 写入表格

- 参数 : 表格名称 {字符串} 表格名称
- 参数 : 表格数据 {String[][]} 表格数据
- 参数 : 保存路径 {字符串} 保存路径(不支持相对路径,必须是绝对路径)
- 版本 : 1.7.8


```javascript
//数据
定义 表格数据 = [
    ["姓名", "年龄"],
    ["小红", "18"],//注意必须都是字符串类型
    ["小明", "19"]
];
//表名
定义 表格名称 = "我的表格";
//路径(必须是绝对路径)
定义 保存路径 = "/sdcard/demo.xlsx";
$表格.写入(表格名称, 表格数据, 保存路径);
```


![](./img/227580225758600.png)

# LoadExtConfig - 加载扩展配置

- 更新时间:2025-12-13 11:58:45

> 加载扩展配置




### const {List<String>} 路径;

> dex、apk、jar等拓展包的路径
> 
> 类型：字符串数组


### const {List<LoadSoConfig>} so;

> so文件加载情况配置
> 
> 类型：LoadSoConfig[] so文件加载配置数组


# LoadSoConfig - 加载so文件配置

- 更新时间:2025-12-13 11:58:45

> 加载so文件配置




### const {String} 路径;

> so文件路径
> 
> 类型：字符串


### const {Boolean} 加载;

> 是否加载so文件
> 
> 类型：布尔值


# $ext - 拓展:加载Dex,Apk,Jar,So

- 更新时间:2025-12-13 11:58:45

> 加载DexApkJarSo拓展API
> 
> $ext顾名思义就是"拓展"的意思，主要用来加载第三方库，拓展本应用中没有的功能。




### 加载apk(apk路径)

> 加载apk文件

- 参数 : apk路径 {字符串} apk文件路径
- 返回 : {DexClassLoader} 类加载器
- 版本 : 1.7.0


```javascript
$拓展.加载apk("/sdcard/测试.apk");
```


### 加载dex(dex路径)

> 加载dex文件
> 
> $拓展中存在一个内置的缓存机制,被加载的dex文件会被生成一个唯一的id作为类加载器的标识,
> 
> 在起初加载dex文件的时候会保存id和类加载器对象
> 
> 当再次加载相同的dex文件时,会通过id直接取得类加载器对象来执行类
> 
> 如果想重新加载需要调用$拓展.clear()清除id和类加载器

- 参数 : dex路径 {字符串} dex文件路径
- 返回 : {DexClassLoader} 类加载器
- 版本 : 1.7.0


```javascript
$拓展.加载dex("./res/demo.dex");
//开始使用dex中的类
```


### 加载多个dex(路径数组)

> 加载多个dex文件

- 参数 : 路径数组 {字符串数组[]} dex文件路径
- 返回 : {DexClassLoader} 类加载器
- 版本 : 1.7.0


```javascript
//加载多个dex文件(传入所有dex文件的路径数组即可)
$拓展.加载多个dex(["/res/demo1.dex","/res/demo2.dex","/res/demo3.dex"]);
```


### 加载jar(jar路径)

> 加载jar文件
> 
> $拓展中存在一个内置的缓存机制,被加载的jar文件会被生成一个唯一的id作为类加载器的标识,
> 
> 在起初加载jar文件的时候会保存id和类加载器对象
> 
> 当再次加载相同的jar文件时,会通过id直接取得类加载器对象来执行类
> 
> 如果想重新加载需要调用$拓展.clear()清除id和类加载器
> 
> 注意:被加载的jar必须经过安卓开发环境(AndroidStudio)编译生成class字节码归档文件才可被加载

- 参数 : jar路径 {字符串} jar文件路径
- 返回 : {DexClassLoader} 类加载器
- 版本 : 1.7.0


```javascript
$拓展.加载jar("/res/demo.jar");
//开始使用jar中的类
```


### 加载多个jar(jar路径数组)

> 加载多个jar文件
> 
> 注意:被加载的jar必须经过安卓开发环境(AndroidStudio)编译生成class字节码归档文件才可被加载

- 参数 : jar路径数组 {字符串数组[]} jar文件路径
- 返回 : {DexClassLoader} 类加载器
- 版本 : 1.7.0


```javascript
//加载多个jar文件(传入所有jar文件的路径数组即可)
$拓展.加载多个jar(["/res/demo1.dex","/res/demo2.dex","/res/demo3.dex"]);
```


### 加载dex(配置)

> 加载dex/so文件
> 
> 值得注意的就是so文件也有很多架构(x86_64,arm64_v8a等),根据自己手机的架构来选择需要加载的so文件(安卓特性);
> 此外:如果dex(java代码)中已经使用System.load(so);加载过的so文件不要重复加载,因为so文件只能被类加载器加载一次(安卓机制)

- 参数 : 配置 {LoadExtConfig} 加载配置
- 返回 : {DexClassLoader} 类加载器
- 版本 : 1.7.0


```javascript
定义 配置 = {
    路径:["dexOrJar路径"],//jar或者dex文件路径数组(可以传入多个dex或jar文件路径)
    so:[
         {路径:"so路径", 加载:否},
         {
           路径:"so路径",//so文件路径
           加载:否 //是否执行系统加载System.load(so);
         },
         //...
    ]
}
$拓展.加载dex(配置);
//开始使用dex里面的类
```


### 加载jar(配置)

> 加载jar/so文件
> 
> 值得注意的就是so文件也有很多架构(x86_64,arm64_v8a等),根据自己手机的架构来选择需要加载的so文件(安卓特性);
> 此外:如果dex(java代码)中已经使用System.load(so);加载过的so文件不要重复加载,因为so文件只能被类加载器加载一次(安卓机制)
> 
> 注意:被加载的jar必须经过安卓开发环境(AndroidStudio)编译生成class字节码归档文件才可被加载

- 参数 : 配置 {LoadExtConfig} 加载配置
- 返回 : {DexClassLoader} 类加载器
- 版本 : 1.7.0


```javascript
定义 配置 = {
    路径:["dexOrJar路径"],//jar或者dex文件路径数组,可以传入多个dex或jar文件路径
    so:[
         {路径:"so路径", 加载:否},
         {
            路径:"so路径",//so文件路径
            加载:否 //是否执行系统加载System.load(so);
         },
         //...
    ]
}
$拓展.加载jar(配置);
//开始使用jar里面的类
```


### 加载apk(配置)

> 加载apk/so文件

- 参数 : 配置 {LoadExtConfig} 加载配置
- 返回 : {DexClassLoader} 类加载器
- 版本 : 1.7.0


```javascript
定义 配置 = {
    路径:["apk路径"],//数组格式,但是只支持一个apk路径,传入多个apk文件路径,只会加载第一个apk文件
    so:[
         {路径:"so路径", 加载:否},
         {
            路径:"so路径",//so文件路径
            加载:否 //是否执行系统加载System.load(so);
         },
         //...
    ]
}
$拓展.加载apk(配置);
//开始使用apk里面的类
```


### 清除缓存()

> 清除缓存的类加载器
> 
> $拓展中存在一个内置的缓存机制,被加载的jar/dex文件会被生成一个唯一的id作为类加载器的标识,
> 
> 在起初加载jar/dex文件的时候会保存id和类加载器对象
> 
> 当再次加载相同的jar/dex文件时,会通过id直接取得类加载器对象来执行类
> 
> 如果想重新加载需要调用$拓展.清除缓存()清除id和类加载器
> 
> 如果只是单纯的加载dex/jar文件,这个函数可以随便调用;
> 但是如果加载了so文件,这个函数最好只使用一次,因为so文件只能被一个类加载器加载一次
> 
> 就算不小心把加载过so文件的类加载器清空了也没有关系，重启app重新运行即可。

- 版本 : 1.7.0


```javascript
$拓展.清除缓存();
```


### 删除缓存()

> 删除缓存文件
> 
> dex加载必须要在安卓的私有目录(安卓机制),所以每次加载的dex文件都会放在私有目录下面
> 
> 然而我们最主要只是拿到类加载器,当加载完后dex文件也就不需要了,所以可以调用这个函数来删除dex文件

- 版本 : 1.7.0


```javascript
$拓展.删除缓存();
```


# FcConfig - 文件选择配置

- 更新时间:2025-12-13 11:58:45

> 文件选择配置




### const {String} 模式;

> 选择模式:单选,多选


### const {String} 类型;

> 选择类型:文件,目录,所有


### const {String} 默认路径;

> 默认路径 /sdcard


### const {String} 根路径;

> 最高根路径 /sdcard


### const {String} 后缀;

> 后缀过滤(使用逗号分割)


# $fc - 文件选择器

- 更新时间:2025-12-13 11:58:45

> 文件选择器




### 显示(回调)

> 显示文件选择器
> 
> 默认是单选文件

- 参数 : 回调 {(文件列表)=>{}}回调
- 版本 : 1.5.8


```javascript
//默认是单选文件
$文件选择器.显示(函数(文件列表) {
    循环(定义 下标 = 0; 下标 < 文件列表.length; 下标++) {
        定义 路径 = 文件列表[下标];
        日志(路径);
    }
});
```


### 显示(回调, 配置)

> 显示文件选择器

- 参数 : 回调 {(文件列表)=>{}}回调
- 参数 : 配置 {object} 配置参数
- 版本 : 1.5.8


```javascript
//多选：文件和目录
$文件选择器.显示(函数(文件列表) {
    循环(定义 下标 = 0; 下标 < 文件列表.length; 下标++) {
        定义 路径 = 文件列表[下标];
        日志(路径);
    }
}, {
    模式: "多选",
    类型: "所有"
});
//配置参数如下:
定义 配置 = {
    模式: "单", //多选模式("单选","多选")写一个字就行了
    类型: "所", //文件和目录("文件","目录","所")写一个字母就行了
    根路径: "/sdcard", //[可选]最高根路径
    默认路径: "/sdcard/Pictures", //[可选]默认路径
    后缀: "jpg,png" //[可选]后缀过滤
}
```


# $file - 文件系统

- 更新时间:2025-12-13 11:58:45

> 文件系统
> 
> 文件系统本身是用来操作外部存储(sdcard)文件的，但是部分函数也可以操作assets目录(app打包后的项目目录)下的文件。
> 
> 如果你希望通过$file操作assets下的文件，你需要知道如下规则：
> 
> 1.assets中的文件夹不能以_开头(安卓机制)否则无法读取文件
> 
> 2.assets只能进行读取操作，因此我们可以进行的操作有：罗列文件、拷贝文件、读取文件




### 获得uri(路径)

> 获得Uri对象
> 
> 通过文件提供器{FileProvider}来解析文件路径，获得{Uri}对象。
> 
> 如果你想单纯的解析字符串构建Uri对象，那么可以使用$http.uri("uriStr");函数
> 
> 该函数只能操作外部存储(sdcard)文件，不能操作assets目录下的文件。

- 参数 : 路径 {字符串} 路径 
- 返回 : {Uri} Uri对象
- 版本 : 1.6.8


```javascript
//一般用来获取图片uri
定义 uri = $文件.获得uri("/storage/emulated/0/Pictures/小红.png");
```


### 打开(路径)

> 获得File对象
> 
> 该函数本质上是一个拼接函数，无论传入的path是否存在，都会根据构想返回一个完整路径。

- 参数 : 路径 {字符串} 路径(支持相对路径) 
- 返回 : {File} 文件对象
- 版本 : 1.6.8


```javascript
//获得res目录
定义 文件 = $文件.打开("res");
提示("文件对象",文件);///storage/emulated/0/Pictures/API教学/res
```


### 是文件(路径)

> 是否是文件
> 
> 如果传入的路径不存在或者不是目录都会返回false，该函数只能操作外部存储(sdcard)文件，不能操作assets目录下的文件。

- 参数 : 路径 {字符串} 路径(支持相对路径) 
- 返回 : {布尔值} 是否是文件
- 版本 : 1.6.8


```javascript
//是否是文件
日志($文件.是文件("res"));//false
日志($文件.是文件("main.js"));//true
```


### 是目录(路径)

> 是否是文件夹
> 
> 如果传入的路径不存在或者不是目录都会返回false，该函数只能操作外部存储(sdcard)文件，不能操作assets目录下的文件。

- 参数 : 路径 {字符串} 路径 
- 返回 : {布尔值} 是否是文件夹
- 版本 : 1.6.8


```javascript
//是否是目录
日志($文件.是目录("res"));//true
日志($文件.是目录("main.js"));//false
```


### 是空目录(路径)

> 是否是空文件夹
> 
> 只有当目标路径是目录并且存在文件的时候才会返回false，如果文件不存在或者不是目录都会返回true。

- 参数 : 路径 {字符串} 路径(支持相对路径) 
- 返回 : {布尔值} 是否是空文件夹
- 版本 : 1.6.8


```javascript
//是否是空目录
日志($文件.是空目录("res"));//false
日志($文件.是空目录("xml"));//true
```


### 是空的(路径)

> 是否是空文件或文件夹
> 
> 如果不存在则返回false
> 
> 如果是文件则判断文件内容是否为空
> 
> 如果是文件夹则判断文件夹是否为空

- 参数 : 路径 {字符串} 路径(支持相对路径) 
- 返回 : {布尔值} 是否是文件夹
- 版本 : 1.6.8


```javascript
//是否是空文件或文件夹
日志($文件.是空的("res"));//false
日志($文件.是空的("xml"));//true
日志($文件.是空的("main.js"));//false
```


### 拼接(父级, 子级)

> 路径拼接

- 参数 : 父级 {字符串} 路径(不支持相对路径) 
- 参数 : 子级 {字符串} 路径(不支持相对路径) 
- 返回 : {字符串} 路径
- 版本 : 1.6.8


```javascript
定义 路径 = $文件.拼接("sdcard", "Pictures");
提示("路径",路径);
```


### 拼接(路径)

> 拼接路径

- 参数 : 路径 {字符串数组[]} 路径数组(不支持相对路径) 
- 返回 : {字符串} 拼接好的路径
- 版本 : 1.0.0


```javascript
定义 路径 = $文件.拼接(["sdcard", "Pictures", "我的项目", "res"]);
提示("路径",路径);
```


### 创建(路径)

> 创建文件
> 
> 如果目录不存在,则会自动创建目录。此函数只能操作外部存储(sdcard)文件，不能操作assets目录下的文件。

- 参数 : 路径 {字符串} 路径(支持相对路径) 
- 返回 : {布尔值} 是否创建成功(文件存在会返回false)
- 版本 : 1.6.8


```javascript
$文件.创建("xml/res/test.js");
```


### 创建目录(路径)

> 创建目录
> 
> 只能操作外部存储(sdcard)目录，不能操作assets目录下的目录。

- 参数 : 路径 {字符串} 路径(支持相对路径) 
- 返回 : {布尔值} 是否创建成功
- 版本 : 1.6.8


```javascript
$文件.创建目录("xml/kir");
```


### 存在(路径)

> 路径是否存在

- 参数 : 路径 {字符串} 路径(支持相对路径) 
- 返回 : {布尔值} 是否存在
- 版本 : 1.6.8


```javascript
$文件.创建("./测试文件夹/a.js");
如果($文件.存在("./测试文件夹/a.js")){
    提示("文件","路径存在");
}
```


### 确保目录(路径)

> 确保文件夹存在
> 
> 如果路径中的目录不存在则会创建目录

- 参数 : 路径 {字符串} 路径(支持相对路径) 
- 返回 : {字符串} 路径
- 版本 : 1.6.8


```javascript
//创建目录:/测试文件夹/demo
$文件.确保目录("./测试文件夹/demo/a.js");
```


### 读取(路径)

> 读取文件
> 
> 此函数支持读取assets中的文件，适用于打包app后读取文本文件。在未打包时将会读取sdcard上的文件。

- 参数 : 路径 {字符串} 路径(支持相对路径) 
- 返回 : {字符串} 文本内容
- 版本 : 1.6.8


```javascript
//开始读取文件
定义 内容 = $文件.读取("./main.js");
提示("内容",内容);
```


### 读取(路径, 编码)

> 读取文件
> 
> 此函数支持读取assets中的文件，适用于打包app后读取文本文件。在未打包时将会读取sdcard上的文件。

- 参数 : 路径 {字符串} 路径(支持相对路径) 
- 参数 : 编码 {字符串} 编码 
- 返回 : {字符串} 文本内容
- 版本 : 1.6.8


```javascript
定义 内容 = $文件.读取("./main.js","gbk");
提示("内容",内容);
```


### 读取行(路径)

> 读取文件行
> 
> 此函数支持读取assets中的文件，适用于打包app后读取文本文件。在未打包时将会读取sdcard上的文件。

- 参数 : 路径 {字符串} 路径(支持相对路径) 
- 返回 : {字符串数组[]} 文件行列表
- 版本 : 1.6.8


```javascript
定义 列表 = $文件.读取行("./main.js");
提示("内容",列表);
```


### 读取字节(路径)

> 读取文件字节
> 
> 此函数支持读取assets中的文件，适用于打包app后读取二进制文件。在未打包时将会读取sdcard上的二进制文件。

- 参数 : 路径 {字符串} 路径 
- 返回 : {字节数组[]} 文件字节
- 版本 : 1.6.8


```javascript
l定义 数据 = $文件.读取字节("./main.js");
日志(数据);
```


### 写入(内容, 路径)

> 写入文件
> 
> 只适用于写入到外部存储

- 参数 : 内容 {字符串} 内容 
- 参数 : 路径 {字符串} 路径(支持相对路径) 
- 版本 : 1.6.8


```javascript
$文件.写入("我是内容","./xml/a.js");
```


### 写入(内容, 路径, 编码)

> 写入文件
> 
> 只适用于写入到外部存储

- 参数 : 内容 {字符串} 内容 
- 参数 : 路径 {字符串} 路径 
- 参数 : 编码 {字符串} 编码 
- 版本 : 1.6.8


```javascript
$文件.写入("我是内容","./code/a.js","GBK");
```


### 写入行(行数据, 路径)

> 写入行数据
> 
> 只适用于写入到外部存储

- 参数 : 行数据 {字符串数组[]} 行数据 
- 参数 : 路径 {字符串} 路径(支持相对路径) 
- 版本 : 1.6.8


```javascript
$文件.写入行(["我是内容1","我是内容2","我是内容3"],"./code/a.js");
```


### 追加(内容, 路径)

> 追加文件
> 
> 只适用于写入到外部存储

- 参数 : 内容 {字符串} 内容 
- 参数 : 路径 {字符串} 路径(支持相对路径) 
- 版本 : 1.6.8


```javascript
//追加一行字符并且换行
$文件.追加("我是新的内容\n","./code/a.js");
```


### 追加行(行数据, 路径)

> 追加行数据
> 
> 只适用于写入到外部存储

- 参数 : 行数据 {字符串数组[]} 行数据 
- 参数 : 路径 {字符串} 路径(支持相对路径) 
- 版本 : 1.6.8


```javascript
//无需换行符号,自动换行
$文件.追加行(["追加01","追加02","追加03"],"./code/a.js");
```


### 写入字节(字节数据, 路径)

> 写入文件
> 
> 只适用于写入到外部存储

- 参数 : 字节数据 {字节数组[]} 内容 
- 参数 : 路径 {字符串} 路径(支持相对路径) 
- 版本 : 1.6.8


```javascript
$文件.写入字节([09,46,36,7,89,34],"./xml/mFile.txt");
```


### 复制(源路径, 目标路径)

> 拷贝文件
> 
> 支持将assets文件拷贝到外部存储，也支持将外部存储文件拷贝到指定路径中，虽然目标路径支持书写相对路径，但是建议源路径使用相对路径，而目标路径最好用绝对路径。

- 参数 : 源路径 {字符串} 源(支持相对路径) 
- 参数 : 目标路径 {字符串} 目标(支持相对路径) 
- 版本 : 1.6.8


```javascript
//把assets文件拷贝到sdcard上
$文件.复制("res/a.txt","/sdcard/Pictures/测试项目/res/a.txt");
```


### 移动(源路径, 目标路径)

> 移动文件或文件夹
> 
> 此函数只适用于操作外部存储文件

- 参数 : 源路径 {字符串} 源文件夹(支持相对路径) 
- 参数 : 目标路径 {字符串} 目标文件夹(支持相对路径) 
- 版本 : 1.6.8


```javascript
//把位于modules文件夹下的所有文件都移动到xml下
//注意传入的都是目录(可以是相对路径)
定义 移动成功了 = $文件.移动("modules","xml");
如果(移动成功了){
    提示("移动文件","成功");
}否则{
    提示("移动文件","失败");
}
//移动文件的话,src必须是存在的(支持相对路径)
定义 移动成功 = $文件.移动("res/code.js","/");
如果(移动成功){
    提示("移动文件","成功");
}否则{
    提示("移动文件","失败");
}
```


### 重命名(源路径, 目录路径)

> 重命名文件
> 
> 此函数只适用于操作外部存储文件

- 参数 : 源路径 {字符串} 源 
- 参数 : 目录路径 {字符串} 目标 
- 返回 : {布尔值} 是否重命名成功
- 版本 : 1.6.8


```javascript
定义 成功 = $文件.重命名("run.js","res/code.js");
如果(成功){
    提示("重命名","成功");
}否则{
    提示("重命名","失败");
}
```


### 长度(路径)

> 获取文件大小
> 
> 如果文件不存在,则返回0，此函数只适用于操作外部存储文件

- 参数 : 路径 {字符串} 路径(支持相对路径) 
- 返回 : {数字} 文件大小
- 版本 : 1.0.0


```javascript
定义 大小 = $文件.长度("./xml/mFile.txt");
提示("文件大小",大小);//6(字节)
```


### 大小(文件长度)

> 获取文件可视化大小
> 
> 如果文件不存在，则返回0b，此函数只适用于操作外部存储文件

- 参数 : 文件长度 {数字} 文件长度
- 返回 : {字符串} 文件大小
- 版本 : 1.6.8


```javascript
定义 尺寸 = $文件.大小(1099);
提示("文件大小",尺寸);//6(字节)
```


### 大小(路径)

> 获取文件可视化大小
> 
> 如果文件不存在，则返回0b，此函数只适用于操作外部存储文件

- 参数 : 路径 {字符串} 路径(支持相对路径) 
- 返回 : {字符串} 文件大小(格式化单位)
- 版本 : 1.6.8


```javascript
定义 尺寸 = $文件.大小("./xml/mFile.txt");
提示("文件大小",尺寸);//6 B
```


### 文件名(路径)

> 文件名称
> 
> 该函数本质上就是字符串操作，解析得到文件名称。

- 参数 : 路径 {字符串} 路径 
- 返回 : {字符串} 文件名称
- 版本 : 1.6.8


```javascript
定义 名称 = $文件.文件名("./xml/mFile.txt");
提示("文件名称",名称);//mFile.txt
```


### 主文件名(路径)

> 主文件名
> 
> 不包含后缀名的文件名称，该函数本质上就是字符串操作，解析得到文件名称(不包含后缀)。

- 参数 : 路径 {字符串} 路径 
- 返回 : {字符串} 文件名称
- 版本 : 1.6.8


```javascript
定义 主文件名 = $文件.主文件名("./xml/mFile.txt");
提示("文件名称",主文件名);//mFile
```


### 后缀名(路径)

> 后缀名
> 
> 该函数本质上就是字符串操作，解析得到文件后缀名。

- 参数 : 路径 {字符串} 路径 
- 返回 : {字符串} 文件名称
- 版本 : 1.6.8


```javascript
定义 后缀名 = $文件.后缀名("./xml/mFile.txt");
提示("后缀名",后缀名);//txt
```


### 存储目录()

> 获得存储目录

- 返回 : {字符串} sdcard路径
- 版本 : 1.6.8


```javascript
定义 路径 = $文件.存储目录();
提示("SDCard路径",路径);///storage/emulated/0
```


### 删除(路径)

> 删除文件或文件夹
> 
> 递归删除文件或者文件夹,如果没有删除成功,则内部会有三次重试机制,强制进行删除
> 
> 该函数只适用于操作外部存储文件

- 参数 : 路径 {字符串} 文件路径(支持相对路径) 
- 返回 : {布尔值} 是否删除成功
- 版本 : 1.6.8


```javascript
//删除目录
$文件.删除("tools");
//删除文件
$文件.删除("main.js");
```


### 罗列(路径)

> 罗列文件
> 
> 该函数支持罗列打包后apk中的资源文件(assets目录)，但是注意书写相对路径

- 参数 : 路径 {字符串} 路径(支持相对路径) 
- 返回 : {字符串列表[]} 文件路径集合
- 版本 : 1.6.8


```javascript
定义 数组 = $文件.罗列("res");
循环(定义 路径 关于 数组){
    日志(路径);
}
```


### 罗列(路径, 过滤器)

> 罗列文件
> 
> 支持罗列打包后apk中的资源文件，但是注意书写相对路径

- 参数 : 路径 {字符串} 路径(支持相对路径) 
- 参数 : 过滤器 {(路径)=>{返回 真;}} 过滤函数 
- 返回 : {字符串列表[]} 文件路径集合
- 版本 : 1.6.8


```javascript
定义 路径数组 = $文件.罗列("res",(路径)=>{
    //过滤器
    返回 真;
});
循环(定义 路径 关于 路径数组){
    日志(路径);
}
```


### 递归文件(路径, accept)

> 递归遍历文件
> 
> 该函数只适用于操作外部存储文件

- 参数 : 路径 {字符串}  路径(支持相对路径)
- 参数 : accept {(文件)=>{返回 真;;}} 过滤函数 
- 返回 : {File[]} 文件列表
- 版本 : 1.6.8


```javascript
$文件.递归文件("/res",(文件)=>{
    //参数类型:文件:java.io.File
    返回 真;
});
```


### 罗列视频()

> 罗列视频文件
> 
> 通过安卓媒体库获取视频文件,需要获取读取视频权限($permit.readVideo())

- 返回 : {VideoInfo[]} 视频文件列表
- 版本 : 1.6.8


```javascript
//VideoInfo属性:
定义 信息对象 = {
    id: 0,    //视频id
    名称: "视频名称",
    路径: "视频路径",
    大小: 0,  //视频大小
    时长: 0,   //视频时长
    时间: 0,  //时间
}
//获取视频列表
定义 信息数组 = $文件.罗列视频();
//遍历视频列表
循环(定义 信息 关于 信息数组){
    日志(信息);
}
```


### 罗列音频()

> 罗列音频文件
> 
> 通过安卓媒体库获取音频文件,需要获取读取音频权限($permit.readAudio())

- 返回 : {AudioInfo[]} 音频文件列表
- 版本 : 1.6.8


```javascript
//AudioInfo属性:
定义 信息对象 = {
    id: 0,    //音频id
    名称: "音频名称",
    路径: "音频路径",
    大小: 0,  //音频大小
    时长: 0,   //音频时长
    艺术家: "艺术家",
    专辑: "专辑",
    时间: 0,  //时间
}
//获取音频列表
定义 音频信息列表 = $文件.罗列音频();
//遍历音频列表
循环(定义 信息 关于 音频信息列表){
    日志(信息);
}
```


### 罗列图片()

> 罗列图片文件
> 
> 通过安卓媒体库获取图片文件,需要获取读取图片权限($permit.readImage())

- 返回 : {ImageInfo[]} 图片文件列表
- 版本 : 1.6.8


```javascript
//ImageInfo属性:
定义 信息 = {
    id: 0,    //图片id
    名称: "图片名称",
    路径: "图片路径",
    大小: 0,  //图片大小
    宽: 0, //图片宽度
    高: 0,//图片高度
    时间: 0,  //时间
}
//获取图片列表
定义 图片信息数组 = $文件.罗列图片();
//遍历图片列表
循环(定义 信息 关于 图片信息数组){
    日志(信息);
}
```


### 获取目录(类型名称, 是否是公共目录)

> 获取安卓目录路径
> 
> 获取安卓系统指定目录的路径，根据目录类型返回对应的目录路径字符串。
> 
> 目录类型可选项有: "pictures","图片", "downloads","下载", "dcim", "music","音乐", "movies","视频", "documents", "文档", "alarms", "闹钟", "notifications", "通知", "podcasts", "播客", "ringtones", "铃声"
> 
> 如果目录类型为自己自己自定义的目录名称，则会返回应用内部私有目录路径，并且以传入的目录类型作为目录的名称。

- 参数 : 类型名称 {字符串} 目录类型,可选项有: "pictures","图片", "downloads","下载", "dcim", "music","音乐", "movies","视频", "documents", "文档", "alarms", "闹钟", "notifications", "通知", "podcasts", "播客", "ringtones", "铃声"
- 参数 : 是否是公共目录 {布尔值} 是否为公共目录(true为公共目录，false为私有目录)，默认为true，公共目录访问时都需要存储权限
- 返回 : {字符串} 目录路径字符串
- 版本 : 1.6.8


```javascript
定义 媒体视频路径 = $文件.获取目录("视频",true);
```


### 获取目录(类型名称)

> 获取安卓公共目录路径
> 
> 获取安卓系统指定目录的路径，根据目录类型返回对应的目录路径字符串。
> 
> 目录类型可选项有: "pictures","图片", "downloads","下载", "dcim", "music","音乐", "movies","视频", "documents", "文档", "alarms", "闹钟", "notifications", "通知", "podcasts", "播客", "ringtones", "铃声"
> 
> 如果目录类型为自己自己自定义的目录名称，则会返回应用内部私有目录路径，并且以传入的目录类型作为目录的名称。

- 参数 : 类型名称 {字符串} 目录类型,可选项有: "pictures","图片", "downloads","下载", "dcim", "music","音乐", "movies","视频", "documents", "文档", "alarms", "闹钟", "notifications", "通知", "podcasts", "播客", "ringtones", "铃声"
- 返回 : {字符串} 目录路径字符串
- 版本 : 1.6.8


```javascript
定义 媒体视频路径 = $文件.获取目录("视频");
```


# AdjFloaty - 可调节悬浮窗

- 更新时间:2025-12-13 11:58:45

> 可调节悬浮窗
> 
> 通过$floaty.newAdj(xml|path)创建，天生就是一个可以调节的悬浮窗，支持移动到自己想要移动的位置，调节悬浮窗的大小，关闭悬浮窗等操作。




### const {WindowManager.LayoutParams} params;

> 悬浮窗参数
> 
> 类型：{android.view.WindowManager.LayoutParams}

- 版本 : 1.5.4


### const {WindowManager} manager;

> 悬浮窗管理器
> 
> 类型：{android.view.WindowManager}

- 版本 : 1.5.4


### 找控件(控件id)

> 选择控件

- 参数 : 控件id {字符串} 控件找控件
- 返回 : {XView} 控件
- 版本 : 1.7.0


```javascript
定义 可调节悬浮窗 = $悬浮窗.新建可调节("界面.xml");
//找控件
定义 按钮 = 可调节悬浮窗.找控件("关闭按钮");
```


### 关闭()

> 关闭悬浮窗

- 版本 : 1.7.0


```javascript
定义 可调节悬浮窗 = $悬浮窗.新建可调节("界面.xml");
//找控件
定义 按钮 = 可调节悬浮窗.找控件("关闭按钮");
//点击按钮后关闭悬浮窗
按钮.点击事件(()=>{
    可调节悬浮窗.关闭();
});
```


### 获取宽度()

> 获得宽度

- 返回 : {整数} 宽度
- 版本 : 1.7.0


```javascript
定义 可调节悬浮窗 = $悬浮窗.新建可调节("界面.xml");
//获得宽度
定义 宽度 = 可调节悬浮窗.获取宽度();
```


### 获取x()

> 获得x坐标

- 返回 : {整数} x坐标
- 版本 : 1.7.0


```javascript
定义 可调节悬浮窗 = $悬浮窗.新建可调节("界面.xml");
//获得x坐标
定义 x坐标 = 可调节悬浮窗.获取x();
```


### 获取y()

> 获得y坐标

- 返回 : {整数} y坐标
- 版本 : 1.7.0


```javascript
定义 可调节悬浮窗 = $悬浮窗.新建可调节("界面.xml");
//获得y坐标
定义 y坐标 = 可调节悬浮窗.获取y();
```


### 获取高度()

> 获得高度

- 返回 : {整数} 高度
- 版本 : 1.7.0


```javascript
定义 可调节悬浮窗 = $悬浮窗.新建可调节("界面.xml");
//获得高度
定义 高度 = 可调节悬浮窗.获取高度();
```


# AppFloaty - 应用级悬浮窗

- 更新时间:2025-12-13 11:58:45

> 应用级悬浮窗
> 
> 通过$floaty.newApp(xml|path)创建，该悬浮窗不会覆盖标题栏和导航栏，是一个比较友好的悬浮窗。




### const {WindowManager.LayoutParams} params;

> 悬浮窗参数
> 
> 类型：{android.view.WindowManager.LayoutParams}

- 版本 : 1.3.5


### const {WindowManager} manager;

> 悬浮窗管理器
> 
> 类型：{android.view.WindowManager}

- 版本 : 1.3.5


### 监听屏幕旋转(回调)

> 设置屏幕旋转监听

- 参数 : 回调 {(屏幕信息)=>{}} 屏幕旋转时回调
- 版本 : 1.7.0


```javascript
定义 悬浮窗 = $悬浮窗.新建应用级("./floaty/main.xml");
悬浮窗.监听屏幕旋转((屏幕信息)=>{
    //屏幕旋转时回调
    悬浮窗.全屏(是);//设置成全屏
});
```


### 找控件(标识)

> 获取控件

- 参数 : 标识 {字符串} 控件找控件
- 返回 : {XView} 组件
- 版本 : 1.7.0


```javascript
//创建悬浮窗对象
定义 悬浮窗 = $悬浮窗.新建应用级(`
<界面>
    <线性布局 宽="最大" 高="最大">
        <!--省略组件-->
        <按钮 标识="关闭按钮" 文本"关闭"/>
    </线性布局>
</界面>
`);
//获取按钮控件
定义 关闭按钮 = 悬浮窗.找控件("关闭按钮");
//绑定点击事件
关闭按钮.点击事件(()=>{
    //关闭悬浮窗
    悬浮窗.关闭();
});
```


### 全屏(是否全屏)

> 是否全屏显示
> 
> 此函数会将悬浮窗的尺寸设置成全屏大小，之后刷新悬浮窗界面
> 
> 当全屏(true)的时候悬浮窗将位置设置为(0,0)并且设置宽高为最大后全屏显示；
> 
> 当全屏(false)的时候悬浮窗将位置设置为上次位置，并且宽高设置为自适应，之后显示。

- 参数 : 是否全屏 {布尔值} 是否全屏
- 返回 : {SysFloaty} 自己
- 版本 : 1.7.0


```javascript
//创建悬浮窗对象
定义 悬浮窗 = $悬浮窗.新建应用级(`
<界面>
    <线性布局 宽="最大" 高="最大">
        <!--省略组件-->
    </线性布局>
</界面>
`);
//全屏显示
悬浮窗.全屏(是);
```


### 触摸(是否可触摸)

> 设置是否可触摸
> 
> 此函数会配置悬浮窗的参数是否可以触摸，之后刷新悬浮窗界面

- 参数 : 是否可触摸 {布尔值} 是否可触摸
- 返回 : {SysFloaty} 自己
- 版本 : 1.7.0


```javascript
//创建悬浮窗对象
定义 悬浮窗 = $悬浮窗.新建应用级(`
<界面>
    <线性布局 宽="最大" 高="最大">
        <!--省略组件-->
    </线性布局>
</界面>
`);
//设置不可触摸
悬浮窗.触摸(否);
```


### 设置x(x)

> 设置X坐标
> 
> 此函数会设置悬浮窗x坐标参数，之后刷新悬浮窗界面

- 参数 : x {整数} X坐标
- 返回 : {SysFloaty} 自己
- 版本 : 1.7.0


```javascript
//创建悬浮窗对象
定义 悬浮窗 = $悬浮窗.新建应用级(`
<界面>
    <线性布局 宽="最大" 高="最大">
        <!--省略组件-->
    </线性布局>
</界面>
`);
//设置X坐标
悬浮窗.设置x(100);
```


### 设置y(y)

> 设置Y坐标
> 
> 此函数会设置悬浮窗y坐标参数，之后刷新悬浮窗界面

- 参数 : y {整数} Y坐标
- 返回 : {SysFloaty} 自己
- 版本 : 1.7.0


```javascript
//创建悬浮窗对象
定义 悬浮窗 = $悬浮窗.新建应用级(`
<界面>
    <线性布局 宽="最大" 高="最大">
        <!--省略组件-->
    </线性布局>
</界面>
`);
//设置Y坐标
悬浮窗.设置y(100);
```


### 设置位置(x, y)

> 设置XY坐标
> 
> 此函数会设置悬浮窗xy坐标参数，之后刷新悬浮窗界面

- 参数 : x {整数} X坐标
- 参数 : y {整数} Y坐标
- 返回 : {SysFloaty} 自己
- 版本 : 1.7.0


```javascript
//创建悬浮窗对象
定义 悬浮窗 = $悬浮窗.新建应用级(`
<界面>
    <线性布局 宽="最大" 高="最大">
        <!--省略组件-->
    </线性布局>
</界面>
`);
//设置XY坐标
悬浮窗.设置位置(100, 100);
```


### 设置宽度(宽度)

> 设置宽度
> 
> 此函数会设置悬浮窗宽度参数，之后刷新悬浮窗界面

- 参数 : 宽度 {整数} 宽度
- 返回 : {SysFloaty} 自己
- 版本 : 1.7.0


```javascript
//创建悬浮窗对象
定义 悬浮窗 = $悬浮窗.新建应用级(`
<界面>
    <线性布局 宽="最大" 高="最大">
        <!--省略组件-->
    </线性布局>
</界面>
`);
//设置宽度
悬浮窗.设置宽度(100);
```


### 设置高度(高度)

> 设置高度
> 
> 此函数会设置悬浮窗高度参数，之后刷新悬浮窗界面

- 参数 : 高度 {整数} 高度
- 返回 : {SysFloaty} 自己
- 版本 : 1.7.0


```javascript
//创建悬浮窗对象
定义 悬浮窗 = $悬浮窗.新建应用级(`
<界面>
    <线性布局 宽="最大" 高="最大">
        <!--省略组件-->
    </线性布局>
</界面>
`);
//设置高度
悬浮窗.设置高度(100);
```


### 设置宽高(宽度, 高度)

> 设置宽高
> 
> 此函数会设置悬浮窗宽高参数，之后刷新悬浮窗界面

- 参数 : 宽度 {整数} 宽度
- 参数 : 高度 {整数} 高度
- 返回 : {SysFloaty} 自己
- 版本 : 1.7.0


```javascript
//创建悬浮窗对象
定义 悬浮窗 = $悬浮窗.新建应用级(`
<界面>
    <线性布局 宽="最大" 高="最大">
        <!--省略组件-->
    </线性布局>
</界面>
`);
//设置宽高
悬浮窗.设置宽高(100, 100);
```


### 断言()

> 断言
> 
> 判断悬浮窗是否处于可此操作状态，不可操作的状态情况如下：
> 
> 1.view为空或被移除
> 
> 2.悬浮窗被关闭

- 返回 : {布尔值} 是否可操作
- 版本 : 1.7.0


```javascript
//创建悬浮窗对象
定义 悬浮窗 = $悬浮窗.新建应用级(`
<界面>
    <线性布局 宽="最大" 高="最大">
        <!--省略组件-->
    </线性布局>
</界面>
`);
//断言
如果(悬浮窗.断言()){
    //可以操作
}否则{
    //悬浮窗已经关闭啦，不能操作了
}
```


### 关闭()

> 关闭悬浮窗

- 版本 : 1.7.0


```javascript
//创建悬浮窗对象
定义 悬浮窗 = $悬浮窗.新建应用级(`
<界面>
    <线性布局 宽="最大" 高="最大">
        <!--省略组件-->
    </线性布局>
</界面>
`);
//关闭悬浮窗
悬浮窗.关闭();
```


# SelectFloaty - 选择悬浮窗

- 更新时间:2025-12-13 11:58:45

> 选择悬浮窗
> 
> 通过$floaty.newSelect((rect)=>{})创建，创建后立马会显示一个区域选择方框，当用户关闭的时候会回调选择的范围。




### const {WindowManager.LayoutParams} params;

> 悬浮窗参数
> 
> 类型：{android.view.WindowManager.LayoutParams}

- 版本 : 1.8.3


### const {WindowManager} manager;

> 悬浮窗管理器
> 
> 类型：{android.view.WindowManager}

- 版本 : 1.8.3


### 关闭()

> 关闭悬浮窗

- 版本 : 1.8.3


# SysFloaty - 系统级悬浮窗

- 更新时间:2025-12-13 11:58:45

> 系统级悬浮窗
> 
> 通过$floaty.newSys(xml|path)创建，悬浮窗会盖住导航栏和状态栏，是一个比较霸道的悬浮窗。




### const {WindowManager.LayoutParams} params;

> 悬浮窗参数
> 
> 类型：{android.view.WindowManager.LayoutParams}

- 版本 : 1.3.5


### const {WindowManager} manager;

> 悬浮窗管理器
> 
> 类型：{android.view.WindowManager}

- 版本 : 1.3.5


### 监听屏幕旋转(旋转回调)

> 设置屏幕旋转监听

- 参数 : 旋转回调 {(屏幕信息)=>{}} 屏幕旋转时回调
- 版本 : 1.7.0


```javascript
定义 悬浮窗 = $悬浮窗.新建系统级("./floaty/main.xml");
悬浮窗.监听屏幕旋转((屏幕信息)=>{
    //屏幕旋转时回调
    悬浮窗.全屏(是);//设置成全屏
});
```


### 找控件(控件id)

> 获取控件

- 参数 : 控件id {字符串} 控件找控件
- 返回 : {XView} 组件
- 版本 : 1.7.0


```javascript
//创建悬浮窗对象
定义 悬浮窗 = $悬浮窗.新建系统级(`
<界面>
    <线性布局 宽="最大" 高="最大">
        <!--省略组件-->
        <按钮 标识="关闭按钮" text="关闭"/>
    </线性布局>
</界面>
`);
//获取按钮控件
定义 关闭按钮 = 悬浮窗.找控件("关闭按钮");
//绑定点击事件
关闭按钮.点击事件(()=>{
    //关闭悬浮窗
    悬浮窗.关闭();
});
```


### 全屏(是否全屏)

> 是否全屏显示
> 
> 此函数会将悬浮窗的尺寸设置成全屏大小，之后刷新悬浮窗界面
> 
> 当全屏(true)的时候悬浮窗将位置设置为(0,0)并且设置宽高为最大后全屏显示；
> 
> 当全屏(false)的时候悬浮窗将位置设置为上次位置，并且宽高设置为自适应，之后显示。

- 参数 : 是否全屏 {布尔值} 是否全屏
- 返回 : {SysFloaty} 自己
- 版本 : 1.7.0


```javascript
//创建悬浮窗对象
定义 悬浮窗 = $悬浮窗.新建系统级(`
<界面>
    <线性布局 宽="最大" 高="最大">
        <!--省略组件-->
    </线性布局>
</界面>
`);
//全屏显示
悬浮窗.全屏(是);
```


### 触摸(是否可触摸)

> 设置是否可触摸
> 
> 此函数会配置悬浮窗的参数是否可以触摸，之后刷新悬浮窗界面

- 参数 : 是否可触摸 {布尔值} 是否可触摸
- 返回 : {SysFloaty} 自己
- 版本 : 1.7.0


```javascript
//创建悬浮窗对象
定义 悬浮窗 = $悬浮窗.新建系统级(`
<界面>
    <线性布局 宽="最大" 高="最大">
        <!--省略组件-->
    </线性布局>
</界面>
`);
//设置不可触摸
悬浮窗.触摸(否);
```


### 设置x(x)

> 设置X坐标
> 
> 此函数会设置悬浮窗x坐标参数，之后刷新悬浮窗界面

- 参数 : x {整数} X坐标
- 返回 : {SysFloaty} 自己
- 版本 : 1.7.0


```javascript
//创建悬浮窗对象
定义 悬浮窗 = $悬浮窗.新建系统级(`
<界面>
    <线性布局 宽="最大" 高="最大">
        <!--省略组件-->
    </线性布局>
</界面>
`);
//设置X坐标
悬浮窗.设置x(100);
```


### 设置y(y)

> 设置Y坐标
> 
> 此函数会设置悬浮窗y坐标参数，之后刷新悬浮窗界面

- 参数 : y {整数} Y坐标
- 返回 : {SysFloaty} 自己
- 版本 : 1.7.0


```javascript
//创建悬浮窗对象
定义 悬浮窗 = $悬浮窗.新建系统级(`
<界面>
    <线性布局 宽="最大" 高="最大">
        <!--省略组件-->
    </线性布局>
</界面>
`);
//设置Y坐标
悬浮窗.设置y(100);
```


### 设置位置(x, y)

> 设置XY坐标
> 
> 此函数会设置悬浮窗xy坐标参数，之后刷新悬浮窗界面

- 参数 : x {整数} X坐标
- 参数 : y {整数} Y坐标
- 返回 : {SysFloaty} 自己
- 版本 : 1.7.0


```javascript
//创建悬浮窗对象
定义 悬浮窗 = $悬浮窗.新建系统级(`
<界面>
    <线性布局 宽="最大" 高="最大">
        <!--省略组件-->
    </线性布局>
</界面>
`);
//设置XY坐标
悬浮窗.设置位置(100, 100);
```


### 设置宽度(宽度)

> 设置宽度
> 
> 此函数会设置悬浮窗宽度参数，之后刷新悬浮窗界面

- 参数 : 宽度 {整数} 宽度
- 返回 : {SysFloaty} 自己
- 版本 : 1.7.0


```javascript
//创建悬浮窗对象
定义 悬浮窗 = $悬浮窗.新建系统级(`
<界面>
    <线性布局 宽="最大" 高="最大">
        <!--省略组件-->
    </线性布局>
</界面>
`);
//设置宽度
悬浮窗.设置宽度(100);
```


### 设置高度(高度)

> 设置高度
> 
> 此函数会设置悬浮窗高度参数，之后刷新悬浮窗界面

- 参数 : 高度 {整数} 高度
- 返回 : {SysFloaty} 自己
- 版本 : 1.7.0


```javascript
//创建悬浮窗对象
定义 悬浮窗 = $悬浮窗.新建系统级(`
<界面>
    <线性布局 宽="最大" 高="最大">
        <!--省略组件-->
    </线性布局>
</界面>
`);
//设置高度
悬浮窗.设置高度(100);
```


### 设置宽高(宽度, 高度)

> 设置宽高
> 
> 此函数会设置悬浮窗宽高参数，之后刷新悬浮窗界面

- 参数 : 宽度 {整数} 宽度
- 参数 : 高度 {整数} 高度
- 返回 : {SysFloaty} 自己
- 版本 : 1.7.0


```javascript
//创建悬浮窗对象
定义 悬浮窗 = $悬浮窗.新建系统级(`
<界面>
    <线性布局 宽="最大" 高="最大">
        <!--省略组件-->
    </线性布局>
</界面>
`);
//设置宽高
悬浮窗.设置宽高(100, 100);
```


### 断言()

> 断言
> 
> 判断悬浮窗是否处于可此操作状态，不可操作的状态情况如下：
> 
> 1.view为空或被移除
> 
> 2.悬浮窗被关闭

- 返回 : {布尔值} 是否可操作
- 版本 : 1.7.0


```javascript
//创建悬浮窗对象
定义 悬浮窗 = $悬浮窗.新建系统级(`
<界面>
    <线性布局 宽="最大" 高="最大">
        <!--省略组件-->
    </线性布局>
</界面>
`);
//断言
如果(悬浮窗.断言()){
    //可以操作
}否则{
    //悬浮窗已经关闭啦，不能操作了
}
```


### 关闭()

> 关闭悬浮窗

- 版本 : 1.7.0


```javascript
//创建悬浮窗对象
定义 悬浮窗 = $悬浮窗.新建系统级(`
<界面>
    <线性布局 宽="最大" 高="最大">
        <!--省略组件-->
    </线性布局>
</界面>
`);
//关闭悬浮窗
悬浮窗.关闭();
```


# $floaty - 悬浮窗

- 更新时间:2025-12-13 11:58:45

> 悬浮窗




### 获取权限()

> 获取悬浮窗权限
> 
> 这个方法是个阻塞方法，如果没有获取到悬浮窗权限，则每隔30秒会请求一次权限，那么后面的代码不会被执行，并且会一直等待悬浮窗权限，直到获取到为止。
> 
> 如果你希望只获取一次悬浮窗权限，可以调用$permit.floaty();来获取权限

- 返回 : {布尔值} 是否有权限
- 版本 : 1.7.0


```javascript
//获取悬浮窗权限
定义 获取成功 = $悬浮窗.获取权限();
如果(获取成功){
    日志("获取到悬浮窗权限");
}
```


### 有权限()

> 是否有悬浮窗权限

- 返回 : {布尔值} 是否有悬浮窗权限
- 版本 : 1.7.0


```javascript
//是否有悬浮窗权限
定义 有权限 = $悬浮窗.有权限();
如果(有权限){
    日志("有悬浮窗权限");
}
```


### 新建可调节(xml内容或者路径)

> 创建可调节悬浮窗

- 参数 : xml内容或者路径 {xml|path} xml或路径
- 返回 : {AdjustableFloaty} 可调节悬浮窗
- 版本 : 1.7.0


```javascript
//你可以直接引入一个布局文件创建一个可调节悬浮窗
定义 可调节悬浮窗1 = $悬浮窗.新建可调节("./res/layout/floaty_adj.xml");
//你也可以直接把xml写成字符串传入
定义 可调节悬浮窗2 = $悬浮窗.新建可调节(`<ui>...</ui>`);
```


### 新建应用级(xml内容或者路径)

> 创建应用级悬浮窗

- 参数 : xml内容或者路径 {xml|path} xml或路径
- 返回 : {AppFloaty} 悬浮窗
- 版本 : 1.7.0


```javascript
//你可以直接引入一个布局文件创建一个应用级悬浮窗
定义 应用悬浮窗1 = $悬浮窗.新建应用级("./res/layout/floaty_app.xml");
//你也可以直接把xml写成字符串传入
定义 应用悬浮窗2 = $悬浮窗.新建应用级(`<ui>...</ui>`);
```


### 新建应用级(xml内容或者路径, 可触摸)

> 创建应用级悬浮窗

- 参数 : xml内容或者路径 {xml|path} xml或路径
- 参数 : 可触摸 {布尔值} 是否可触摸(默认:是)
- 返回 : {AppFloaty} 悬浮窗
- 版本 : 1.8.3


```javascript
//你可以直接引入一个布局文件创建一个应用级悬浮窗
定义 应用悬浮窗1 = $悬浮窗.新建应用级("./res/layout/floaty_app.xml",否);
//你也可以直接把xml写成字符串传入
定义 应用悬浮窗2 = $悬浮窗.新建应用级(`<ui>...</ui>`,否);
```


### 新建系统级(xml内容或者路径)

> 创建系统级悬浮窗
> 
> 系统级悬浮窗可以全屏覆盖包括导航栏和状态栏的位置，不过这种悬浮窗容易被第三方应用检测到，部分游戏检测到此类悬浮窗后会自动闪退。

- 参数 : xml内容或者路径 {xml|path} xml或路径
- 返回 : {SysFloaty} 悬浮窗
- 版本 : 1.7.0


```javascript
//你可以直接引入一个布局文件创建一个系统级悬浮窗
定义 系统悬浮窗1 = $悬浮窗.新建系统级("./res/layout/floaty_sys.xml");
//你也可以直接把xml写成字符串传入
定义 系统悬浮窗2 = $悬浮窗.新建系统级(`<ui>...</ui>`);
```


### 新建系统级(xml内容或者路径, 可触摸)

> 创建系统级悬浮窗
> 
> 系统级悬浮窗可以全屏覆盖包括导航栏和状态栏的位置，不过这种悬浮窗容易被第三方应用检测到，部分游戏检测到此类悬浮窗后会自动闪退。

- 参数 : xml内容或者路径 {xml|path} xml或路径
- 参数 : 可触摸 {布尔值} 是否可触摸
- 返回 : {SysFloaty} 悬浮窗
- 版本 : 1.8.3


```javascript
//你可以直接引入一个布局文件创建一个系统级悬浮窗
定义 系统悬浮窗1 = $悬浮窗.新建系统级("./res/layout/floaty_sys.xml",否);
//你也可以直接把xml写成字符串传入
定义 系统悬浮窗2 = $悬浮窗.新建系统级(`<ui>...</ui>`,否);
```


### 新建范围选择(回调)

> 创建选择范围悬浮窗
> 
> 该悬浮窗将显示一个范围选择器，你可以调节选框的大小和位置，当悬浮窗关闭的时候，将会回调出选框的位置和范围数据。

- 参数 : 回调 {SimpleFloatArrCallback} 关闭时回调范围数据
- 返回 : {SelectFloaty} 选择范围悬浮窗
- 版本 : 1.8.3


```javascript
$悬浮窗.新建范围选择((范围)=>{
    日志("用户选择范围:",范围);
});
```


![](./img/floaty_newSelect.png)

### 关闭所有()

> 关闭所有悬浮窗

- 版本 : 1.7.0


```javascript
$悬浮窗.关闭所有();
```


# $global - 全局函数

- 更新时间:2025-12-13 11:58:45

> 全局函数
> 
> 全局函数，在调用的时候无需使用`$`前缀直接写函数即可




### 睡觉(时长)

> 睡觉

- 参数 : 时长 {整数} 毫秒 
- 版本 : 1.0.0


```javascript
//停止1秒钟
睡觉(1000);
```


### 等待(时长)

> 等待

- 参数 : 时长 {整数} 毫秒 
- 版本 : 1.6.8


```javascript
//停止1秒钟
等待(1000);
```


### 提示(信息)

> 提示
> 
> 显示一个对话框出来

- 参数 : 信息 {字符串} 信息 
- 版本 : 1.6.8


```javascript
提示("我是提示");
```


### 弹窗(标题, 信息)

> 对话框

- 参数 : 标题 {字符串} 标题 
- 参数 : 信息 {字符串} 内容 
- 版本 : 1.6.8


```javascript
弹窗("提示对话框","我很好");
```


### 显示图片(图片或路径)

> 显示图片

- 参数 : 图片或路径 {图片|字符串} 图片路径或图片对象 
- 版本 : 1.6.8


```javascript
//显示图片路径上的图片
定义 图片路径 = "sdcard/Pictures/示例/全局函数/t01.png";
显示图片(imgPath);
//显示图片对象(Image)
定义 图片 = $图片.读取(imgPath);
显示图片(图片);
```


### 关闭绘制日志()

> 关闭绘制日志

- 版本 : 1.6.8


```javascript
关闭绘制日志();
```


### 关闭绘制()

> 关闭绘制
> 
> 关闭绘制悬浮窗

- 版本 : 1.6.9


```javascript
关闭绘制();
```


### 清空绘制()

> 清空绘制
> 
> 此方法会清空绘制，但是不会关闭绘制悬浮窗

- 版本 : 1.6.8


```javascript
清空绘制();
```


### 获取剪切板()

> 获取剪切板内容

- 返回 : {字符串} 剪切板内容 
- 版本 : 1.6.8


```javascript
定义 内容 = 获取剪切板();
```


### 设置剪切板(文本)

> 设置剪切板内容

- 参数 : 文本 {字符串} 内容 
- 版本 : 1.6.8


```javascript
设置剪切板("我是剪切板内容");
```


### 剪切板有内容()

> 是否有剪切板内容

- 返回 : {布尔值} 剪切板是否有内容
- 版本 : 1.6.8


```javascript
如果(剪切板有内容()){
    定义 内容 = 获取剪切板();
}
```


### 清空剪切板()

> 清空剪切板内容

- 返回 : {布尔值} 是否清空成功
- 版本 : 1.6.8


```javascript
清空剪切板();
```


### 当前包名()

> 获取无障碍检测到的包名

- 返回 : {字符串} 活动名称
- 版本 : 1.6.8


```javascript
定义 包名 = 当前包名();
```


### 当前类名()

> 获取无障碍检测到的活动名

- 返回 : {字符串} 活动名称
- 版本 : 1.6.8


```javascript
定义 类名 = 当前类名();
```


### 当前时间()

> 获取当前时间戳

- 返回 : {数字} 时间戳
- 版本 : 1.7.8


```javascript
定义 时间戳 = 当前时间();
日志(时间戳);
```


### 信息(内容)

> 悬浮土司提示
> 
> 悬浮窗土司，可以显示在任何app界面，但是需要悬浮窗权限。

- 参数 : 内容 {字符串...} 日志信息  


```javascript
信息("提示信息");
```


### 信息日志(信息)

> 悬浮土司加控制台打印

- 参数 : 信息 {字符串...} 日志信息 


```javascript
信息日志("提示信息");
```


### 土司(信息)

> 系统土司
> 
> 部分手机需要开启通知权限才允许显示在其他应用上方

- 参数 : 信息 {字符串...} 日志信息 


```javascript
土司("信息");
```


### 土司日志(信息)

> 系统土司加控制台打印

- 参数 : 信息 {字符串...} 日志信息 


```javascript
土司日志("提示信息");
```


### 日志(信息)

> 控制台日志

- 参数 : 信息 {字符串...} 日志信息 


```javascript
日志("信息");
```


### 打印(信息)

> 控制台日志

- 参数 : 信息 {字符串...} 日志信息 


```javascript
打印("信息");
```


### 随机数()

> 随机数(0-1)

- 返回 : {float} 随机数(0-1)


```javascript
日志(随机数());//0-1之间的随机数
```


### 随机数(最大值)

> 随机数(0-max)

- 参数 : 最大值 {整数} 最大值 


```javascript
日志(随机数(10));//0-10之间的随机数
```


### 随机数(最小值, 最大值)

> 随机数(min-max)

- 参数 : 最小值 {整数} 最小值 
- 参数 : 最大值 {整数} 最大值 


```javascript
日志(随机数(10,30));//10-30之间的随机数
```


### 导入(路径)

> 导入模块

- 参数 : 路径 {字符串} 模块路径或相对路径 
- 返回 : {JsObject} 模块对象


```javascript
定义 我的类 = 导入("mCls.js");
定义 对象 = 新建 我的类();
```


# $html - 网页操作

- 更新时间:2025-12-13 11:58:45

> 网页操作




### escape(html)

> 转义HTML字符
> 
> 此函数会遍历么一个字符，将特殊字符进行转义。
> 

- 参数 : html 被转义的文本
- 返回 : 转义后的文本


```javascript
let html = "<div>123</div>";
let escapeHtml = $html.escape(html);
```


### unescape(text)

> 还原被转义的HTML特殊字符

- 参数 : text {string} HTML字符串
- 返回 : {string} 转换后的字符串


### cleanHtmlTag(text)

> 清除所有HTML标签

- 参数 : text {string} 文本
- 返回 : {string} 清除标签后的文本


### removeHtmlTag(text, tagNames)

> 删除HTML标签(包括内容)

- 参数 : text {string} 文本
- 参数 : tagNames {string...} 要清除的标签
- 返回 : 去除标签后的文本


### unwrapHtmlTag(text, tagNames)

> 清除指定HTML标签(不包括内容)

- 参数 : text {string} 文本
- 参数 : tagNames {string...} 要清除的标签
- 返回 : {string} 去除标签后的文本


### removeHtmlTag(text, withTagContent, tagNames)

> 清除指定HTML标签

- 参数 : text {string} 文本
- 参数 : withTagContent {boolean} 是否去掉被包含在标签中的内容
- 参数 : tagNames {string...}  要清除的标签
- 返回 : {string} 去除标签后的文本


### removeHtmlAttr(html, attrs)

> 去除HTML标签中的所有属性

- 参数 : html {string} 文本
- 参数 : attrs {string...} 属性名
- 返回 : {string} 处理后的文本


### removeAllHtmlAttr(html, tagNames)

> 去除指定标签的所有属性

- 参数 : html {string} 内容
- 参数 : tagNames {string...} 指定标签
- 返回 : {string} 处理后的文本


### filter(html)

> 过滤HTML文本，防止XSS攻击

- 参数 : html {string} HTML内容
- 返回 : {string} 过滤后的内容


### getWeiYunNote(shortLink)

> 处理腾讯微笔记
> 
> 我们可以在[腾讯微云]->[我的]->[笔记]中创建一个纯文本笔记(切记不要有特殊字符，例如粗体或者改变文本颜色等等特殊处理都不要有)，之后我们点击分享，就可以看到链接最后面的一个字段，我称之为短链接，把短链接放入到这个函数中来，我将解析你的微云笔记，最后把处理好的文本字符串返回给你。
> 
> 这样以来，你可以把腾讯微云当作你的免费云数据库来使用，写一个微云笔记，把自己的数据(例如json字符)存入到笔记中，需要使用的时候使用这个函数拉取后解析成json对象(JSON.parse(str))，就可以使用数据了。

- 参数 : shortLink {string} 短链接 
- 返回 : {string} 处理好的字符串
- 版本 : 1.5.0


```javascript
// 微云笔记链接：https://share.weiyun.com/bnaMAKsa
// 短链接：bnaMAKsa
let noteContent = $html.getWeiYunNote("bnaMAKsa");
// 解析json字符串
let jsonObj = JSON.parse(noteContent);
```


# HttpResponse - 网络请求响应体

- 更新时间:2025-12-13 11:58:45

> HttpResponse - 网络请求响应体




### const {Response} response;

> OkHttp3原生响应对象
> 可以直接调用原生方法
> 如：response.body().string()


### const {String} desc;

> 响应描述
> 如果存在异常,将会设置为异常信息


### const {boolean} success;

> 响应是否成功
> 如果存在异常,将会设置为false


### const {int} statusCode;

> 响应状态码
> 
> 适配auto.js的习惯,保留了这个字段,但是不建议使用,因为不够简约,推荐使用code或者status


### const {int} status;

> 响应状态码


### const {int} code;

> 响应状态码


### const {String} statusMessage;

> 响应状态信息
> 
> 适配auto.js的习惯,保留了这个字段,但是不建议使用,因为不够简约,推荐使用msg


### const {String} msg;

> 响应状态信息


### const {String} method;

> 请求方法


### const {String} url;

> 请求地址


### const {String} str;


### const {String} string;


### const {String} json;


### const {String} bytes;


### getStatusCode()

> 响应状态码

- 返回 : {int} 响应状态码


### getStatusMessage()

> 响应状态信息

- 返回 : {string} 响应状态信息


### str()

> 读取响应字符串

- 返回 : {string} 响应字符串


### string()

> 读取响应字符串
> 
> 适配auto.js的习惯,保留了这个字段,但是不建议使用,因为不够简约,推荐使用str()

- 返回 : {string} 响应字符串


### json()

> 读取响应字符串并转为json对象

- 返回 : {object} 响应字符串转为json对象


### bytes()

> 读取响应字节

- 返回 : {byte[]} 响应字节


### getDesc()

> 读取响应字符串

- 返回 : {string} 响应字符串


### isSuccess()

> 响应是否成功

- 返回 : {boolean} 响应是否成功


### getMethod()

> 响应是否成功

- 返回 : {boolean} 响应是否成功


### getUrl()

> 请求地址

- 返回 : {string} 请求地址


### getStatus()

> 响应状态码

- 返回 : {int} 响应状态码


### getMsg()

> 响应状态码

- 返回 : {int} 响应状态码


# $http - 网络请求

- 更新时间:2025-12-13 11:58:45

> 网络请求




### uri(uri)

> 解析Uri字符串
> 
> 如果你想通过文件提供器{FileProvider}来解析文件路径，那么可以使用$file.uri("path");函数

- 参数 : uri {String} Uri字符串
- 返回 : {Uri} Uri对象
- 版本 : 1.3.7


```javascript
let uri = $http.uri("smsto:"+$str.uriEncode("13693749475"));
```


### get(url)

> 同步请求

- 参数 : url {url} 链接地址
- 返回 : {HttpResponse} 返回结果
- 版本 : 1.2.0


```javascript
//全部配置参数
let opt = {
    url:"",//请求地址
    head:{
        "key":"value",
        "key2":"value2"
    },
    data: "请求数据",//支持file、xml、json、string等类型，会自动判断
    connectTimeout:30, //[可选]连接超时时间(默认30秒)
    readTimeout:30, //[可选]读超时时间(默认30秒)
    writeTimeout:30, //[可选]写超时时间(默认30秒)
    callTimeout:60 //[可选]请求超时时间(默认60秒)
}
//如果要发送文件
let opt = {
    url:"",//请求地址
    head:{ },
    data: "/sdcard/img.png"
}
//如果要发送json
let opt = {
    url:"",//请求地址
    head:{ },
    //直接写json对象，或json字符串也可以
    data: {
        "key":"value",
        "key2":"value2"
    }
}
```


### get(opts)

> GET请求

- 参数 : opts {HttpOptions} 配置
- 返回 : {HttpResponse} 返回结果
- 版本 : 1.2.0


### post(opts)

> POST请求

- 参数 : opts {HttpOptions} 配置
- 返回 : {HttpResponse} 返回结果
- 版本 : 1.2.0


### del(opts)

> DELETE请求

- 参数 : opts {HttpOptions} 配置
- 返回 : {HttpResponse} 返回结果
- 版本 : 1.2.0


### delete(opts)

> DELETE请求

- 参数 : opts {HttpOptions} 配置
- 返回 : {HttpResponse} 返回结果
- 版本 : 1.2.0


### put(opts)

> PUT请求

- 参数 : opts {HttpOptions} 配置
- 返回 : {HttpResponse} 返回结果
- 版本 : 1.2.0


### patch(opts)

> PATCH请求

- 参数 : opts {HttpOptions} 配置
- 返回 : {HttpResponse} 返回结果
- 版本 : 1.2.0


### download(url, savePath)

> 下载文件

- 参数 : url {string}  url
- 参数 : savePath {string} 保存路径


### download(url, savePath, completeCallback)

> 下载文件

- 参数 : url {string}  url
- 参数 : savePath {string} 保存路径
- 参数 : completeCallback {()=>{}} 下载完成回调


### download(url, savePath, completeCallback, onFailure)

> 下载文件

- 参数 : url {string}  url
- 参数 : savePath {string} 保存路径
- 参数 : completeCallback {()=>{}} 下载完成回调
- 参数 : onFailure {(res)=>}  错误回调


### download(url, savePath, progressListener, completeCallback, onFailure)

> 下载文件

- 参数 : url {string}  url
- 参数 : savePath {string} 保存路径
- 参数 : progressListener {(cur,total,percent)=>{}} 进度监听器
- 参数 : completeCallback {()=>{}} 下载完成回调
- 参数 : onFailure {(res)=>}    错误回调


```javascript
$http.download(
"https://pics0.baidu.com/feed/f11f3a292df5e0feee2783e88baf3fa75fdf727e.jpeg?token=4afc91463326e4f4a44e2cde691a54a0",
"/sdcard/美女.png",
(cur,total,percent)=>{
    log("下载进度",percent);
},()=>{
    log("下载完毕");
},(res)=>{
    log("下载失败",res);
});
```


### wifiIp()

> 获取wifi的ip地址
> 
> 如果连接方式不是wifi则返回null

- 返回 : {string} ip地址


# Image - 图片

- 更新时间:2025-12-13 11:58:45

> 表示图片
> 
> 是为了防止图片占用太大的内存,于是封装此对象用于表示图片,一般情况下,在本应用中绝大多数使用图片的场景都会自动回收图片,以免占用过多内存。




### const {int} 宽;


### const {int} 高;


### 获取矩阵()

> 获取mat类型


### 获取位图()

> 获取bitmap类型


### 宽()

> 图片宽度


### 高()

> 图片高度


### 获取宽度()

> 图片宽度


### 获取高度()

> 图片高度


### 关闭()

> 释放资源


### 释放()

> 释放资源


### 获取像素(x, y)

> 获取像素值

- 参数 : x {int} x坐标
- 参数 : y {int} y坐标
- 返回 : {int} 像素值


### 获取像素(位置)

> 获取像素值

- 参数 : 位置 {Point} 坐标
- 返回 : {int} 像素值


### 保存(路径)

> 保存图片

- 参数 : 路径 {String} 保存路径


### 显示()

> 显示图片


### 复制()

> 复制图片
> 
> 从源图片数据中拷贝一份图片后返回

- 返回 : {Image} 拷贝后的图片
- 版本 : 1.7.0


```javascript
定义 截屏 = $屏幕.获取截屏();
定义 图片 = 截屏.复制();
//接下来可以对 '截屏' 以及 '图片' 分别进行操作
```


### json()

> 转json字符串

- 返回 : {String} json字符串


# $img - 图片操作

- 更新时间:2025-12-13 11:58:46

> 图片操作




### 制作透明图(图片, 保留色, 阈值)

> 制作透明图片

- 参数 : 图片 {Image} 需要处理的图片
- 参数 : 保留色 {字符串} 保留的颜色
- 参数 : 阈值 {数字} 允许颜色的误差
- 返回 : {Image} 生成新的png图片
- 版本 : 1.7.0


```javascript
//相对于项目的路径
定义 图片 = $图片.读取("/$图片/res/t01.png");
定义 透明图片 = $图片.制作透明图(图片 ,"#db0306", 20);
//保存到本地
$图片.保存(透明图片,"/$图片/img/s01.png");
$图片.显示(透明图片);
```


### 制作透明图(图片, 保留色, 阈值)

> 制作透明图片
> 
> 注意：颜色的数量和阈值数量保持一致

- 参数 : 图片 {Image} 需要处理的图片
- 参数 : 保留色 {字符串} 保留的颜色
- 参数 : 阈值 {number} 允许颜色的误差
- 返回 : {Image} 生成新的png图片
- 版本 : 1.7.0


```javascript
//相对于项目的路径
定义 图片 = $图片.读取("/$图片/res/t01.png");
定义 透明图片 = $图片.制作透明图(图片 ,["#db0306","#a70602","#a02a16"], [20,20,20]);
//保存到本地
$图片.保存(透明图片,"/$图片/img/s02.png");
$图片.显示(透明图片);
```


### 制作透明图(图片, 保留色, 颜色误差, 参数)

> 制作透明图片

- 参数 : 图片 {Image} 需要处理的图片
- 参数 : 保留色 {字符串} 保留的颜色
- 参数 : 颜色误差 {number} 允许颜色的误差
- 参数 : 参数 {object} 配置参数
- 返回 : {Image} 生成新的png图片
- 版本 : 1.7.0


```javascript
定义 options = {
    isBlur:true,//开启滤波(默认值:true)
    blurSize:1,//滤波大小(默认值:1)
    isDilate:true,//开启膨胀(默认值:true)
    dilateSize:1,//膨胀大小(默认值:1)
    isErode:true,//开启腐蚀(默认值:true)
    erodeSize:3,//腐蚀大小(默认值:3)
}
```


### 读取(图片路径)

> 读取图片
> 
> 支持相对路径写法
> 
> 读取资源失败时会返回空null

- 参数 : 图片路径 {字符串} 图片路径
- 返回 : {Image} 读取的图片
- 版本 : 1.7.0


```javascript
//图片路径
定义 路径 = "sdcard/Pictures/示例/$图片/res/p01.png";
//读取图片
定义 图片 = $图片.读取(路径);
```


### 打开(图片路径)

> 构建img对象
> 
> 和read效果一样的

- 参数 : 图片路径 {字符串} 图片路径
- 返回 : {Image} 图片对象
- 版本 : 1.7.0


```javascript
//图片路径
定义 路径 = "sdcard/Pictures/示例/$图片/res/p01.png";
//读取图片
定义 图片 = $图片.打开(路径);
```


### 打开(位图)

> 构建img对象

- 参数 : 位图 {Bitmap} 安卓图片对象
- 返回 : {Image} 图片对象
- 版本 : 1.7.0


```javascript
//解析布局,获得ui对象
定义 界面 = $界面.解析布局("./mUi.xml");
//获取控件
定义 图片控件 = 界面.找控件("我的图片");
//获取图片(安卓图片对象)
定义 位图 = 图片控件.获取图片();
//构建'$图片'对象
定义 图片 = $图片.打开(位图);
```


### 读取(图片文件)

> 读取图片
> 
> 读取资源失败时会返回空null

- 参数 : 图片文件 {File} 图片路径
- 返回 : {Image} 读取的图片
- 版本 : 1.7.0


### 保存(图片, 路径, 格式, 质量)

> 保存图片
> 
> 支持相对路径写法

- 参数 : 图片 {Image} 需要保存的图片
- 参数 : 路径 {字符串} 保存路径
- 参数 : 格式 {字符串} 格式
- 参数 : 质量 {整数} 质量
- 版本 : 1.7.0


```javascript
//截屏并且保存到本地
//但是在实际中我们可以直接调用'$屏幕.保存("路径");'更加方便
$屏幕.获取权限();
定义 截屏图片 = $屏幕.获取截屏();
$图片.保存(截屏图片,"/$图片/img/s05.png","png",100);
```


### 保存(图片, 路径)

> 保存图片
> 
> 默认保存png格式，质量为100，支持相对路径写法

- 参数 : 图片 {Image} 需要保存的图片
- 参数 : 路径 {字符串} 保存路径
- 版本 : 1.7.0


```javascript
//截屏并且保存到本地
//但是在实际中我们可以直接调用'$屏幕.保存("路径");'更加方便
$屏幕.获取权限();
定义 屏幕截屏 = $屏幕.获取截屏();
$图片.保存(屏幕截屏,"/$图片/img/s05.png");
```


### 转base64(图片, 格式, 质量)

> 转换base64

- 参数 : 图片 {Image} 需要转换为base64的图片
- 参数 : 格式 {字符串} 格式
- 参数 : 质量 {整数} 质量
- 返回 : 图片的base64字符串
- 版本 : 1.7.0


```javascript
定义 图片 = $图片.读取("/$图片/res/t01.png");
定义 字符串 = $图片.转base64( 图片 ,"png" , 50);
提示("图片Base64",字符串);
```


### 转base64(图片)

> 转换base64

- 参数 : 图片 {Image} 需要转换的图片
- 返回 : {字符串} base64字符串
- 版本 : 1.7.0


```javascript
//图片路径
定义 路径 = "sdcard/Pictures/示例/$图片/res/p01.png";
//读取图片
定义 图片 = $图片.读取(路径);
//转化为base64
定义 图片Base64 = $图片.转base64(图片);
日志(图片Base64)
```


### 转base64(路径)

> 转换base64

- 参数 : 路径 {字符串} 需要转换的图片
- 返回 : {字符串} base64字符串
- 版本 : 1.7.0


```javascript
//图片路径
定义 路径 = "sdcard/Pictures/示例/$图片/res/p01.png";
//转化为base64
定义 图片Base64 = $图片.转base64(路径);
日志(图片Base64)
```


### 读取base64(base64)

> 加载base64

- 参数 : base64 {字符串} base64字符串
- 返回 : {Image} 图片对象
- 版本 : 1.7.0


```javascript
定义 图片 = $图片.读取("/$图片/res/t01.png");
定义 字符串 = $图片.转base64( 图片 ,"png" , 50);
提示("图片Base64",字符串);
//从base64中读取图片
定义 图片2 = $图片.读取base64(baseStr);
显示图片(图片2);
```


### 裁剪(图片, x, y, w, h)

> 裁剪图片

- 参数 : 图片 {img} 原本的图片
- 参数 : x {整数}  开始坐标
- 参数 : y {整数} 开始坐标
- 参数 : w {整数}  宽度
- 参数 : h {整数} 高度
- 返回 : {Image} 新的图片
- 版本 : 1.7.0


```javascript
//图片路径
定义 路径 = "sdcard/Pictures/示例/$图片/res/p03.png";
//读取图片
定义 图片 = $图片.读取(路径);
//操作图片
定义 裁剪后图片 = $图片.裁剪(图片, 0, 0, 300, 200);
//显示图片
$图片.显示(裁剪后图片);
```


### 设置尺寸(图片, w, h, 插值方式)

> 设置尺寸
> 
> 插值方式(忽略大小写)：
> NEAREST,
> LINEAR,
> CUBIC,
> AREA,
> LANCZOS4,
> EXACT

- 参数 : 图片 {Image}      需要处理的图片
- 参数 : w {整数} 宽度
- 参数 : h {整数}  高度
- 参数 : 插值方式 {字符串} 插值方式
- 返回 : 图片
- 版本 : 1.7.0


```javascript
//图片路径
定义 路径 = "sdcard/Pictures/示例/$图片/res/p02.png";
//读取图片
定义 图片 = $图片.读取(路径);
//操作图片
定义 新图片 = $图片.设置尺寸(图片, 200, 200, "INTER_CUBIC");
//显示图片
$图片.显示(新图片);
```


### 设置尺寸(图片, w, h)

> 设置尺寸
> 
> 使用默认插值方式:LINEAR

- 参数 : 图片 {Image} 需要处理的图片
- 参数 : w {整数} 宽度
- 参数 : h {整数} 高度
- 返回 : {Image} 处理后的图片
- 版本 : 1.7.0


```javascript
//图片路径
定义 路径 = "sdcard/Pictures/示例/$图片/res/p02.png";
//读取图片
定义 图片 = $图片.读取(路径);
//操作图片
定义 新图片 = $图片.设置尺寸(图片, 200, 200);
//显示图片
$图片.显示(新图片);
```


### 缩放(图片, 缩放X, 缩放Y, 插值方式)

> 缩放图片

- 参数 : 图片 {Image}  需要处理的图片
- 参数 : 缩放X {double} 宽度缩放倍数
- 参数 : 缩放Y {double}   高度缩放倍数
- 参数 : 插值方式 {字符串}  插值方式
- 返回 : {Image} 处理后的图片
- 版本 : 1.7.0


```javascript
//图片路径
定义 路径 = "sdcard/Pictures/示例/$图片/res/p02.png";
//读取图片
定义 图片 = $图片.读取(路径);
//操作图片
定义 新图片 = $图片.缩放(图片, 0.3, 0.2, "CUBIC");
//显示图片
$图片.显示(新图片);
```


### 缩放(图片, 缩放X, 缩放Y)

> 缩放图片

- 参数 : 图片 {Image}  需要处理的图片
- 参数 : 缩放X {double} 宽度缩放倍数
- 参数 : 缩放Y {double} 高度缩放倍数
- 返回 : {Image} 处理后的图片
- 版本 : 1.7.0


```javascript
//图片路径
定义 路径 = "sdcard/Pictures/示例/$图片/res/p02.png";
//读取图片
定义 图片 = $图片.读取(路径);
//操作图片
定义 新图片 = $图片.缩放(图片, 0.3, 0.2);
//显示图片
$图片.显示(新图片);
```


### 旋转(图片, 角度, x, y)

> 旋转图片

- 参数 : 图片 {Image} 需要处理的图片
- 参数 : 角度 {小数} 旋转的角度
- 参数 : x {整数} 旋转中心点x坐标
- 参数 : y {整数} 旋转中心点y =坐标
- 返回 : {Image} 处理后的图片
- 版本 : 1.7.0


```javascript
//图片路径
定义 路径 = "sdcard/Pictures/示例/$图片/res/p02.png";
//读取图片
定义 图片 = $图片.读取(路径);
//操作图片
定义 新图片 = $图片.旋转(图片, 45, 100, 200);
//显示图片
$图片.显示(新图片);
```


### 旋转(图片, 角度)

> 旋转图片

- 参数 : 图片 {Image}  需要处理的图片
- 参数 : 角度 {小数} 旋转的角度
- 返回 : {Image}  处理后的图片
- 版本 : 1.7.0


```javascript
//图片路径
定义 路径 = "sdcard/Pictures/示例/$图片/res/p02.png";
//读取图片
定义 图片 = $图片.读取(路径);
//操作图片
定义 新图片 = $图片.旋转(图片, 45);
//显示图片
$图片.显示(新图片);
```


### 旋转(图片)

> 旋转图片
> 
> 默认旋转90度

- 参数 : 图片 {Image}   需要处理的图片
- 返回 : {Image}   处理后的图片
- 版本 : 1.7.0


```javascript
//图片路径
定义 路径 = "sdcard/Pictures/示例/$图片/res/p02.png";
//读取图片
定义 图片 = $图片.读取(路径);
//操作图片
定义 新图片 = $图片.旋转(图片);//默认旋转90度
//显示图片
$图片.显示(新图片);
```


### 拼接(图片1, 图片2, 拼接方向)

> 拼接图片

- 参数 : 图片1 {Image}     需要拼接的图片1
- 参数 : 图片2 {Image}  需要拼接的图片2
- 参数 : 拼接方向 {字符串} 拼接方向(左,右,上,下)
- 返回 : {Image}  拼接好的图片
- 版本 : 1.7.0


```javascript
//相对于项目的路径
定义 图片1 = $图片.读取("/$图片/res/t02.png");
定义 图片2 = $图片.读取("/$图片/res/t03.png");
//调整一下尺寸(保持一致)
图片1 = $图片.设置尺寸(图片1,300,200);
图片2 = $图片.设置尺寸(图片2,300,200);
//调整一下大小
定义 图片 = $图片.拼接(图片1,图片2,"下");
显示图片(图片);
```


### 灰度化(图片)

> 灰度化

- 参数 : 图片 {Image} 需要灰度化的图片
- 返回 : {Image}  灰度化的图片
- 版本 : 1.7.0


```javascript
//图片路径
定义 路径 = "sdcard/Pictures/示例/$图片/res/p02.png";
//读取图片
定义 图片 = $图片.读取(路径);
//操作图片
定义 新图片 = $图片.灰度化(图片);
//显示图片
$图片.显示(新图片);
```


### 二值化(图片, 最小阈值, 最大阈值)

> 二值化图片

- 参数 : 图片 {Image} 需要处理的图片
- 参数 : 最小阈值 {double} 最小阈值
- 参数 : 最大阈值 {double} 最大阈值
- 返回 : {Image} 处理后的图片
- 版本 : 1.7.0


```javascript
//图片路径
定义 路径 = "sdcard/Pictures/示例/$图片/res/p02.png";
//读取图片
定义 图片 = $图片.读取(路径);
//操作图片
定义 新图片 = $图片.二值化(图片, 150, 255);
//显示图片
$图片.显示(新图片);
```


### 自适应二值化(图片, 最大值, 自适应算法, 阈值化类型, 邻域块大小, 偏移值调整量)

> 自适应二值化

- 参数 : 图片 {Image} 图片
- 参数 : 最大值 {number} 最大值
- 参数 : 自适应算法 {字符串} 在一个邻域内计算阈值所采用的算法 默认值是：GAUSSIAN_C
- 参数 : 阈值化类型 {字符串} 阈值化类型 默认值是：BINARY
- 参数 : 邻域块大小 {number} 邻域块大小
- 参数 : 偏移值调整量 {number} 偏移值调整量
- 返回 : {Image} 处理后的图片
- 版本 : 1.7.0


```javascript
//图片路径
定义 路径 = "sdcard/Pictures/示例/$图片/res/p02.png";
//读取图片
定义 图片 = $图片.读取(路径);
//操作图片
定义 新图片 = $图片.自适应二值化(图片,255,"MEAN_C","BINARY", 11, 2);
//显示图片
$图片.显示(新图片);
```


### 颜色空间转换(图片, 转换类型, 颜色通道数量)

> 颜色空间转换

- 参数 : 图片 {Image} 图片
- 参数 : 转换类型 {字符串} 颜色空间转换的类型，可选的值有一共有205个 默认值:COLOR_BGR2GRAY
- 参数 : 颜色通道数量 {整数} 目标图像的颜色通道数量，如果不填写则根据其他参数自动决定。
- 返回 : {Image} 颜色转换后的图片
- 版本 : 1.7.0


```javascript
//图片路径
定义 路径 = "sdcard/Pictures/示例/$图片/res/p02.png";
//读取图片
定义 图片 = $图片.读取(路径);
//操作图片
定义 新图片 = $图片.颜色空间转换(图片,"RGBA2BGR",null);
//显示图片
$图片.显示(新图片);
```


### 颜色空间转换(图片, 转换类型)

> 颜色空间转换

- 参数 : 图片 {Image} 图片
- 参数 : 转换类型 {字符串} 颜色空间转换的类型，可选的值有一共有205个 默认值:COLOR_BGR2GRAY
- 返回 : {Image} 颜色转换后的图片
- 版本 : 1.7.0


```javascript
//图片路径
定义 路径 = "sdcard/Pictures/示例/$图片/res/p02.png";
//读取图片
定义 图片 = $图片.读取(路径);
//操作图片
定义 新图片 = $图片.颜色空间转换(图片,"RGBA2BGR");
//显示图片
$图片.显示(新图片);
```


### 图片二值化(图片, 颜色下界, 颜色上界)

> 图片二值化

- 参数 : 图片 {Image} 图片
- 参数 : 颜色下界 {string|number}  颜色下界
- 参数 : 颜色上界 {string|number}  颜色上界
- 返回 : {Image} 处理后的图片
- 版本 : 1.7.0


```javascript
//图片路径
定义 路径 = "sdcard/Pictures/示例/$图片/res/p02.png";
//读取图片
定义 图片 = $图片.读取(路径);
//操作图片
定义 新图片 = $图片.图片二值化(图片,"#666666","#FFFFFF");
//显示图片
$图片.显示(新图片);
```


### 滤波(图片, 滤波器大小, 锚点, 推断类型)

> 模糊处理
> 
> 模糊类型(不区分大小写)：
> CONSTANT,
> REPLICATE,
> REFLECT,
> WRAP,
> REFLECT_101,
> TRANSPARENT,
> REFLECT101,
> DEFAULT,
> ISOLATED

- 参数 : 图片 {Image} 图片
- 参数 : 滤波器大小 {double[]} 定义滤波器的大小，如[3, 3]
- 参数 : 锚点 {double[]} 指定锚点位置(被平滑点)，默认为图像中心
- 参数 : 推断类型 {字符串} 推断边缘像素类型，默认为"DEFAULT"
- 返回 : {Image} 处理后的图片
- 版本 : 1.7.0


```javascript
//图片路径
定义 路径 = "sdcard/Pictures/示例/$图片/res/p02.png";
//读取图片
定义 图片 = $图片.读取(路径);
//操作图片
定义 新图片 = $图片.滤波(图片,[10,10],[-1,-1],"REPLICATE");
//显示图片
$图片.显示(新图片);
```


### 中值滤波(图片, 滤波器大小)

> 中值滤波

- 参数 : 图片 {Image} 图片
- 参数 : 滤波器大小 {整数} 定义滤波器的大小
- 返回 : {Image} 处理后的图片
- 版本 : 1.7.0


```javascript
//图片路径
定义 路径 = "sdcard/Pictures/示例/$图片/res/p02.png";
//读取图片
定义 图片 = $图片.读取(路径);
//操作图片
定义 新图片 = $图片.中值滤波(图片,3);
//显示图片
$图片.显示(新图片);
```


### 高斯滤波(图片, 滤波器大小, x方差, y方差, 推断类型)

> 高斯模糊
> 
> 模糊类型(不区分大小写)：
> CONSTANT,
> REPLICATE,
> REFLECT,
> WRAP,
> REFLECT_101,
> TRANSPARENT,
> REFLECT101,
> DEFAULT,
> ISOLATED

- 参数 : 图片 {Image} 图片
- 参数 : 滤波器大小 {double[]} 定义滤波器的大小，如[3, 3]
- 参数 : x方差 {double} x方向的标准方差，不填写则自动计算
- 参数 : y方差 {double} y方向的标准方差，不填写则自动计算
- 参数 : 推断类型 {字符串} 推断边缘像素类型，默认为"DEFAULT"
- 返回 : {Image} 处理后的图片
- 版本 : 1.7.0


```javascript
//图片路径
定义 路径 = "sdcard/Pictures/示例/$图片/res/p02.png";
//读取图片
定义 图片 = $图片.读取(路径);
//操作图片
定义 新图片 = $图片.高斯滤波(图片,[15,15],0,0,"WRAP");
//显示图片
$图片.显示(新图片);
```


### 左右翻转(图片)

> 左右翻转

- 参数 : 图片 {Image} 需要处理的图片
- 返回 : {Image} 处理后的图片
- 版本 : 1.7.0


```javascript
//图片路径
定义 路径 = "sdcard/Pictures/示例/$图片/res/p02.png";
//读取图片
定义 图片 = $图片.读取(路径);
//操作图片
定义 新图片 = $图片.左右翻转(图片);
//显示图片
$图片.显示(新图片);
```


### 上下翻转(图片)

> 上下翻转

- 参数 : 图片 {Image} 需要处理的图片
- 返回 : {Image} 处理后的图片
- 版本 : 1.7.0


```javascript
//图片路径
定义 路径 = "sdcard/Pictures/示例/$图片/res/p02.png";
//读取图片
定义 图片 = $图片.读取(路径);
//操作图片
定义 新图片 = $图片.上下翻转(图片);
//显示图片
$图片.显示(新图片);
```


### 翻转(图片, sx, sy)

> 水平翻转

- 参数 : 图片 {Image} 需要处理的图片
- 参数 : sx {小数}   横向翻转的方向
- 参数 : sy {小数}  纵向翻转的方向
- 返回 : {Image} 处理后的图片
- 版本 : 1.7.0


```javascript
//图片路径
定义 路径 = "sdcard/Pictures/示例/$图片/res/p02.png";
//读取图片
定义 图片 = $图片.读取(路径);
//操作图片(上下反转)
定义 新图片 = $图片.翻转(图片,-1,-1);
//显示图片
$图片.显示(新图片);
```


### 放在上面(大图, 小图, x, y)

> 在大图片上面放置一个小图片

- 参数 : 大图 {Image} 大图片
- 参数 : 小图 {Image} 小图片
- 参数 : x {整数} 小图片左上角x
- 参数 : y {整数} 小图片左上角y
- 返回 : {Image}  处理完成的图片
- 版本 : 1.7.0


```javascript
//图片路径
定义 路径1 = "sdcard/Pictures/示例/$图片/res/p02.png"; //大图片
定义 路径2 = "sdcard/Pictures/示例/$图片/res/p04.png"; //小图片
定义 大图 = $图片.读取(路径1);
定义 小图 = $图片.读取(路径2);
//设置放置的位置
定义 新图片 = $图片.放在上面(大图, 小图, 20, 20);
//显示图片
$图片.显示(新图片);
```


### 找色(图片, 颜色, 阈值, x, y, w, h)

> 查找颜色

- 参数 : 图片 {Image} 需要处理的图片
- 参数 : 颜色 {字符串} 需要查找的颜色
- 参数 : 阈值 {整数} 阈值
- 参数 : x {整数} 范围x起点坐标
- 参数 : y {整数} 范围y起点坐标
- 参数 : w {整数} 范围宽度
- 参数 : h {整数} 范围高度
- 返回 : {Image} 处理后的图片
- 版本 : 1.7.0


```javascript
定义 图片 = $图片.读取("/$图片/res/t01.png");
定义 位置 = $图片.找色(图片,"#d80005",5,0,0,100,100);
提示("结果",位置);
```


### 找色(图片, 颜色, 阈值, 范围)

> 查找颜色

- 参数 : 图片 {Image} 需要处理的图片
- 参数 : 颜色 {字符串} 需要查找的颜色
- 参数 : 阈值 {整数} 阈值
- 参数 : 范围 {int[]}  找色范围
- 返回 : {Point} 找到的结果
- 版本 : 1.7.0


```javascript
定义 图片 = $图片.读取("/$图片/res/t01.png");
定义 位置 = $图片.找色(图片,"#d80005",5,[0,0,100,100]);
提示("结果",位置);
```


### 找色(图片, 颜色, 阈值)

> 查找颜色

- 参数 : 图片 {Image}  需要处理的图片
- 参数 : 颜色 {字符串} 需要查找的颜色
- 参数 : 阈值 {整数} 阈值
- 返回 : {Image} 处理后的图片
- 版本 : 1.7.0


```javascript
定义 图片 = $图片.读取("/$图片/res/t01.png");
定义 位置 = $图片.找色(图片,"#d80005",5);
提示("结果",位置);
```


### 找色(图片, 颜色)

> 查找颜色

- 参数 : 图片 {Image} 需要处理的图片
- 参数 : 颜色 {字符串} 需要查找的颜色
- 返回 : {Image} 处理后的图片
- 版本 : 1.7.0


```javascript
定义 图片 = $图片.读取("/$图片/res/t01.png");
定义 位置 = $图片.找色(图片,"#d80005");
提示("结果",位置);
```


### 多点找色(图片, 范围, 起点颜色, 阈值, 点色数据)

> 多点找色

- 参数 : 图片 {Image} 图片
- 参数 : 范围 {int[]} 范围
- 参数 : 起点颜色 {字符串} 起点颜色
- 参数 : 阈值 {整数} 起点色阈值
- 参数 : 点色数据 {int[]} 点色数据
- 返回 : {point} 位置
- 版本 : 1.7.0


```javascript
定义 图片 = $图片.读取("/$图片/res/t01.png");
定义 位置 = $图片.多点找色(图片,[0],"#e70216",5,[
	-54, -13, "#db0306", 5,
	-121, -13, "#dc0407", 5,
	-155, -18, "#d80306", 5,
	-132, -85, "#da0306", 5,
	-78, -63, "#dd0206", 5,
	-49, -100, "#db0306", 5,
	6, -77, "#db0306", 5,
	3, -42, "#db0306", 5,
	-103, -52, "#dc0406", 5,
]);
提示("结果",位置);
```


### 找图(大图片, 小图片, 参数)


### 找图(大图片, 小图片)

> 找图

- 参数 : 大图片 {Image} 大图片
- 参数 : 小图片 {Image} 小图片
- 返回 : 找到的位置(中心点)
- 版本 : 1.7.0


```javascript
//相对于项目的路径
定义 图片1 = $图片.读取("/$图片/res/t05.png");
定义 图片2 = $图片.读取("/$图片/res/t04.png");
定义 位置 = $图片.找图(图片1,img2);
提示("结果",位置);
```


### 找到所有图(大图片, 小图片, 参数)

> 找到所有图片位置

- 参数 : 大图片 {Image} 大图片
- 参数 : 小图片 {Image} 需要查找的小图片
- 参数 : 参数 {object} 查找参数
- 返回 : {point[]} 所有的位置集合
- 版本 : 1.7.0


```javascript
定义 图片1 = $图片.读取("/$图片/res/t06.png");
定义 图片2 = $图片.读取("/$图片/res/t07.png");
定义 位置 = $图片.找到所有图(图片1,图片2,{
    similar:0.8,//(可选)相似度
    region:[0,0,350,280],//(可选)范围
    trans:false,//(可选)是否开启透明找图模式
    drawResult:true,//(可选)是否保存结果图片
    savePath:"/$图片/img/result.png",//(可选)保存结果图片
});
提示("结果",位置);
如果($文件.存在("/$图片/img/result.png")){
    显示图片("/$图片/img/result.png");
}
```


### 找到所有图(大图片, 小图片)

> 找到所有图片位置

- 参数 : 大图片 {Image} 大图片
- 参数 : 小图片 {Image} 需要查找的小图片
- 返回 : {point[]} 所有的位置集合
- 版本 : 1.7.0


```javascript
定义 图片1 = $图片.读取("/$图片/res/t06.png");
定义 图片2 = $图片.读取("/$图片/res/t07.png");
定义 位置 = $图片.找到所有图(图片1,图片2);
提示("结果",位置);
如果($文件.存在("/$图片/img/result.png")){
    显示图片("/$图片/img/result.png");
}
```


### 特征匹配(大图, 小图, 参数)

> 特征匹配

- 参数 : 大图 {Image} 大图
- 参数 : 小图 {Image} 小图
- 参数 : 参数 {Image} 特征匹配参数
- 返回 : {Result} 结果集
- 版本 : 1.7.0


```javascript
定义 图片1 = $图片.读取("/$图片/res/t04.png");
定义 图片2 = $图片.读取("/$图片/res/t05.png");
定义 point = $图片.特征匹配(图片1,图片2,{
    similar:0.75,//(可选)相似度
    fastMode:false,//(可选)快速模式
    isGray:false,//(可选)灰度化后匹配
    drawKeyPoints:false,//(可选)结果图片是否绘制特征点
    drawMatches:true,//(可选)结果图片是否绘制匹配点
    drawResult:true,//(可选)是否绘制结果图片
    savePath:"/$图片/img/result_feature.png",//(可选)保存图片路径
});
提示("结果",point);
如果($文件.存在("/$图片/img/result_feature.png")){
    显示图片("/$图片/img/result_feature.png");
}
```


### 特征匹配(大图, 小图)

> 特征匹配

- 参数 : 大图 {Image}  大图
- 参数 : 小图 {Image} 小图
- 返回 : {Result} 找到的图片中心点
- 版本 : 1.7.0


```javascript
定义 图片1 = $图片.读取("/$图片/res/t04.png");
定义 图片2 = $图片.读取("/$图片/res/t05.png");
定义 位置 = $图片.特征匹配(图片1,img2);
提示("结果",位置);
```


### 显示(图片)

> 显示图片

- 参数 : 图片 {Image} 需要显示的图片
- 版本 : 1.7.0


### 显示(路径)

> 显示图片

- 参数 : 路径 {字符串} 图片路径
- 版本 : 1.7.0


```javascript
//把图片显示在屏幕上
定义 图片路径 = "sdcard/Pictures/t01.png";
$图片.显示(图片路径);
```


# $log - 日志框架

- 更新时间:2025-12-13 11:58:45

> 日志框架




### 信息(数据)

> 打印信息日志

- 参数 : 数据 {数据...} 日志
- 版本 : 1.7.0


```javascript
$日志.信息("信息");
```


### 调试(数据)

> 打印调试日志

- 参数 : 数据 {数据...} 日志
- 版本 : 1.7.0


```javascript
$日志.调试("调试");
```


### 警告(数据)

> 打印警告日志

- 参数 : 数据 {数据...} 日志
- 版本 : 1.7.0


```javascript
$日志.警告("警告");
```


### 异常(数据)

> 打印异常日志

- 参数 : 数据 {数据...} 日志
- 版本 : 1.7.0


```javascript
$日志.异常("异常");
```


### 日志(数据)

> 打印日志

- 参数 : 数据 {数据...} 日志
- 版本 : 1.7.0


```javascript
$日志.日志("hello");
```


### 打印(数据)

> 打印日志

- 参数 : 数据 {数据...} 日志
- 版本 : 1.7.0


```javascript
$日志.打印("hello");
```


### 悬浮窗()

> 打开日志悬浮窗

- 版本 : 1.7.0


```javascript
$日志.悬浮窗();
```


### 界面()

> 打开日志界面

- 版本 : 1.7.0


```javascript
$日志.界面();
```


### 删除缓存()

> 删除本地缓存

- 版本 : 1.7.0


```javascript
$日志.删除缓存();
```


# $media - 媒体播放

- 更新时间:2025-12-13 11:58:45

> 媒体播放




### 播放(路径)

> 播放音频
> 
> 直接播放音频，播放结束之后我将自动回收音频资源。
> 
> 注意:如果音频资源加载失败会返回null，资源文件已经处于播放状态也会返回null(不过一般不会出现这个情况，因为每次调用播放函数的时候都会重新创建新的媒体播放器，因此播放状态也是未播放的)。

- 参数 : 路径 {字符串} 音频路径(支持相对路径) 
- 返回 : {MediaPlayer} 媒体播放器
- 版本 : 1.7.0


```javascript
$媒体.播放("res/mTip.mp3");
```


### 创建()

> 创建媒体播放器
> 
> 当你拿到MediaPlayer对象之后，它的所有方法请参考{android.media.MediaPlayer}类

- 返回 : {MediaPlayer} 媒体播放器
- 版本 : 1.7.0


```javascript
定义 mediaPlayer = $媒体.创建();
//常用的{MediaPlayer}方法有:其他方法请参考{android.media.MediaPlayer}类
//mediaPlayer.isPlaying();//是否处于播放状态
//mediaPlayer.isLooping();//是否是循环播放
//mediaPlayer.start();//开始播放
//mediaPlayer.stop();//停止播放
//mediaPlayer.getDuration();//总时长
//mediaPlayer.getCurrentPosition();//当前进度
//mediaPlayer.seekTo(long,int);//跳转到进度
//mediaPlayer.seekTo(int);//跳转到进度
//mediaPlayer.prepare();//准备资源
//mediaPlayer.reset();//重置
//mediaPlayer.release();//释放资源
```


### 创建(路径)

> 创建媒体播放器
> 
> 创建媒体播放器，并且加载音频路径，如果加载成功则返回媒体播放器，如果加载失败则返回null。

- 参数 : 路径 {字符串} 音频路径(支持相对路径) 
- 返回 : {MediaPlayer} 媒体播放器
- 版本 : 1.7.0


### 设置路径(mediaPlayer, 路径)

> 为媒体播放器设置音频路径
> 
> 如果音频资源没有找到，则会返回false，如果成功设置，则会准备音频，并且返回true。
> 
> 如果此函数被重复调用，可能会抛出异常。

- 参数 : mediaPlayer {MediaPlayer} 媒体播放器 
- 参数 : 路径 {字符串} 音频路径 
- 返回 : {布尔值} 是否设置成功
- 版本 : 1.7.0


# OcrOptions - 识别配置

- 更新时间:2025-12-13 11:58:45

> 识别配置




### const {String} 颜色;

> 二值化识别需要指定文字颜色


### const {Number[]} 范围;

> 识别区域


### const {Integer} 阈值;

> 二值化识别文字用到的阈值


### const {Boolean} 是否灰度化;

> 是否使用灰度化识别


### const {Boolean} 是否提取数字;

> 是否提取数字


### const {Boolean} 是否保存图片;

> 是否保存结果


### const {String} 保存路径;

> 保存路径


# $ocr - 文字识别

- 更新时间:2025-12-13 11:58:45

> 文字识别
> 
> 文字识别是指通过计算机视觉技术，将图片中的文字提取出来，转换为程序可处理的文本格式。文字识别在很多场景下都有广泛的应用，比如文档扫描、图片识别、验证码识别等等。
> 
> 目前本应用内涵盖三种识别引擎,分别是 PaddleOcr、PpOcrV5、GoogleMlkit。




### 版本(版本名称)

> 设置要使用的OCR引擎
> 
> 下面我简单介绍几个识别引擎的特点,ncnn速度最快,但是部分手机会出现识别混乱的现象;
> mlkit是google提供的OCR引擎,速度较慢,但是识别准确率较高,并且兼容性比ncnn好很多;
> ppv5是2025年比较流行的一款OCR识别方案,支持识别中英文以及特殊字符,精确度高,不过它是和ncnn同系列的产品;

- 参数 : 版本名称 {字符串} 可选:ncnn,mlkit(默认),ppv5 
- 版本 : 1.6.0


```javascript
//此函数要放在识别之前调用
$文字识别.版本("mlkit"); //设置要使用的OCR引擎
```


### 初始化()

> 初始化ocr
> 
> 在使用OCR(文字识别)之前,需要加载文字模型,因此需要进行初始化,不过目前版本来看,初始化速度都很快,一般都在1秒左右
> 
> 实际上mlkit是不需要初始化的,此外如果你忘记了初始化,在进行识别文字的时候,也会自动进行初始化

- 返回 : {结果集} 结果
- 版本 : 1.6.0


```javascript
$文字识别.初始化();
```


### 识别位置(文字, 配置)

> 识别文字拿位置
> 
> 识别后将把每行结果去除空格和换行符后,判断是否包含指定文字,如果包含则返回该文字识别出来的位置
> 
> 该函数其实是对'识别()'函数的封装,只是在识别到文字后,会判断文字关系是否包含指定文字,如果包含则返回该文字识别出来的位置

- 参数 : 文字 {字符串} 文字 
- 参数 : 配置 {对象} 配置 
- 返回 : {Point} 位置
- 版本 : 1.6.0


```javascript
//配置方式1:灰度化识别
定义 配置1 = {
    范围: [0,0,200,100], //(可选)识别范围(为空则识别整个屏幕)
    是否灰度化: 是, //(必须)开启灰度化(默认:否),开启后会将图片转换为灰度图,识别速度会快很多,但是识别准确率会低一些
    是否保存图片: 是, //(可选)是否保存图片(默认:否),开启后会将识别到的图片保存到指定路径
    保存路径: "/sdcard/ocr.png" //(可选)保存图片路径(为空则不保存图片),仅开启保存图片功能时有效
};
//配置方式2:二值化识别
定义 配置2 = {
    范围: [0,0,200,100], //(可选)识别范围(为空则识别整个屏幕)
    颜色: "#EEEEEE", //(必须)文字颜色(默认:#EEEEEE)
    阈值: 20, //(可选)二值化阈值(默认:20)推荐在20-50之间
    是否保存图片: 是, //(可选)是否保存图片(默认:否),开启后会将识别到的图片保存到指定路径
    保存路径: "/sdcard/ocr.png" //保存图片路径(为空则不保存图片),仅开启保存图片功能时有效
};
//上面的配置自己根据自身需求选择一个即可
//返回opencv的Point对象
定义 识别结果 = $文字识别.识别位置("文字", 配置2);
如果 (识别结果 != 空) {
    //直接点击opencv的Point对象
    $动作.点击(识别结果);
}
```


### 识别单行(配置)

> 识别单行文字
> 
> 识别的方式有二值化和灰度化，自行配置即可，识别完成后会对识别的结果进行包装处理，提取出文字为单行字符串，并且去除不需要的空格和换行符。
> 
> 当你开启提取数字的时候,该函数会把提取的数字按照','号进行分隔。
> 
> 该函数是对'识别()'函数的封装,只是在识别到文字后,会先去除空白字符之后拼接成一行;

- 参数 : 配置 {对象} 配置 
- 返回 : {字符串} 一行字符
- 版本 : 1.0.0


```javascript
定义 配置 = {
    范围: [0,0,200,100], //(推荐)识别范围(为空则识别整个屏幕)
    是否提取数字: 是, //(可选)是否提取数字(用,号分割)
    //其他配置项目参考'识别()'方法
};
定义 结果 = $文字识别.识别单行(配置);
```


### 识别(配置)

> 识别文字
> 
> 会自动截屏并且识别文字,支持灰度化识别,支持二值化(默认)识别
> 
> 如果你是小白,那么请记住:二值化其实就是把图片转换为黑白的图片,而灰度化就是把图片转换为灰度的图片,经过处理之后的图片识别起来更加准确。

- 参数 : 配置 {对象} 参数 
- 返回 : {结果集} 结果
- 版本 : 1.0.0


```javascript
//灰度化识别
定义 配置1 = {
    范围: [0,0,200,100], //(推荐)识别范围(为空则识别整个屏幕)
    是否灰度化: 是, //(推荐)开启灰度化
    是否保存图片: 是, //(可选)是否保存图片
    保存路径: "./资源/处理后的图片.png" //(可选)保存图片路径(为空则不保存图片)
};
定义 结果1 = $文字识别.识别(配置1);
//二值化识别
定义 配置2 = {
    范围: [0,0,200,100], //(推荐)识别范围(为空则识别整个屏幕)
    颜色: "#EEEEEE", //(推荐)文字颜色(默认:#EEEEEE)
    阈值: 20, //(推荐)二值化阈值(默认:20)
    是否保存图片: 是, //(可选)是否保存图片
    保存路径: "./资源/处理后的图片.png" //(可选)保存图片路径(为空则不保存图片)
};
//如果你是小白,不懂阈值是什么意思,记住:二值化是把图片处理成黑白图片,那么颜色就是黑白两级的分界线,
//而阈值就相当于给这个分界线增加范围,范围内的会被处理成白色,其他的都会变成黑色
//最原始的识别函数
定义 结果2 = $文字识别.识别(配置2);
```


### 识别base64(base64)

> 识别base64图片

- 参数 : base64 {字符串} 图片base64字符串 
- 返回 : {结果集} 结果
- 版本 : 1.6.0


```javascript
//识别base64图片
定义 测试图片 = $图片.读取("./资源/图片01.png");
定义 base64字符串 = $图片.转base64(测试图片);
//一般情况下,base64可以从服务器端获取,而上面的代码是把本地图片转成base64的
定义 识别结果 = $文字识别.识别base64(base64字符串);
```


### 识别路径(图片路径)

> 识别路径中图片

- 参数 : 图片路径 {字符串} 图片路径 
- 返回 : {结果集} 结果
- 版本 : 1.6.0


```javascript
//识别本地图片
定义 识别结果 = $文字识别.识别路径("./资源/图片01.png");
```


### 识别图片(img)

> 识别图片

- 参数 : img {图片} 图片对象 
- 返回 : {结果集} 结果
- 版本 : 1.0.0


```javascript
//获取本地图片对象
定义 图片 = $图片.读取("./资源/图片01.png");
//识别图片对象
定义 识别结果 = $文字识别.识别图片(图片);
如果 (识别结果.是否成功()) {
    //...
}
```


### 识别位图(位图)

> 识别路径中图片

- 参数 : 位图 {Bitmap} 位图对象 
- 返回 : {DetectResult} 结果
- 版本 : 1.7.0


```javascript
//获取一个位图对象
定义 图片 = $图片.读取("/sdcard/t01.png");
定义 位图 = 图片.获取位图();
//识别本地图片
定义 结果 = $文字识别.识别位图(位图);
```


# $permit - 权限工具

- 更新时间:2025-12-13 11:58:46

> 权限工具




### 获取悬浮窗权限()

> 获取悬浮窗权限
> 
> 注意：在$权限中调用任何权限,都只会调用一次

- 版本 : 1.7.0


```javascript
//获取悬浮窗权限
$权限.获取悬浮窗权限();
```


### 有悬浮窗权限()

> 判断是否有悬浮窗权限
> 
> 注意：在$权限中调用任何权限,都只会调用一次

- 返回 : {布尔值} 是否有权限
- 版本 : 1.7.0


```javascript
日志("悬浮窗",$权限.有悬浮窗权限());
```


### 获取无障碍权限()

> 获取无障碍权限
> 
> 注意：在$权限中调用任何权限,都只会调用一次
> 
> 如果有Root权限:则使用Root权限为本应用授权永久无障碍
> 
> 如果有Shizuku权限:则使用Shizuku权限为本应用授权永久无障碍
> 
> 如果没有Root和Shizuku:则进行普通权限申请(非永久有效,受系统限制)

- 版本 : 1.7.0


```javascript
//获取无障碍权限
$权限.获取无障碍权限();
```


### 有无障碍权限()

> 判断是否有无障碍权限
> 
> 注意：在$权限中调用任何权限,都只会调用一次

- 返回 : {布尔值} 是否有权限
- 版本 : 1.7.0


```javascript
日志("无障碍",$权限.有无障碍权限());
```


### 获取存储权限()

> 获取存储权限
> 
> 注意：在$权限中调用任何权限,都只会调用一次

- 版本 : 1.7.0


```javascript
//获取存储权限
$权限.获取存储权限();
```


### 有存储权限()

> 判断是否有存储权限
> 
> 注意：在$权限中调用任何权限,都只会调用一次

- 返回 : {布尔值} 是否有权限
- 版本 : 1.7.0


```javascript
日志("存储权限",$权限.有存储权限());
```


### 获取电话权限()

> 获取电话权限
> 
> 注意：在$权限中调用任何权限,都只会调用一次

- 版本 : 1.7.0


```javascript
//获取电话权限
$权限.获取电话权限();
```


### 有电话权限()

> 判断是否有电话权限
> 
> 注意：在$权限中调用任何权限,都只会调用一次

- 返回 : {布尔值} 是否有权限
- 版本 : 1.7.0


```javascript
日志("打电话",$权限.有电话权限());
```


### 获取修改系统设置权限()

> 获取修改系统设置权限
> 
> 注意：在$权限中调用任何权限,都只会调用一次

- 版本 : 1.7.0


```javascript
//获取修改设置权限
$权限.获取修改系统设置权限();
```


### 有修改系统设置权限()

> 判断是否有修改系统设置权限
> 
> 注意：在$权限中调用任何权限,都只会调用一次

- 返回 : {布尔值} 是否有权限
- 版本 : 1.7.0


```javascript
日志("修改设置",$权限.有修改系统设置权限());
```


### 获取网络权限()

> 获取网络权限
> 
> 注意：在$权限中调用任何权限,都只会调用一次

- 版本 : 1.7.0


```javascript
//获取网络权限
$权限.获取网络权限();
```


### 有网络权限()

> 判断是否有网络权限
> 
> 注意：在$权限中调用任何权限,都只会调用一次

- 返回 : {布尔值} 是否有权限
- 版本 : 1.7.0


```javascript
日志("网络权限",$权限.有网络权限());
```


### 获取相机权限()

> 获取相机权限
> 
> 注意：在$权限中调用任何权限,都只会调用一次

- 版本 : 1.7.0


```javascript
//获取相机权限
$权限.获取相机权限();
```


### 有相机权限()

> 判断是否有相机权限
> 
> 注意：在$权限中调用任何权限,都只会调用一次

- 返回 : {布尔值} 是否有权限
- 版本 : 1.7.0


```javascript
日志("相机权限",$权限.有相机权限());
```


### 获取录音权限()

> 获取录音权限
> 
> 注意：在$权限中调用任何权限,都只会调用一次

- 版本 : 1.7.0


```javascript
//获取录音权限
$权限.获取录音权限();
```


### 有录音权限()

> 判断是否有录音权限
> 
> 注意：在$权限中调用任何权限,都只会调用一次

- 返回 : {布尔值} 是否有权限
- 版本 : 1.7.0


```javascript
日志("录音权限",$权限.有录音权限());
```


### 获取读取短信权限()

> 获取读取短信权限
> 
> 注意：在$权限中调用任何权限,都只会调用一次

- 版本 : 1.7.0


```javascript
//获取读取信息权限
$权限.获取读取短信权限();
```


### 有读取短信权限()

> 判断是否有读取短信权限
> 
> 注意：在$权限中调用任何权限,都只会调用一次

- 返回 : {布尔值} 是否有权限
- 版本 : 1.7.0


```javascript
日志("读取短信",$权限.有读取短信权限());
```


### 获取发送短信权限()

> 获取发送短信权限
> 
> 注意：在$权限中调用任何权限,都只会调用一次

- 版本 : 1.7.0


```javascript
//获取发送信息权限
$权限.获取发送短信权限();
```


### 有发送短信权限()

> 判断是否有发送短信权限
> 
> 注意：在$权限中调用任何权限,都只会调用一次

- 返回 : {布尔值} 是否有权限
- 版本 : 1.7.0


```javascript
日志("发送短信",$权限.有发送短信权限());
```


### 获取读取联系人权限()

> 获取读取联系人权限
> 
> 注意：在$权限中调用任何权限,都只会调用一次

- 版本 : 1.7.0


```javascript
//获取读取联系人权限
$权限.获取读取联系人权限();
```


### 有读取联系人权限()

> 判断是否有读取联系人权限
> 
> 注意：在$权限中调用任何权限,都只会调用一次

- 返回 : {布尔值} 是否有权限
- 版本 : 1.7.0


```javascript
日志("读取联系人",$权限.有读取联系人权限());
```


### 获取写入联系人权限()

> 获取写入联系人权限
> 
> 注意：在$权限中调用任何权限,都只会调用一次

- 版本 : 1.7.0


```javascript
//获取写入联系人权限
$权限.获取写入联系人权限();
```


### 有写入联系人权限()

> 判断是否有写入联系人权限
> 
> 注意：在$权限中调用任何权限,都只会调用一次

- 返回 : {布尔值} 是否有权限
- 版本 : 1.7.0


```javascript
日志("写入联系人",$权限.有写入联系人权限());
```


### 获取定位权限()

> 获取定位权限
> 
> 注意：在$权限中调用任何权限,都只会调用一次

- 版本 : 1.7.0


```javascript
//获取定位权限
$权限.获取定位权限();
```


### 有定位权限()

> 判断是否有定位权限
> 
> 注意：在$权限中调用任何权限,都只会调用一次

- 返回 : {布尔值} 是否有权限
- 版本 : 1.7.0


```javascript
日志("位置权限",$权限.有定位权限());
```


### 获取读取日历权限()

> 获取读取日历权限
> 
> 注意：在$权限中调用任何权限,都只会调用一次

- 版本 : 1.7.0


```javascript
//获取读取日历权限
$权限.获取读取日历权限();  //获取读取日历权限
```


### 有读取日历权限()

> 判断是否有读取日历权限
> 
> 注意：在$权限中调用任何权限,都只会调用一次

- 返回 : {布尔值} 是否有权限
- 版本 : 1.7.0


```javascript
日志("读取日历",$权限.有读取日历权限());
```


### 获取写入日历权限()

> 获取写入日历权限
> 
> 注意：在$权限中调用任何权限,都只会调用一次

- 版本 : 1.7.0


```javascript
//获取写入日历权限
$权限.获取写入日历权限();
```


### 有写入日历权限()

> 判断是否有写入日历权限
> 
> 注意：在$权限中调用任何权限,都只会调用一次

- 返回 : {布尔值} 是否有权限
- 版本 : 1.7.0


```javascript
日志("写入日历",$权限.有写入日历权限());
```


### 有权限(权限名称)

> 判断是否有权限
> 
> 注意：在$权限中调用任何权限,都只会调用一次

- 参数 : 权限名称 {字符串} 权限名 
- 返回 : {布尔值} 是否有权限
- 版本 : 1.7.0


```javascript
//判断是否有权限
$权限.有权限("android.Manifest.permission.GET_ACCOUNTS");
//等同于
$权限.有权限("android.permission.GET_ACCOUNTS");
```


### 有权限(权限名称数组)

> 判断是否有权限
> 
> 注意：在$权限中调用任何权限,都只会调用一次

- 参数 : 权限名称数组 {字符串数组[]} 权限名 
- 返回 : {布尔值} 是否有权限
- 版本 : 1.7.0


```javascript
定义 权限组 = ["android.permission.READ_CALENDAR","android.permission.WRITE_CALENDAR"];
//判断是否有权限
$权限.有权限(权限组);
```


### 获取权限(权限名称数组)

> 获取权限
> 
> 注意：在$权限中调用任何权限,都只会调用一次

- 参数 : 权限名称数组 {字符串数组[]} 权限名 
- 版本 : 1.7.0


```javascript
定义 权限组 = ["android.permission.READ_CALENDAR","android.permission.WRITE_CALENDAR"];
//获取权限
$权限.获取权限(权限组);
```


### 获取权限(权限名称)

> 获取权限
> 
> 注意：在$权限中调用任何权限,都只会调用一次

- 参数 : 权限名称 {字符串} 权限名 
- 版本 : 1.7.0


```javascript
//获取权限
$权限.获取权限("android.Manifest.permission.GET_ACCOUNTS");
//等同于
$权限.获取权限("android.permission.GET_ACCOUNTS");
```


### 有通知访问权限()

> 是否已授予通知访问权限

- 返回 : {布尔值} 是否有通知访问权限
- 版本 : 1.7.0


### 获取通知访问权限()

> 获取通知访问权限
> 
> 此权限将允许应用读取所有通知

- 版本 : 1.7.0


### 有读取视频权限()

> 判断是否有读取视频权限

- 返回 : {布尔值} 是否有读取视频权限
- 版本 : 1.7.0


### 获取读取视频权限()

> 获取读取视频权限

- 版本 : 1.7.0


### 有读取图片权限()

> 判断是否有读取图片权限

- 返回 : {布尔值} 是否有读取视频权限
- 版本 : 1.7.0


### 获取读取图片权限()

> 获取读取图片权限

- 版本 : 1.7.0


### 有读取音频权限()

> 判断是否有读取音频权限

- 返回 : {布尔值} 是否有读取视频权限
- 版本 : 1.7.0


### 获取读取音频权限()

> 获取读取音频权限

- 版本 : 1.7.0


### 有读取媒体权限()

> 判断是否有读取媒体权限
> 
> 这个方法综合了读取音频、图片、视频权限

- 返回 : {布尔值} 是否有读取媒体权限
- 版本 : 1.7.0


### 获取读取媒体权限()

> 获取读取媒体权限
> 
> 这个方法综合了读取音频、图片、视频权限

- 版本 : 1.7.0


# <span style="color: green">[稳定]</span>$plugin - 插件开发

> 我将教会你如何开发属于自己的apk插件，你可以在手机上开发，也可以使用电脑。 手机上开发，推荐使用AIDE进行安卓app的开发；
> 电脑端推荐使用AndroidStudio进行安卓app开发。

## 01.开发插件类

> 在你的项目中随便创建一个类，类名、包名都可随意，不过你需要遵守一个规则：那就是构造函数的参数类型，必须是(Activity,Context)，除此以外，没有任何限制了。

```java
package com.demo.test1;

import android.app.Activity;
import android.content.Context;
import android.content.res.Resources;

import androidx.appcompat.app.AppCompatActivity;

public class MyPlugin {

    /**
     * 插件类必须有两个构造参数(或者无参构造,但是推荐写两个参数,以便于插件实现更多的功能)
     * <p>
     * 注意：这两个参数类型都不能变！
     *
     * @param parentActivity {Activity} 宿主软件的Activity (测试时可以用插件自己的Activity)
     * @param selfContext    {Context} 插件自己的Context
     */
    public MyPlugin(Activity parentActivity, Context selfContext) {
        //其实宿主软件的Activity是AppCompatActivity类型的，因此如果你想访问宿主软件的activity的主题等资源，可以这么做：
        if (parentActivity instanceof AppCompatActivity) {
            AppCompatActivity appCompatActivity = (AppCompatActivity) parentActivity;
            //获取宿主软件的主题(M3风格的主题)
            Resources.Theme theme = appCompatActivity.getTheme();
            //获取宿主软件的资源
            Resources resources = appCompatActivity.getResources();
        }
    }

    //插件被加载后，这个函数就可以被直接调用了
    public String getPluginName() {
        return "MyPlugin";
    }

    //你也可以继续写更多你想实现的方法
}
```

### 02.添加元数据

> 当你开发玩自己的插件类的时候，你需要把这个类显示声明在元数据中，否则宿主软件无法找到这个类。


```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools">

    <application android:label="我的插件" android:icon="@mipmap/ic_launcher">

        <!--
        在这里定义一个元数据
        名称(name)必须是：org.aigame.plugin.className
        值(value)是插件的全类名：当$plugin加载后会创建这个类的实例
        -->
        <meta-data android:name="org.aigame.plugin.className"
            android:value="com.demo.test1.MyPlugin" />

    </application>
</manifest>
```


### 03.安装与调用

> 你需要把开发好的插件apk安装到手机上，然后在宿主软件中使用$plugin来调用插件。

```javascript
//1.加载插件
let obj = $plugin.load("com.demo.test1");
//2.调用插件类中的函数
obj.getPluginName();
```

# $plugin - 插件系统

- 更新时间:2025-12-13 11:58:46

> 插件系统
> 
> 本应用内置一个使用非常方便的插件系统，开发者可以开发自己的apk插件并且在这里进行调用。
> 
> 一个插件其实就是一个apk文件，它被安装在安卓手机上，之后就可以在本应用中使用$plugin进行调用。
> 
> 
> 和$ext不同的地方在于：
> 
> 1.$ext主要用于加载dex、jar、so、apk文件，$ext加载的是apk文件，无需安装apk文件，并且可以直接使用apk中的类。
> 
> 2.$plugin对象主要通过load("包名")加载已安装的插件apk，加载完成后，会返回一个主类对象，该对象中的函数可以直接调用，无需像$ext加载的apk那样需要导包调用。
> 
> 3.$plugin插件机制访问插件apk的资源更加方便。




### 加载(包名)

> 加载插件

- 参数 : 包名 {字符串} 插件的包名 
- 返回 : {object} 插件的实例对象
- 版本 : 1.6.8


```javascript
//加载插件
定义 插件对象 = $插件.加载("com.example.myplugin");
//使用自己定义的函数
插件对象.我的函数();
```


### 罗列()

> 获得插件列表

- 返回 : {AppInfo[]} 插件列表
- 版本 : 1.6.8


```javascript
//罗列所有插件应用
定义 插件列表 = $插件.罗列();
//打印信息
循环 (定义 信息 关于 插件列表) {
    日志("应用名:",信息.应用名称);
    日志("包名:",信息.包名);
    //显示图标: 信息.图标.显示();
}
```


# QrOptions - 制作二维码配置

- 更新时间:2025-12-13 11:58:46

> 制作二维码配置




### const {Integer} 宽;

> 宽度(默认500)


### const {Integer} 高;

> 高度(默认500)


### const {Integer} 边距;

> 边距(默认2)


### const {String} 前景色;

> 前景颜色(默认#000000)


### const {String} 背景色;

> 背景颜色(默认#FFFFFF)


# $qr - 二维码工具

- 更新时间:2025-12-13 11:58:46

> 二维码工具
> 
> 使用$qr你可以实现制作二维码，或者识别二维码




### 制作(内容)

> 制作二维码

- 参数 : 内容 {字符串} 二维码内容 
- 返回 : {Image} 图片对象
- 版本 : 1.6.8


```javascript
//生成二维码
定义 图片 = $二维码.制作("欢迎来到AIGame!");
//显示图片
图片.显示();//或者调用 显示图片(图片); 全局函数也可也显示图片
//保存到本地
图片.保存("/sdcard/qr.png");
```


### 制作(内容, 配置)

> 制作二维码

- 参数 : 内容 {字符串} 二维码内容 
- 参数 : 配置 {QrOptions} 参数 
- 返回 : {Image} 图片对象
- 版本 : 1.6.8


```javascript
//生成二维码
定义 图片 = $二维码.制作("Hello AIGame !", {
    宽: 500,//宽度(默认:500)
    高: 500,//高度(默认:500)
    边距: 2,//边距(默认:2)
    前景色: "#2AACB8",//前景色(默认:#000000)
    背景色: "#2B2D30",//背景色(默认:#FFFFFF)
});
如果 (图片 != 空) {
    //显示图片
    图片.显示(); //或者调用 显示图片(图片); 全局函数也可也显示图片
    //保存到本地
    图片.保存("/sdcard/qr.png");
}
```


### 解析(路径)

> 解析二维码

- 参数 : 路径 {字符串} 图片路径 
- 返回 : {字符串} 二维码内容
- 版本 : 1.6.8


```javascript
定义 内容 = $二维码.解析("/sdcard/qr.png");
```


### 解析(图片)

> 解析二维码

- 参数 : 图片 {Image} 图片对象 
- 返回 : {字符串} 二维码内容
- 版本 : 1.6.8


```javascript
//获得图片(Image)对象
定义 图片 = $图片.读取("/sdcard/qr.png");
//识别图片(Image)对象
定义 内容 = $二维码.解析(图片);
```


### 解析(x, y, 宽, 高)

> 解析屏幕上的二维码
> 
> 根据传入的范围来解析屏幕上的二维码,需要截屏权限

- 参数 : x {整数} x坐标 
- 参数 : y {整数} y坐标 
- 参数 : 宽 {整数} 宽度 
- 参数 : 高 {整数} 高度 
- 返回 : {字符串} 二维码内容
- 版本 : 1.6.8


```javascript
//截屏后识别指定范围的二维码
定义 内容 = $二维码.解析(0,400,1080,600);
```


### 解析(范围)

> 解析屏幕上的二维码
> 
> 根据传入的范围来解析屏幕上的二维码,需要截屏权限

- 参数 : 范围 {int[]} 范围 
- 返回 : {字符串} 二维码内容
- 版本 : 1.6.8


```javascript
//截屏后识别指定范围的二维码
定义 内容 = $二维码.解析([0,400,1080,600]);
```


### 解析(范围)

> 解析屏幕上的二维码
> 
> 根据传入的范围来解析屏幕上的二维码,需要截屏权限

- 参数 : 范围 {Rect} opencv的范围对象
- 返回 : {字符串} 二维码内容
- 版本 : 1.6.8


```javascript
//使用opencv中的范围对象
定义 范围 = new org.opencv.core.Rect(0, 400, 1080, 600);
//解析截屏范围中的二维码
定义 内容 = $二维码.解析(范围);
```


# $res - 资源管理器

- 更新时间:2025-12-13 11:58:46

> 资源管理器
> 
> 针对脚本引擎设计的资源管理器，方便存储和读取资源，支持跨线程访问，在对于一些大型项目中，可以起到非常好的维护效果。




### 创建(名称)

> 创建一个资源对象

- 参数 : 名称 {字符串} 应用名称,决定了资源文件存放的位置 
- 返回 : {AgRes} 资源对象
- 版本 : 1.6.9


```javascript
定义 资源 = $资源.创建("我的资源");
```


### 设置(名称, 数据)

> 设置一个资源

- 参数 : 名称 {字符串} 资源名称 
- 参数 : 数据 {object} 资源数据,就是js对象,可以直接把js对象存入进来,用的时候打点调用即可 
- 版本 : 1.6.9


```javascript
//(1)创建资源对象(指定名称)
定义 资源 = $资源.创建("我的资源");
//(2)添加资源
资源.设置("名字","张三");
```


### 获取(名称)

> 获取资源

- 参数 : 名称 {字符串} 资源名称 
- 返回 : {object} 资源数据
- 版本 : 1.6.9


```javascript
//(1)创建资源对象(指定名称)
定义 资源 = $资源.创建("我的资源");
//(2)添加资源
资源.设置("名字","张三");
//(3)获取资源
日志(资源.获取("名字"));
```


### 获取(名称, 默认值)

> 获取资源

- 参数 : 名称 {字符串} 资源名称 
- 参数 : 默认值 {字符串} 默认值 
- 返回 : {字符串} 资源值
- 版本 : 1.6.9


```javascript
//如果本身就不存在数据，就会返回默认值
定义 数据 = $资源.获取("姓名","张三");
```


### 获取(名称, 默认值)

> 获取资源

- 参数 : 名称 {字符串} 资源名称 
- 参数 : 默认值 {小数} 默认值 
- 返回 : {小数} 资源值
- 版本 : 1.6.9


```javascript
//如果本身就不存在数据，就会返回默认值
定义 数据 = $资源.获取("派",3.14);
```


### 获取(名称, 默认值)

> 获取资源

- 参数 : 名称 {字符串} 资源名称 
- 参数 : 默认值 {整数} 默认值 
- 返回 : {整数} 资源值
- 版本 : 1.6.9


```javascript
//如果本身就不存在数据，就会返回默认值
定义 数据 = $资源.获取("年龄",18);
```


### 获取(名称, 默认值)

> 获取资源

- 参数 : 名称 {字符串} 资源名称 
- 参数 : 默认值 {布尔值} 默认值 
- 返回 : {布尔值} 资源值
- 版本 : 1.6.9


```javascript
//如果本身就不存在数据，就会返回默认值
定义 是个男孩 = $资源.获取("性别",真);
如果(是个男孩){
    日志("我是男孩");
}
```


### 加载(路径)

> 加载本地资源到内部存储中
> 
> 本质上就是把sdcard下的资源文件拷贝到内部存储中

- 参数 : 路径 {字符串} 本地资源路径,可以是相对路径,但前提是文件必须要存在 
- 返回 : {布尔值} 是否加载成功
- 版本 : 1.6.9


```javascript
//先准备数据名称
定义 资源 = $资源.创建("我的资源");
//加载数据到应用内部存储空间中(导入时不会添加.res后缀名,所以要写全文件名)
资源.加载("/数据.res");//sdcard/当前项目/数据.res
//看看数据
日志(资源.查看());
```


### 罗列()

> 列出所有资源名称

- 返回 : {字符串列表} 资源名称列表
- 版本 : 1.6.9


```javascript
//(1)创建资源对象(指定名称)
定义 资源 = $资源.创建("我的资源");
//(2)查询所有资源名称
定义 资源列表 = 资源.罗列();
日志(资源列表);
```


### 查看()

> 查看当前资源内容
> 
> 本质上是将存储的js对象转换成格式化美化后的json字符串

- 返回 : {string} 资源内容
- 版本 : 1.6.9


```javascript
//(1)加载资源对象(指定名称)
定义 资源 = $资源.创建("我的资源");
//(2)获得资源内容
定义 内容 = 资源.查看();
提示("资源内容", 内容);
```


### 下载(保存路径)

> 导出资源
> 
> 本质上是将内部存储的数据拷贝到指定路径下

- 参数 : 保存路径 {字符串} 导出路径,可以使用相对路径,文件可以不存在,如果文件存在,则会覆盖 
- 返回 : {字符串} 导出路径
- 版本 : 1.6.9


```javascript
//先准备一点数据
定义 资源 = $资源.创建("我的资源");
资源.设置("人", {
    姓名: "张三",
    年龄: 16
});
//下载资源到当前项目的文件夹下(会自动添加.res后缀名)
资源.下载("/数据");//sdcard/当前项目/数据.res
```


# $root - ROOT与Shell命令

- 更新时间:2025-12-13 11:58:46

> ROOT与Shell工具




### 有权限()

> 是否获得ROOT权限

- 返回 : {布尔值} 是否获得ROOT权限
- 版本 : 1.7.0


```javascript
定义 是否有权限 = $管理员.有权限();
提示("是否有root权限",是否有权限);
```


### 获取权限()

> 获得root权限

- 返回 : {布尔值} 是否获得root权限
- 版本 : 1.7.0


```javascript
$管理员.获取权限();
```


### 指针授权(启用)

> 启用指针
> 
> 打开或者关闭开发者调试的指针位置选项

- 参数 : 启用 {布尔值} 是否启用 
- 版本 : 1.7.0


```javascript
//打开指针位置显示
$管理员.指针授权(是);
```


### 点击(x, y)

> 点击
> 

- 参数 : x {整数} 点击位置x 
- 参数 : y {整数} 点击位置y 
- 版本 : 1.7.0


```javascript
//点击手势
$管理员.点击(500,800);
```


### 点击(x, y, 时长)

> 点击
> 

- 参数 : x {整数} 点击位置x 
- 参数 : y {整数} 点击位置y 
- 参数 : 时长 {整数} 点击时长 
- 版本 : 1.7.0


```javascript
//点击手势(长按)
$管理员.点击(500,800,1500);
```


### 点击(x, y, 时长, 延迟)

> 点击
> 

- 参数 : x {整数} 点击位置x 
- 参数 : y {整数} 点击位置y 
- 参数 : 时长 {整数} 点击时长 
- 参数 : 延迟 {整数} 点击前延迟 
- 版本 : 1.7.0


```javascript
//点击手势(长按)(延迟一秒)
$管理员.点击(500,800,1500,100);
```


### 点击(坐标)

> 点击
> 

- 参数 : 坐标 {int[]} 点击位置 
- 版本 : 1.7.0


```javascript
//点击
$管理员.点击([500,800]);
```


### 点击(坐标, 时长)

> 点击
> 

- 参数 : 坐标 {int[]} 点击位置 
- 参数 : 时长 {整数} 点击时间 
- 版本 : 1.7.0


```javascript
//点击
$管理员.点击([500,800],50);
```


### 点击(坐标, 时长, 延迟)

> 点击
> 

- 参数 : 坐标 {int[]} 点击位置 
- 参数 : 时长 {整数} 点击时间 
- 参数 : 延迟 {整数} 延迟 
- 版本 : 1.7.0


```javascript
//点击
$管理员.点击([500,800],50,2000);
```


### 点击(坐标)

> 点击
> 

- 参数 : 坐标 {Point} 点击位置
- 版本 : 1.7.0


```javascript
//点击手势
定义 位置 = 新建 org.opencv.core.Point(500,800);
$管理员.点击(位置);
```


### 点击(坐标, 时长)

> 点击
> 

- 参数 : 坐标 {Point} 点击位置
- 参数 : 时长 {整数} 点击时长 
- 版本 : 1.7.0


```javascript
//点击手势(长按)(延迟一秒)
定义 位置 = 新建 org.opencv.core.Point(500,800);
$管理员.点击(位置,1500);
```


### 点击(坐标, 时长, 延迟)

> 点击
> 

- 参数 : 坐标 {Point} 点击位置
- 参数 : 时长 {整数} 点击时长 
- 参数 : 延迟 {整数} 点击前延迟 
- 版本 : 1.7.0


```javascript
//点击手势(长按)(延迟一秒)
定义 位置 = 新建 org.opencv.core.Point(500,800);
$管理员.点击(位置,1500,100);
```


### 长按(x, y)

> 长按
> 

- 参数 : x {整数} 长按位置x 
- 参数 : y {整数} 长按位置y 
- 版本 : 1.7.0


```javascript
//点击手势(长按)(延迟一秒)
$管理员.长按(500,800);
```


### 长按(x, y, 时长)

> 长按
> 

- 参数 : x {整数} 长按位置x 
- 参数 : y {整数} 长按位置y 
- 参数 : 时长 {整数} 长按后延迟 
- 版本 : 1.7.0


```javascript
//点击手势(长按)(延迟一秒)
$管理员.长按(500,800,1500);
```


### 长按(x, y, 时长, 延迟)

> 长按
> 

- 参数 : x {整数} 长按位置x 
- 参数 : y {整数} 长按位置y 
- 参数 : 时长 {整数} 长按后延迟 
- 参数 : 延迟 {整数} 长按前延迟 
- 版本 : 1.7.0


```javascript
//点击手势(长按)(延迟一秒)
$管理员.长按(500,800,1500,100);
```


### 滑动(x1, y1, x2, y2)

> 滑动
> 

- 参数 : x1 {整数} 起点x 
- 参数 : y1 {整数} 起点y 
- 参数 : x2 {整数} 终点x 
- 参数 : y2 {整数} 终点y 
- 版本 : 1.7.0


```javascript
//滑动手势
$管理员.滑动(500,0,500,800);
```


### 滑动(x1, y1, x2, y2, 时长)

> 滑动
> 

- 参数 : x1 {整数} 起点x 
- 参数 : y1 {整数} 起点y 
- 参数 : x2 {整数} 终点x 
- 参数 : y2 {整数} 终点y 
- 参数 : 时长 {整数} 滑动时间 
- 版本 : 1.7.0


```javascript
//滑动手势
$管理员.滑动(500,0,500,800,500);
```


### 滑动(x1, y1, x2, y2, 时长, 延迟)

> 滑动
> 

- 参数 : x1 {整数} 起点x 
- 参数 : y1 {整数} 起点y 
- 参数 : x2 {整数} 终点x 
- 参数 : y2 {整数} 终点y 
- 参数 : 时长 {整数} 滑动时间 
- 参数 : 延迟 {整数} 滑动延迟 
- 版本 : 1.7.0


```javascript
//滑动手势
$管理员.滑动(500,0,500,800,500.1000);
```


### 锁屏()

> 锁屏

- 版本 : 1.7.0


```javascript
$管理员.锁屏();
```


### 解锁屏幕()

> 解锁屏幕

- 版本 : 1.7.0


```javascript
$管理员.解锁屏幕();
```


### 电源键()

> 电源按键

- 版本 : 1.7.0


```javascript
$管理员.电源键();
```


### 执行(命令)

> 执行ROOT命令

- 参数 : 命令 {字符串} 命令 
- 版本 : 1.7.0


```javascript
//手机变砖(别用!!!!)
//$管理员.执行("rm -rf /data");
```


### 执行root命令(命令)

> 执行ROOT命令

- 参数 : 命令 {字符串} 命令 
- 版本 : 1.7.0


```javascript
//手机变砖(别用!!!!)
//$管理员.执行root命令("rm -rf /data");
```


### 执行root命令(命令, 输出回调)

> 执行ROOT命令

- 参数 : 命令 {字符串} 命令 
- 参数 : 输出回调 {(信息)=>{}} 命令输出(回调:输出) 
- 版本 : 1.7.0


```javascript
//查看系统网络配置
$管理员.执行root命令("cat /data/misc/dhcp/mac",(信息)=>{
    日志(信息);
});
```


### 执行root命令(命令, 输出回调, 中止回调)

> 执行ROOT命令

- 参数 : 命令 {字符串} 命令 
- 参数 : 输出回调 {(信息)=>{}} 命令输出(回调:输出) 
- 参数 : 中止回调 {(异常)=>{}} 命令中止(回调:原因) 
- 版本 : 1.7.0


```javascript
//查看系统网络配置
$管理员.执行root命令("cat /data/misc/dhcp/mac",(信息)=>{
    日志(信息);
},(异常)=>{
    $日志.异常(异常);
});
```


### 执行root命令(命令, 输出回调, 中止回调, 完成回调)

> 执行ROOT命令

- 参数 : 命令 {字符串} 命令 
- 参数 : 输出回调 {(信息)=>{}} 命令输出(回调:输出) 
- 参数 : 中止回调 {(异常)=>{}} 命令中止(回调:原因) 
- 参数 : 完成回调 {(退出码)=>{}} 命令完成(回调:退出码) 
- 版本 : 1.7.0


```javascript
//查看系统网络配置
$管理员.执行root命令("cat /data/misc/dhcp/mac",(信息)=> {
    日志(信息);
},(异常)=> {
    $日志.异常(异常);
},(退出码)=> {
    $日志.信息("执行完毕",退出码);
});
```


### 执行shell(命令)

> 执行免ROOT命令

- 参数 : 命令 {字符串} 命令 
- 版本 : 1.7.0


```javascript
$管理员.执行shell("ls /sdcard/Pictures");
```


### 执行shell(命令, 输出回调)

> 执行免ROOT命令

- 参数 : 命令 {字符串} 命令 
- 参数 : 输出回调 {(信息)=>{}} 命令输出(回调:输出) 
- 版本 : 1.7.0


```javascript
//列出/sdcard目录下的文件
$管理员.执行shell("ls /sdcard",(信息)=>{
    日志(信息);
});
```


### 执行shell(命令, 输出回调, 中止回调)

> 执行免ROOT命令

- 参数 : 命令 {字符串} 命令 
- 参数 : 输出回调 {(信息)=>{}} 命令输出(回调:输出) 
- 参数 : 中止回调 {(异常)=>{}} 命令中止(回调:原因) 
- 版本 : 1.7.0


```javascript
$管理员.执行shell("ls /sdcard/Pictures",(信息)=> {
    日志(信息);
},(异常)=> {
    $日志.异常(异常);
});
```


### 执行shell(命令, 输出回调, 中止回调, 完成回调)

> 执行免ROOT命令

- 参数 : 命令 {字符串} 命令 
- 参数 : 输出回调 {(信息)=>{}} 命令输出(回调:输出) 
- 参数 : 中止回调 {(异常)=>{}} 命令中止(回调:原因) 
- 参数 : 完成回调 {(退出码)=>{}} 命令完成(回调:退出码) 
- 版本 : 1.7.0


```javascript
$管理员.执行shell("ls /sdcard/Pictures",(信息)=> {
    日志(信息);
},(异常)=> {
    $日志.异常(异常);
},(退出码)=> {
    $日志.信息("执行结束",退出码);
});
```


### 关闭root命令()

> 关闭rootShell

- 版本 : 1.7.0


```javascript
$管理员.关闭root命令();
```


### 关闭shell命令()

> 关闭shell

- 版本 : 1.7.0


```javascript
$管理员.关闭shell命令();
```


### 关闭所有()

> 关闭所有

- 版本 : 1.7.0


```javascript
$管理员.关闭所有();
```


### 输入(文本)

> 输入文本

- 参数 : 文本 {字符串} 内容 
- 版本 : 1.7.0


```javascript
$管理员.输入("我是输入的文本");
```


### 杀死应用(包名)

> 杀死应用
> 
> 需要root权限才能执行

- 参数 : 包名 {字符串} 包名 
- 版本 : 1.7.0


```javascript
$管理员.杀死应用("com.example.app");
```


### 罗列运行的应用(回调)

> 列出所有运行的应用

- 参数 : 回调 {(包名)=>{}} 回调(回调:应用包名) 
- 版本 : 1.7.0


```javascript
$管理员.罗列运行的应用((包名)=>{
    日志(包名);
});
```


### 主页()

> 回到主页

- 版本 : 1.7.0


```javascript
$管理员.主页();
```


### 返回()

> 返回按键

- 版本 : 1.7.0


```javascript
$管理员.返回();
```


### 菜单()

> 菜单按键

- 版本 : 1.7.0


```javascript
$管理员.菜单();
```


### 最近()

> 最近任务

- 版本 : 1.7.0


```javascript
$管理员.最近();
```


### 设置分辨率(宽度, 高度)

> 设置手机分辨率

- 参数 : 宽度 {整数} 宽度 
- 参数 : 高度 {整数} 高度 


```javascript
$管理员.设置分辨率(1080,2200);
```


### 设置dpi(密度因子)

> 设置手机分辨率

- 参数 : 密度因子 {整数} 分辨率 
- 版本 : 1.7.0


```javascript
$管理员.设置dpi(320);
```


### 重置分辨率()

> 重置手机分辨率与DPI

- 版本 : 1.7.0


```javascript
$管理员.重置分辨率();
```


### 按键(按键名称)

> 模拟按键

- 参数 : 按键名称 按键名称
- 版本 : 1.7.0


```javascript
$管理员.按键("KEYCODE_POWER");
```


# ScreenInfo - 屏幕信息

- 更新时间:2025-12-13 11:58:46

> 屏幕信息




### const {int} 宽;

> 屏幕宽度


### const {int} 高;

> 屏幕高度


### const {int} 密度;

> 屏幕密度


### const {float} 水平密度;

> 屏幕水平密度


### const {float} 垂直密度;

> 屏幕垂直密度


### const {float} 密度因子;

> 屏幕密度因子


### const {float} 缩放密度;

> 屏幕缩放密度


### const {Boolean} 是否垂直;

> 是否为垂直方向


### const {Boolean} 是否显示导航栏;

> 是否显示导航栏


### const {int} 导航栏高度;

> 导航栏高度


### const {Boolean} 是否显示状态栏;

> 是否显示状态栏


### const {int} 状态栏高度;

> 状态栏高度


### 获取宽度()

> 获取屏幕宽度

- 返回 : {整数} 屏幕宽度
- 版本 : 1.7.0


```javascript
定义 屏幕信息 = $屏幕.信息();
//获取屏幕宽度
日志(屏幕信息.获取宽度());
```


### 获取高度()

> 获取屏幕高度

- 返回 : {整数} 屏幕高度
- 版本 : 1.7.0


```javascript
定义 屏幕信息 = $屏幕.信息();
//获取屏幕高度
日志(屏幕信息.获取高度());
```


### 获取密度()

> 获取屏幕密度

- 返回 : {整数} 屏幕密度
- 版本 : 1.7.0


```javascript
定义 屏幕信息 = $屏幕.信息();
//获取屏幕密度
日志(屏幕信息.获取密度());
```


### 是竖屏的()

> 是否为垂直方向

- 返回 : {布尔值} 是否为垂直方向
- 版本 : 1.7.0


```javascript
定义 屏幕信息 = $屏幕.信息();
//判断:是否为垂直方向
日志(屏幕信息.是竖屏的());
```


### 获取密度因子()

> 获取屏幕密度因子

- 返回 : {小数} 屏幕密度因子
- 版本 : 1.7.0


```javascript
定义 屏幕信息 = $屏幕.信息();
//获取屏幕密度因子
日志(屏幕信息.获取密度因子());
```


### 是显示导航栏的()

> 是否显示导航栏

- 返回 : {布尔值} 是否显示导航栏
- 版本 : 1.7.0


```javascript
定义 屏幕信息 = $屏幕.信息();
//判断：是否显示导航栏
日志(屏幕信息.是显示导航栏的());
```


### 获取导航栏高度()

> 获取导航栏高度

- 返回 : {整数} 导航栏高度
- 版本 : 1.7.0


```javascript
定义 屏幕信息 = $屏幕.信息();
//获取导航栏高度
日志(屏幕信息.获取导航栏高度());
```


### 是显示状态栏的()

> 是否显示状态栏

- 返回 : {布尔值} 是否显示状态栏
- 版本 : 1.7.0


```javascript
定义 屏幕信息 = $屏幕.信息();
//判断：是否显示状态栏
日志(屏幕信息.是显示状态栏的());
```


### 获取状态栏高度()

> 获取状态栏高度

- 返回 : {整数} 状态栏高度
- 版本 : 1.7.0


```javascript
定义 屏幕信息 = $屏幕.信息();
//获取状态栏高度
日志(屏幕信息.获取状态栏高度());
```


### 获取水平密度()

> 获取水平密度

- 返回 : {小数} 水平密度
- 版本 : 1.7.0


```javascript
定义 屏幕信息 = $屏幕.信息();
//获取水平密度
日志(屏幕信息.获取水平密度());
```


### 获取垂直密度()

> 获取垂直密度

- 返回 : {小数} 垂直密度
- 版本 : 1.7.0


```javascript
定义 屏幕信息 = $屏幕.信息();
//获取垂直密度
日志(屏幕信息.获取垂直密度());
```


### 获取缩放密度()

> 获取缩放密度

- 返回 : {小数} 缩放密度
- 版本 : 1.7.0


```javascript
定义 屏幕信息 = $屏幕.信息();
//获取缩放密度
日志(屏幕信息.获取缩放密度());
```


# $screen - 屏幕操作

- 更新时间:2025-12-13 11:58:46

> 屏幕操作




### 获取权限()

> 获取截屏权限
> 
> 如果支持无障碍截屏的话，会直接返回true，否则就会阻塞线程来获取录屏权限，直到获取到为止。
> 
> 需要注意的是：安卓15+的用户在获取录屏权限的时候记得选中整个屏幕选项，而不是单个当前应用截屏。

- 返回 : {布尔值} 是否获取成功
- 版本 : 1.7.0


```javascript
//等待获取截屏权限
$屏幕.获取权限();
```


### 获取权限一次()

> 获取截屏权限一次

- 版本 : 1.7.0


```javascript
//获取截屏权限一次
$屏幕.获取权限一次();
```


### 有录屏权限()

> 判断是否有录屏权限
> 
> 这个方法只会判断是否有录屏权限，不会判断无障碍截屏是否可用

- 返回 : {布尔值} 是否有录屏权限
- 版本 : 1.7.4


```javascript
如果($屏幕.有录屏权限()){
    日志("有录屏权限");
}
```


### 只用录屏权限(只用录屏权限)

> 只用录屏权限
> 
> 默认是false，即默认优先使用无障碍截屏，后用录屏权限截屏。
> 如果设置为true，那么判断是否有权限的函数只会判断录屏权限是否可用，不会判断无障碍截屏是否可用。并且获取截屏的时候只会通过录屏权限获取截屏。

- 参数 : 只用录屏权限 {布尔值} 是否只用录屏权限
- 版本 : 1.7.4


```javascript
//设置只使用录屏权限获取截屏
$屏幕.只用录屏权限(是);
```


### 有截屏权限()

> 是否有截屏权限

- 返回 : {布尔值} 是否有截屏权限
- 版本 : 1.7.0


```javascript
如果($屏幕.有截屏权限()){
    日志("有截屏权限");
}
```


### 获取截屏()

> 获取屏幕截屏
> 
> 此函数将优先使用无障碍截屏(安卓11+)，否则将使用截屏权限来进行截屏。

- 返回 : {Image} 截屏图片
- 版本 : 1.7.0


```javascript
//等待获取截屏权限
$屏幕.获取权限();
//如果不想用上面的方式，也可以使用 $动作.获取权限(); //获取无障碍，也可以截屏(安卓11+以上才行)
定义 图片 = $屏幕.获取截屏();//获得屏幕截屏
$图片.显示(图片);//显示截屏
```


### 设置亮度(亮度)

> 设置屏幕亮度

- 参数 : 亮度 {整数} 亮度值(0-255)
- 版本 : 1.7.0


```javascript
//设置屏幕亮度
$屏幕.设置亮度(100);
```


### 设置方向(角度)

> 设置屏幕方向

- 参数 : 角度 {字符串} 屏幕旋转度数
- 版本 : 1.7.0


```javascript
//设置屏幕方向
$屏幕.设置方向(0);//(强制)竖屏
$屏幕.设置方向(90);//(强制)右转横屏
$屏幕.设置方向(180);//(强制)倒置竖屏
$屏幕.设置方向(270);//(强制)左转横屏
$屏幕.设置方向(-1);//(不强制)自动旋转(任何其他数字都是自动旋转)
// 模拟器测试：
// 逍遥     安卓5  : 成功旋转屏幕 会闪退
// 逍遥     安卓7  : 成功旋转屏幕 会闪退
// 逍遥     安卓9  : 成功旋转屏幕 会闪退
// 逍遥     安卓12 : 完美!!!
// 雷电     安卓9  : 毫无反应
//真机测试：
// OPPO    安卓12 : 完美!!!
```


### 获取高度()

> 屏幕高
> 
> 该方法会先获取屏幕的所有信息，之后再反馈屏幕高度。

- 返回 : {整数} 屏幕高度
- 版本 : 1.7.0


```javascript
定义 宽 = $屏幕.获取宽度();
定义 高 = $屏幕.获取高度();
提示("屏幕宽高",宽+"x"+高);
```


### 获取宽度()

> 屏幕宽
> 
> 该方法会先获取屏幕的所有信息，之后再反馈屏幕宽度。

- 返回 : {整数} 屏幕宽度
- 版本 : 1.7.0


```javascript
定义 宽 = $屏幕.获取宽度();
定义 高 = $屏幕.获取高度();
提示("屏幕宽高",宽+"x"+高);
```


### 获取屏幕信息()

> 屏幕信息
> 
> 该方法会获取屏幕的所有信息。

- 返回 : {ScreenInfo} 屏幕宽高信息
- 版本 : 1.7.0


```javascript
定义 屏幕信息 = $屏幕.获取屏幕信息();//等价于：'$屏幕.信息()'
提示("详细信息",屏幕信息);
```


### 信息()

> 屏幕信息
> 
> 该方法会获取屏幕的所有信息。

- 返回 : {ScreenInfo} 屏幕宽高信息
- 版本 : 1.7.0


```javascript
定义 信息 = $屏幕.信息();//等价于：'$屏幕.获取屏幕信息()'
提示("详细信息",信息);
```


### 获取密度因子()

> 获取密度
> 
> 获取屏幕的密度因子

- 返回 : {小数} 密度因子
- 版本 : 1.7.0


```javascript
定义 密度因子 = $屏幕.获取密度因子();
提示("当前设备的密度",密度因子);
```


### 是息屏的()

> 判断屏幕是否息屏

- 返回 : {布尔值} 是否息屏
- 版本 : 1.7.0


```javascript
如果($屏幕.是息屏的()){
    日志("屏幕息屏");
}
```


### 是亮屏的()

> 判断屏幕是否亮屏

- 返回 : {布尔值} 是否亮屏
- 版本 : 1.7.0


```javascript
如果($屏幕.是亮屏的()){
    日志("屏幕亮屏");
}
```


### 分割(横向分割数量, 纵向分割数量, 索引)

> 屏幕分割
> 
> 将屏幕进行横向和纵向的分割，返回指定索引的范围，该函数对于制作全分辨率脚本非常有用。

- 参数 : 横向分割数量 {整数} 横向分割数量
- 参数 : 纵向分割数量 {整数} 纵向分割数量
- 参数 : 索引 {整数} 块的索引
- 返回 : {Rect} 范围
- 版本 : 1.7.0


```javascript
$绘制.关闭所有();
//将屏幕分割成9份，找到最后一份的范围
定义 范围 = $屏幕.分割(3, 3, 8);
//绘制出这个范围
$绘制.方框(范围);
```


### 保存截屏(保存路径)

> 截屏并保存
> 
> 该函数会直接截屏(需要截屏权限或者无障碍权限)，之后保存截屏到指定的路径。

- 参数 : 保存路径 {字符串} 保存路径
- 版本 : 1.7.0


```javascript
//截屏并且保存(支持相对路径写法)
定义 截屏路径 = "/sdcard/Pictures/截屏.png";
$屏幕.保存截屏(截屏路径);
```


### 强制竖屏()

> 强制竖屏截屏
> 
> 一般情况下用不到该函数，但是确实存在少量设备存在横竖屏异常，此函数就是为了应对特殊情况的。

- 版本 : 1.7.0


```javascript
$屏幕.强制竖屏();//强制竖屏截屏
```


### 强制横屏()

> 强制横屏截屏
> 
> 一般情况下用不到该函数，但是确实存在少量设备存在横竖屏异常，此函数就是为了应对特殊情况的。

- 版本 : 1.7.0


```javascript
$屏幕.强制横屏();//强制横屏截屏
```


### 取消强制()

> 取消强制横竖屏
> 
> 默认情况下,'$屏幕'会根据当前屏幕状态自动检测截屏是横屏还是竖屏,所以一般情况下 '强制竖屏'、'强制横屏'、'取消强制'这三个函数没必要调用。
> 之所以设计这三个函数,是为了更好的适配更多的设备,正常情况下手机的宽度都是小于高度的,但是也有那种宽度大于高度的情况,例如：平板设备，此时就可以使用强制横屏或竖屏来截屏了。

- 版本 : 1.7.0


```javascript
$屏幕.取消强制();//取消强制横竖屏(默认是:自动检测)
```


# $sqlite - 轻量数据库

- 更新时间:2025-12-13 11:58:46

> 轻量数据库
> 
> 线程安全,支持并发编程,本地轻量级数据库存储,存储的文件会随着应用的卸载而清空。




### 创建新对象()

> 创建新对象
> 
> 创建一个新的数据库对象，你可以用这个对象来操作其他数据库

- 返回 : {this} 自己


```javascript
定义 数据库操作对象 = $小数据库.创建新对象();
定义 打开成功 = 数据库操作对象.打开("我的数据2");
如果(打开成功){
    日志("链接成功");
}
```


### 打开(库名称, 是否存于外部存储)

> 打开数据库
> 
> 如果数据库文件存在则会加载数据库，如果不存在则先创建后加载

- 参数 : 库名称 {字符串} 数据库名称 
- 参数 : 是否存于外部存储 {布尔值} 是否存于外部存储(默认:否) 
- 返回 : {布尔值} 是否连接成功


```javascript
//第二个参数的含义:
//否:保存到内部存储:无需后缀，只需要取一个数据库名称即可，应用卸载后数据会被删除
//是:保存到外部存储:需全路径，包括文件名和后缀，应用卸载后数据不会被删除
定义 打开成功 = $小数据库.打开("/sdcard/mData.db",是);
如果(打开成功){
    日志("链接成功");
}
```


### 打开(库名称)

> 打开数据库
> 
> 如果数据库文件存在则会加载数据库，如果不存在则先创建后加载

- 参数 : 库名称 {字符串} 数据库名称 
- 返回 : {布尔值} 是否连接成功


```javascript
//无需后缀，只需要取一个数据库名称即可
定义 打开成功 = $小数据库.打开("我的数据");
如果(打开成功){
    日志("链接成功");
}
```


### 创建表(表名, 列名)

> 创建数据表
> 
> 注意:不管你的数据是什么类型都用字符串类型存储

- 参数 : 表名 {字符串} 表名称 
- 参数 : 列名 {字符串列表[]} 列名称 
- 返回 : {布尔值} 是否执行成功


```javascript
定义 创建成功 = $小数据库.创建表("表1",["姓名","性别","年龄"]);
如果(创建成功){
    日志("建表成功");
}
```


### 添加(表名, 数据)

> 添加数据
> 
> 注意:不管你的数据是什么类型都用字符串类型存储，默认使用自增id作为主键

- 参数 : 表名 {字符串} 表名 
- 参数 : 数据 {对象}  数据对象 
- 返回 : {布尔值} 是否执行成功


```javascript
//其实此函数等价于 $小数据库.执行("INSERT INTO 表1 (姓名, 性别, 年龄) VALUES ('张三', '男', 20)");
定义 添加成功 = $小数据库.添加("表1",{
    姓名:"张三",
    性别:"男",
    年龄:20
});
如果(添加成功){
    日志("添加成功");
}
```


### 更新(表名, 数据, 条件语句)

> 更新数据

- 参数 : 表名 {字符串} 表名称 
- 参数 : 数据 {对象} 数据对象 
- 参数 : 条件语句 {字符串} 条件语句 
- 返回 : {布尔值} 是否执行成功


```javascript
//更新数据
定义 更新成功 = $小数据库.更新("表1", {
    姓名: "张三",
    性别: "女",
    年龄: 20
},"姓名='张三'");
如果 (更新成功) {
    日志("更新成功");
}
```


### 罗列(表名)

> 罗列数据
> 
> 注意:不管你的数据是什么类型，查询出来的必是字符串类型，即使是报错也不会返回null，而是返回空列表，因此可以不用判断数据是否为空

- 参数 : 表名 {字符串} 表名称
- 返回 : {数据列表[]} 数据集合对象


```javascript
//即使是报错也不会返回null，而是返回空列表，因此可以不用判断数据是否为空
定义 结果集 = $小数据库.罗列("表1");
循环(定义 数据 关于 结果集){
    日志(数据);
}
```


### 罗列()

> 罗列数据
> 
> 查询数据库中的所有表名并且返回表名列表

- 返回 : {表名列表[]} 表名列表


```javascript
//罗列数据库中的表
定义 结果集 = $小数据库.罗列();
循环(定义 数据 关于 结果集){
    日志(数据);
}
```


### 查询(sql语句)

> 执行查询语句
> 
> 注意:不管你的数据是什么类型，查询出来统一是字符串类型。

- 参数 : sql语句 {字符串} sql查询语句
- 返回 : {数据列表[]} 执行结果


```javascript
//即使是报错也不会返回null，而是返回空列表，因此可以不用判断数据是否为空
定义 结果列表 = $小数据库.查询("select * from table1");
循环(定义 数据 关于 结果列表){
    日志(数据);
}
```


### 有表(表名称)

> 判断表是否存在

- 参数 : 表名称 {字符串} 表名称
- 返回 : {布尔值} 是否存在该表


```javascript
如果($小数据库.有表("我的表格")){
    日志("存在表");
} 否则 {
    日志("不存在表");
}
```


### 执行(sql语句)

> 执行SQL语句

- 参数 : sql语句 {字符串} sql语句
- 返回 : {布尔值} 是否执行成功


```javascript
//删除表
$小数据库.执行("drop table if exists table1");
```


### 删除数据库(外部数据)

> 删除数据库
> 
> 我将直接删除本地数据库的存储文件，那么你将丢失所有数据

- 参数 : 外部数据 {布尔值} 是否是外部数据，如果是外部数据则库名就是外部数据的路径
- 返回 : {布尔值} 是否执行成功


```javascript
//无需打开数据库，直接就能删除数据库文件
定义 删除成功 = $小数据库.删除数据库(true);
如果(删除成功){
    日志("删库成功");
}
```


### 删除数据库(库名, 外部数据)

> 删除数据库
> 
> 我将直接删除本地数据库的存储文件，那么你将丢失所有数据

- 参数 : 库名 {字符串} 数据库名称
- 参数 : 外部数据 {布尔值} 是否是外部数据，如果是外部数据则库名就是外部数据的路径
- 返回 : {布尔值} 是否执行成功


```javascript
//无需打开数据库，直接就能删除数据库文件
定义 删除成功 = $小数据库.删除数据库("我的数据");
如果(删除成功){
    日志("删库成功");
}
```


### 删除数据库(库名)

> 删除数据库
> 
> 我将直接删除本地数据库的存储文件，那么你将丢失所有数据

- 参数 : 库名 {字符串} 数据库名称
- 返回 : {布尔值} 是否执行成功


```javascript
//无需打开数据库，直接就能删除数据库文件
定义 删除成功 = $小数据库.删除数据库("我的数据");
如果(删除成功){
    日志("删库成功");
}
```


### 删除表(表名)

> 删除表

- 参数 : 表名 {字符串} 表名
- 返回 : {布尔值} 是否执行成功


```javascript
定义 删除成功 = $小数据库.删除表("表1");
如果(删除成功){
    日志("删除表成功");
}
```


### 关闭()

> 关闭数据库
> 
> 当你操作完毕后可以关闭数据库链接，释放资源。

- 返回 : {布尔值} 是否关闭成功


```javascript
定义 成功关闭 = $小数据库.关闭();
如果(成功关闭){
    日志("结束操作");
}
```


# $storage - 应用内存储

- 更新时间:2025-12-13 11:58:46

> 应用内存储
> 
> 轻量级的存储方案，用于存储一些简单基础的数据，一般用作于全局配置，当应用被卸载后，这些配置也会随之清空。




### 创建(命名空间)

> 创建存储
> 
> 其实如果不创建应用存储也可以，因为默认就有一个命名空间，但是建议还是自己创建一个自定义的命名空间。

- 参数 : 命名空间 {字符串} 命名空间
- 返回 : {$存储} 存储对象
- 版本 : 1.7.0


```javascript
//命名空间的名称随意
定义 存储 = $存储.创建("命名空间");
```


### 获取(关键字, 默认值)

> 获取值
> 
> 如果设置了默认值，就算拿不到数据，也会返回默认值

- 参数 : 关键字 {字符串} 关键字
- 参数 : 默认值 {Object} 默认值
- 返回 : {Object} 获取到的值
- 版本 : 1.7.0


```javascript
定义 存储 = $存储.创建("命名空间");
提示("数据",存储.获取("我的字符串","我是默认值"));
```


### 获取(关键字)

> 获取值

- 参数 : 关键字 {字符串} 关键字
- 返回 : {Object} 获取到的值
- 版本 : 1.7.0


```javascript
定义 存储 = $存储.创建("命名空间");
存储.放入("我的字符串","我是被存放进来的数据");
提示("数据",存储.获取("我的字符串"));
```


### 放入(关键字, 数据)

> 存放数据

- 参数 : 关键字 {字符串} 关键字
- 参数 : 数据 {Object} 数据
- 版本 : 1.7.0


```javascript
//只要保持命名空间的名称一致,就能正常读取到数据
定义 存储 = $存储.创建("命名空间");
存储.放入("我的字符串","我是被存放进来的数据");
```


### 获取字符串(关键字)

> 获得字符串数据

- 参数 : 关键字 {字符串} 关键字
- 返回 : {字符串} 数据
- 版本 : 1.7.0


```javascript
//只要保持命名空间的名称一致,就能正常读取到数据
定义 存储 = $存储.创建("命名空间");
存储.放入("我的字符串","我是被存放进来的数据");
提示("数据",存储.获取字符串("我的字符串"));
```


### 获取字符串(关键字, 默认值)

> 获得字符串数据

- 参数 : 关键字 {字符串} 关键字
- 参数 : 默认值 {字符串} 默认值
- 返回 : {字符串} 数据
- 版本 : 1.7.0


```javascript
//只要保持命名空间的名称一致,就能正常读取到数据
定义 存储 = $存储.创建("命名空间");
存储.放入("我的字符串","我是被存放进来的数据");
提示("数据",存储.获取字符串("我的字符串","默认数据"));
```


### 放入字符串(关键字, 数据)

> 存放字符串数据

- 参数 : 关键字 {字符串} 关键字
- 参数 : 数据 {字符串} 存放的数据
- 版本 : 1.7.0


```javascript
定义 存储 = $存储.创建("命名空间");
存储.放入字符串("我的字符串","我是内容");
提示("数据",存储.获取字符串("我的字符串")); //我是内容
```


### 获取整数(关键字, 默认值)

> 获得整数数据

- 参数 : 关键字 {整数} 关键字
- 参数 : 默认值 {整数} 默认值
- 返回 : {整数} 数据
- 版本 : 1.7.0


```javascript
定义 存储 = $存储.创建("命名空间");
提示("数据",存储.获取整数("我的整数",20)); //20
```


### 获取整数(关键字)

> 获得整数数据
> 
> 如果没有找打就返回默认值-1

- 参数 : 关键字 {整数} 关键字
- 返回 : {整数} 数据
- 版本 : 1.7.0


```javascript
定义 存储 = $存储.创建("命名空间");
提示("数据",存储.获取整数("我的整数")); //-1
```


### 放入整数(关键字, 数据)

> 存放数字数据

- 参数 : 关键字 {字符串} 关键字
- 参数 : 数据 {整数} 存放的数据
- 版本 : 1.7.0


```javascript
定义 存储 = $存储.创建("命名空间");
存储.放入整数("我的整数",100);
提示("数据",存储.获取整数("我的整数")); //100
```


### 获取布尔值(关键字, 默认值)

> 获得布尔数据

- 参数 : 关键字 {Boolean} 关键字
- 参数 : 默认值 {Boolean} 默认值
- 返回 : {Boolean} 数据
- 版本 : 1.7.0


```javascript
定义 存储 = $存储.创建("命名空间");
存储.放入布尔值("我的布尔值",是);
提示("数据",存储.获取布尔值("我的布尔值")); //false
//如果默认值是true，那么就在找不到数据的时候返回true
提示("数据",存储.获取布尔值("我的布尔值",是)); //true
```


### 获取布尔值(关键字)

> 获得布尔数据

- 参数 : 关键字 {Boolean} 关键字
- 返回 : {Boolean} 数据
- 版本 : 1.7.0


```javascript
定义 存储 = $存储.创建("命名空间");
存储.放入布尔值("我的布尔值",true);
提示("数据",存储.获取布尔值("我的布尔值")); //true
```


### 放入布尔值(关键字, 数据)

> 存放布尔数据

- 参数 : 关键字 {字符串} 关键字
- 参数 : 数据 {Boolean} 存放的数据
- 版本 : 1.7.0


```javascript
定义 存储 = $存储.创建("命名空间");
存储.放入布尔值("我的布尔值",是);
提示("数据",存储.获取布尔值("我的布尔值")); //true
```


### 获取小数(关键字, 默认值)

> 获得浮点数数据

- 参数 : 关键字 {小数} 关键字
- 参数 : 默认值 {小数} 默认值
- 返回 : {小数} 数据
- 版本 : 1.7.0


```javascript
定义 存储 = $存储.创建("命名空间");
提示("数据",存储.获取小数("我的小数")); //-1.0
```


### 获取小数(关键字)

> 获得浮点数数据

- 参数 : 关键字 {小数} 关键字
- 返回 : {小数} 数据
- 版本 : 1.7.0


```javascript
定义 存储 = $存储.创建("命名空间");
存储.放入小数("我的小数",3.1415926);
提示("数据",存储.获取小数("我的小数")); //3.1415926
```


### 放入小数(关键字, 数据)

> 存放浮点数数据

- 参数 : 关键字 {字符串} 关键字
- 参数 : 数据 {小数} 存放的数据
- 版本 : 1.7.0


```javascript
定义 存储 = $存储.创建("命名空间");
存储.放入小数("我的小数",3.1415926);
提示("数据",存储.获取小数("我的小数",0)); //3.1415926
```


### 获取长整数(关键字, 默认值)

> 获得长数字数据

- 参数 : 关键字 {long} 关键字
- 参数 : 默认值 {long} 默认值
- 返回 : {Long} 数据
- 版本 : 1.7.0


```javascript
定义 存储 = $存储.创建("命名空间");
提示("数据",存储.获取长整数("我的长整数",100));
```


### 获取长整数(关键字)

> 获得长数字数据

- 参数 : 关键字 {字符串} 关键字
- 返回 : {长整数} 数据
- 版本 : 1.7.0


```javascript
定义 存储 = $存储.创建("命名空间");
存储.放入长整数("我的长整数",5201314);
提示("数据",存储.获取长整数("我的长整数"));
```


### 放入长整数(关键字, 数据)

> 存放长数字数据
> 

- 参数 : 关键字 {字符串} 关键字
- 参数 : 数据 {长整数} 存放的数据
- 版本 : 1.7.0


```javascript
定义 存储 = $存储.创建("命名空间");
存储.放入长整数("我的长整数",5201314);
提示("数据",存储.获取长整数("我的长整数",100));//5201314
```


### 获取字符串集合(关键字, 默认值)

> 获得字符串集合数据

- 参数 : 关键字 {字符串} 关键字
- 参数 : 默认值 {字符串数组[]} 默认值
- 返回 : {字符串数组[]} 数据
- 版本 : 1.7.0


```javascript
定义 存储 = $存储.创建("命名空间");
存储.放入字符串集合("我的集合",["数据1","数据2","数据3"]);
提示("数据",存储.获取字符串集合("我的集合",[])); //["数据1","数据2","数据3"]
```


### 获取字符串集合(关键字)

> 获得字符串集合数据
> 
> 如果没有数据就默认返回空集合

- 参数 : 关键字 {字符串} 关键字
- 返回 : {字符串数组[]} 数据
- 版本 : 1.7.0


```javascript
定义 存储 = $存储.创建("命名空间");
存储.放入字符串集合("我的集合",["数据1","数据2","数据3"]);
提示("数据",存储.获取字符串集合("我的集合")); //["数据1","数据2","数据3"]
```


### 放入字符串集合(关键字, 数据)

> 存放字符串集合数据

- 参数 : 关键字 {字符串} 关键字
- 参数 : 数据 {字符串数组[]} 存放的数据
- 版本 : 1.7.0


```javascript
定义 存储 = $存储.创建("命名空间");
存储.放入字符串集合("我的集合",["数据1","数据2","数据3"]);
提示("数据",存储.获取字符串集合("我的集合",[])); //["数据1","数据2","数据3"]
```


### 获取全部()

> 获得全部数据

- 返回 : {对象} 数据(使用时直接当作js对象打.调用即可)
- 版本 : 1.7.0


```javascript
定义 存储 = $存储.创建("命名空间");
提示("数据",存储.获取全部());
```


### 有(关键字)

> 是否包含

- 参数 : 关键字 {字符串} 关键字
- 返回 : {布尔值} 是否包含
- 版本 : 1.7.0


```javascript
定义 存储 = $存储.创建("命名空间");
存储.放入("我的整数",100);
log(存储.有("我的整数"));//true
存储.clear();
log(存储.有("我的整数"));//false
提示("数据",存储.获取整数("我的整数"));//-1
```


### 清空()

> 删除全部数据

- 版本 : 1.7.0


```javascript
定义 存储 = $存储.创建("命名空间");
存储.放入("我的整数",100);
存储.清空();
提示("数据",存储.获取整数("我的整数"));//-1
```


### 删除(关键字)

> 移除数据

- 参数 : 关键字 {字符串} 关键字
- 版本 : 1.7.0


```javascript
定义 存储 = $存储.创建("命名空间");
存储.放入("我的整数",100);
存储.删除("我的整数");
提示("数据",存储.获取整数("我的整数"));//-1(默认值)
```


# $str - 字符串操作

- 更新时间:2025-12-13 11:58:46

> 字符操作




### getBytes(str, encoding)

> 转字节(指定编码)

- 参数 : str {string} 字符串
- 参数 : encoding {string} 编码格式
- 返回 : {byte[]} 字节数组
- 版本 : 1.0.0


```javascript
let strBytes = $str.getBytes("字符串","utf-8");
log("字节数组",strBytes);
```


### getBytes(str)

> 转字节

- 参数 : str {string} 字符串
- 返回 : {byte[]} 字节数组
- 版本 : 1.0.0


```javascript
let strBytes = $str.getBytes("字符串");
log("字节数组",strBytes);
```


### extractNumbers(str)

> 提取数字
> 
> 将提取出来的数字使用','号分割，返回一个这样的字符串

- 参数 : str {string} 字符串
- 返回 : {string} 提取的数字(用","号分割)
- 版本 : 1.0.0


```javascript
let nums = $str.extractNumbers("22字符33串44");
alert("提取数字",nums);
```


### decodeBase64(str, encoding)

> Base64解码为明文

- 参数 : str {string} Base64 字符串
- 参数 : encoding {string} 编码格式
- 返回 : {string} 解码后的原始字符串
- 版本 : 1.0.0


```javascript
//先把字符串转换为base64编码
let base64Str = $str.encodeBase64("我是字符串","utf-8");
//再把base64解码为正常的明文
let str = $str.decodeBase64(base64Str,"utf-8");
alert("base64字符串",str);
```


### decodeBase64(str)

> Base64解码为明文
> 
> 默认使用的编码为UTF-8

- 参数 : str {string} Base64 字符串
- 返回 : {string} 解码后的原始字符串
- 版本 : 1.0.0


```javascript
//先把字符串转换为base64编码
let base64Str = $str.encodeBase64("我是字符串");
//再把base64解码为正常的明文
let str = $str.decodeBase64(base64Str);
alert("base64字符串",str);
```


### encodeBase64(str, encoding)

> 编码为Base64

- 参数 : str {string} 要编码的字符串
- 参数 : encoding {string} 编码格式
- 返回 : {string} 编码后的 Base64 字符串
- 版本 : 1.0.0


```javascript
let base64Str = $str.encodeBase64("我是字符串","utf-8");
alert("base64字符串",base64Str);
```


### encodeBase64(str)

> 编码为Base64

- 参数 : str {string} 要编码的字符串
- 返回 : {string} 编码后的 Base64 字符串
- 版本 : 1.0.0


```javascript
let base64Str = $str.encodeBase64("我是字符串","utf-8");
alert("base64字符串",base64Str);
```


### uriEncode(str)

> Uri编码

- 参数 : str {string} 要编码的字符串
- 返回 : {string} 编码后的 Uri 字符串
- 版本 : 1.3.7


### uriDecode(str)

> Uri解码

- 参数 : str {string} 要解码的字符串
- 返回 : {string} 解码后的字符串
- 版本 : 1.3.7


### random(str)

> 随机字符

- 参数 : str {string]} 字符串
- 返回 : {string} 随机选择的字符串
- 版本 : 1.0.0


```javascript
//在输入的字符串中随机获取某个字符
for (let i = 0; i < 20; i++) {
    let str = $str.random("abcdefghijk");
    log(str);
}
```


### random(strList)

> 随机字符表

- 参数 : strList {string[]} 字符串列表
- 返回 : {string} 随机选择的字符串
- 版本 : 1.0.0


```javascript
//在输入的字符列表中随机获取某个元素
for (let i = 0; i < 20; i++) {
    let str = $str.random(["abc","defg","hijk"]);
    log(str);
}
```


### isBlank(str)

> 是否为空白

- 参数 : str {string} 要判断的字符序列
- 返回 : {boolean} 如果字符序列为空白则返回 true，否则返回 false
- 版本 : 1.0.0


```javascript
log($str.isBlank("    a "));//false
log($str.isBlank("     "));//true
```


### isNotBlank(str)

> 是否不是空白

- 参数 : str {string} 要判断的字符序列
- 返回 : {boolean} 如果字符序列不为空白则返回 true，否则返回 false
- 版本 : 1.0.0


```javascript
log($str.isNotBlank("    a "));//true
log($str.isNotBlank("     "));//false
```


### hasBlank(strs)

> 字符数组是否有空白

- 参数 : strs {string[]} 要判断的字符序列数组
- 返回 : {boolean} 如果数组中有空白字符序列则返回 true，否则返回 false
- 版本 : 1.0.0


```javascript
log($str.hasBlank(["    a ","  "]));//true
log($str.hasBlank(["    a "," b "]));//false
```


### isAllBlank(strs)

> 字符数组是否全是空白
> 
> 如果传入的列表位空则返回true

- 参数 : strs {string[]} 要判断的字符序列数组
- 返回 : {boolean} 如果数组中的所有元素都是空白则返回 true，否则返回 false
- 版本 : 1.0.0


```javascript
log($str.isAllBlank(["    a ","  "]));//false
log($str.isAllBlank(["      ","  "]));//true
```


### isEmpty(str)

> 是否为空
> 
> 如果传入的参数为null则返回true

- 参数 : str {string} 要判断的字符序列
- 返回 : {boolean} 如果字符序列为空则返回 true，否则返回 false
- 版本 : 1.0.0


```javascript
log($str.isEmpty("a "));//false
log($str.isEmpty("  "));//true
log($str.isEmpty(null));//true
```


### isNotEmpty(str)

> 是否不为空

- 参数 : str {string} 要判断的字符序列
- 返回 : {boolean} 如果字符序列不为空则返回 true，否则返回 false
- 版本 : 1.0.0


```javascript
log($str.isNotEmpty("a "));//true
log($str.isNotEmpty("  "));//false
log($str.isNotEmpty(null));//false
```


### emptyIfNull(str)

> null转空字符

- 参数 : str {string} 要处理的字符序列
- 返回 : {string} 如果字符序列为 null 则返回空字符串，否则返回原字符序列
- 版本 : 1.0.0


```javascript
log($str.emptyIfNull("  "));//"  "
log($str.emptyIfNull("嘿嘿"));//"嘿嘿"
log($str.emptyIfNull(null));//""
```


### nullToEmpty(str)

> null转空字符
> 
> 和emptyIfNull()函数功能一致

- 参数 : str 要处理的字符序列
- 返回 : {string} 如果字符序列为 null 则返回空字符串，否则返回原字符序列
- 版本 : 1.0.0


```javascript
log($str.nullToEmpty("  "));//"  "
log($str.nullToEmpty("嘿嘿"));//"嘿嘿"
log($str.nullToEmpty(null));//""
```


### nullToDefault(str, def)

> null转默认字符串

- 参数 : str {string} 要处理的字符序列
- 参数 : def {string} 默认字符串
- 返回 : {string} 如果字符序列为 null 则返回默认字符串，否则返回原字符序列
- 版本 : 1.0.0


```javascript
log($str.nullToDefault("  ","默认")); //"  "
log($str.nullToDefault("嘿嘿","默认")); //"嘿嘿"
log($str.nullToDefault(null,"默认")); //"默认"
```


### emptyToDefault(str, def)

> 空串转默认字符串
> 
> 和 nullToDefault 略有不同的地方是：此函数会判断当前字符串是否为空串，而不是判断是否为null，如果是个null或者空白的字符串，则返回默认值，否则返回原本的字符串。

- 参数 : str {string} 要处理的字符序列
- 参数 : def {string} 默认字符串
- 返回 : {string} 如果字符序列为空则返回默认字符串，否则返回原字符序列
- 版本 : 1.0.0


```javascript
log($str.emptyToDefault("  ","默认")); //"默认"
log($str.emptyToDefault("嘿嘿","默认")); //"嘿嘿"
log($str.emptyToDefault(null,"默认")); //"默认"
```


### subStart(input, length)

> 截取开头字符

- 参数 : input {string} 输入的字符串
- 参数 : length {int} 截取长度
- 返回 : 字符串
- 版本 : 1.0.0


```javascript
log($str.subStart("ABCDEFG",100)); //"ABCDEFG"
log($str.subStart("ABCDEFG",7)); //"ABCDEFG"
log($str.subStart("ABCDEFG",3)); //"ABC"
```


### subEnd(input, length)

> 截取末尾字符

- 参数 : input {string} 输入的字符串
- 参数 : length {int} 截取长度
- 返回 : 字符串
- 版本 : 1.0.0


```javascript
log($str.subEnd("ABCDEFG",100)); //"ABCDEFG"
log($str.subEnd("ABCDEFG",7)); //"ABCDEFG"
log($str.subEnd("ABCDEFG",3)); //"EFG"
log($str.subEnd("ABCDEFG",2)); //"FG"
log($str.subEnd("ABCDEFG",1)); //"G"
```


### trim(str)

> 去除首尾空格
> 
> 如果输入的字符串为null，则返回""空串

- 参数 : str {string} 要处理的字符序列
- 返回 : {string} 去除前后空格后的字符序列，如果原字符序列为 null 则返回 null
- 版本 : 1.0.0


```javascript
log($str.trim(" ABCDEFG ")); //"ABCDEFG"
```


### trimStart(str)

> 去除开头空格
> 
> 如果输入的字符串为null，则返回""空串

- 参数 : str {string} 要处理的字符序列
- 返回 : {string} 去除开头空格后的字符序列，如果原字符序列为 null 则返回 null
- 版本 : 1.0.0


```javascript
log($str.trimStart(" ABCDEFG ")); //"ABCDEFG "
log($str.trimStart(null)); //""
```


### trimEnd(str)

> 去除结尾空格
> 
> 如果输入的字符串为null，则返回""空串

- 参数 : str {string} 要处理的字符序列
- 返回 : {string} 去除结尾空格后的字符序列，如果原字符序列为 null 则返回 null
- 版本 : 1.0.0


```javascript
log($str.trimEnd(" ABCDEFG ")); //" ABCDEFG"
log($str.trimEnd(null)); //""
```


### trim(str, mode)

> 根据模式去除空格

- 参数 : str {string} 要处理的字符序列
- 参数 : mode {int} 模式： 0 去除前后空格，1 去除开头空格，2 去除结尾空格 其他数字就返回字符串本身
- 返回 : {string} 根据模式处理后的字符序列
- 版本 : 1.0.0


```javascript
log($str.trim(" ABCDEFG ",0)); //"ABCDEFG"(去除首尾)
log($str.trim(" ABCDEFG ",1)); //"ABCDEFG "(去除开头)
log($str.trim(" ABCDEFG ",2)); //" ABCDEFG"(去除结尾)
log($str.trim(" ABCDEFG ",100)); //" ABCDEFG "(啥也不干)
log($str.trim(null,0)); //""
log($str.trim(null,1)); //""
log($str.trim(null,2)); //""
```


### startWith(str, prefix, ignoreCase)

> 是否以前缀开头

- 参数 : str {string}  要判断的字符序列
- 参数 : prefix {string} 指定的前缀
- 参数 : ignoreCase {boolean} 是否忽略大小写
- 返回 : 如果字符序列以指定前缀开头则返回 true，否则返回 false
- 版本 : 1.0.0


### startWith(str, prefix)

> 是否以前缀开头
> 
> 如果传入的参数为空，则会提示并且返回false，默认不忽略大小写

- 参数 : str {string} 要判断的字符序列
- 参数 : prefix {string} 指定的前缀
- 返回 : {boolean} 是否以前缀开头
- 版本 : 1.0.0


### startWithIgnoreEquals(str, prefix)

> 判断字符序列是否以指定前缀开头，忽略相等比较（暂未明确相等比较的具体含义，这里忽略此含义）

- 参数 : str 要判断的字符序列
- 参数 : prefix 指定的前缀
- 返回 : 如果字符序列以指定前缀开头则返回 true，否则返回 false
- 版本 : 1.0.0


### startWithIgnoreCase(str, prefix)

> 判断字符序列是否以指定前缀开头，忽略大小写

- 参数 : str 要判断的字符序列
- 参数 : prefix 指定的前缀
- 返回 : 如果字符序列以指定前缀开头则返回 true，否则返回 false
- 版本 : 1.0.0


### startWithAny(str, prefixes)

> 判断字符序列是否以指定前缀数组中的任意一个前缀开头

- 参数 : str {String}   要判断的字符序列
- 参数 : prefixes {string[]} 指定的前缀数组
- 返回 : 如果字符序列以指定前缀数组中的任意一个前缀开头则返回 true，否则返回 false
- 版本 : 1.0.0


### startWithAnyIgnoreCase(str, prefixes)

> 判断字符序列是否以指定前缀数组中的任意一个前缀开头，忽略大小写

- 参数 : str {string} 要判断的字符序列
- 参数 : prefixes {string[]} 指定的前缀数组
- 返回 : 如果字符序列以指定前缀数组中的任意一个前缀开头则返回 true，否则返回 false
- 版本 : 1.0.0


### endWith(str, suffix, ignoreCase)

> 判断字符串是否以指定后缀结尾，可选择是否忽略大小写

- 参数 : str 要检查的字符串
- 参数 : suffix 要检查的后缀
- 参数 : ignoreCase 是否忽略大小写
- 返回 : 如果字符串以指定后缀结尾返回 true，否则返回 false
- 版本 : 1.0.0


### endWith(str, suffix, ignoreCase, ignoreEquals)

> 判断字符串是否以指定后缀结尾，可选择是否忽略大小写和是否忽略相等

- 参数 : str 要检查的字符串
- 参数 : suffix 要检查的后缀
- 参数 : ignoreCase 是否忽略大小写
- 参数 : ignoreEquals 是否忽略相等
- 返回 : 如果字符串以指定后缀结尾返回 true，否则返回 false
- 版本 : 1.0.0


### endWith(str, suffix)

> 判断字符串是否以指定后缀结尾

- 参数 : str 要检查的字符串
- 参数 : suffix 要检查的后缀
- 返回 : 如果字符串以指定后缀结尾返回 true，否则返回 false
- 版本 : 1.0.0


### endWithIgnoreCase(str, suffix)

> 判断字符串是否以指定后缀结尾，忽略大小写

- 参数 : str 要检查的字符串
- 参数 : suffix 要检查的后缀
- 返回 : 如果字符串以指定后缀结尾返回 true，否则返回 false
- 版本 : 1.0.0


### endWithAny(str, suffixes)

> 判断字符串是否以指定后缀中的任意一个结尾

- 参数 : str {string}  要检查的字符串
- 参数 : suffixes {string[]} 要检查的后缀数组
- 返回 : 如果字符串以指定后缀中的任意一个结尾返回 true，否则返回 false
- 版本 : 1.0.0


### endWithAnyIgnoreCase(str, suffixes)

> 判断字符串是否以指定后缀中的任意一个结尾，忽略大小写

- 参数 : str {string} 要检查的字符串
- 参数 : suffixes {string[]} 要检查的后缀数组
- 返回 : 如果字符串以指定后缀中的任意一个结尾返回 true，否则返回 false
- 版本 : 1.0.0


### contains(str, searchStr)

> 判断字符串是否包含指定子字符串

- 参数 : str 要检查的字符串 
- 参数 : searchStr 要检查的子字符串 
- 返回 : 如果字符串包含指定子字符串返回 true，否则返回 false
- 版本 : 1.0.0


### has(str, searchStr)

> 判断字符串是否包含指定子字符串

- 参数 : str 要检查的字符串 
- 参数 : searchStr 要检查的子字符串 
- 返回 : 如果字符串包含指定子字符串返回 true，否则返回 false
- 版本 : 1.0.0


### containsAny(str, sreArr)

> 判断字符串是否包含指定子字符串数组中的任意一个

- 参数 : str {str} 字符串
- 参数 : sreArr {string[]} 要检查的子字符串数组
- 返回 : 如果字符串包含指定子字符串数组中的任意一个返回 true，否则返回 false
- 版本 : 1.0.0


```javascript
let strArr = ["main","splash","welcome","start"];
let hasStr = $str.containsAny("ada main asd",strArr);
if (hasStr) {
    alert("判断字符串","包含");
} else {
    alert("判断字符串","不包含");
}
```


### containsAll(str, testChars)

> 判断字符串是否包含指定字符数组中的所有字符

- 参数 : str 要检查的字符串
- 参数 : testChars 要检查的字符数组
- 返回 : 如果字符串包含指定字符数组中的所有字符返回 true，否则返回 false
- 版本 : 1.0.0


### containsBlank(str)

> 判断字符串是否包含空白字符

- 参数 : str 要检查的字符串
- 返回 : 如果字符串包含空白字符返回 true，否则返回 false
- 版本 : 1.0.0


### getContainsStr(str, testStrs)

> 获取字符串中包含的指定子字符串

- 参数 : str 要检查的字符串
- 参数 : testStrs 要检查的子字符串数组
- 返回 : 包含的子字符串，如果没有则返回 null
- 版本 : 1.0.0


### containsIgnoreCase(str, testStr)

> 判断字符串是否包含指定子字符串，忽略大小写

- 参数 : str 要检查的字符串
- 参数 : testStr 要检查的子字符串
- 返回 : 如果字符串包含指定子字符串返回 true，否则返回 false
- 版本 : 1.0.0


### containsAnyIgnoreCase(str, testStrs)

> 判断字符串是否包含指定子字符串数组中的任意一个，忽略大小写

- 参数 : str 要检查的字符串
- 参数 : testStrs 要检查的子字符串数组
- 返回 : 如果字符串包含指定子字符串数组中的任意一个返回 true，否则返回 false
- 版本 : 1.0.0


### getContainsStrIgnoreCase(str, testStrs)

> 获取字符串中包含的指定子字符串，忽略大小写

- 参数 : str 要检查的字符串
- 参数 : testStrs 要检查的子字符串数组
- 返回 : 包含的子字符串，如果没有则返回 null
- 版本 : 1.0.0


### indexOfIgnoreCase(str, searchStr)

> 获取指定子字符串在字符串中第一次出现的索引，忽略大小写

- 参数 : str 要检查的字符串
- 参数 : searchStr 要检查的子字符串
- 返回 : 子字符串第一次出现的索引，如果没有则返回 -1
- 版本 : 1.0.0


### indexOfIgnoreCase(str, searchStr, fromIndex)

> 获取指定子字符串在字符串中从指定位置开始第一次出现的索引，忽略大小写

- 参数 : str 要检查的字符串
- 参数 : searchStr 要检查的子字符串
- 参数 : fromIndex 开始搜索的位置
- 返回 : 子字符串第一次出现的索引，如果没有则返回 -1
- 版本 : 1.0.0


### indexOf(text, searchStr, from, ignoreCase)

> 获取指定子字符串在字符串中从指定位置开始第一次出现的索引，可选择是否忽略大小写

- 参数 : text 要检查的字符串
- 参数 : searchStr 要检查的子字符串
- 参数 : from 开始搜索的位置
- 参数 : ignoreCase 是否忽略大小写
- 返回 : 子字符串第一次出现的索引，如果没有则返回 -1
- 版本 : 1.0.0


### lastIndexOfIgnoreCase(str, searchStr)

> 获取指定子字符串在字符串中最后一次出现的索引，忽略大小写

- 参数 : str 要检查的字符串
- 参数 : searchStr 要检查的子字符串
- 返回 : 子字符串最后一次出现的索引，如果没有则返回 -1
- 版本 : 1.0.0


### lastIndexOfIgnoreCase(str, searchStr, fromIndex)

> 获取指定子字符串在字符串中从指定位置开始最后一次出现的索引，忽略大小写

- 参数 : str 要检查的字符串
- 参数 : searchStr 要检查的子字符串
- 参数 : fromIndex 开始搜索的位置
- 返回 : 子字符串最后一次出现的索引，如果没有则返回 -1
- 版本 : 1.0.0


### cleanBlank(str)

> 清除字符串中的空白字符

- 参数 : str 输入的字符序列
- 返回 : 清除空白字符后的字符串
- 版本 : 1.0.0


### stripIgnoreCase(str, prefixOrSuffix)

> 忽略大小写地去除字符串的前缀或后缀

- 参数 : str 输入的字符序列
- 参数 : prefixOrSuffix 要去除的前缀或后缀
- 返回 : 去除后的字符串
- 版本 : 1.0.0


### stripIgnoreCase(str, prefix, suffix)

> 忽略大小写地去除字符串的前缀和后缀

- 参数 : str 输入的字符序列
- 参数 : prefix 要去除的前缀
- 参数 : suffix 要去除的后缀
- 返回 : 去除后的字符串
- 版本 : 1.0.0


### strip(str, prefixOrSuffix)

> 去除字符串的前缀或后缀

- 参数 : str 输入的字符序列
- 参数 : prefixOrSuffix 要去除的前缀或后缀
- 返回 : 去除后的字符串
- 版本 : 1.0.0


### strip(str, prefix, suffix)

> 去除字符串的前缀和后缀

- 参数 : str 输入的字符序列
- 参数 : prefix 要去除的前缀
- 参数 : suffix 要去除的后缀
- 返回 : 去除后的字符串
- 版本 : 1.0.0


### strip(str, prefix, suffix, ignoreCase)

> 去除字符串的前缀和后缀，可选择是否忽略大小写

- 参数 : str 输入的字符序列
- 参数 : prefix 要去除的前缀
- 参数 : suffix 要去除的后缀
- 参数 : ignoreCase 是否忽略大小写
- 返回 : 去除后的字符串
- 版本 : 1.0.0


### stripAll(str, prefixOrSuffix)

> 去除字符串中所有的前缀或后缀

- 参数 : str 输入的字符序列
- 参数 : prefixOrSuffix 要去除的前缀或后缀
- 返回 : 去除后的字符串
- 版本 : 1.0.0


### stripAll(str, prefix, suffix)

> 去除字符串中所有的前缀和后缀

- 参数 : str 输入的字符序列
- 参数 : prefix 要去除的前缀
- 参数 : suffix 要去除的后缀
- 返回 : 去除后的字符串
- 版本 : 1.0.0


### addPrefixIfNot(str, prefix)

> 如果字符串没有指定前缀，则添加该前缀

- 参数 : str 输入的字符序列
- 参数 : prefix 要添加的前缀
- 返回 : 添加前缀后的字符串
- 版本 : 1.0.0


### addSuffixIfNot(str, suffix)

> 如果字符串没有指定后缀，则添加该后缀

- 参数 : str 输入的字符序列
- 参数 : suffix 要添加的后缀
- 返回 : 添加后缀后的字符串
- 版本 : 1.0.0


### splitToLong(str, separator)

> 将字符串按指定字符序列分隔并转换为 long 数组

- 参数 : str 输入的字符序列
- 参数 : separator 分隔字符序列
- 返回 : long 数组
- 版本 : 1.0.0


### splitToInt(str, separator)

> 将字符串按指定字符序列分隔并转换为 int 数组

- 参数 : str 输入的字符序列
- 参数 : separator 分隔字符序列
- 返回 : int 数组
- 版本 : 1.0.0


### splitToArray(str, separator)

> 将字符串按指定字符序列分隔成字符串数组

- 参数 : str 输入的字符序列
- 参数 : separator 分隔字符序列
- 返回 : 字符串数组
- 版本 : 1.0.0


### splitTrim(str, regex)

> 分割并且去除首尾空格

- 参数 : str 输入的字符序列 
- 参数 : regex 分隔字符(表达式) 
- 返回 : 字符串列表
- 版本 : 1.0.0


### splitTrim(str, separator, limit)

> 将字符串按指定字符序列分隔成字符串列表，限制列表长度，并去除每个元素的前后空白字符

- 参数 : str 输入的字符序列
- 参数 : separator 分隔字符序列
- 参数 : limit 列表长度限制
- 返回 : 字符串列表
- 版本 : 1.0.0


### toUnderlineCase(str)

> 将输入的字符序列转换为下划线格式的字符串

- 参数 : str 输入的字符序列
- 返回 : 转换后的下划线格式字符串
- 版本 : 1.0.0


### toCamelCase(name)

> 将输入的字符序列转换为驼峰格式的字符串

- 参数 : name 输入的字符序列
- 返回 : 转换后的驼峰格式字符串
- 版本 : 1.0.0


### isSurround(str, prefix, suffix)

> 判断输入的字符序列是否以指定的前缀和后缀包围

- 参数 : str 输入的字符序列
- 参数 : prefix 前缀字符序列
- 参数 : suffix 后缀字符序列
- 返回 : 如果以指定的前缀和后缀包围则返回 true，否则返回 false
- 版本 : 1.0.0


### builder(strs)

> 将输入的字符序列数组连接成一个 StringBuilder 对象

- 参数 : strs 输入的字符序列数组
- 返回 : 连接后的 StringBuilder 对象
- 版本 : 1.0.0


### concat(isNullToEmpty, strs)

> 连接输入的字符序列数组，根据 isNullToEmpty 参数决定是否将 null 转换为空字符串

- 参数 : isNullToEmpty 如果为 true，则将 null 转换为空字符串；否则保持 null
- 参数 : strs 输入的字符序列数组
- 返回 : 连接后的字符串
- 版本 : 1.0.0


### brief(str, maxLength)

> 截取输入的字符序列，使其长度不超过指定的最大长度

- 参数 : str 输入的字符序列
- 参数 : maxLength 最大长度
- 返回 : 截取后的字符串
- 版本 : 1.0.0


### join(conjunction, objs)

> 使用指定的连接词连接输入的对象数组

- 参数 : conjunction 连接词
- 参数 : objs 输入的对象数组
- 返回 : 连接后的字符串
- 版本 : 1.0.0


### isNumeric(str)

> 判断输入的字符序列是否为数字

- 参数 : str 输入的字符序列
- 返回 : 如果是数字则返回 true，否则返回 false
- 版本 : 1.0.0


### move(str, startInclude, endExclude, moveLength)

> 将输入的字符序列的指定子串移动指定的长度

- 参数 : str 输入的字符序列
- 参数 : startInclude 起始位置（包含）
- 参数 : endExclude 结束位置（不包含）
- 参数 : moveLength 移动的长度
- 返回 : 移动后的字符串
- 版本 : 1.0.0


### isCharEquals(str)

> 判断输入的字符序列是否所有字符都相等

- 参数 : str 输入的字符序列
- 返回 : 如果所有字符都相等则返回 true，否则返回 false
- 版本 : 1.0.0


### normalize(str)

> 对输入的字符序列进行规范化处理，去除首尾空格

- 参数 : str 输入的字符序列
- 返回 : 规范化处理后的字符串
- 版本 : 1.0.0


### hasLetter(str)

> 判断输入的字符序列是否包含字母

- 参数 : str 输入的字符序列
- 返回 : 如果包含字母则返回 true，否则返回 false
- 版本 : 1.0.0


### commonPrefix(str1, str2)

> 找出两个字符序列的公共前缀

- 参数 : str1 第一个字符序列
- 参数 : str2 第二个字符序列
- 返回 : 公共前缀
- 版本 : 1.0.0


### commonSuffix(str1, str2)

> 找出两个字符序列的公共后缀

- 参数 : str1 第一个字符序列
- 参数 : str2 第二个字符序列
- 返回 : 公共后缀
- 版本 : 1.0.0


### isBlankIfStr(obj)

> 判断输入的对象如果是字符串则是否为空白字符串

- 参数 : obj 输入的对象
- 返回 : 如果是字符串且为空白字符串则返回 true，否则返回 false
- 版本 : 1.0.0


### isEmptyIfStr(obj)

> 判断输入的对象如果是字符串则是否为空字符串

- 参数 : obj 输入的对象
- 返回 : 如果是字符串且为空字符串则返回 true，否则返回 false
- 版本 : 1.0.0


### trim(strs)

> 去除字符串数组中每个字符串的首尾空格

- 参数 : strs 输入的字符串数组
- 版本 : 1.0.0


### utf8Str(obj)

> 将输入的对象转换为 UTF-8 编码的字符串

- 参数 : obj 输入的对象
- 返回 : UTF-8 编码的字符串
- 版本 : 1.0.0


### str(obj, charsetName)

> 将输入的对象转换为指定字符集编码的字符串

- 参数 : obj 输入的对象
- 参数 : charsetName 指定的字符集名称
- 返回 : 指定字符集编码的字符串
- 版本 : 1.0.0


### str(bytes, charset)

> 将输入的字节数组转换为指定字符集编码的字符串

- 参数 : bytes 输入的字节数组
- 参数 : charset 指定的字符集名称
- 返回 : 指定字符集编码的字符串
- 版本 : 1.0.0


### repeat(str, count)

> 将指定字符序列重复指定次数并返回结果字符串

- 参数 : str 要重复的字符序列
- 参数 : count 重复的次数
- 返回 : 重复字符序列组成的字符串
- 版本 : 1.0.0


### repeatByLength(str, padLen)

> 将指定字符序列重复直到达到指定长度并返回结果字符串

- 参数 : str 要重复的字符序列
- 参数 : padLen 目标长度
- 返回 : 重复字符序列组成的字符串，长度达到 padLen
- 版本 : 1.0.0


### repeatAndJoin(str, count, delimiter)

> 将指定字符序列重复指定次数，并使用指定分隔符连接，返回结果字符串

- 参数 : str 要重复的字符序列
- 参数 : count 重复的次数
- 参数 : delimiter 分隔符
- 返回 : 重复字符序列并用分隔符连接的字符串
- 版本 : 1.0.0


### equals(str1, str2)

> 比较两个字符序列是否相等

- 参数 : str1 第一个字符序列
- 参数 : str2 第二个字符序列
- 返回 : 如果两个字符序列相等则返回 true，否则返回 false
- 版本 : 1.0.0


### equalsIgnoreCase(str1, str2)

> 比较两个字符序列是否相等，忽略大小写

- 参数 : str1 第一个字符序列
- 参数 : str2 第二个字符序列
- 返回 : 如果两个字符序列相等（忽略大小写）则返回 true，否则返回 false
- 版本 : 1.0.0


### equals(str1, str2, ignoreCase)

> 比较两个字符序列是否相等，可选择是否忽略大小写

- 参数 : str1 第一个字符序列
- 参数 : str2 第二个字符序列
- 参数 : ignoreCase 是否忽略大小写
- 返回 : 如果两个字符序列相等（根据 ignoreCase 决定是否忽略大小写）则返回 true，否则返回 false
- 版本 : 1.0.0


### equalsAnyIgnoreCase(str1, strs)

> 检查一个字符序列是否与给定的多个字符序列中的任何一个相等，忽略大小写

- 参数 : str1 要检查的字符序列
- 参数 : strs 多个字符序列
- 返回 : 如果 str1 与 strs 中的任何一个相等（忽略大小写）则返回 true，否则返回 false
- 版本 : 1.0.0


### equalsAny(str1, strs)

> 检查一个字符序列是否与给定的多个字符序列中的任何一个相等

- 参数 : str1 要检查的字符序列
- 参数 : strs 多个字符序列
- 返回 : 如果 str1 与 strs 中的任何一个相等则返回 true，否则返回 false
- 版本 : 1.0.0


### equalsAny(str1, ignoreCase, strs)

> 检查一个字符序列是否与给定的多个字符序列中的任何一个相等，可选择是否忽略大小写

- 参数 : str1 要检查的字符序列
- 参数 : ignoreCase 是否忽略大小写
- 参数 : strs 多个字符序列
- 返回 : 如果 str1 与 strs 中的任何一个相等（根据 ignoreCase 决定是否忽略大小写）则返回 true，否则返回 false
- 版本 : 1.0.0


### isSubEquals(str1, start1, str2, ignoreCase)

> 检查一个字符序列的子序列是否与另一个字符序列相等，可选择是否忽略大小写

- 参数 : str1 第一个字符序列
- 参数 : start1 第一个字符序列的起始位置
- 参数 : str2 第二个字符序列
- 参数 : ignoreCase 是否忽略大小写
- 返回 : 如果 str1 从 start1 开始的子序列与 str2 相等（根据 ignoreCase 决定是否忽略大小写）则返回 true，否则返回 false
- 版本 : 1.0.0


### isSubEquals(str1, start1, str2, start2, length, ignoreCase)

> 检查一个字符序列的指定子序列是否与另一个字符序列的指定子序列相等，可选择是否忽略大小写

- 参数 : str1 第一个字符序列
- 参数 : start1 第一个字符序列的起始位置
- 参数 : str2 第二个字符序列
- 参数 : start2 第二个字符序列的起始位置
- 参数 : length 要比较的长度
- 参数 : ignoreCase 是否忽略大小写
- 返回 : 如果 str1 从 start1 开始长度为 length 的子序列与 str2 从 start2 开始长度为 length 的子序列相等（根据 ignoreCase 决定是否忽略大小写）则返回 true，否则返回 false
- 版本 : 1.0.0


### format(template, params)

> 使用指定的参数格式化字符序列模板

- 参数 : template 字符序列模板
- 参数 : params 格式化参数
- 返回 : 格式化后的字符串
- 版本 : 1.0.0


### indexedFormat(pattern, arguments)

> 使用指定的参数格式化带索引的字符序列模板

- 参数 : pattern 带索引的字符序列模板
- 参数 : arguments 格式化参数
- 返回 : 格式化后的字符串
- 版本 : 1.0.0


### utf8Bytes(str)

> 将字符序列转换为 UTF-8 字节数组

- 参数 : str 要转换的字符序列
- 返回 : UTF-8 字节数组
- 版本 : 1.0.0


### bytes(str)

> 将字符序列转换为默认字符集的字节数组

- 参数 : str 要转换的字符序列
- 返回 : 默认字符集的字节数组
- 版本 : 1.0.0


### bytes(str, charset)

> 将字符序列转换为指定字符集的字节数组

- 参数 : str 要转换的字符序列
- 参数 : charset 指定的字符集名称
- 返回 : 指定字符集的字节数组
- 版本 : 1.0.0


### wrap(str, prefixAndSuffix)

> 用指定的前缀和后缀包装字符序列

- 参数 : str 要包装的字符序列
- 参数 : prefixAndSuffix 前缀和后缀
- 返回 : 包装后的字符串
- 版本 : 1.0.0


### wrap(str, prefix, suffix)

> 用指定的前缀和后缀包装字符序列

- 参数 : str 要包装的字符序列
- 参数 : prefix 前缀
- 参数 : suffix 后缀
- 返回 : 包装后的字符串
- 版本 : 1.0.0


### wrapAllWithPair(prefixAndSuffix, strs)

> 用指定的前缀和后缀包装多个字符序列

- 参数 : prefixAndSuffix 前缀和后缀
- 参数 : strs 多个字符序列
- 返回 : 包装后的字符串数组
- 版本 : 1.0.0


### wrapAll(prefix, suffix, strs)

> 用指定的前缀和后缀包装多个字符序列

- 参数 : prefix 前缀
- 参数 : suffix 后缀
- 参数 : strs 多个字符序列
- 返回 : 包装后的字符串数组
- 版本 : 1.0.0


### wrapIfMissing(str, prefix, suffix)

> 如果字符序列没有指定的前缀和后缀，则用其包装

- 参数 : str 要包装的字符序列
- 参数 : prefix 前缀
- 参数 : suffix 后缀
- 返回 : 包装后的字符串
- 版本 : 1.0.0


### wrapAllWithPairIfMissing(prefixAndSuffix, strs)

> 如果多个字符序列没有指定的前缀和后缀，则用其包装

- 参数 : prefixAndSuffix 前缀和后缀
- 参数 : strs 多个字符序列
- 返回 : 包装后的字符串数组
- 版本 : 1.0.0


### count(content, strForSearch)

> 计算 String 中指定 String 出现的次数

- 参数 : content 要搜索的内容
- 参数 : strForSearch 要搜索的字符串
- 返回 : 出现的次数
- 版本 : 1.0.0


### compare(str1, str2, nullIsLess)

> 比较两个 String 的大小

- 参数 : str1 第一个字符串
- 参数 : str2 第二个字符串
- 参数 : nullIsLess 当字符串为 null 时是否认为更小
- 返回 : 比较结果，小于返回负数，等于返回 0，大于返回正数
- 版本 : 1.0.0


### compareIgnoreCase(str1, str2, nullIsLess)

> 忽略大小写比较两个 String 的大小

- 参数 : str1 第一个字符串
- 参数 : str2 第二个字符串
- 参数 : nullIsLess 当字符串为 null 时是否认为更小
- 返回 : 比较结果，小于返回负数，等于返回 0，大于返回正数
- 版本 : 1.0.0


### compareVersion(version1, version2)

> 比较两个版本号的大小

- 参数 : version1 第一个版本号
- 参数 : version2 第二个版本号
- 返回 : 比较结果，小于返回负数，等于返回 0，大于返回正数
- 版本 : 1.0.0


### appendIfMissing(str, suffix, suffixes)

> 如果字符串不以指定后缀结尾，则添加后缀

- 参数 : str 原始字符串
- 参数 : suffix 要添加的后缀
- 参数 : suffixes 其他可能的后缀
- 返回 : 添加后缀后的字符串
- 版本 : 1.0.0


### appendIfMissingIgnoreCase(str, suffix, suffixes)

> 如果字符串不以指定后缀结尾（忽略大小写），则添加后缀

- 参数 : str 原始字符串
- 参数 : suffix 要添加的后缀
- 参数 : suffixes 其他可能的后缀
- 返回 : 添加后缀后的字符串
- 版本 : 1.0.0


### appendIfMissing(str, suffix, ignoreCase, testSuffixes)

> 如果字符串不以指定后缀结尾（可指定是否忽略大小写），则添加后缀

- 参数 : str 原始字符串
- 参数 : suffix 要添加的后缀
- 参数 : ignoreCase 是否忽略大小写
- 参数 : testSuffixes 其他可能的后缀
- 返回 : 添加后缀后的字符串
- 版本 : 1.0.0


### prependIfMissing(str, prefix, prefixes)

> 如果字符串不以指定前缀开头，则添加前缀

- 参数 : str 原始字符串
- 参数 : prefix 要添加的前缀
- 参数 : prefixes 其他可能的前缀
- 返回 : 添加前缀后的字符串
- 版本 : 1.0.0


### prependIfMissingIgnoreCase(str, prefix, prefixes)

> 如果字符串不以指定前缀开头（忽略大小写），则添加前缀

- 参数 : str 原始字符串
- 参数 : prefix 要添加的前缀
- 参数 : prefixes 其他可能的前缀
- 返回 : 添加前缀后的字符串
- 版本 : 1.0.0


### prependIfMissing(str, prefix, ignoreCase, prefixes)

> 如果字符串不以指定前缀开头（可指定是否忽略大小写），则添加前缀

- 参数 : str 原始字符串
- 参数 : prefix 要添加的前缀
- 参数 : ignoreCase 是否忽略大小写
- 参数 : prefixes 其他可能的前缀
- 返回 : 添加前缀后的字符串
- 版本 : 1.0.0


### replaceIgnoreCase(str, searchStr, replacement)

> 忽略大小写替换字符串中的指定内容

- 参数 : str 原始字符串
- 参数 : searchStr 要查找的字符串
- 参数 : replacement 替换后的字符串
- 返回 : 替换后的字符串
- 版本 : 1.0.0


### replace(str, searchStr, replacement)

> 替换字符串中的指定内容

- 参数 : str 原始字符串
- 参数 : searchStr 要查找的字符串
- 参数 : replacement 替换后的字符串
- 返回 : 替换后的字符串
- 版本 : 1.0.0


### lastIndexOf(text, searchStr, from, ignoreCase)

> 从指定位置开始查找指定字符序列最后一次出现的位置，可选择是否忽略大小写

- 参数 : text 要查找的文本
- 参数 : searchStr 要查找的字符序列
- 参数 : from 开始查找的位置
- 参数 : ignoreCase 是否忽略大小写
- 返回 : 最后一次出现的位置，如果未找到则返回 -1
- 版本 : 1.0.0


### ordinalIndexOf(str, searchStr, ordinal)

> 查找指定字符序列在另一个字符序列中第 ordinal 次出现的位置

- 参数 : str 要查找的文本
- 参数 : searchStr 要查找的字符序列
- 参数 : ordinal 要查找的第几次出现（从 1 开始）
- 返回 : 第 ordinal 次出现的位置，如果未找到则返回 -1
- 版本 : 1.0.0


### removeAll(str, strToRemove)

> 从字符序列中移除所有指定的字符序列

- 参数 : str 原始字符序列
- 参数 : strToRemove 要移除的字符序列
- 返回 : 移除后的字符序列
- 版本 : 1.0.0


### removeAny(str, strsToRemove)

> 从字符序列中移除指定的多个字符序列中的任意一个

- 参数 : str 原始字符序列
- 参数 : strsToRemove 要移除的多个字符序列
- 返回 : 移除后的字符序列
- 版本 : 1.0.0


### removeAllLineBreaks(str)

> 移除字符序列中的所有换行符

- 参数 : str 原始字符序列
- 返回 : 移除换行符后的字符序列
- 版本 : 1.0.0


### removePreAndLowerFirst(str, preLength)

> 移除字符序列的前 preLength 个字符并将第一个字符转换为小写

- 参数 : str 原始字符序列
- 参数 : preLength 要移除的前缀长度
- 返回 : 处理后的字符序列
- 版本 : 1.0.0


### removePreAndLowerFirst(str, prefix)

> 移除字符序列的指定前缀并将第一个字符转换为小写

- 参数 : str 原始字符序列
- 参数 : prefix 要移除的前缀
- 返回 : 处理后的字符序列
- 版本 : 1.0.0


### removePrefix(str, prefix)

> 移除字符序列的指定前缀

- 参数 : str 原始字符序列
- 参数 : prefix 要移除的前缀
- 返回 : 移除前缀后的字符序列
- 版本 : 1.0.0


### removeAllPrefix(str, prefix)

> 移除字符序列中所有的指定前缀

- 参数 : str 原始字符序列
- 参数 : prefix 要移除的前缀
- 返回 : 移除所有前缀后的字符序列
- 版本 : 1.0.0


### removePrefixIgnoreCase(str, prefix)

> 忽略大小写地移除字符序列的指定前缀

- 参数 : str 原始字符序列
- 参数 : prefix 要移除的前缀
- 返回 : 移除前缀后的字符序列
- 版本 : 1.0.0


### removeSuffix(str, suffix)

> 移除字符序列的指定后缀

- 参数 : str 原始字符序列
- 参数 : suffix 要移除的后缀
- 返回 : 移除后缀后的字符序列
- 版本 : 1.0.0


### removeAllSuffix(str, suffix)

> 移除字符序列中所有的指定后缀

- 参数 : str 原始字符序列
- 参数 : suffix 要移除的后缀
- 返回 : 移除所有后缀后的字符序列
- 版本 : 1.0.0


### removeSufAndLowerFirst(str, suffix)

> 移除字符序列的指定后缀并将第一个字符转换为小写

- 参数 : str 原始字符序列
- 参数 : suffix 要移除的后缀
- 返回 : 处理后的字符序列
- 版本 : 1.0.0


### removeSuffixIgnoreCase(str, suffix)

> 忽略大小写地移除字符序列的指定后缀

- 参数 : str 原始字符序列
- 参数 : suffix 要移除的后缀
- 返回 : 移除后缀后的字符序列
- 版本 : 1.0.0


### wrapAllIfMissing(prefix, suffix, strs)

> 如果字符串数组中的每个字符串没有指定的前缀和后缀，则添加前缀和后缀

- 参数 : prefix 要添加的前缀
- 参数 : suffix 要添加的后缀
- 参数 : strs 字符串数组
- 返回 : 处理后的字符串数组
- 版本 : 1.0.0


### unWrap(str, prefix, suffix)

> 移除字符串的指定前缀和后缀

- 参数 : str 要处理的字符串
- 参数 : prefix 要移除的前缀
- 参数 : suffix 要移除的后缀
- 返回 : 处理后的字符串
- 版本 : 1.0.0


### isWrap(str, prefix, suffix)

> 判断字符串是否以指定的前缀和后缀包裹

- 参数 : str 要判断的字符串
- 参数 : prefix 前缀
- 参数 : suffix 后缀
- 返回 : 如果字符串以指定的前缀和后缀包裹则返回 true，否则返回 false
- 版本 : 1.0.0


### isWrap(str, wrapper)

> 判断字符串是否以指定的包裹字符串包裹

- 参数 : str 要判断的字符串
- 参数 : wrapper 包裹字符串
- 返回 : 如果字符串以指定的包裹字符串包裹则返回 true，否则返回 false
- 版本 : 1.0.0


### padPre(str, length, padStr)

> 在字符串前面填充指定的字符串，直到达到指定的长度

- 参数 : str 要填充的字符串
- 参数 : length 填充后的长度
- 参数 : padStr 用于填充的字符串
- 返回 : 填充后的字符串
- 版本 : 1.0.0


### padAfter(str, length, padStr)

> 在字符串后面填充指定的字符串，直到达到指定的长度

- 参数 : str 要填充的字符串
- 参数 : length 填充后的长度
- 参数 : padStr 用于填充的字符串
- 返回 : 填充后的字符串
- 版本 : 1.0.0


### center(str, size)

> 将字符串居中，使用空格填充

- 参数 : str 要居中的字符串
- 参数 : size 填充后的总长度
- 返回 : 居中后的字符串
- 版本 : 1.0.0


### center(str, size, padStr)

> 将字符串居中，使用指定的字符串填充

- 参数 : str 要居中的字符串
- 参数 : size 填充后的总长度
- 参数 : padStr 用于填充的字符串
- 返回 : 居中后的字符串
- 版本 : 1.0.0


### replace(str, searchStr, replacement, ignoreCase)

> 替换字符串中所有匹配的子字符串

- 参数 : str 原始字符串
- 参数 : searchStr 要查找的子字符串
- 参数 : replacement 用于替换的字符串
- 参数 : ignoreCase 是否忽略大小写
- 返回 : 替换后的字符串
- 版本 : 1.0.0


### replace(str, fromIndex, searchStr, replacement, ignoreCase)

> 从指定索引开始替换字符串中所有匹配的子字符串

- 参数 : str 原始字符串
- 参数 : fromIndex 开始查找的索引
- 参数 : searchStr 要查找的子字符串
- 参数 : replacement 用于替换的字符串
- 参数 : ignoreCase 是否忽略大小写
- 返回 : 替换后的字符串
- 版本 : 1.0.0


### replace(str, startInclude, endExclude, replacedStr)

> 替换指定范围内的子字符串

- 参数 : str 原始字符串
- 参数 : startInclude 开始索引（包含）
- 参数 : endExclude 结束索引（不包含）
- 参数 : replacedStr 用于替换的字符串
- 返回 : 替换后的字符串
- 版本 : 1.0.0


### replaceLast(str, searchStr, replacedStr)

> 替换字符串中最后一个匹配的子字符串

- 参数 : str 原始字符串
- 参数 : searchStr 要查找的子字符串
- 参数 : replacedStr 用于替换的字符串
- 返回 : 替换后的字符串
- 版本 : 1.0.0


### replaceLast(str, searchStr, replacedStr, ignoreCase)

> 替换字符串中最后一个匹配的子字符串，可选择是否忽略大小写

- 参数 : str 原始字符串
- 参数 : searchStr 要查找的子字符串
- 参数 : replacedStr 用于替换的字符串
- 参数 : ignoreCase 是否忽略大小写
- 返回 : 替换后的字符串
- 版本 : 1.0.0


### replaceFirst(str, searchStr, replacedStr)

> 替换字符串中第一个匹配的子字符串

- 参数 : str 原始字符串
- 参数 : searchStr 要查找的子字符串
- 参数 : replacedStr 用于替换的字符串
- 返回 : 替换后的字符串
- 版本 : 1.0.0


### replaceFirst(str, searchStr, replacedStr, ignoreCase)

> 替换字符串中第一个匹配的子字符串，可选择是否忽略大小写

- 参数 : str 原始字符串
- 参数 : searchStr 要查找的子字符串
- 参数 : replacedStr 用于替换的字符串
- 参数 : ignoreCase 是否忽略大小写
- 返回 : 替换后的字符串
- 版本 : 1.0.0


### hide(str, startInclude, endExclude)

> 隐藏指定范围内的字符

- 参数 : str 原始字符串
- 参数 : startInclude 开始索引（包含）
- 参数 : endExclude 结束索引（不包含）
- 返回 : 隐藏后的字符串
- 版本 : 1.0.0


### replaceChars(str, chars, replacedStr)

> 替换字符串中指定字符集合中的字符

- 参数 : str 原始字符串
- 参数 : chars 要替换的字符集合（字符串形式）
- 参数 : replacedStr 用于替换的字符串
- 返回 : 替换后的字符串
- 版本 : 1.0.0


### length(cs)

> 获取字符串的长度

- 参数 : cs 字符串
- 返回 : 字符串的长度，如果字符串为 null 则返回 0
- 版本 : 1.0.0


### totalLength(strs)

> 获取多个字符串的总长度

- 参数 : strs 字符串数组
- 返回 : 所有字符串的总长度，如果数组为 null 则返回 0
- 版本 : 1.0.0


### maxLength(string, length)

> 如果字符串长度超过指定长度，截取到指定长度

- 参数 : string 原始字符串
- 参数 : length 最大长度
- 返回 : 截取后的字符串
- 版本 : 1.0.0


### upperFirstAndAddPre(str, preString)

> 将字符串首字母大写并添加前缀

- 参数 : str 原始字符串
- 参数 : preString 要添加的前缀
- 返回 : 处理后的字符串
- 版本 : 1.0.0


### upperFirst(str)

> 将字符串首字母大写

- 参数 : str 原始字符串
- 返回 : 首字母大写后的字符串
- 版本 : 1.0.0


### lowerFirst(str)

> 将字符串首字母小写

- 参数 : str 原始字符串
- 返回 : 首字母小写后的字符串
- 版本 : 1.0.0


### isUpperCase(str)

> 判断字符串是否全部为大写

- 参数 : str 要判断的字符串
- 返回 : 如果字符串全部为大写则返回 true，否则返回 false
- 版本 : 1.0.0


### isLowerCase(str)

> 判断字符串是否全部为小写

- 参数 : str 要判断的字符串
- 返回 : 如果字符串全部为小写则返回 true，否则返回 false
- 版本 : 1.0.0


### swapCase(str)

> 反转字符串的大小写

- 参数 : str 原始字符串
- 返回 : 大小写反转后的字符串
- 版本 : 1.0.0


### toString(obj)

> 将对象转换为字符串

- 参数 : obj 要转换的对象
- 返回 : 对象的字符串表示，如果对象为 null，则返回 "null"
- 版本 : 1.0.0


### toStringOrNull(obj)

> 将对象转换为字符串，如果对象为 null 则返回 null

- 参数 : obj 要转换的对象
- 返回 : 对象的字符串表示，如果对象为 null，则返回 null
- 版本 : 1.0.0


### toStringOrEmpty(obj)

> 将对象转换为字符串，如果对象为 null 则返回空字符串

- 参数 : obj 要转换的对象
- 返回 : 对象的字符串表示，如果对象为 null，则返回空字符串
- 版本 : 1.0.0


### builder()

> 创建一个默认容量的 StringBuilder 对象

- 返回 : 一个默认容量的 StringBuilder 对象
- 版本 : 1.0.0


### builder(capacity)

> 创建一个指定容量的 StringBuilder 对象

- 参数 : capacity 指定的容量
- 返回 : 一个指定容量的 StringBuilder 对象
- 版本 : 1.0.0


### reverse(str)

> 反转字符串

- 参数 : str 要反转的字符串
- 返回 : 反转后的字符串，如果输入为 null 则返回 null
- 版本 : 1.0.0


### similar(str1, str2)

> 计算两个字符串的相似度，返回相似度比例（0.0 - 1.0）

- 参数 : str1 第一个字符串
- 参数 : str2 第二个字符串
- 返回 : 相似度比例
- 版本 : 1.0.0


### similar(str1, str2, scale)

> 计算两个字符串的相似度，返回相似度比例（0.0 - 1.0），并根据 scale 进行四舍五入

- 参数 : str1 第一个字符串
- 参数 : str2 第二个字符串
- 参数 : scale 小数位数
- 返回 : 四舍五入后的相似度比例
- 版本 : 1.0.0


### uuid()

> 生成一个 UUID 字符串

- 返回 : UUID 字符串
- 版本 : 1.0.0


### split(str, separator, limit, isTrim, ignoreEmpty)

> 按照指定分隔符分割字符串序列，可设置分割次数限制、是否去除前后空格、是否忽略空字符串

- 参数 : str 要分割的字符序列
- 参数 : separator 分隔符
- 参数 : limit 分割次数限制，小于等于 0 表示无限制
- 参数 : isTrim 是否去除分割后的子字符串前后空格
- 参数 : ignoreEmpty 是否忽略空字符串
- 返回 : 分割后的字符串列表
- 版本 : 1.0.0


### split(str, len)

> 按照指定长度分割字符序列

- 参数 : str 要分割的字符序列
- 参数 : len 分割的长度
- 返回 : 分割后的字符串数组
- 版本 : 1.0.0


### split(str, separator)


### cut(str, partLength)

> 按照指定长度切割字符序列

- 参数 : str 要切割的字符序列
- 参数 : partLength 切割的长度
- 返回 : 切割后的字符串数组
- 版本 : 1.0.0


### sub(str, fromIndexInclude, toIndexExclude)

> 截取字符序列中指定范围的子字符串

- 参数 : str 要截取的字符序列
- 参数 : fromIndexInclude 起始位置（包含）
- 参数 : toIndexExclude 结束位置（不包含）
- 返回 : 截取的子字符串
- 版本 : 1.0.0


### subPreGbk(str, len, suffix)

> 截取字符序列中指定长度的子字符串（按 GBK 编码），可添加后缀

- 参数 : str 要截取的字符序列
- 参数 : len 截取的长度
- 参数 : suffix 截取后的后缀
- 返回 : 截取的子字符串
- 版本 : 1.0.0


### subPreGbk(str, len, halfUp)

> 截取字符序列中指定长度的子字符串（按 GBK 编码），可选择是否四舍五入

- 参数 : str 要截取的字符序列
- 参数 : len 截取的长度
- 参数 : halfUp 是否四舍五入
- 返回 : 截取的子字符串
- 版本 : 1.0.0


### subPre(string, toIndexExclude)

> 截取字符序列中从开头到指定位置（不包含）的子字符串

- 参数 : string 要截取的字符序列
- 参数 : toIndexExclude 结束位置（不包含）
- 返回 : 截取的子字符串
- 版本 : 1.0.0


### subSuf(string, fromIndex)

> 截取字符序列中从指定位置到结尾的子字符串

- 参数 : string 要截取的字符序列
- 参数 : fromIndex 起始位置
- 返回 : 截取的子字符串
- 版本 : 1.0.0


### subSufByLength(string, length)

> 截取字符序列中从结尾开始指定长度的子字符串

- 参数 : string 要截取的字符序列
- 参数 : length 截取的长度
- 返回 : 截取的子字符串
- 版本 : 1.0.0


### subWithLength(input, fromIndex, length)

> 截取字符串中从指定位置开始指定长度的子字符串

- 参数 : input 要截取的字符串
- 参数 : fromIndex 起始位置
- 参数 : length 截取的长度
- 返回 : 截取的子字符串
- 版本 : 1.0.0


### subBefore(string, separator, isLastSeparator)

> 截取之前字符串

- 参数 : string 要截取的字符序列 
- 参数 : separator 分隔符 
- 参数 : isLastSeparator 是否使用最后一个分隔符 
- 返回 : 截取的子字符串
- 版本 : 1.0.0


### subAfter(string, separator, isLastSeparator)

> 截取之后字符串

- 参数 : string 要截取的字符序列 
- 参数 : separator 分隔符 
- 参数 : isLastSeparator 是否使用最后一个分隔符  
- 返回 : 截取的子字符串
- 版本 : 1.0.0


### subBetween(str, before, after)

> 截取字符序列中两个指定分隔符之间的子字符串

- 参数 : str 要截取的字符序列
- 参数 : before 前分隔符
- 参数 : after 后分隔符
- 返回 : 截取的子字符串
- 版本 : 1.0.0


### subBetween(str, beforeAndAfter)

> 截取字符序列中指定分隔符之间的子字符串（前后分隔符相同）

- 参数 : str 要截取的字符序列
- 参数 : beforeAndAfter 前后分隔符
- 返回 : 截取的子字符串
- 版本 : 1.0.0


### subBetweenAll(str, prefix, suffix)

> 从给定的字符序列中提取所有位于指定前缀和后缀之间的子字符串

- 参数 : str 要进行搜索的字符序列，不能为 null
- 参数 : prefix 作为子字符串起始标记的字符序列，不能为 null
- 参数 : suffix 作为子字符串结束标记的字符序列，不能为 null
- 返回 : 包含所有找到的子字符串的数组，如果没有找到则返回空数组
- 版本 : 1.0.0


### subBetweenAll(str, prefixAndSuffix)

> 从给定的字符序列中提取所有位于指定前缀和后缀（前缀和后缀相同）之间的子字符串

- 参数 : str 要进行搜索的字符序列，不能为 null
- 参数 : prefixAndSuffix 作为子字符串起始和结束标记的字符序列，不能为 null
- 返回 : 包含所有找到的子字符串的数组，如果没有找到则返回空数组
- 版本 : 1.0.0


# $sys - 系统工具

- 更新时间:2025-12-13 11:58:47

> 系统工具




### 飞行模式(是否开启)

> 设置飞行模式
> 
> 如果无法修改系统达到设置飞行模式的目的，那么就要求用户手动设置飞行模式

- 参数 : 是否开启 {布尔值} 是否开启飞行模式(是:开启,否:关闭)
- 版本 : 1.7.0


```javascript
//设置飞行模式
$系统.飞行模式(是);
```


### 音量(类型, 音量)

> 设置媒体音量
> 
> 可以选则的类型：系统、铃声、音乐、闹钟、通知、电话、dtmf、无障碍

- 参数 : 类型 {字符串} 音量模式(系统|铃声|音乐|闹钟|通知|电话|dtmf|无障碍)
- 参数 : 音量 {整数} 音量大小
- 版本 : 1.7.0


```javascript
//设置音量大小
$系统.音量("系统",100);//系统
$系统.音量("铃声",100);//铃声
$系统.音量("音乐",100);//媒体
$系统.音量("闹钟",100);//闹钟
$系统.音量("通知",100);//通知
$系统.音量("电话",100);//电话
$系统.音量("dtmf",100);//双音多频(信号的音量流)
$系统.音量("无障碍",100);//无障碍
toast("音量已全部加满！");
```


### 获取设备标识()

> 获得唯一标识

- 返回 : {字符串} 设备唯一标识
- 版本 : 1.7.0


```javascript
定义 标识 = $系统.获取设备标识();
提示("设备标识",标识);
```


### 有剪切板()

> 判断剪切板是否有内容

- 返回 : {布尔值} 是否存在剪切板
- 版本 : 1.7.0


```javascript
//判断是否有内容
如果($系统.有剪切板()){
    //获得内容
    定义 内容 = $系统.获取剪切板();
    提示("内容",内容);
}
```


### 清空剪切板()

> 清除剪切板内容

- 返回 : {布尔值} 是否清除成功
- 版本 : 1.7.0


```javascript
$系统.清空剪切板();
```


### 获取剪切板()

> 获得剪切板文字

- 返回 : {字符串} 剪切板的文字
- 版本 : 1.7.0


```javascript
//获得内容
定义 内容 = $系统.获取剪切板();
提示("剪切板内容",内容);
```


### 设置剪切板(文本)

> 设置剪切板

- 参数 : 文本 {字符串} 需要添加的文字
- 返回 : {字符串} 获得文字
- 版本 : 1.7.0


```javascript
//设置剪切板
$系统.设置剪切板("Hello AIGame !");
```


### 忽略电池优化(包名)

> 是否忽略电池优化
> 
> 该功能只能在部分低版本安卓系统上才可使用

- 参数 : 包名 {字符串} 包名
- 返回 : {布尔值} 是否成功
- 版本 : 1.7.0


```javascript
//是否忽略电池优化
定义 是否忽略 = $系统.忽略电池优化("org.aigame.app");
提示("是否忽略电池优化",是否忽略);
```


### 请求电池优化(包名)

> 请求忽略电池优化
> 
> 该功能只能在部分低版本安卓系统上才可使用

- 参数 : 包名 {字符串} 包名
- 版本 : 1.7.0


```javascript
//请求忽略电池优化
$系统.请求电池优化("org.aigame.app");
```


### 保活(是否开启)

> 开启前台保活服务

- 参数 : 是否开启 {布尔值} 是否开启
- 版本 : 1.7.0


```javascript
//开启前台保活服务
$系统.保活(是);
//关闭前台保活服务
$系统.保活(否);
```


### 有保活()

> 是否开启前台保活服务

- 返回 : {布尔值} 是否开启
- 版本 : 1.7.0


```javascript
//是否开启前台保活服务
定义 是否有保活 = $系统.有保活();
提示("是否开启前台保活服务",是否有保活);
```


### 有指针()

> 判断是否开启指针
> 
> 判断是否开启开发者调试的指针位置显示

- 返回 : {布尔值} 是否开启
- 版本 : 1.7.0


```javascript
如果($系统.有指针()){
    //已经开启了开发者指针
    提示("指针状态","指针已开启");
}
```


### 指针(是否开启)

> 开发者指针授权
> 
> 需要root或者shizuku权限才能开启指针

- 参数 : 是否开启 {布尔值} 是否开启
- 版本 : 1.7.0


```javascript
//授权开启开发者指针
$系统.指针(是);
//等待一秒后再判断指针是否可用(指针授权并非是立马生效的)
睡觉(1000);
//判断指针是否可用
如果($系统.有指针()){
    //指针已开启
    提示("指针授权","指针已开启");
}
```


# $szk - Shizuku工具

- 更新时间:2025-12-13 11:58:46

> Shizuku工具
> 
> 这是一种不需要root就能享受到root同等级权限的工具




### 获取权限()

> 获取Shizuku权限
> 
> 如果Shizuku权限已经获取，那么就判断是否链接上服务，如果服务没有链接则尝试连接服务
> 

- 版本 : 1.7.0


```javascript
$始祖库.获取权限();
```


### 有权限()

> 是否可用
> 
> 1.判断Shizuku是否授权
> 
> 2.判断Shizuku服务是否可用
> 
> 3.如果Shizuku可用,则判断是否获取到了服务实例
> 
> 4.如果没有获取服务实例,则会尝试重连服务(重连服务成功就会创建服务实例)
> 

- 返回 : {布尔值} 判断Shizuku是否获取权限并且可用
- 版本 : 1.7.0


```javascript
如果($始祖库.有权限()){
    日志("Shizuku权限已获取");
}
```


### 启用指针(是否启用)

> 启用指针
> 
> 打开或者关闭开发者调试的指针位置选项

- 参数 : 是否启用 {布尔值} 是否启用
- 版本 : 1.7.0


```javascript
//打开指针位置显示
$始祖库.启用指针(是);
```


### 等待权限()

> 等待Shizuku权限
> 
> 此函数是个阻塞同步方法,只有当本函数执行完毕后,下面的方法才会执行
> 
> 如果shizuku没有安装或者不可用会直接返回false,否则就会循环等待shizuku权限,直到shizuku权限获取成功
> 
> 但是这个函数不能作为获取权限来使用，它不会获取shizuku权限，所以你需要调用getPermit()成功获取权限后再调用此方法，
> 设计这个方法是因为:shizuku权限获取后,并不是立马就能执行命令了，而是需要等待一段时间，而这个函数就是用来衔接这段等待时间的。

- 返回 : {布尔值} 等待shizuku权限成功返回true,否则返回false
- 版本 : 1.7.0


### 等待权限(等待回调)

> 等待Shizuku权限
> 
> 此函数是个异步方法,放在后台等待shizuku权限,如果获取成功就执行回调

- 参数 : 等待回调 ((是否成功)=>{}) 执行回调,参数是授权是否成功
- 版本 : 1.7.0


### 点击(x, y)

> 点击
> 

- 参数 : x {整数} 点击位置x
- 参数 : y {整数} 点击位置y
- 版本 : 1.7.0


```javascript
//点击手势(长按)(时长一秒)
$始祖库.点击(500,800);
```


### 点击(x, y, 持续时长)

> 点击
> 

- 参数 : x {整数} 点击位置x
- 参数 : y {整数} 点击位置y
- 参数 : 持续时长 {整数} 点击持续时长
- 版本 : 1.7.0


```javascript
//点击手势(长按)(时长一秒)
$始祖库.点击(500,800,1000);
```


### 点击(x, y, 持续时长, 延迟)

> 点击
> 

- 参数 : x {整数} 点击位置x
- 参数 : y {整数} 点击位置y
- 参数 : 持续时长 {整数} 点击持续时长
- 参数 : 延迟 {整数} 点击前延迟
- 版本 : 1.7.0


```javascript
//点击手势(长按)(时长一秒)
$始祖库.点击(500,800,1000,100);
```


### 点击(位置)

> 点击
> 

- 参数 : 位置 {int[]} 点击位置
- 版本 : 1.7.0


```javascript
//点击
$始祖库.点击([500,800]);
```


### 点击(位置, 持续时长)

> 点击
> 

- 参数 : 位置 {int[]} 点击位置
- 参数 : 持续时长 {整数} 点击持续时长
- 版本 : 1.7.0


```javascript
//点击
$始祖库.点击([500,800],50);
```


### 点击(位置, 持续时长, 延迟)

> 点击
> 

- 参数 : 位置 {int[]} 点击位置
- 参数 : 持续时长 {整数} 点击持续时长
- 参数 : 延迟 {整数} 延迟
- 版本 : 1.7.0


```javascript
//点击
$始祖库.点击([500,800],50,2000);
```


### 点击(位置)

> 点击
> 

- 参数 : 位置 {Point} 点击位置
- 版本 : 1.7.0


```javascript
//点击手势(长按)
定义 位置 = 新建 org.opencv.core.Point(500,800);
$始祖库.点击(位置);
```


### 点击(位置, 持续时长)

> 点击
> 

- 参数 : 位置 {Point} 点击位置
- 参数 : 持续时长 {整数} 点击持续时长
- 版本 : 1.7.0


```javascript
//点击手势(长按)(时长一秒)
定义 位置 = 新建 org.opencv.core.Point(500,800);
$始祖库.点击(point,位置);
```


### 点击(位置, 持续时长, 延迟)

> 点击
> 

- 参数 : 位置 {Point} 点击位置
- 参数 : 持续时长 {整数} 点击持续时长
- 参数 : 延迟 {整数} 点击前延迟
- 版本 : 1.7.0


```javascript
//点击手势(长按)(时长一秒)
定义 位置 = 新建 org.opencv.core.Point(500,800);
$始祖库.点击(位置,1000,100);
```


### 长按(x, y)

> 长按
> 

- 参数 : x {整数} 长按位置x
- 参数 : y {整数} 长按位置y
- 版本 : 1.7.0


```javascript
//点击手势(长按)(时长一秒)
$始祖库.长按(500,800);
```


### 长按(x, y, 持续时长)

> 长按
> 

- 参数 : x {整数} 长按位置x
- 参数 : y {整数} 长按位置y
- 参数 : 持续时长 {整数} 长按持续时间
- 版本 : 1.7.0


```javascript
//点击手势(长按)(时长一秒)
$始祖库.长按(500,800,1000);
```


### 长按(x, y, 持续时长, 延迟)

> 长按
> 

- 参数 : x {整数} 长按位置x
- 参数 : y {整数} 长按位置y
- 参数 : 持续时长 {整数} 长按持续时间
- 参数 : 延迟 {整数} 长按前延迟
- 版本 : 1.7.0


```javascript
//点击手势(长按)(延迟一秒)
$始祖库.长按(500,800,1500,100);
```


### 滑动(x1, y1, x2, y2)

> 滑动
> 

- 参数 : x1 {整数} 起点x
- 参数 : y1 {整数} 起点y
- 参数 : x2 {整数} 终点x
- 参数 : y2 {整数} 终点y
- 版本 : 1.7.0


```javascript
//滑动手势
$始祖库.滑动(500,0,500,800);
```


### 滑动(x1, y1, x2, y2, 持续时长)

> 滑动
> 

- 参数 : x1 {整数} 起点x
- 参数 : y1 {整数} 起点y
- 参数 : x2 {整数} 终点x
- 参数 : y2 {整数} 终点y
- 参数 : 持续时长 {整数} 时长
- 版本 : 1.7.0


```javascript
//滑动手势
$始祖库.滑动(500,0,500,800,1000);
```


### 滑动(x1, y1, x2, y2, 持续时长, 延迟)

> 滑动
> 

- 参数 : x1 {整数} 起点x
- 参数 : y1 {整数} 起点y
- 参数 : x2 {整数} 终点x
- 参数 : y2 {整数} 终点y
- 参数 : 持续时长 {整数} 时长
- 参数 : 延迟 {整数} 延迟
- 版本 : 1.7.0


```javascript
//滑动手势
$始祖库.滑动(500,0,500,800,1000,2000);
```


### 主页()

> 返回手机主页

- 版本 : 1.7.0


```javascript
$始祖库.主页();
```


### 返回()

> 执行返回按钮

- 版本 : 1.7.0


```javascript
$始祖库.返回();
```


### 菜单()

> 执行菜单按钮

- 版本 : 1.7.0


```javascript
$始祖库.菜单();
```


### 最近任务()

> 打开最近任务列表
> 
> 效果和'菜单()'一样

- 版本 : 1.7.0


```javascript
$始祖库.最近任务();
```


### 电源键()

> 执行关机键

- 版本 : 1.7.0


```javascript
$始祖库.电源键();
```


### 锁屏()

> 锁屏

- 版本 : 1.7.0


```javascript
$始祖库.锁屏();
```


### 解锁()

> 唤醒屏幕

- 版本 : 1.7.0


```javascript
$始祖库.解锁();
```


### 输入(文本)

> 输入文本

- 参数 : 文本 {字符串} 文本内容
- 版本 : 1.7.0


```javascript
$始祖库.输入("我是文本");
```


### 杀死应用(包名)

> 杀死应用

- 参数 : 包名 {字符串} 包名
- 版本 : 1.7.0


```javascript
$始祖库.杀死应用("包名");
```


### 设置分辨率(宽度, 高度)

> 设置手机分辨率

- 参数 : 宽度 {整数} 宽度 
- 参数 : 高度 {整数} 高度 


```javascript
$始祖库.设置分辨率(1080,2200);
```


### 设置密度因子(密度因子)

> 设置手机DPI

- 参数 : 密度因子 {整数} 密度因子 
- 版本 : 1.7.0


```javascript
$始祖库.设置密度因子(320);
```


### 重置分辨率()

> 重置手机分辨率与DPI

- 版本 : 1.7.0


```javascript
$始祖库.重置分辨率();
```


### 执行(命令)

> 执行一条命令

- 参数 : 命令 {字符串} 需要执行的命令
- 返回 : {字符串} 执行结果
- 版本 : 1.7.0


```javascript
//等待获取shizuku权限，如果没有权限那么就会一直等待下去
$始祖库.获取权限();
$始祖库.执行("input keyevent KEYCODE_POWER");//点击电源按钮
```


### 执行(命令, 信息回调, 异常回调)

> 执行命令

- 参数 : 命令 {字符串} 命令
- 参数 : 信息回调 {(信息)=>{}} 输出信息回调
- 参数 : 异常回调 {(异常)=>{}} 错误信息回调
- 版本 : 1.7.0


```javascript
//等待获取shizuku权限，如果没有权限那么就会一直等待下去
$始祖库.获取权限();
$始祖库.执行("ls",
    (信息)=> {
        //信息输出回调
        日志(信息);
    },
    (异常)=> {
        //异常输出回调
        $日志.异常(异常);
    }
);
```


### 执行(命令, 信息回调, 异常回调, 结束回调)

> 执行命令

- 参数 : 命令 {字符串} 命令
- 参数 : 信息回调 {(信息)=>{}} 输出信息回调
- 参数 : 异常回调 {(异常)=>{}} 错误信息回调
- 参数 : 结束回调 {(结果)=>{}} 结束执行回调
- 版本 : 1.7.0


```javascript
//等待获取shizuku权限，如果没有权限那么就会一直等待下去
$始祖库.获取权限();
$始祖库.执行("ls",
    (信息)=> {
        //信息输出回调
        日志(信息);
    },
    (异常)=> {
        //异常输出回调
        $日志.异常(异常);
    },
    (结果)=> {
        //结束回调
        日志(结果)
    }
);
```


### 执行(命令, 开始回调, 信息回调, 异常回调, 结束回调)

> 执行命令

- 参数 : 命令 {字符串} 命令
- 参数 : 开始回调 {()=>{}} 开始执行时的回调
- 参数 : 信息回调 {(信息)=>{}} 输出信息回调
- 参数 : 异常回调 {(异常)=>{}} 错误信息回调
- 参数 : 结束回调 {(结果)=>{}} 结束执行回调
- 版本 : 1.7.0


```javascript
//等待获取shizuku权限，如果没有权限那么就会一直等待下去
$始祖库.获取权限();
$始祖库.执行("ls",
    ()=> {
        //开始执行回调
        日志("开始执行");
    },
    (信息)=> {
        //信息输出回调
        日志(信息);
    },
    (异常)=> {
        //异常输出回调
        $日志.异常(异常);
    },
    (结果)=> {
        //结束回调
        日志(结果)
    }
);
```


# CdLock - 倒计时锁

- 更新时间:2025-12-13 11:58:47

> 倒计时锁
> 
> 是对CountDownLatch的封装对象，倒计时锁，用于等待多个线程完成。




### 完成()

> 完成一个倒计时

- 版本 : 1.8.3


### 结束()

> 等待所有倒计时完成

- 版本 : 1.8.3


### 结束(超时时间)

> 等待所有倒计时完成

- 参数 : 超时时间 {长整数} 超时时间(ms)
- 返回 : {布尔} 是否完成
- 版本 : 1.8.3


### 获取数量()

> 获取倒计时数量

- 返回 : {长整数} 倒计时数量
- 版本 : 1.8.3


# Threadx - 增强线程

- 更新时间:2025-12-13 11:58:47

> 增强线程
> 
> 增强线程名为"Threadx"，它继承自"java.lang.Thread"类，提供了额外的功能和属性，主要允许线程携带一些简单的基础数据。




### 名称()

> 获取线程名称

- 返回 : {字符串} 线程名称
- 版本 : 1.7.0


```javascript
//增强线程对象
定义 线程 = $线程.创建(()=>{
    //...
});
//获取线程名称
定义 名字 = 线程.名称();
//输出线程名称
提示("线程名称" , 名字);
```


### 是运行的()

> 判断当前线程是否终止

- 返回 : {布尔值} 是否停止运行
- 版本 : 1.7.0


```javascript
//增强线程对象
定义 线程 = $线程.创建(()=>{
    //...
});
//判断当前线程是否终止
如果(线程.是运行的()){
     提示("线程正在运行");
}否则{
     提示("线程已终止");
}
```


### 设置字符串(str)

> 设置字符类型的标志

- 参数 : str {字符串} 字符类型的标志
- 版本 : 1.7.0


```javascript
//增强线程对象
定义 线程 = $线程.创建(()=>{
    //...
});
//设置字符类型的标志
线程.设置字符串("携带数据");
```


### 获取字符串()

> 获得字符类型的标志

- 返回 : {字符串} 字符类型的标志
- 版本 : 1.7.0


```javascript
//增强线程对象
定义 线程 = $线程.创建(()=>{
    //...
});
//获得字符类型的标志
定义 字符串 = 线程.获取字符串();
```


### 设置布尔(booFlag)

> 设置布尔类型的标志
> 
> 需要注意:当线程(非循环器)被终止时，布尔类型的标志位会被设置为false;

- 参数 : booFlag {布尔值} 布尔类型的标志
- 版本 : 1.7.0


```javascript
//增强线程对象
定义 线程 = $线程.创建(()=>{
    //...
});
//设置布尔类型的标志
线程.设置布尔(否);
```


### 获取布尔()

> 获取布尔类型的标志
> 
> 需要注意:当线程(非循环器)被终止时，布尔类型的标志位会被设置为false;

- 返回 : {布尔值} 布尔类型的标志
- 版本 : 1.7.0


```javascript
//增强线程对象
定义 线程 = $线程.创建(()=>{
    //...
});
//获取布尔类型的标志
定义 布尔值 = 线程.获取布尔();
```


### 获取整数()

> 获取整数类型的标志

- 返回 : {整数} 整数标志值
- 版本 : 1.7.0


```javascript
//增强线程对象
定义 线程 = $线程.创建(()=>{
    //...
});
//获取整数类型的标志
定义 整数 = 线程.获取整数();
```


### 设置整数(flag)

> 设置整数类型的标志

- 参数 : flag {整数} 整数标志值
- 版本 : 1.7.0


```javascript
//增强线程对象
定义 线程 = $线程.创建(()=>{
    //...
});
//设置整数类型的标志
线程.设置整数(0);
```


### 获取长整数()

> 获取长整数类型的标志

- 返回 : {long} 长整数标志值
- 版本 : 1.7.0


```javascript
//增强线程对象
定义 线程 = $线程.创建(()=>{
    //...
});
//获取长整数类型的标志
定义 长整数 = 线程.获取长整数();
```


### 设置长整数(flag)

> 设置长整数类型的标志

- 参数 : flag {long} 长整数标志值
- 版本 : 1.7.0


```javascript
//增强线程对象
定义 线程 = $线程.创建(()=>{
    //...
});
//设置长整数类型的标志
线程.设置长整数(1000);
```


### 获取对象()

> 获取对象类型的标志

- 返回 : {Object} 对象标志值
- 版本 : 1.7.0


```javascript
//增强线程对象
定义 线程 = $线程.创建(()=>{
    //...
});
//获取对象类型的标志
定义 对象数据 = 线程.获取对象();
```


### 设置对象(flag)

> 设置对象类型的标志

- 参数 : flag {Object} 对象标志值
- 版本 : 1.7.0


```javascript
//增强线程对象
定义 线程 = $线程.创建(()=>{
    //...
});
//设置对象类型的标志
线程.设置对象("我是任意数据");
```


### 停止()

> 终止线程

- 版本 : 1.7.0


```javascript
//由于interrupt不太好记，所以就写了个'停止()'方便中止线程。
//使用停止方法中止线程
线程.停止();//等价于:线程.interrupt();
```


# $thread - 并发编程

- 更新时间:2025-12-13 11:58:47

> 并发编程
> 
> 本平台支持多线程并发编程，并且很多API内部都已经解决了并发问题




### 界面(任务回调)

> 在UI线程中执行
> 
> 其实也可以使用$界面.运行(()=>{});在界面线程中执行

- 参数 : 任务回调 {()=>{}} 任务
- 版本 : 1.7.0


```javascript
$线程.界面(()=>{
    //这里是UI线程
});
```


### 运行(任务回调)

> 创建并且运行线程

- 参数 : 任务回调 {()=>{}} 任务
- 返回 : {Threadx} 增强线程
- 版本 : 1.7.0


```javascript
定义 线程 = $线程.运行(()=>{
    //耗时任务
});
//要想停止或者关闭
线程.停止();
```


### 创建(任务回调)

> 创建线程
> 
> 会自动生成线程名称，之后将线程名称和线程对象存储到序列中。

- 参数 : 任务回调 {()=>{}} 线程任务
- 返回 : {Threadx} 增强线程
- 版本 : 1.7.0


```javascript
定义 线程 = $线程.创建(()=> {
    循环 (定义 下标 = 0; 下标 < 10; 下标++) {
        睡觉("300");
        日志(线程.名称()+"==>"+下标);
    }
    日志(线程.名称()+"执行完毕");
});
线程.开始();
```


### 创建(线程名称, 任务回调)

> 创建线程
> 
> 优先去序列中查找是否存在这个线程名称，如果存在，会提示名称重复并且返回已经存在的线程对象(threadx)

- 参数 : 线程名称 {字符串} 线程名称
- 参数 : 任务回调 {()=>{}} 线程任务
- 返回 : {Threadx} 增强线程
- 版本 : 1.7.0


```javascript
定义 线程 = $线程.创建("线程名称",()=> {
    循环 (定义 下标 = 0; 下标 < 10; 下标++) {
        睡觉("300");
        日志(线程.名称()+"==>"+下标);
    }
    日志(线程.名称()+"执行完毕");
});
线程.开始();
```


### 新建倒计时锁(数量)

> 创建一个倒计时锁

- 参数 : 数量 {整数} 倒计时数量
- 返回 : {CdLock} 倒计时锁
- 版本 : 1.8.3


### 有(线程名称)

> 是否存在线程名称

- 参数 : 线程名称 {字符串} 线程名称
- 返回 : {布尔值} 是否存在
- 版本 : 1.7.0


```javascript
定义 有 = $线程.有("线程名称");
如果(有){
    //存在线程名称
}否则{
    //不存在线程名称
}
```


### 获取(线程名称)

> 获得已存在的线程

- 参数 : 线程名称 {字符串} 线程名称
- 版本 : 1.7.0


```javascript
//获得线程对象
定义 线程 = $线程.获取("线程名称");
if(线程!=空){
    //...
}
```


### 循环(循环器名称, 执行回调)

> 创建一个循环执行器

- 参数 : 循环器名称 {字符串} 循环器名称
- 参数 : 执行回调 {()=>{}} 循环体
- 返回 : {Threadx} 增强线程
- 版本 : 1.7.0


```javascript
定义 线程 = $线程.循环("循环1号",()=>{
    睡觉(1000);
    日志("我还活着！");
});
线程.开始();
```


### 有循环(循环器名称)

> 是否存在循环执行器

- 参数 : 循环器名称 {字符串} 循环器名称
- 返回 : {布尔值} 是否存在
- 版本 : 1.7.0


```javascript
//关闭循环器
定义 存在 = $线程.有循环("循环1号");
```


### 停止循环(循环器名称)

> 停止循环执行器

- 参数 : 循环器名称 {字符串} 循环器名称
- 版本 : 1.7.0


```javascript
//关闭循环器
$线程.停止循环("循环1号");
```


### 停止(线程对象)

> 停止指定线程
> 
> 如果停止线程成功,会将增强线程中的布尔标识(设置布尔())设置为false

- 参数 : 线程对象 {Threadx} 增强线程
- 版本 : 1.7.0


### 停止(线程名称)

> 停止指定线程

- 参数 : 线程名称 {字符串} 线程名称
- 版本 : 1.7.0


### 停止所有()

> 停止所有线程

- 版本 : 1.7.0


```javascript
//停止所有线程(不包括循环器线程)
$线程.停止所有();
```


### 停止所有循环()

> 停止所有循环执行器
> 
> 'setInterval'本质上也是通过循环执行器实现的，因此本函数也可以停止'setInterval'的循环执行

- 版本 : 1.7.0


```javascript
//停止所有循环执行器
$线程.停止所有循环();
```


# $alert - 原生对话框

- 更新时间:2025-12-13 11:58:47

> 矩形对话框
> 
> 目前我们的对话框有三种:$tip($提示)、$dialog($对话框)、$alert($提示框)，这三种有哪些特点？
> 
> - $tip($提示):阻塞式对话框，很适合流程脚本，当对话框关闭后，下面的代码才会接着运行
> - $dialog($对话框):非阻塞式对话框，采用M3的风格，缺点就是由于遵循了M3布局规则导致显示的视图范围有限。
> - $alert($提示框):非阻塞式对话框，采用安卓默认实体风格，弥补$dialog显示视图小的缺点，可以通过maxWH(true)显示较大的视图区域。




### 创建()

> 创建一个对话框

- 返回 : {$alert} 对话框对象
- 版本 : 1.7.0


```javascript
//创建一个对话框(注意对象名称不要和全局函数alert相同)
定义 提示框 = $提示框.创建();
```


### 标题(标题)

> 设置对话框标题

- 参数 : 标题 {字符串} 对话框标题
- 返回 : {$alert} 自己
- 版本 : 1.7.0


```javascript
//创建一个对话框(注意对象名称不要和全局函数alert相同)
定义 提示框 = $提示框.创建();
//设置对话框标题
提示框.标题("标题");
```


### 是显示的()

> 检查对话框是否正在显示

- 返回 : {布尔值} 对话框是否正在显示
- 版本 : 1.7.0


```javascript
//创建一个对话框(注意对象名称不要和全局函数alert相同)
定义 提示框 = $提示框.创建();
//是否显示了
日志(提示框.是显示的());//false
```


### 内容(内容)

> 设置对话框消息

- 参数 : 内容 {字符串} 对话框消息
- 返回 : {$alert} 自己
- 版本 : 1.7.0


```javascript
//创建一个对话框(注意对象名称不要和全局函数alert相同)
定义 提示框 = $提示框.创建();
//设置内容
提示框.内容("内容");
```


### 可取消(可取消)

> 设置对话框是否可以取消

- 参数 : 可取消 {布尔值} 是否可以取消
- 返回 : {$alert} 自己
- 版本 : 1.7.0


```javascript
//创建一个对话框(注意对象名称不要和全局函数alert相同)
定义 提示框 = $提示框.创建();
//设置是否可以取消
提示框.可取消(是);
```


### 图标(图标)

> 设置对话框图标

- 参数 : 图标 {字符串} 图标资源路径
- 返回 : {$alert} 自己
- 版本 : 1.7.0


```javascript
//创建一个对话框(注意对象名称不要和全局函数alert相同)
定义 提示框 = $提示框.创建();
//设置对话框图标
提示框.图标("ag_logo");
```


### 视图(视图)

> 设置对话框视图

- 参数 : 视图 {视图} 视图
- 返回 : {$alert} 自己
- 版本 : 1.7.0


```javascript
//解析一个布局
定义 界面 = $界面.解析布局("main.xml");
定义 视图 = 界面.获取视图();//获取视图
//创建一个对话框(注意对象名称不要和全局函数alert相同)
定义 提示框 = $提示框.创建();
//设置对话框视图
提示框.视图(视图);
```


### 视图(视图)

> 设置对话框视图

- 参数 : 视图 {视图} 视图
- 返回 : {$alert} 自己
- 版本 : 1.7.0


```javascript
//解析一个布局
定义 界面 = $界面.解析布局("main.xml");
定义 视图 = 界面.找控件("myView");//获取XView组件视图
//创建一个对话框(注意对象名称不要和全局函数alert相同)
定义 提示框 = $提示框.创建();
//设置对话框视图
提示框.视图(视图);
```


### 最大高度(是否最大)

> 设置最高显示

- 参数 : 是否最大 {布尔值} 是否最宽高显示
- 返回 : {$alert} 自己
- 版本 : 1.7.0


```javascript
//创建一个对话框(注意对象名称不要和全局函数alert相同)
定义 提示框 = $提示框.创建();
//设置最高显示，对话框的高度会显示到最大
提示框.最大高度(是);
```


### 最大宽度(是否最大)

> 设置最宽显示

- 参数 : 是否最大 {布尔值} 是否最宽显示
- 返回 : {$alert} 自己
- 版本 : 1.7.0


```javascript
//创建一个对话框(注意对象名称不要和全局函数alert相同)
定义 提示框 = $提示框.创建();
//设置最宽显示，对话框的宽度会显示到最大
提示框.最大宽度(是);
```


### 最大宽高(是否最大)

> 设置最大宽高显示

- 参数 : 是否最大 {xview} 是否最大宽高显示
- 返回 : {$alert} 自己
- 版本 : 1.7.0


```javascript
//创建一个对话框(注意对象名称不要和全局函数alert相同)
定义 提示框 = $提示框.创建();
//设置最宽高显示，对话框的宽高会显示到最大
提示框.最大宽高(是);
```


### 按钮1(文本)

> 设置对话框第一个按钮

- 参数 : 文本 {字符串} 按钮文本
- 返回 : {$alert} 自己
- 版本 : 1.7.0


```javascript
//创建一个对话框(注意对象名称不要和全局函数alert相同)
定义 提示框 = $提示框.创建();
//设置按钮
提示框.按钮1("按钮1");
```


### 按钮1(文本, 回调)

> 设置对话框第一个按钮
> 
> 回调参数：di:{DialogInterface} 接收到点击的对话框 which:{整数}被点击的按钮位置

- 参数 : 文本 {字符串} 按钮文本
- 参数 : 回调 {(di,which)=>{}} 回调函数
- 返回 : {$alert} 自己
- 版本 : 1.7.0


```javascript
//创建一个对话框(注意对象名称不要和全局函数alert相同)
定义 提示框 = $提示框.创建();
//设置按钮
提示框.按钮1("按钮1",(di,which)=>{
    //点击事件
});
```


### 按钮2(文本)

> 设置对话框第二个按钮

- 参数 : 文本 {字符串} 按钮文本
- 返回 : {$alert} 自己
- 版本 : 1.7.0


```javascript
//创建一个对话框(注意对象名称不要和全局函数alert相同)
定义 提示框 = $提示框.创建();
//设置按钮
提示框.按钮2("按钮2");
```


### 按钮2(文本, 回调)

> 设置对话框第二个按钮
> 
> 回调参数：di:{DialogInterface} 接收到点击的对话框 which:{整数}被点击的按钮位置

- 参数 : 文本 {字符串} 按钮文本
- 参数 : 回调 {(di,which)=>{}} 回调函数
- 返回 : {$alert} 自己
- 版本 : 1.7.0


```javascript
//创建一个对话框(注意对象名称不要和全局函数alert相同)
定义 提示框 = $提示框.创建();
//设置按钮
提示框.按钮2("按钮2",(di,which)=>{
    //点击事件
});
```


### 按钮3(文本)

> 设置对话框第三个按钮

- 参数 : 文本 {字符串} 按钮文本
- 返回 : {$alert} 自己
- 版本 : 1.7.0


```javascript
//创建一个对话框(注意对象名称不要和全局函数alert相同)
定义 提示框 = $提示框.创建();
//设置按钮
提示框.按钮3("按钮3");
```


### 按钮3(文本, 回调)

> 设置对话框第三个按钮
> 
> 回调参数：di:{DialogInterface} 接收到点击的对话框 which:{整数}被点击的按钮位置

- 参数 : 文本 {字符串} 按钮文本
- 参数 : 回调 {(di,which)=>{}} 回调函数
- 返回 : {$alert} 自己
- 版本 : 1.7.0


```javascript
//创建一个对话框(注意对象名称不要和全局函数alert相同)
定义 提示框 = $提示框.创建();
//设置按钮
提示框.按钮3("按钮3",(di,which)=>{
    //点击事件
});
```


### 选项(选项, 回调)

> 设置对话框选项
> 
> 回调参数：di:{DialogInterface} 接收到点击的对话框 which:{整数}被点击的按钮位置

- 参数 : 选项 {字符串数组[]} 选项数组
- 参数 : 回调 {(di,which)=>{}} 回调函数
- 返回 : {$alert} 自己
- 版本 : 1.7.0


```javascript
//创建一个对话框(注意对象名称不要和全局函数alert相同)
定义 提示框 = $提示框.创建();
//设置对话框选项
提示框.选项(["选项1","选项2","选项3"],(di,which)=>{
    //点击事件
});
```


### 单选(选项, 选中的下标, 回调)

> 设置对话框单选选项
> 
> 回调参数：di:{DialogInterface} 接收到点击的对话框 which:{整数}被点击的按钮位置

- 参数 : 选项 {字符串数组[]} 选项数组
- 参数 : 选中的下标 {整数} 选中的选项位置
- 参数 : 回调 {(di,which)=>{}} 回调函数
- 返回 : {$alert} 自己
- 版本 : 1.7.0


```javascript
//创建一个对话框(注意对象名称不要和全局函数alert相同)
定义 提示框 = $提示框.创建();
//设置对话框选项
提示框.单选(["选项1","选项2","选项3"],0,(di,which)=>{
    //点击事件
});
```


### 多选(选项, 回调)

> 设置对话框多选选项
> 
> 回调参数：di:{DialogInterface} 接收到点击的对话框 which:{整数}被点击的按钮位置 isChecked:{布尔值} 是否被选中

- 参数 : 选项 {字符串数组[]} 选项数组
- 参数 : 回调 {(di,which,isChecked)=>{}} 回调函数
- 返回 : {$alert} 自己
- 版本 : 1.7.0


```javascript
//创建一个对话框(注意对象名称不要和全局函数alert相同)
定义 提示框 = $提示框.创建();
//设置对话框选项
提示框.多选(["选项1","选项2","选项3"],(di,which,isChecked)=>{
    //点击事件
});
```


### 多选(选项, 选中状态, 回调)

> 设置对话框多选选项
> 
> 回调参数：di:{DialogInterface} 接收到点击的对话框 which:{整数}被点击的按钮位置 isChecked:{布尔值} 是否被选中

- 参数 : 选项 {字符串数组[]} 选项数组
- 参数 : 选中状态 {boolean[]} 选中的选项数组
- 参数 : 回调 {(di,which,isChecked)=>{}} 回调函数
- 返回 : {$alert} 自己
- 版本 : 1.7.0


```javascript
//创建一个对话框(注意对象名称不要和全局函数alert相同)
定义 提示框 = $提示框.创建();
//设置对话框选项
提示框.多选(["选项1","选项2","选项3"],[false,false,true],(di,which,isChecked)=>{
    //点击事件
});
```


### 显示()

> 显示对话框

- 返回 : {AlertDialog} 对话框对象
- 版本 : 1.7.0


```javascript
$提示框.创建()
.标题("标题")
.内容("我是信息")
.按钮3("确定",()=>{
    日志("我被点击了");
})
.显示();//显示对话框
```


### 显示之前(回调)

> 对话框显示前回调
> 
> 需要注意的是:该回调是放在UI线程中执行的

- 参数 : 回调 {()=>{}} 回调函数 
- 返回 : {$alert} 自己
- 版本 : 1.7.0


```javascript
$提示框.创建()
.标题("标题")
.内容("我是信息")
.按钮3("确定",()=>{
    日志("我被点击了");
})
.显示之前(()=>{
    日志("准备显示对话框啦");
})
.显示();//显示对话框
```


### 显示之后(回调)

> 对话框显示后回调
> 
> 需要注意的是:该回调是放在UI线程中执行的

- 参数 : 回调 {()=>{}} 回调函数 
- 返回 : {$alert} 自己
- 版本 : 1.7.0


```javascript
//在自定义view中，如果有界面元素需要刷新，那么就最好在alert显示之后再操作
//例如:
定义 界面 = $界面.解析布局("界面.xml");//解析一个视图
定义 提示框 = $提示框.创建();//创建一个对话框
提示框.显示之后(()=>{
    //如果自定义视图中存在需要操作的ui元素，可以放到这里操作
    定义 关闭按钮 = 界面.找控件("关闭按钮");
    关闭按钮.点击事件(()=>{
        提示框.关闭();//关闭对话框
    });
}).视图(界面.获取视图()).显示();//显示自定义视图
```


### 监听关闭(回调)

> 监听对话框关闭

- 参数 : 回调 {()=>{}} 提示框关闭后回调
- 版本 : 1.8.0


```javascript
定义 提示框 = $提示框.创建()
.标题("标题")
.内容("我是信息")
.按钮3("关闭",()=>{
    //这里关闭提示框
    提示框.关闭();
})
.监听关闭(()=>{
    日志("对话框被关闭了");
})
.显示();//显示对话框
```


### 关闭()

> 关闭对话框

- 版本 : 1.7.0


```javascript
定义 提示框 = $提示框.创建()
.标题("标题")
.内容("我是信息")
.按钮3("关闭",()=>{
    //这里关闭对话框
    提示框.关闭();
})
.显示();//显示对话框
```


# $dialog - M3对话框

- 更新时间:2025-12-13 11:58:47

> M3对话框
> 
> 与$alert($提示框)不同，$dialog($对话框)是一个Material Design 3风格的对话框。




### 创建()

> 创建一个对话框

- 返回 : {$dialog} 对话框对象


```javascript
// 创建一个对话框
定义 对话框 = $对话框.创建()
```


### 标题(标题)

> 设置对话框标题

- 参数 : 标题 {字符串} 对话框标题
- 返回 : {$dialog} 自己


```javascript
// 创建一个对话框
定义 对话框 = $对话框.创建()
// 设置对话框标题
对话框.标题("标题")
```


### 是显示的()

> 检查对话框是否正在显示

- 返回 : {布尔值} 对话框是否正在显示


```javascript
// 创建一个对话框
定义 对话框 = $对话框.创建()
// 设置对话框标题
if(对话框.是显示的()){
    日志("对话框正再显示");
}
```


### 内容(内容)

> 设置对话框消息

- 参数 : 内容 {字符串} 对话框消息
- 返回 : {$dialog} 自己


```javascript
// 创建一个对话框
定义 对话框 = $对话框.创建()
// 设置对话框消息
对话框.内容("内容");
```


### 可取消(可取消)

> 设置对话框是否可以取消

- 参数 : 可取消 {布尔值} 是否可以取消
- 返回 : {$dialog} 自己


```javascript
// 创建一个对话框
定义 对话框 = $对话框.创建()
// 设置对话框是否可以取消
对话框.可取消(是);
```


### 图标(图标)

> 设置对话框图标

- 参数 : 图标 {字符串} 图标资源路径
- 返回 : {$dialog} 自己


```javascript
// 创建一个对话框
定义 对话框 = $对话框.创建()
// 设置对话框图标
对话框.图标("ag_logo);
```


### 视图(视图)

> 设置对话框视图

- 参数 : 视图 {视图} 视图
- 返回 : {$dialog} 自己


```javascript
//解析一个布局
定义 界面 = $界面.解析界面("main.xml");
定义 视图 = 界面.获取视图();//获取视图
//创建一个对话框
定义 对话框 = $对话框.创建()
//设置对话框视图
对话框.视图(视图);
```


### 视图(视图)

> 设置对话框视图

- 参数 : 视图 {视图} 视图
- 返回 : {$dialog} 自己


```javascript
//解析一个布局
定义 界面 = $界面.解析界面("main.xml");
定义 视图 = 界面.找控件("myView");//获取XView对象
//创建一个对话框
定义 对话框 = $对话框.创建()
//设置对话框视图
对话框.视图(视图);
```


### 按钮1(文本)

> 设置对话框第一个按钮

- 参数 : 文本 {字符串} 按钮文本
- 返回 : {$dialog} 自己


```javascript
//创建一个对话框
定义 对话框 = $对话框.创建()
//设置按钮
对话框.按钮1("按钮1");
```


### 按钮1(文本, 回调)

> 设置对话框第一个按钮
> 
> 回调参数：di:{DialogInterface} 接收到点击的对话框 which:{整数}被点击的按钮位置

- 参数 : 文本 {字符串} 按钮文本
- 参数 : 回调 {(di,which)=>{}} 回调函数
- 返回 : {$dialog} 自己


```javascript
//创建一个对话框
定义 对话框 = $对话框.创建()
//设置按钮
对话框.按钮1("按钮1",(di,which)=>{
    日志("我被点击了");
});
```


### 按钮2(文本)

> 设置对话框第二个按钮

- 参数 : 文本 {字符串} 按钮文本
- 返回 : {$dialog} 自己


```javascript
//创建一个对话框
定义 对话框 = $对话框.创建()
//设置按钮
对话框.按钮2("按钮2");
```


### 按钮2(文本, 回调)

> 设置对话框第二个按钮
> 
> 回调参数：di:{DialogInterface} 接收到点击的对话框 which:{整数}被点击的按钮位置

- 参数 : 文本 {字符串} 按钮文本
- 参数 : 回调 {(di,which)=>{}} 回调函数
- 返回 : {$dialog} 自己


```javascript
//创建一个对话框
定义 对话框 = $对话框.创建()
//设置按钮
对话框.按钮2("按钮2",(di,which)=>{
    日志("我被点击了");
});
```


### 按钮3(文本)

> 设置对话框第三个按钮

- 参数 : 文本 {字符串} 按钮文本
- 返回 : {$dialog} 自己


```javascript
//创建一个对话框
定义 对话框 = $对话框.创建()
//设置按钮
对话框.按钮3("按钮3");
```


### 按钮3(文本, 回调)

> 设置对话框第三个按钮
> 
> 回调参数：di:{DialogInterface} 接收到点击的对话框 which:{整数}被点击的按钮位置

- 参数 : 文本 {字符串} 按钮文本
- 参数 : 回调 {(di,which)=>{}} 回调函数
- 返回 : {$dialog} 自己


```javascript
//创建一个对话框
定义 对话框 = $对话框.创建()
//设置按钮
对话框.按钮3("按钮3",(di,which)=>{
    日志("我被点击了");
});
```


### 选项(选项, 回调)

> 设置对话框选项
> 
> 回调参数：di:{DialogInterface} 接收到点击的对话框 which:{整数}被点击的按钮位置

- 参数 : 选项 {字符串数组[]} 选项数组
- 参数 : 回调 {(di,which)=>{}} 回调函数
- 返回 : {$dialog} 自己


```javascript
//创建一个对话框
定义 对话框 = $对话框.创建()
.选项(["选项1","选项2","选项3"],(di,which)=>{
    日志("我被点击了");
})
.显示();
```


### 单选(选项, 选中位置, 回调)

> 设置对话框单选选项
> 
> 回调参数：di:{DialogInterface} 接收到点击的对话框 which:{整数}被点击的按钮位置

- 参数 : 选项 {字符串数组[]} 选项数组
- 参数 : 选中位置 {整数} 选中的选项位置
- 参数 : 回调 {(di,which)=>{}} 回调函数
- 返回 : {$dialog} 自己


```javascript
//创建一个对话框
定义 对话框 = $对话框.创建()
.单选(["选项1","选项2","选项3"],0,(di,which)=>{
    日志("我被点击了");
})
.显示();
```


### 多选(选项, 回调)

> 设置对话框多选选项
> 
> 回调参数：di:{DialogInterface} 接收到点击的对话框 which:{整数}被点击的按钮位置 isChecked:{布尔值} 是否被选中

- 参数 : 选项 {字符串数组[]} 选项数组
- 参数 : 回调 {(di,which,isChecked)=>{}} 回调函数
- 返回 : {$dialog} 自己


```javascript
//创建一个对话框
定义 对话框 = $对话框.创建()
.多选(["选项1","选项2","选项3"],(di,which)=>{
    日志("我被点击了");
})
.显示();
```


### 多选(选项, 选中项, 回调)

> 设置对话框多选选项
> 
> 回调参数：di:{DialogInterface} 接收到点击的对话框 which:{整数}被点击的按钮位置 isChecked:{布尔值} 是否被选中

- 参数 : 选项 {字符串数组[]} 选项数组
- 参数 : 选中项 {boolean[]} 选中的选项数组
- 参数 : 回调 {(di,which,isChecked)=>{}} 回调函数
- 返回 : {$dialog} 自己


```javascript
//创建一个对话框
定义 对话框 = $对话框.创建()
.多选(["选项1","选项2","选项3"],[false,true,false],(di,which,isChecked)=>{
    日志("我被点击了");
})
.显示();
```


### 显示()

> 显示对话框

- 返回 : {AlertDialog} 对话框对象


```javascript
//创建一个对话框
定义 对话框 = $对话框.创建()
.标题("提示")
.内容("我是一个对话框")
.显示();//显示对话框
```


### 显示之前(回调)

> 对话框显示前回调
> 
> 需要注意的是:该回调是放在UI线程中执行的

- 参数 : 回调 {()=>{}} 回调函数 
- 返回 : {$dialog} 自己
- 版本 : 1.7.0


```javascript
//创建一个对话框
定义 对话框 = $对话框.创建()
.标题("提示")
.内容("我是一个对话框")
.显示之前(()=>{
    日志("对话框显示前回调");
})
.显示();//显示对话框
```


### 显示之后(回调)

> 对话框显示后回调
> 
> 需要注意的是:该回调是放在UI线程中执行的

- 参数 : 回调 {()=>{}} 回调函数 
- 返回 : {$dialog} 自己
- 版本 : 1.7.0


```javascript
//在自定义view中，如果有界面元素需要刷新，那么就最好在dialog显示之后再操作
//例如:
定义 界面 = $界面.解析界面("界面.xml");//解析一个视图
定义 对话框 = $对话框.创建();//创建一个对话框
对话框.显示之后(()=>{
    //如果自定义视图中存在需要操作的ui元素，可以放到这里操作
    定义 关闭按钮 = 界面.找控件("关闭按钮");
    关闭按钮.点击事件(()=>{
        对话框.关闭();//关闭对话框
    });
}).视图(界面.获取视图()).显示();//显示自定义视图
```


### 监听关闭(回调)

> 监听对话框关闭

- 参数 : 回调 {()=>{}} 对话框关闭后回调
- 版本 : 1.8.0


```javascript
定义 对话框 = $对话框.创建()
.标题("标题")
.内容("我是信息")
.按钮3("关闭",()=>{
    //这里关闭对话框
    对话框.关闭();
})
.监听关闭(()=>{
    日志("对话框被关闭了");
})
.显示();//显示对话框
```


### 关闭()

> 关闭对话框


```javascript
//创建一个对话框
定义 对话框 = $对话框.创建()
.标题("提示")
.内容("我是一个对话框")
.按钮1("关闭",()=>{
    对话框.关闭();//关闭对话框
})
.显示();//显示对话框
```


# $tip - 阻塞式对话框

- 更新时间:2025-12-13 11:58:47

> 阻塞式对话框
> 
> 什么是阻塞式对话框？
> 
> 答：当对话框发起调用时，阻塞当前线程不向下执行代码，当对话框处理完事件之后，下面的代码才会执行。




### 信息(信息)

> [信息]对话框

- 参数 : 信息 {Object...} 信息内容
- 版本 : 1.7.0


```javascript
$提示.信息("我是信息");
```


### 忽略(信息)

> [说明]对话框

- 参数 : 信息 {Object...} 信息内容
- 版本 : 1.7.0


```javascript
$提示.忽略("我是信息");
```


### 警告(信息)

> [警告]对话框

- 参数 : 信息 {Object...} 信息内容
- 版本 : 1.7.0


```javascript
$提示.警告("我是信息");
```


### 异常(信息)

> [异常]对话框

- 参数 : 信息 {Object...} 信息内容
- 版本 : 1.7.0


```javascript
$提示.异常("我是信息");
```


### 调试(信息)

> [调试]对话框

- 参数 : 信息 {Object...} 信息内容
- 版本 : 1.7.0


```javascript
$提示.调试("我是信息");
```


### 输入(标题, 回调)

> 输入对话框

- 参数 : 标题 {字符串} 标题
- 参数 : 回调 {(数据)=>{}} 确定按钮回调
- 版本 : 1.7.0


```javascript
$提示.输入("请输入你的名字",(数据)=> {
    信息("输入的内容:"+数据);
});
```


### 输入(标题, 默认值, 回调)

> 输入对话框(默认值)

- 参数 : 标题 {字符串} 标题
- 参数 : 默认值 {字符串} 默认值
- 参数 : 回调 {(数据)=>{}} 确定按钮回调
- 版本 : 1.7.0


```javascript
$提示.输入("请输入你的名字","张三",(数据)=> {
    信息("输入的内容:"+数据);
});
```


### 输入(标题, 提示, 默认值, 回调)

> 输入对话框(默认值)

- 参数 : 标题 {字符串} 标题
- 参数 : 提示 {字符串} 提示
- 参数 : 默认值 {字符串} 默认值
- 参数 : 回调 {(数据)=>{}} 确定按钮回调
- 版本 : 1.7.0


```javascript
$提示.输入("你是?","输入名字","张三",(数据)=> {
    信息("输入的内容:"+数据);
});
```


### 输入整数(标题, 回调)

> 输入整数
> 
> 如果输入的字符串最后无法解析成数字则回调结果为0
> 
> 引导文字默认为标题
> 
> 默认值为0

- 参数 : 标题 {字符串} 标题
- 参数 : 回调 {(数字)=>{}} 结果回调
- 版本 : 1.7.0


```javascript
$提示.输入整数("年龄",(数字)=> {
    信息("刚满"+数字+"岁~");
});
```


### 输入整数(标题, 默认值, 回调)

> 输入整数
> 
> 如果输入的字符串最后无法解析成数字则回调结果为0
> 
> 引导文字默认为标题

- 参数 : 标题 {字符串} 标题
- 参数 : 默认值 {整数} 默认值
- 参数 : 回调 {(数字)=>{}} 结果回调


```javascript
$提示.输入整数("年龄",18,(数字)=> {
    信息("刚满"+数字+"岁~");
});
```


### 输入整数(标题, 提示, 回调)

> 输入整数
> 
> 如果输入的字符串最后无法解析成数字则回调结果为0
> 
> 默认值为0

- 参数 : 标题 {字符串} 标题
- 参数 : 提示 {字符串} 引导文字
- 参数 : 回调 {(数字)=>{}} 结果回调


```javascript
$提示.输入整数("年龄","请输入年龄:",(数字)=> {
    信息("刚满"+数字+"岁~");
});
```


### 输入整数(标题, 提示, 默认值, 回调)

> 输入整数
> 
> 如果输入的字符串最后无法解析成数字则回调结果为0

- 参数 : 标题 {字符串} 标题
- 参数 : 提示 {字符串} 引导文字
- 参数 : 默认值 {整数} 默认值
- 参数 : 回调 {(数字)=>{}} 结果回调


```javascript
$提示.输入整数("年龄","请输入你的年龄:",18,(数字)=> {
    信息("刚满"+数字+"岁~");
});
```


### 显示(标题, 信息)

> 文本提示对话框

- 参数 : 标题 {字符串} 标题
- 参数 : 信息 {字符串} 信息
- 版本 : 1.7.0


```javascript
$提示.显示("你好新人","我是你的AIGame助手");
```


### 显示(标题, 信息, 点击回调)

> 文本提示对话框(有回调)

- 参数 : 标题 {字符串} 标题
- 参数 : 信息 {字符串} 信息
- 参数 : 点击回调 {()=>{}} [确定]按钮回调
- 版本 : 1.7.0


```javascript
$提示.显示("你好新人","我是你的AIGame助手",()=> {
    信息("你好!");
});
```


### 显示(标题, 视图)

> 自定义对话框(右上角关闭)

- 参数 : 标题 {字符串} 标题
- 参数 : 视图 {View} 自定义视图
- 版本 : 1.7.0


```javascript
//解析xml并且获得ui对象
定义 界面 = $界面.解析布局("ag-app-example/$提示 - 阻塞式对话框/01.自定义对话框/ui.xml");
//通过ui对象拿到View对象
定义 视图 = 界面.获取视图();
//这种方式不会显示底部的按钮
$提示.显示("自定义对话框", 视图);
```


### 显示(标题, 视图, 点击回调)

> 自定义对话框(确定关闭)

- 参数 : 标题 {字符串} 标题
- 参数 : 视图 {View} 自定义视图
- 参数 : 点击回调 {()=>{}} 点击确定按钮的回调
- 版本 : 1.7.0


```javascript
//解析xml并且获得ui对象
定义 界面 = $界面.解析布局("ag-app-example/$提示 - 阻塞式对话框/01.自定义对话框/ui.xml");
//通过ui对象拿到View对象
定义 视图 = 界面.获取视图();
//通过tip显示这个视图
$提示.显示("自定义对话框", 视图, ()=> {
    信息("保存成功");
});
```


### 单选(标题, 选项, 回调)

> 单选对话框

- 参数 : 标题 {字符串} 标题
- 参数 : 选项 {list[string]} 选项
- 参数 : 回调 {(数据)=>{}} 选择回调
- 版本 : 1.7.0


```javascript
定义 数组 = ["小狗","小猫","小猪"];
$提示.单选("请选择",数组,(数据)=> {
    信息("你选择了:"+数据);
});
```


### 多选(标题, 选项, 回调)

> 多选对话框

- 参数 : 标题 {字符串} 标题
- 参数 : 选项 {list[string]} 选项
- 参数 : 回调 {(数据组)=>{}} 选择回调
- 版本 : 1.7.0


```javascript
定义 数组 = ["小狗","小猫","小猪"];
$提示.多选("请选择",数组,(数据组)=> {
    信息("你选择了:"+数据组);
});
```


### 选择日历(回调)

> 日期选择对话框

- 参数 : 回调 {(dateInfo)=>{}} 选择回调
- 版本 : 1.7.0


```javascript
//选择日期
$提示.选择日历((信息)=> {
    //此回调处于第三方线程
    定义 年 = 信息.年; //年
    定义 月 = 信息.月; //月
    定义 日 = 信息.日; //日
    //显示日期
    提示("日期",年+"-"+月+"-"+日);
});
```


### 选择日期(回调)

> 滚轮方式选择日期

- 参数 : 回调 {(时间信息)=>{}} 选择回调
- 版本 : 1.7.0


```javascript
//滚轮方式选择日期
$提示.选择日期((信息)=> {
    //此回调处于第三方线程
    定义 年 = 信息.年; //年
    定义 月 = 信息.月; //月
    定义 日 = 信息.日; //日
    //显示日期
    提示("日期",年+"-"+月+"-"+日);
});
```


### 选择时钟(回调)

> 时间选择对话框

- 参数 : 回调 {(时间信息)=>{}} 选择回调
- 版本 : 1.7.0


```javascript
//24小时制:时间选择对话框
$提示.选择时钟((信息)=> {
    //此回调处于第三方线程
    定义 时 = 信息.时; //时
    定义 分 = 信息.分; //分
    //显示时间
    提示("时间",时+":"+分);
});
```


### 选择时间(回调)

> 时间滚动选择对话框

- 参数 : 回调 {(选择时间)=>{}} 选择回调
- 版本 : 1.7.0


```javascript
//24小时制:滚轮方式时间选择对话框
$提示.选择时间((信息)=> {
    //此回调处于第三方线程
    定义 时 = 信息.时; //时
    定义 分 = 信息.分; //分
    //显示时间
    提示("时间",时+":"+分);
});
```


# $touch - 触摸驱动

- 更新时间:2025-12-13 11:58:47

> 触摸驱动
> 
> 需要ROOT权限，部分手机不会与手指触摸冲突。




### 有权限()

> 是否可用
> 
> 一般如果有root权限，就是可用的状态，本质上这个函数是用来判断设备是否有root权限的。这个函数性能很高，一旦初始化成功了，就会直接返回true，并不会每次都检查root权限。

- 返回 : {布尔值} 是否可用
- 版本 : 1.7.0


```javascript
//初始化
if($触摸.有权限()){
    $触摸.初始化();
}
//之后再操作，否则无效果
```


### 初始化()

> 初始化
> 
> $触摸需要初始化才可以使用，初始化大概需要5秒时间，但如果已经初始化过了，就会直接返回true。

- 返回 : {布尔值} 是否已经初始化成功


```javascript
//开始初始化
$触摸.初始化();
```


### 触摸按下(手指ID, x, y)

> 按下手指

- 参数 : 手指ID {整数} 手指ID 
- 参数 : x {整数}  坐标X 
- 参数 : y {整数}  坐标Y 
- 版本 : 1.7.0


```javascript
$触摸.触摸按下(1, 100, 100);
```


### 触摸移动(手指ID, x, y)

> 移动手指

- 参数 : 手指ID {整数} 手指ID 
- 参数 : x {整数}  坐标X 
- 参数 : y {整数}  坐标Y 
- 版本 : 1.7.0


```javascript
$触摸.触摸移动(1, 300, 500);
```


### 触摸抬起(手指ID)

> 抬起手指

- 参数 : 手指ID {整数} 手指ID 
- 版本 : 1.7.0


```javascript
$触摸.触摸抬起(1);
```


### 点击(x, y)

> 点击
> 
> 原理是在C/C++层执行系统命令进行事件注入，因此效率较高

- 参数 : x {整数} 坐标X 
- 参数 : y {整数} 坐标Y 
- 版本 : 1.7.0


```javascript
$触摸.点击(300, 500);
```


### 点击(手指ID, x, y)

> 点击
> 
> 默认按压时长为1毫秒，该函数的本质是touchDown和touchUp的组合，因此效率较慢

- 参数 : 手指ID {整数} 手指ID 
- 参数 : x {整数}  坐标X 
- 参数 : y {整数}  坐标Y 
- 版本 : 1.7.0


```javascript
$触摸.点击(1, 300, 500);
```


### 点击(手指ID, x, y, 时长)

> 点击
> 
> 原理是touchDown和touchUp的组合

- 参数 : 手指ID {整数} 手指ID 
- 参数 : x {整数}  坐标X 
- 参数 : y {整数}  坐标Y 
- 参数 : 时长 {整数}  按压时长 
- 版本 : 1.7.0


```javascript
$触摸.点击(1, 300, 500, 50);
```


### 长按(x, y)

> 长按
> 
> 原理是touchDown和touchUp的组合，默认按压时间是750毫秒

- 参数 : x {整数}  坐标X 
- 参数 : y {整数}  坐标Y 
- 版本 : 1.7.0


```javascript
$触摸.长按(300, 500);
```


### 长按(手指ID, x, y)

> 长按
> 
> 原理是touchDown和touchUp的组合，默认按压时间是750毫秒

- 参数 : 手指ID {整数} 手指ID 
- 参数 : x {整数}  坐标X 
- 参数 : y {整数}  坐标Y 
- 版本 : 1.7.0


```javascript
$触摸.长按(1, 300, 500);
```


### 长按(手指ID, x, y, 时长)

> 长按
> 
> 原理是touchDown和touchUp的组合

- 参数 : 手指ID {整数} 手指ID 
- 参数 : x {整数}  坐标X 
- 参数 : y {整数}  坐标Y 
- 参数 : 时长 {整数}  长按时间 
- 版本 : 1.7.0


```javascript
$触摸.长按(1, 300, 500, 2000);
```


### 滑动(x, y, x2, y2)

> 滑动
> 
> 默认的滑动时间是1秒

- 参数 : x {整数}  起点X 
- 参数 : y {整数}  起点Y 
- 参数 : x2 {整数}  终点X 
- 参数 : y2 {整数}  终点Y 
- 版本 : 1.7.0


```javascript
$触摸.滑动(100, 100, 300, 500);
```


### 滑动(x, y, x2, y2, 时长)

> 滑动

- 参数 : x {整数}  起点X 
- 参数 : y {整数}  起点Y 
- 参数 : x2 {整数}  终点X 
- 参数 : y2 {整数}  终点Y 
- 参数 : 时长 {整数}  移动时间 
- 版本 : 1.7.0


```javascript
$触摸.滑动(100, 100, 300, 500, 1000);
```


### 滑动(手指ID, x, y, x2, y2, 时长)

> 滑动
> 
> 滑动的时间是根据CPU数量来进行计算的，因此并不一定就完全准确，不同手机执行的滑动时间可能有一点误差，但这并没有太大影响。

- 参数 : 手指ID {整数} 手指ID 
- 参数 : x {整数}  起点X 
- 参数 : y {整数}  起点Y 
- 参数 : x2 {整数}  终点X 
- 参数 : y2 {整数}  终点Y 
- 参数 : 时长 {整数}  移动时间 
- 版本 : 1.7.0


```javascript
$触摸.滑动(1, 100, 100, 300, 500, 1000);
```


### 移动(x, y, x2, y2, 时长)

> 模拟滑动
> 
> 原理是C/C++层系统调用命令来实现注入滑动

- 参数 : x {整数} 起点X 
- 参数 : y {整数}  起点Y 
- 参数 : x2 {整数} 终点X 
- 参数 : y2 {整数} 终点Y 
- 参数 : 时长 {整数} 滑动时间 
- 版本 : 1.7.0


```javascript
$触摸.移动(100,200,600,1200,2000);
```


### 按键(键值)

> 模拟按键
> 
> 原理是C/C++层系统调用命令来实现注入按键事件

- 参数 : 键值 {整数} 键值 
- 版本 : 1.7.0


```javascript
$触摸.按键(4);//返回按钮
```


# TtsOptions - 语音配置

- 更新时间:2025-12-13 11:58:47

> TtsOptions - 语音配置




### const {Float} 速度;

> 播放倍速


### const {Float} 音调;

> 音调


### const {Float} 音量;

> 音量


### const {String} 语言;

> 语言
> 
> 可选值有：zh,en,fr,de,it,ja,ko
> 
> 分别意思：中文,英文,法文,德文,意大利文,日文,韩文


### const {String} 类型;

> 播放流类型
> 
> 可选值有：alarm,music,notification,ring,system,call,dtmf
> 
> 分别意思：闹钟,音乐,通知,铃声,系统,通话,DTMF


# $tts - 语音阅读

- 更新时间:2025-12-13 11:58:47

> 语音阅读




### 阅读(文本, 配置)

> 播放文本(配置)
> 
> 对于没有TTS引擎的设备而言，此函数执行后无任何效果

- 参数 : 文本 {字符串} 文本
- 参数 : 配置 {TtsOptions} 配置
- 版本 : 1.6.9


```javascript
定义 配置 = {
    速度: 1,//速度
    音调: 1,//音调
    音量: 1,//音量
    语言: "zh",//语言
    类型: "system"//播放流('system'播放声音最大)
}
$语音.阅读("你好呀，早安~",配置);
```


### 阅读(文本)

> 播放文本
> 
> 对于没有TTS引擎的设备而言，此函数执行后无任何效果

- 参数 : 文本 {字符串} 文本
- 版本 : 1.6.9


```javascript
$语音.阅读("你好呀，早安~");
```


# Ws - WS封装对象

- 更新时间:2025-12-13 11:58:47

> 双工通信包装对象
> 
> 对okhttp3.WebSocket对象进行封装的对象




### 发送(字符串)

> 发送字符消息

- 参数 : 字符串 {字符串} 字符串消息
- 版本 : 1.6.9


```javascript
//创建ws对象
定义 通信 = $通信.创建("wss://echo.websocket.org");
//发送字符消息
通信.发送("你好呀~");
```


### 发送(字节数组)

> 发送字节消息

- 参数 : 字节数组 {byte[]} 字节消息
- 版本 : 1.6.9


```javascript
//创建ws对象
定义 通信 = $通信.创建("wss://echo.websocket.org");
//发送字节消息
通信.发送([10,15,0,1,20]);
```


### 发送(数据)

> 发送消息
> 
> ByteString类型是okhttp提供的一种数据类型，具体函数可以参考okhttp文档

- 参数 : 数据 {ByteString} byteString对象消息
- 版本 : 1.6.9


```javascript
//创建ws对象
定义 通信 = $通信.创建("wss://echo.websocket.org");
定义 数据对象 = okio.ByteString.encodeUtf8("字符串");
//发送消息
通信.发送(数据对象);
```


### 发送base64(base64字符串)

> 发送base64消息

- 参数 : base64字符串 {字符串} base64 字符串
- 版本 : 1.6.9


```javascript
//创建ws对象
定义 通信 = $通信.创建("wss://echo.websocket.org");
//发送base64消息
通信.发送base64("QXV0by5qcyBQcm8geXlkcw==");
```


### 发送16进制字符串(十六进制字符串)

> 发送16进制消息

- 参数 : 十六进制字符串 {字符串} 16进制字符串
- 版本 : 1.6.9


```javascript
//创建ws对象
定义 通信 = $通信.创建("wss://echo.websocket.org");
//发送16进制消息
通信.发送16进制字符串("621172314F60");
```


### 取消()

> 关闭
> 
> 效果和 '停止()' 相同

- 版本 : 1.6.9


```javascript
//创建ws对象
定义 通信 = $通信.创建("wss://echo.websocket.org");
//立即关闭
通信.取消();
```


### 停止()

> 关闭
> 
> 效果和 '取消()' 相同

- 版本 : 1.6.9


```javascript
//创建ws对象
定义 通信 = $通信.创建("wss://echo.websocket.org");
//立即关闭
通信.停止();
```


### 关闭()

> 关闭
> 
> 效果和 '停止(),取消()' 相同

- 版本 : 1.6.9


```javascript
//创建ws对象
定义 通信 = $通信.创建("wss://echo.websocket.org");
//立即关闭
通信.关闭();
```


### 关闭(退出码)

> 尝试正常关闭

- 参数 : 退出码 {number} 关闭码
- 版本 : 1.6.9


```javascript
//创建ws对象
定义 通信 = $通信.创建("wss://echo.websocket.org");
//尝试正常关闭(正常关闭退出码一般是1001)
通信.关闭(1001);
```


### 关闭(退出码, 原因)

> 尝试正常关闭

- 参数 : 退出码 {整数} 关闭码
- 参数 : 原因 {字符串} 关闭原因
- 版本 : 1.6.9


```javascript
//创建ws对象
定义 通信 = $通信.创建("wss://echo.websocket.org");
//尝试正常关闭(正常关闭退出码一般是1001)
通信.关闭(1001,"关闭");
```


### 监听消息(回调函数)

> 设置字节字符信息接受回调
> 
> 如果不设置，则使用默认的回调：打印字节数组

- 参数 : 回调函数 {(byteString)=>{}}
- 返回 : {Ws} 返回当前对象
- 版本 : 1.6.9


```javascript
//创建ws对象
定义 通信 = $通信.创建("wss://echo.websocket.org");
//发送消息
通信.监听字节消息((bs)=> {
    //参数说明：
    // bs: okio.ByteString (参考okhttp3文档)
    //接收到字节数据时回调
    日志("收到二进制消息：大小 ", bs.size());
    日志("hex: ", bs.hex());
    日志("base64: ", bs.base64());
    日志("md5: ", bs.md5());
    日志("bytes: ", bs.toByteArray());
});
```


### 监听字符串消息(回调函数)

> 设置字符串信息接受回调
> 
> 如果不设置，则使用默认的回调：打印字符串

- 参数 : 回调函数 {(str)=>{}}
- 返回 : {Ws} 返回当前对象
- 版本 : 1.6.9


```javascript
//创建ws对象
定义 通信 = $通信.创建("wss://echo.websocket.org");
//设置字符串信息接受回调
通信.监听字符串消息((str, ws)=> {
    //参数说明：
    // str: String 字符串数据
    // ws: okhttp3.WebSocket (参考okhttp3文档)
    //接收到字符串信息时回调
    日志("收到字符串：",str);
});
```


### 监听打开(回调函数)

> 设置连接成功回调
> 
> 如果不设置，则使用默认的回调：打印连接信息

- 参数 : 回调函数 {(res,ws)=>{}} 回调
- 返回 : {Ws} 返回当前对象
- 版本 : 1.6.9


```javascript
//创建ws对象
定义 通信 = $通信.创建("wss://echo.websocket.org");
//设置连接成功回调
通信.监听打开((res,ws)=> {
    //参数说明：
    // res: okhttp3.Response (参考okhttp3文档)
    // ws: okhttp3.WebSocket (参考okhttp3文档)
    日志("链接成功");
});
```


### 监听关闭(回调函数)

> 设置连接关闭回调
> 
> 如果不设置，则使用默认的回调：打印关闭信息

- 参数 : 回调函数 {(code,reason,ws)=>{}} 回调
- 返回 : {Ws} 返回当前对象
- 版本 : 1.6.9


```javascript
//创建ws对象
定义 通信 = $通信.创建("wss://echo.websocket.org");
//设置连接关闭回调
通信.监听关闭((code,reason,ws)=>{
    //参数说明：
    // code:   int    数字
    // reason: String 字符串
    // ws: okhttp3.WebSocket (参考okhttp3文档)
    日志("正在关闭");
});
```


### 监听关闭中(回调函数)

> 设置连接关闭中回调
> 
> 如果不设置，则使用默认的回调：打印关闭信息

- 参数 : 回调函数 {(code,reason,ws)=>{}} 回调
- 返回 : {Ws} 返回当前对象
- 版本 : 1.6.9


```javascript
//创建ws对象
定义 通信 = $通信.创建("wss://echo.websocket.org");
//设置连接关闭中回调
通信.监听关闭中((code,reason,ws)=>{
    //参数说明：
    // code:   int    数字
    // reason: String 字符串
    // ws: okhttp3.WebSocket (参考okhttp3文档)
    日志("正在关闭");
});
```


### 监听失败(失败回调)

> 设置连接失败回调
> 
> 如果不设置，则使用默认的回调：打印错误信息

- 参数 : 失败回调 {(err,res,ws)=>{}} 回调
- 返回 : {Ws} 返回当前对象
- 版本 : 1.6.9


```javascript
//创建ws对象
定义 通信 = $通信.创建("wss://echo.websocket.org");
//设置连接失败回调
通信.监听失败((err,res,ws)=>{
    //参数说明：
    // err: Throwable
    // res: okhttp3.Response (参考okhttp3文档)
    // ws: okhttp3.WebSocket (参考okhttp3文档)
    //打印错误信息
    日志("出现异常",err);
});
```


# $ws - 双工通信:WebSocket

- 更新时间:2025-12-13 11:58:47

> WebSocket工具
> 
> 让客户端和服务器之间建立一条"热线电话"，双方可以随时说话(通信)，不用像以前那样每次都要重新拨号(不用重新建立连接)。




### 创建(url)

> 创建一个 WebSocket

- 参数 : url {字符串} 例如:ws://127.0.0.1:8080
- 返回 : Ws


```javascript
//返回的ws是经过封装的WebSocket对象(不是okhttp3.WebSocket原生对象)
定义 通信 = $通信.创建("wss://echo.websocket.org");
//设置监听
通信.监听打开((res,ws)=> {
    //参数说明：
    // res: okhttp3.Response (参考okhttp3文档)
    // ws: okhttp3.WebSocket (参考okhttp3文档)
    //当成功连接时回调(此函数可以不用设置，拥有默认回调:打印信息)
    日志("链接成功");
})
.监听关闭((code,reason,ws)=> {
    //参数说明：
    // code:   int    数字
    // reason: String 字符串
    // ws: okhttp3.WebSocket (参考okhttp3文档)
    //当关闭后回调(此函数可以不用设置，拥有默认回调:打印信息)
    日志("关闭成功");
})
.监听关闭中((code,reason,ws)=> {
    //参数说明：
    // code:   int    数字
    // reason: String 字符串
    // ws: okhttp3.WebSocket (参考okhttp3文档)
    //处于关闭时回调(此函数可以不用设置，拥有默认回调:打印信息)
    日志("正在关闭");
})
.监听失败((err,res,ws)=> {
    //参数说明：
    // err: Throwable
    // res: okhttp3.Response (参考okhttp3文档)
    // ws: okhttp3.WebSocket (参考okhttp3文档)
    //出现异常时回调(此函数可以不用设置，拥有默认回调:打印信息)
    日志("出现异常",err);
})
.监听字符串消息((str, ws)=> {
    //参数说明：
    // str: String 字符串数据
    // ws: okhttp3.WebSocket (参考okhttp3文档)
    //接收到字符串信息时回调
    日志("收到字符串：",str);
})
.监听消息((bs)=> {
    //参数说明：
    // bs: okio.ByteString (参考okhttp3文档)
    //接收到字节数据时回调
    日志("收到二进制消息：大小 ", bs.size());
    日志("hex: ", bs.hex());
    日志("base64: ", bs.base64());
    日志("md5: ", bs.md5());
    日志("bytes: ", bs.toByteArray());
});
//发送字符串消息
通信.发送("Hello AIGame!");
//发送二进制消息
//通信.发送([10,15,1,1,0,5]);
```


# 训练模型-环境搭建

- 更新时间:2025-12-13 11:58:47

> 训练模型-环境搭建
> 
> 这个教程是适合小白的教程，但是你需要具备如下基础：会下载文件、会安装软件、会打字、会点按钮、会执行命令。




## 下载Python

下载python3.12.0 https://www.python.org/downloads/release/python-3120/

注意：不要下载最新版本，我规定下载这个版本当然是有说法的，不然后面安装依赖的时候报错别怪我。打开连接之后网页滑动到最后，找到适合自己电脑的版本下载安装即可，随便你安装到哪都行，但是你要知道自己安装的路径在哪，后面会用到。
这是专门用来执行python代码的。

[点击前往下载](https://www.python.org/downloads/release/python-3120/)

![](../img/395994874847000.png)


## 打开命令窗口执行一堆命令

当我们安装完python之后，需要安装一堆依赖，不过不用紧张，这个教程是给小白看的，你不需要有编程基础，会用电脑就行。

首先按住电脑快捷键Win+R，看到一个窗口输入"cmd"后回车就能打开黑窗口了。

![](../img/396597681211100.png)


当python安装完之后，打卡cmd黑色窗口直接按照寻徐运行下面的命令：(你不需要担心网速问题，这些命令用的都是国内的仓库地址，速度都很快)

注意：一定要只在一个黑色窗口中依次运行，不要为了方便开多个黑窗口执行命令，否则可能会造成pip安装工具冲突，严重点会损坏pip组件。

下面的命令是训练yolo模型需要的依赖
```bash
pip install -i https://pypi.tuna.tsinghua.edu.cn/simple/ torch torchvision torchaudio
pip install -i https://pypi.tuna.tsinghua.edu.cn/simple/ ultralytics
pip install -i https://pypi.tuna.tsinghua.edu.cn/simple/ PyYAML
pip install -i https://pypi.tuna.tsinghua.edu.cn/simple/ matplotlib
pip install -i https://pypi.tuna.tsinghua.edu.cn/simple/ polars
pip install -i https://pypi.tuna.tsinghua.edu.cn/simple/ scipy
```

下面的命令是将pt模型转换为onnx模型需要的依赖
```bash
pip install onnx==1.16.0 -i https://pypi.tuna.tsinghua.edu.cn/simple
pip install onnxruntime==1.22.0 -i https://pypi.tuna.tsinghua.edu.cn/simple
pip install onnxscript==0.5.7.dev20251113 -i https://pypi.tuna.tsinghua.edu.cn/simple/
pip install onnxslim==0.1.74 -i https://pypi.tuna.tsinghua.edu.cn/simple
```

下面的命令是将onnx模型转换为ncnn模型需要的依赖
```bash
pip install pnnx -i https://pypi.tuna.tsinghua.edu.cn/simple
```

我在安装onnxslim的时候遇到路径长度限制，解决方法：电脑下面搜索 power 就能看到 "Windows PowerShell"

以管理员身份打开PowerShell 执行命令：
```bash
New-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Control\FileSystem" -Name "LongPathsEnabled"
-Value 1 -PropertyType DWORD -Force
```


## 下载PyCharm

下载PyCharm: https://www.jetbrains.com/pycharm/download/?section=windows

下载最新版就行，随便安装在什么位置。这个工具是帮助我们运行python代码的，不过不用担心，我都把代码写好了，你只需要会配置、会点运行按钮即可。

[点击前往下载](https://www.jetbrains.com/pycharm/download/?section=windows)

![](../img/396328945123500.png)


# 输入输出层名称对照表

- 更新时间:2025-12-13 11:58:47

> 输入输出层名称对照表
> 
> 使用任何模型之前，确保param文件的输入层名称和输出层名称一致。




## 输入输出层名称对照表

在onnx转换为ncnn模型文件的时候，如果导出的param文件中输入输出层对应不上，则会出现闪退。为此，我将源码中的输入输出层罗列出来，方便开发者们对照各个版本的输入输出层名称来调整模型转换参数。

| 版本  | input  | output         | 尺寸      |
|-----|--------|----------------|---------|
| V5  | images | output、数字、数字   | 320x320 |
| V6  | images | output         | 640x640 |
| V7  | in0    | out0、out1、out2 | 640x640 |
| V8  | images | output         | 640x640 |
| V9  | images | output0        | 640x640 |
| V10 | in0    | out0、out1、out2 | 640x640 |
| V11 | in0    | out0、out1、out2 | 640x640 |
| V12 | in0    | out0           | 640x640 |
| V13 | in0    | out0           | 640x640 |

YoloV5版本后面输出层的两个"数字"需要看param文件的末尾"Permute"开头的行

例如:

```bash
Permute                  Transpose_590            1 1 780 781 0=1
Convolution              Conv_591                 1 1 741 782 0=255 1=1 5=1 6=130560
Reshape                  Reshape_605              1 1 782 800 0=-1 1=85 2=3
Permute                  Transpose_606            1 1 800 801 0=1
```

两个Permute行的输出层分别是：781、801 (需要你自己找找看，有一定规律，一般在"0=1"这个字段前一个，或者 1 1
800 801 这里的801就是第三个输出层名称)

那么在脚本开发的过程中如何设置yolo的输入输出层的名称呢？仔细观察输入输出层名称对照表，可以发现输入层的名称是固定的，只有一个，而输出层的名称要么是一个，要么就是三个，因此我提供了三个函数用来配置：

```javascript
$yolo.v(5);//指定版本之后才能调用，不然我不知道你要对哪个版本的yolo进行配置
$yolo.input("");//输入层只有一个名称
//输出层
$yolo.output("");//适用于yolo6、8、9(参看对照表)
$yolo.output("", "", "");//适用于yolo5、7、10、11(参看对照表)
//当你指定完输入输出层名称之后再加载模型，模型加载的时候会使用你指定的输入输出层名称
$yolo.init("demo.bin","demo.params","labels.txt");
```

其实将pt或者onnx转为ncnn模型有狠多坑要踩，为了减少一些乱七八糟的坑，我提供了输入输出层名称对照表，方便开发者们配置。


## 默认参数对照表

使用'$yolo.config()'即可配置参数，设计这个函数的主要作用是用来调优的，如果不配置则使用默认配置数据。

```js
//首先指定版本,若不指定版本，默认使用Yolo V8
$yolo.v(5);//指定使用的yolo版本为:Yolo V5
//为Yolo V5设置配置参数
$yolo.config(targetSize, meanVals, normVals, useGpu, probThreshold, nmsThreshold);
```

参数说明：不需要配置的参数填null即可

- targetSize {int} : 期望的输入图像边长（通常为正方形），例如 640 表示 640×640 像素。图像会被缩放至该尺寸后输入网络
- meanVals {float[3]} : 图像通道归一化的均值，格式为[B_mean, G_mean, R_mean] 元素范围:(0-255)
- normVals {float[3]} : 图像通道归一化的标准差，格式为[B_std, G_std, R_std] 元素范围:(0.001-0.1)
- useGpu {boolean} : 是否使用 GPU 加速
- probThreshold {float} : 过滤低置信度预测框的阈值，范围[0,1]
- nmsThreshold {float} : 抑制重叠检测框的阈值，范围[0,1]

但是我在开发yolo系列的时候，发现有些版本对于配置参数的支持也是不一样的，所以我在C/C++中尽可能的完善了所有yolo的配置参数，
不过呢还是存在无法完成的配置参数，具体的配置支持度如下：

打`Y`的表示支持配置此参数,打`N`表示不支持此参数,如果配置了这个参数也不会生效。

| 版本        | targetSize | meanVals     | normVals                          | useGpu | probThreshold | nmsThreshold |
|-----------|------------|--------------|-----------------------------------|--------|---------------|--------------|
| V5        | Y          | Y            | Y                                 | Y      | Y             | Y            |
| V6        | Y          | Y            | Y                                 | Y      | Y             | Y            |
| V7        | Y          | Y            | Y                                 | Y      | Y             | Y            |
| V8        | Y          | Y            | Y                                 | Y      | Y             | Y            |
| V9        | Y          | Y            | Y                                 | Y      | Y             | Y            |
| V10       | Y          | Y            | Y                                 | Y      | Y             | N            |
| V11       | Y          | Y            | Y                                 | Y      | Y             | Y            |
| V12       | Y          | Y            | Y                                 | Y      | Y             | Y            |
| V13       | Y          | Y            | Y                                 | Y      | Y             | Y            |
| VX        | Y          | Y            | Y                                 | Y      | Y             | Y            |
| AIGame默认值 | 640        | [0f, 0f, 0f] | [1 / 255.f, 1 / 255.f, 1 / 255.f] | false  | 0.25          | 0.45         |

总的来说，除了YoloV10不支持NMS阈值配置外，其他版本都支持全部配置。


## 如何查看输出层名称

让我们来学习几个param文件是如何查看输出层名称的吧：

在yolo5的param文件后面几行可以在0=1的地方看到781、801这样的名称作为输出层名称，所以yolo5的坑是最隐蔽的，很多人训练完模型后，高高兴兴的用移动端部署运行模型，结果闪退报错等等。

```bash
Permute                  Transpose_590            1 1 780 781 0=1
Convolution              Conv_591                 1 1 741 782 0=255 1=1 5=1 6=130560
Reshape                  Reshape_605              1 1 782 800 0=-1 1=85 2=3
Permute                  Transpose_606            1 1 800 801 0=1
```

![](../img/407162455999700.png)


在yolo8的param文件中可以找到最后一行看到output这样的输出层名称

```bash
Reshape                  Reshape_287              1 1 405 434 0=-1 1=144
Reshape                  Reshape_288              1 1 420 441 0=-1 1=144
Concat                   Concat_289               3 1 427 434 441 442 0=1
Permute                  Transpose_526            1 1 442 output 0=1
```

![](../img/407224323928300.png)


在yolo11的param文件中：可以看见out0、out1、out2这样的输出层名称

```bash
Permute                  permute_171              1 1 300 301 0=3
Concat                   cat_19                   2 1 291 301 out2 0=2
```

![](../img/407372540692700.png)


# 结果排序规则表

- 更新时间:2025-12-13 11:58:47

> 结果排序规则表




## YOLO识别结果排序规则表

| 参数     | 排序方向/规则    | 描述                           |
|--------|------------|------------------------------|
| -1     | 不排序（默认）    | 不对识别结果集进行任何排序操作（追求效率可选）      |
| 1      | 从左到右       | 按矩形框的x坐标升序排列（x越小，越靠左，排在前面）   |
| 2      | 从右到左       | 按矩形框的x坐标降序排列（x越大，越靠右，排在前面）   |
| 3      | 从上到下       | 按矩形框的y坐标升序排列（y越小，越靠上，排在前面）   |
| 4      | 从下到上       | 按矩形框的y坐标降序排列（y越大，越靠下，排在前面）   |
| 5      | 从左上到右下     | 按矩形框x+y的和升序排列（左上区域值更小，排在前面）  |
| 6      | 从右上到左下     | 按矩形框x-y的差降序排列（右上区域差值更大，排在前面） |
| 7      | 从左下到右上     | 按矩形框x-y的差升序排列（左下区域差值更小，排在前面） |
| 8      | 从右下到左上     | 按矩形框x+y的和降序排列（右下区域值更大，排在前面）  |
| 9      | 从左到右并且从上到下 | 优先按x坐标升序，x相同时按y坐标升序          |
| 10     | 从右到左并且从上到下 | 优先按x坐标降序，x相同时按y坐标升序          |
| 11     | 从左到右并且从下到上 | 优先按x坐标升序，x相同时按y坐标降序          |
| 12     | 从右到左并且从下到上 | 优先按x坐标降序，x相同时按y坐标降序          |
| 13     | 大的面积在前面    | 按矩形框面积降序排列（面积越大，排在前面）        |
| 14     | 小的面积在前面    | 按矩形框面积升序排列（面积越小，排在前面）        |
| 其他（默认） | 从左到右（默认规则） | 按矩形框的x坐标升序排列（与编码1的规则一致）      |


## 具体应用

例如现在我有一个数据集，我主要用来识别数字和一个逗号字符串，我的数据集大多数都是205x30的图片，你觉得我应该用什么样的尺寸比较合适？用什么样的排序规则比较合适？

![](../img/3811231098900.png)

首先我们要知道：yolo输入的图片尺寸必须是32的倍数，我们的图片是高度为30的，因此使用32来作为模型的输入高度，宽度是205，我们找到最近的32的倍数，就是192，因此输入的尺寸就定好了：192x32



```python
//训练模型的py代码 ：
from ultralytics import YOLO
if __name__ == '__main__':
    model = YOLO(r"yolo11n.pt")  # 指定权重 (项目/yolo11n.pt)
    model.train(
        data=r"hydd2.yaml",  # 指定你的数据集配置文件 (项目/ultralytics/cfg/datasets/cm.yaml)
        epochs=50,  # 定义训练的总轮数
        imgsz=[32, 192],  # 指定输入图片的尺寸[高度,宽度]
        batch=2,  # 定义批次大小 每次同时向模型喂送 2 张图片进行处理
        cache=False,  # 不用缓存 避免内存溢出 （如果电脑内存大、可以开启，因为速度会快一点）
        workers=4,  # 指定数据加载时使用的 CPU 线程数 推荐：0、4、8 都是可以的
    )
```



```python
# 导出为ONNX格式（高在前、宽在后）
model.export(format='onnx', imgsz=[32, 192])
```


最终把onnx转为ncnn模型时的参数：高在前、宽在后


```bash
pnnx best.onnx inputshape=[1,3,32,192]f32 device=cpu
```


接下来确定排序方向，由于我制作的是文字识别，排序方向当然就是从左到右的，因此代码这么写：


```javascript
let yolo = $yolo.create(12);
yolo.setSize(192,32);//先宽、后高
yolo.setDir(1);//识别结果按照从左到右排序
//开始加载模型
yolo.init("res/ocr.bin","res/ocr.param",["0","1","2","3","4","5","6","7","8","9",","]);
```


# YoloObject - 目标检测对象

- 更新时间:2025-12-13 11:58:47

> Yolo对象




### 初始化(模型文件路径, 参数文件路径, 标签文件路径)

> 初始化

- 参数 : 模型文件路径 {字符串} 模型文件路径
- 参数 : 参数文件路径 {字符串} 参数文件路径
- 参数 : 标签文件路径 {字符串} 标签文件路径
- 返回 : {YoloResult} 结果
- 版本 : 1.8.3


```javascript
定义 检测对象 = $目标检测.创建(12);
检测对象.初始化("资源/检测模型.bin", "资源/检测模型.param", "资源/标签.txt")
```


### 初始化(模型文件路径, 参数文件路径, 标签)

> 初始化

- 参数 : 模型文件路径 {字符串} 模型文件路径
- 参数 : 参数文件路径 {字符串} 参数文件路径
- 参数 : 标签 {字符串数组[]} 标签
- 返回 : {YoloResult} 结果
- 版本 : 1.8.3


```javascript
定义 检测对象 = $目标检测.创建(12);
检测对象.初始化("资源/检测模型.bin", "资源/检测模型.param", ["人","鸟","自行车"])
```


### 检测()

> 检测屏幕
> 
> 需要截屏权限

- 返回 : {YoloResult} 结果
- 版本 : 1.8.3


```javascript
定义 检测对象 = $目标检测.创建(12);
检测对象.初始化("资源/检测模型.bin", "资源/检测模型.param", "资源/标签.txt");
定义 结果 = 检测对象.检测();
日志("检测结果",结果);
```


### 检测(img)

> 检测图片

- 参数 : img {Image} 图片
- 返回 : {YoloResult} 结果
- 版本 : 1.8.3


```javascript
定义 检测对象 = $目标检测.创建(12);
检测对象.初始化("资源/检测模型.bin", "资源/检测模型.param", "资源/标签.txt");
定义 图片 = $图片.读取("资源/t01.png");
定义 结果 = 检测对象.检测(图片);
日志("检测结果",结果);
```


### 检测(位图)

> 检测位图

- 参数 : 位图 {Bitmap} 位图
- 返回 : {YoloResult} 结果
- 版本 : 1.8.3


```javascript
定义 检测对象 = $目标检测.创建(12);
检测对象.初始化("资源/检测模型.bin", "资源/检测模型.param", "资源/标签.txt");
定义 图片 = 图片.读取("资源/t01.png");
定义 结果 = 检测对象.检测(图片.获取位图());
日志("检测结果",结果);
```


### 检测(图片路径)

> 检测路径中的图片

- 参数 : 图片路径 {字符串} 图片路径
- 返回 : {YoloResult} 结果
- 版本 : 1.8.3


```javascript
定义 检测对象 = $目标检测.创建(12);
检测对象.初始化("资源/检测模型.bin", "资源/检测模型.param", "资源/标签.txt");
定义 结果 = 检测对象.检测("资源/test.jpg");
日志(结果);
```


### 是初始化的()

> 是否初始化
> 
> 只有成功加载模型之后才会返回true

- 返回 : {布尔值} 是否初始化了
- 版本 : 1.8.3


```javascript
定义 检测对象 = $目标检测.创建(12);
检测对象.初始化("资源/检测模型.bin", "资源/检测模型.param", "资源/标签.txt");
if(检测对象.是初始化的()) {
    日志("初始化成功");
}
```


### 设置排序方向(方向)

> 设置排序方向
> 
> 排序方向一共有15种，默认是不排序，具体排序顺序请参考：结果排序规则表

- 参数 : 方向 {整数} 排序方向(默认:-1)
- 版本 : 1.8.3


```javascript
定义 检测对象 = $目标检测.创建(12);
检测对象.设置排序方向(-1);//如果不需要排序就不排序，以免影响速度
```


### 设置尺寸(宽, 高)

> 设置输入尺寸

- 参数 : 宽 {整数} 宽
- 参数 : 高 {整数} 高
- 版本 : 1.8.3


```javascript
定义 检测对象 = $目标检测.创建(12);
检测对象.设置尺寸(640,640);
```


### 设置使用gpu(使用)

> 设置是否使用GPU

- 参数 : 使用 {布尔值} 是否使用GPU
- 版本 : 1.8.3


```javascript
定义 检测对象 = $目标检测.创建(12);
检测对象.设置使用gpu(true);
```


### 设置相似度(相似度)

> 设置相似度阈值

- 参数 : 相似度 {小数} 相似度阈值
- 版本 : 1.8.3


```javascript
定义 检测对象 = $目标检测.创建(12);
检测对象.设置相似度(0.5f);
```


### 设置抑制阈值(抑制阈值)

> 设置抑制阈值

- 参数 : 抑制阈值 {小数} 抑制阈值
- 版本 : 1.8.3


```javascript
定义 检测对象 = $目标检测.创建(12);
检测对象.设置抑制阈值(0.5f);
```


### 设置均值(均值)

> 设置均值

- 参数 : 均值 {float[]} 均值
- 版本 : 1.8.3


```javascript
定义 检测对象 = $目标检测.创建(12);
检测对象.设置均值([0.485f, 0.456f, 0.406]);
```


### 设置归一化(归一化)

> 设置归一化

- 参数 : 归一化 {float[]} 归一化
- 版本 : 1.8.3


```javascript
定义 检测对象 = $目标检测.创建(12);
检测对象.设置归一化([0.00392157f, 0.00392157f, 0.00392157f]);
```


### 设置输入层(输入层名称)

> 设置输入层名称
> 
> 输入层一般只有一个

- 参数 : 输入层名称 {字符串} 输入层名称
- 版本 : 1.8.3


```javascript
定义 检测对象 = $目标检测.创建(12);
检测对象.设置输入层("images");
```


### 设置输出层(输出层名称1)

> 设置输出层名称
> 
> 有些版本的模型输出层可能有多个，当模型输出层只有一个的时候可以使用这个函数。

- 参数 : 输出层名称1 {字符串} 输出层名称1
- 版本 : 1.8.3


```javascript
定义 检测对象 = $目标检测.创建(12);
检测对象.设置输出层("output1");
```


### 设置输出层(输出层名称1, 输出层名称2, 输出层名称3)

> 设置输出层名称
> 
> 有些版本的模型有多个输出层，但是有些输出层只有一个，即便你设置了三个，也只会生效第一个。

- 参数 : 输出层名称1 {字符串} 输出层名称1
- 参数 : 输出层名称2 {字符串} 输出层名称2
- 参数 : 输出层名称3 {字符串} 输出层名称3
- 版本 : 1.8.3


```javascript
定义 检测对象 = $目标检测.创建(12);
检测对象.设置输出层("output1", "output2", "output3");
```


### 获取id()

> 获取id

- 返回 : {字符串} id
- 版本 : 1.8.3


```javascript
定义 检测对象 = $目标检测.创建(12);
日志(检测对象.获取id());
```


### 释放资源()

> 释放资源
> 
> 释放资源，效果和 '关闭()' 等价

- 版本 : 1.8.3


```javascript
定义 检测对象 = $目标检测.创建(12);
检测对象.释放资源();
```


### 关闭()

> 关闭
> 
> 释放资源，效果和 '释放资源()' 等价

- 版本 : 1.8.3


```javascript
定义 检测对象 = $目标检测.创建(12);
检测对象.关闭();
```


# $yolo - 目标检测

- 更新时间:2025-12-13 11:58:47

> 目标检测
> 
> $yolo支持全系列的yolo版本：yoloV5、yoloV6、yoloV7、yoloV8、yoloV9、yoloV10、yoloV11、yoloV12、yoloV13；




### 创建(版本号)

> 创建yolo对象
> 
> 当前支持的Yolo版本有：YoloX、YoloV5、YoloV6、YoloV7、YoloV8、YoloV9、YoloV10、YoloV11、YoloV12、YoloV13，
> 当你传入版本号为0，则创建一个YoloX对象；当你传入版本号为5，则创建一个YoloV5对象；为11，则创建一个YoloV11对象，以此类推。
> 
> 每当创建一个yolo对象的时候，我会存储一个键值对[yoloId,yolo对象]，因此你可以在任何脚本中通过这个id拿到对象。

- 参数 : 版本号 {整数} yolo版本
- 返回 : {YoloObject} yolo对象
- 版本 : 1.8.3


```javascript
//首选创建一个对象
定义 检测对象 = $目标检测.创建(12);
//接下来就可以设置一些基础配置了
//使用gpu这个配置必须在初始化之前调用才能生效，其他的配置可以在任何地方调用
检测对象.设置使用gpu(是);//是否使用GPU加速
检测对象.设置尺寸(192,64);//注意尺寸必须是32的倍数
检测对象.设置相似度(0.5);//设置相似度
```


### 有(id)

> 是否有yolo对象

- 参数 : id {字符串} yoloID
- 返回 : {布尔值} 是否有
- 版本 : 1.8.3


```javascript
定义 yolo = $目标检测.create(12);
日志($目标检测.有(yolo.获取id()));//true
```


### 获取(id)

> 获取yolo对象

- 参数 : id {字符串} yoloID
- 返回 : {YoloObject} yolo对象
- 版本 : 1.8.3


```javascript
//[初始化脚本.js]:
定义 存储 = $存储.创建("我的YOLO");
定义 检测对象 = $目标检测.创建(12);
检测对象.设置尺寸(192,64);
检测对象.设置使用gpu(true);
存储.放入字符串("mYoloId",检测对象.获取Id());//保存yolo对象id
//[其他脚本.js]:
定义 存储 = $存储.创建("我的YOLO");
定义 检测对象 = $目标检测.获取(存储.获取字符串("mYoloId","null"));
检测对象.检测(图片);//使用yolo对象进行检测
```


### 关闭(id)

> 关闭yolo对象
> 
> 由于java端只是持有了C端的(yolo对象)对象句柄，双端的回收机制无法相互干涉，如果java端回收了对象，并不会回收C端的对象，因此需要手动释放资源。
> 
> 因此在使用yolo的时候，在初始化阶段就先存好一个yolo对象的ID，之后就可以在任何脚本中获取这个对象了。

- 参数 : id {字符串} yoloID
- 版本 : 1.8.3


```javascript
定义 yolo对象 = $目标检测.create(12);
//拿到id
定义 id = yolo对象.获取id();
//释放(C端)yolo对象
$目标检测.关闭(id);
```


### 关闭所有()

> 释放所有yolo对象
> 
> 由于java端只是持有了C端的(yolo对象)对象句柄，双端的回收机制无法相互干涉，如果java端回收了对象，并不会回收C端的对象，因此需要手动释放资源。
> 
> 因此在使用yolo的时候，在初始化阶段就先存好一个yolo对象的ID，之后就可以在任何脚本中获取这个对象了。

- 版本 : 1.8.3


```javascript
//释放所有(C端)yolo对象
$目标检测.关闭所有();
```


# 01.环境搭建

## 一、下载安装包

请前往[资源发布页面](/res/)找到对应的网盘链接后下载对应的资源，这里我使用[夸克网盘下载](https://pan.quark.cn/s/f069da62404f)作为演示案例：

### 1.下载安卓端安装包

![](./img/290500383193200.png)

![](./img/290536971270600.png)



### 2.下载电脑端开发工具

![](./img/290388851586800.png)

![](./img/290560734764100.png)

## 二、安装开发工具

### 1.安装安卓端

推荐直接安装在真机上，不过也可以下载最新版本的雷电模拟器进行安装。

:::danger 注意
不要使用mumu模拟器，该模拟器安装包签名算法被篡改，截屏权限也无法使用，不推荐！
:::

### 2.安装电脑端开发工具

将下载好的zip压缩包解压到自己喜欢的目录下即可。

![](./img/290911763117000.png)

![](./img/290992539953500.png)

双击快捷方式即可打开电脑端的开发工具




# 02.链接调试

## 一、链接调试

### 01.局域网调试

这里我使用雷电模拟器作为演示，首先你需要确保自己的模拟器开启了网络链接和桥接模式：

![](./img/292058507783500.png)

之后我们打开安卓端的AIGame程序以及电脑端的集成开发环境：


![](./img/292348153971600.png)




### 02.ADB调试

真机请确保自己手机打开开发者模式中的USB调试，模拟器需确保ADB开启本地链接调试，一般都是默认开启的，不过可以在模拟器的设置中查看：

![](./img/292561063118900.png)

之后在电脑端助手中选择自己需要链接的设备：

![](./img/292732409975400.png)


# 03.第一个程序

## 一、创建与运行

点击菜单按钮后，点击新建项目：

![](./img/292839104146500.png)

选择项目模板，输入项目名称和安卓位置即可：

![](./img/292970094348900.png)

## 二、运行项目

首先需要打开自己想要运行的代码，之后点击运行按钮，或者鼠标右键选择[运行]，或者按快捷键F5即可运行项目：

![](./img/293115610196400.png)

:::tip 注意
每次运行项目的时候，都会把整个项目都推送到安卓端，并且只会执行当前编辑器打开的脚本文件。
如果你的项目中使用了yolo模型文件，这样的文件都比较大，一般推荐你只运行一次（确保模型文件推送到安卓端）后，
在电脑端把模型文件删除，这样就只保留模型文件在安卓端了，不需要每次都把模型文件都推送过去。
:::

运行成功：

![](./img/293846062553300.png)
# 开始

这里我将教会你如何搭建开发环境，并且开发属于自己的脚本程序。

## [01.环境搭建](./01.环境搭建.md)

## [02.链接调试](./02.链接调试.md)

## [03.第一个程序](./03.第一个程序.md)
---
pageType: home

hero:
  name: AIGame
  text: 强大、安全、简洁
  tagline: 2025年最新一代安卓自动化脚本开发平台
  actions:
    - theme: brand
      text: 快速开始
      link: /guide/index
    - theme: alt
      text: 资源下载
      link: /res/
    - theme: alt
      text: 开发文档
      link: /api/act
  image:
    src: /ag_logo.svg
    alt: AIGame
  theme: dark
features:
  - title: OCR文字识别
    details: 支持PaddleOCR、GoogleMLKit、PPOcrV5识别框架。
    icon: 👁️
    link: /api/ocr
  - title: Yolo目标检测
    details: 支持YoloV5、V6、V7、V8、V9、V10、V11、V12、V13以及YoloX等框架
    icon: 🧩
    link: /api/yolo
  - title: 拓展性强
    details: 支持加载apk、dex、jar、so文件，以及支持Plugin插件开发。
    icon: 🛡️
    link: /api/ext
  - title: 兼容性强
    details: 支持安卓7+到安卓16的安卓系统、支持雷电模拟器、云手机等平台。
    icon: 📱
  - title: 防HOOK
    details: 打包时源码转为不可逆混淆码，不遵循任何语法规则，因此APK中没有源码，使用VMP混淆引擎执行混淆码，完美避免所有HOOK方案
    icon: 🛡️
  - title: 防抓包
    details: 传输协议高仿HTTPS，JSON字段加密混淆，使用高强度非对称加密传输，保证数据安全；并且APK使用高强度混淆源码，无法进行有效的抓包分析
    icon: 🌐
  - title: 防离线破解
    details: 打包后的APK会进行本地与云端双端签名校验，不通过校验则无法使用脚本引擎，部分脚本引擎存于云端，避免离线破解
    icon: 🔒
  - title: 执行效率高
    details: 打包后的APK脚本引擎直接执行混淆码，如同开发阶段直接执行源码一样，效率旗鼓相当
    icon: ⚡
---
# 产品优势



## 一、无法被破解

### 1.回顾历史

​	作者之前一直都是使用auto.js的，曾经有一段非常恼火的经历：用auto.js写了一个游戏辅助，花了将近半年的时间去维护、更新，当时我还建立了一个QQ群，群里都是使用我的游戏辅助的人，直到有一天，群里有个铁粉告诉我有人搬运我的软件，甚至连QQ群都抄袭我的，Q群管家的消息回复什么的都抄袭我的，后来我才知道这人不知道啥时候把我脚本源码掏出来了，我当时就破防了，他丫的！！

​	自从那一次开始，我就开始对auto.js产生了厌恶，不是软件不好，而是这软件开源，导致的最大的问题就是没有安全性可言，当时流行了一大堆的加密软件，同时也有一大堆一键解密的软件。哎，反正用auto.js的时候，还是需要跟别人斗智斗勇，我那个时候才刚开始了解脚本，也算是个小白，那些王八蛋也算是给我上了一课吧。

​	后来auto.js停服，我当时还在市面上火急火燎的找替代品，国内的自动化软件其实很多，但是那些UI我真的看不下去，太丑了，找了很多平台，要么就是入手太难了，要么就是只支持电脑端开发，几乎没有比auto.js好看又方便的软件了。

​	从2024年11月开始，我决定我要自己编写一个开发工具，不仅要超越auto.js，最重要的就是保证安全。于是，我开始规划开发，整个开发过程都采用逆向思维，并且不定期我会自己尝试破解自己的软件，尝试破解自己的脚本，直到我无法破解为止。因此：像什么算法助手、MT管理器、黄鸟之类的软件拿AIGame一点办法没有。

​	不过，我的技术实力有限，毕竟逆向这种东西，人外有人，那么我为什么敢说我的软件无法被破解呢？其实我这么说不太严谨，我应该说：AIGame打包后的脚本无法被人还原出来！！！！

### 2.无法还原

​	接下来我就告诉你为什么无法被还原？其实脚本引擎在执行代码之前，必须要先解密成脚本引擎能够读懂的代码才行，要想让机器懂，不让人懂，最直接的方法就是自己实现脚本引擎，于是我花了一个月的时间重新编写出了混淆引擎，这个引擎只能执行混淆码（由源码转换得来的），对于混淆引擎而言，混淆码就是源码。

​	所以啊，防止hook的最好办法不是防止hook，而是想办法让别人hook到的东西是坨垃圾。因为hook本身没办法防止，别人总有办法hook你。

​	刚刚聊的是本地运行的情况，AIGame最重要的地方在于：它需要联网才能执行！很多人最开始接触这个平台，觉得联网很麻烦，果然，只有懂行的人才能看出门道。如果软件不联网，那么它就没有安全性可言。说到这里肯定有些杠精要出来抬杠：“那不是可以抓包吗？”，这种人可能就是认为：只要能抓包，就一定能破解，纯属放屁！

​	这个世界上最安全的方式就是：混合开发+云服务器，这也就是AIGame采取的方式，我不知道有没有人逆向过AIGame的？如果你尝试过抓包，你会发现，你需要解密，如果你解密出来了，你会发现json的字段居然是混淆的，于是你又要硬着头皮去看apk中的二进制，分析出加密算法，分析出混淆字段的意思，可是当你打开apk的时候，你发现它还是混淆的......

### 3.总结一下

1. 高仿HTTPS传输协议、请求json字段混淆、多层加密、防抓包
2. 高仿JSVMP技术、字段混淆、字符串加密、函数名称加密、防HOOK



## 二、功能丰富简洁

​	其实软件最开始也只是给我自己自用的，没想到后来的需求这么大，于是在2025年4月发布了第一个测试版本。正是因为软件最开始是自己用，加上我这个人比较懒，于是api简洁、功能丰富的特点就展现出来了。

### 1.文件选择

​	一行代码就能调出一个文件选择器，专门用来选择文件的，支持单选、多选、文件、目录，支持后缀名过滤。

### 2.全局绘制

​	最主要就是在屏幕上绘制日志、线条、矩阵、圆圈、准心的，本质上基于悬浮窗来实现。

### 3.悬浮菜单

​	几行代码就能实现一个悬浮菜单按钮，支持展开收回动画、支持自动贴边动画、自动监听屏幕旋转、支持自定义按钮样式、你能想到的细节，我都搞定了。

### 4.API方便

​	AIGame的API简直方便到爆了，如果你还没用过，我就简单举几个例子吧：

#### 【1】$act - 手势动作

​	在$act手势动作里面，集成了$szk(Shizuku)、$root、无障碍等多种手势方案，只需用$act调用一个手势，自动匹配合适的触摸方案。

#### 【2】$ocr - 文字识别

​	在$ocr文字识别中，集成了PaddleOcr、PPOCRV5、GoogleMlkit等识别方案，只需要通过$ocr.v("mlkit");来指定识别引擎即可切换识别方案，不需要像其他平台那样一个识别引擎就要对应一套写法。

#### 【3】$yolo - 目标检测

​	yolo支持v5、6、7、8、9、10、11、12 。只需要通过$yolo.v(8);即可切换到yolov8来进行目标检测了，不需要一个版本就写一套代码。

上面举的例子也只是冰山一角，具体的细节还需要你自己去体会。



## 三、并发编程支持

​	由于我之前用的就是auto.js，它最大的问题就是不支持并发编程，虽然它确实支持多线程，但是其api不能并发，例如：我有两条线程，这两条线程都需要使用截屏函数，这种情况下，auto.js就会出大问题，比较经典的问题就是：截屏还没有被使用，就被另一条线程回收释放掉了。

​	在AIGame里面，我很看重脚本的并发，我允许多条线程使用图色，并且截屏之间独立，不会出现互相回收的情况，并且本身又自带回收机制，保证脚本无限运行下去。

​	不仅是图色、节点也支持多线程。



## 四、最终我说两句

​	Auto.js很好，它是前辈，也是带领我走进脚本行业的领头羊，但由于本身存在一些不可控的问题，我决定慢慢离开它，现在，我也终于可以不再依赖Auto.js了，希望AIGame会越来越好。








---
pageType: home

hero:
  name: AIGame
  text:
  tagline:
  actions:
    - theme: alt
      text: 阿里云盘
      link: https://www.alipan.com/s/8anEKwDN6ya
    - theme: alt
      text: 迅雷网盘
      link: https://pan.xunlei.com/s/VOcQTIlGWaGmJ43lKW8z67VhA1?pwd=7gcy#
    - theme: alt
      text: 百度网盘
      link: https://pan.baidu.com/s/1-1BAsKluxhCqBJbrsouvbQ?pwd=6666
    - theme: alt
      text: 夸克云盘
      link: https://pan.quark.cn/s/f069da62404f
    - theme: alt
      text: 123云盘
      link: https://www.123865.com/s/FfMGvd-9LsJ3
    - theme: alt
      text: AI知识库
      link: https://ima.qq.com/wiki/?shareId=c6620d25c102dac965bb7c701ab0344cba813557aa5730657beea506e5847c69
    - theme: alt
      text: 哔哩哔哩
      link: https://space.bilibili.com/3546959394638577
    - theme: alt
      text: QQ群聊
      link: https://qm.qq.com/q/IK4gvFKRic
    - theme: alt
      text: QQ频道
      link: https://pd.qq.com/s/d6mi9tsar
  image:
    src: /ag_logo.svg
    alt: AIGame
---
# 应用条布局

- 更新时间:2025-12-02 10:12:45

> 应用条布局-appbar-layout
> 
> 是布局父类的(XLayout)的子类
> 
> 原生类型:{com.google.android.material.appbar.AppBarLayout}




## 一、常用属性


### bg - 背景颜色

> 设置背景颜色


```xml
<appbar-layout bg="#FF0000">
</appbar-layout>
```


### bgImg - 背景图片

> 设置背景图片


```xml
<appbar-layout bgImg="/res/t01.png">
</appbar-layout>
```


### liftOnScroll - 是否启用滚动阴影

> 是否启用滚动阴影


```xml
<appbar-layout liftOnScroll="false">
</appbar-layout>
```


### padding - 内边距

> 设置内边距
> 
> 参数顺序:左,上,右,下(单位:dp)


```xml
<appbar-layout padding="0,0,0,0">
</appbar-layout>
```


### gravity - 重力

> 设置重力


```xml
<appbar-layout gravity="center">
</appbar-layout>
```


### setBg(color)

> 设置背景颜色

- 参数 : color {int} 颜色值


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获得控件
let abl = ui.get("mAppBarLayout");
//设置背景颜色
abl.setBg($color.RED);
```


### setBg(color)

> 设置背景颜色

- 参数 : color {string} 颜色值


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获得控件
let abl = ui.get("mAppBarLayout");
//设置背景颜色
abl.setBg("#000000");
```


# 应用条

- 更新时间:2025-12-02 10:12:45

> 应用条-appbar
> 
> 原生类型:{com.google.android.material.appbar.MaterialToolbar}
> 
> 在使用的时候最好配合[appbar-layout]组件一起使用




应用条是一个软件的顶部条，用来显示标题、操作按钮等。


![](./img/558715009602800.png)

## 一、常用属性


### title - 标题

> 设置标题


```xml
<ui>
    <!-- 状态栏 -->
    <statusbar/>
    <!-- 应用条需要配合此布局才能生效 -->
    <appbar-layout w="max">
        <appbar title="我是标题" w="max" />
    </appbar-layout>
</ui>
```


![](./img/556438552061700.png)

### subTitle - 副标题

> 设置副标题


```xml
<ui>
    <!-- 状态栏 -->
    <statusbar/>
    <!-- 应用条需要配合此布局才能生效 -->
    <appbar-layout w="max">
        <appbar subTitle="副标题" title="我是标题" w="max" />
    </appbar-layout>
</ui>
```


![](./img/556492040793400.png)

### titleColor - 标题颜色

> 设置标题颜色


```xml
<ui>
    <!-- 状态栏 -->
    <statusbar/>
    <!-- 应用条需要配合此布局才能生效 -->
    <appbar-layout w="max">
        <appbar titleColor="#B44A4A" title="我是标题" w="max" />
    </appbar-layout>
</ui>
```


![](./img/556534168069700.png)

### subTitleColor - 副标题颜色

> 设置副标题颜色


```xml
<ui>
    <!-- 状态栏 -->
    <statusbar />
    <!-- 应用条需要配合此布局才能生效 -->
    <appbar-layout w="max">
        <appbar subTitle="副标题" subTitleColor="#B44A4A" title="我是标题" w="max" />
    </appbar-layout>
</ui>
```


![](./img/556598502098800.png)

### bg - 背景颜色

> 设置背景颜色


```xml
<ui>
    <!-- 状态栏 -->
    <statusbar />
    <!-- 应用条需要配合此布局才能生效 -->
    <appbar-layout w="max">
        <appbar subTitle="副标题" bg="#345de6ff" title="我是标题" w="max" />
    </appbar-layout>
</ui>
```


![](./img/556657614089500.png)

### bgImg - 背景图片

> 设置背景图片


```xml
<ui>
    <!-- 状态栏 -->
    <statusbar />
    <!-- 应用条需要配合此布局才能生效 -->
    <appbar-layout w="max">
        <appbar titleColor="#FFFFFF" bgImg="/res/appbar-bg.png" title="我是标题" w="max" />
    </appbar-layout>
</ui>
```


![](./img/556860510275500.png)

### menu - 菜单节点

> 菜单节点
> 
> menu节点中拥有如下属性：
> 
> - text {string} 设置文本
> - icon {string} 设置图标
> - iconTint {string} 设置图标颜色
> - showAction {string} 菜单显示方式(always:总是显示;ifRoom:如果有空间才显示;never:从不显示;withtext:携带文本显示)
> - item {xml} 子菜单节点
> 
> item节点拥有如下属性：
> 
> - text {string} 设置文本
> - item {xml} 为子菜单设置子菜单节点(因此item节点中可以嵌套写自己的item子菜单节点)


```xml
<!--[用法一]只用主菜单-->
<appbar back="true" bg="#F1F0FA" subTitle="安卓自动化平台..." title="主菜单"
    w="max">
    <menu icon="ic_menu_line" iconTint="#000000" text="菜单" />
    <menu icon="ic_home_fill" iconTint="#000000" text="主页" />
    <menu icon="ic_3d" iconTint="#000000" text="转换" />
</appbar>
```

```xml
<!--[用法二]多级子菜单-->
<appbar back="true" bg="#F1F0FA" subTitle="可设置多级子菜单" title="子菜单" w="max">
    <menu>
        <item text="菜单1" />
        <item text="菜单2" />
        <item text="菜单3">
            <!--item中还允许添加item子菜单-->
            <item text="菜单3-1" />
            <item text="菜单3-2">
                <item text="菜单3-2-1" />
                <item text="菜单3-2-2" />
                <item text="菜单3-2-3" />
            </item>
            <item text="菜单3-3" />
        </item>
    </menu>
</appbar>
```


#### 示例：主菜单


```xml
<ui>
    <!-- 状态栏 -->
    <statusbar />
    <!-- 应用条需要配合此布局才能生效 -->
    <appbar-layout w="max">
        <appbar title="我是标题" w="max">
            <menu icon="ic_menu_line" iconTint="#000000" text="菜单" />
            <menu icon="ic_home_fill" iconTint="#000000" text="主页" />
            <menu icon="ic_3d" iconTint="#000000" text="转换" />
        </appbar>
    </appbar-layout>
</ui>
```


![](./img/557417348724400.png)

#### 示例：多级子菜单


```xml
<ui>
    <!-- 状态栏 -->
    <statusbar />
    <!-- 应用条需要配合此布局才能生效 -->
    <appbar-layout w="max">
        <appbar title="我是标题" w="max">
            <menu icon="ic_menu_line" iconTint="#000000" text="菜单" />
            <menu icon="ic_home_fill" iconTint="#000000" text="主页" />
            <menu icon="ic_more" iconTint="#000000" text="更多">
                <item text="菜单1-1" />
                <item text="菜单1-2" />
                <item text="菜单1-3">
                    <!-- item 中还可以继续嵌套子item -->
                    <item text="菜单2-1" />
                    <item text="菜单3-2" />
                </item>
            </menu>
        </appbar>
    </appbar-layout>
</ui>
```


![](./img/557700754691000.gif)

### back - 启用返回按钮

> 设置启用返回按钮


```xml
<ui>
    <!-- 状态栏 -->
    <statusbar />
    <!-- 应用条需要配合此布局才能生效 -->
    <appbar-layout w="max">
        <appbar back="true" title="我是标题" w="max" />
    </appbar-layout>
</ui>
```


![](./img/556937828243900.png)

### padding - 内边距

> 设置内边距


```xml
<ui>
    <!-- 状态栏 -->
    <statusbar />
    <!-- 应用条需要配合此布局才能生效 -->
    <appbar-layout w="max">
        <appbar title="我是标题" subTitle="我没有内边距" w="max" />
    </appbar-layout>
    <!-- 分割线 -->
    <hr />
    <appbar-layout w="max">
        <!--padding顺序是:左,上,右,下-->
        <!--padding只设置一个值：则设置所有方向的内边距-->
        <!--padding只设置两个值：则设置左右和上下方向的内边距-->
        <appbar padding="50" title="我是标题" subTitle="我有内边距" w="max" />
    </appbar-layout>
</ui>
```


![](./img/557150663620200.png)

## 二、常用函数


### setTitle(title)

> 设置标题

- 参数 : title {string} 标题


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUI.xml");
//拿到控件
let appbar = ui.id("appbar");
//设置标题
appbar.setTitle("标题");
```


### setSubTitle(subTitle)

> 设置副标题

- 参数 : subTitle {string} 副标题


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUI.xml");
//拿到控件
let appbar = ui.id("appbar");
//设置副标题
appbar.setSubTitle("副标题");
```


### setTitleColor(color)

> 设置标题颜色

- 参数 : color {int} 颜色值


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUI.xml");
//拿到控件
let appbar = ui.id("appbar");
//设置标题颜色
appbar.setTitleColor($color.RED);
```


### setTitleColor(color)

> 设置标题颜色

- 参数 : color {string} 颜色值


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUI.xml");
//拿到控件
let appbar = ui.id("appbar");
//设置标题颜色
appbar.setTitleColor("#1E1F22");
```


### setSubTitleColor(color)

> 设置副标题颜色

- 参数 : color {int} 颜色值


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUI.xml");
//拿到控件
let appbar = ui.id("appbar");
//设置副标题颜色
appbar.setSubTitleColor($color.RED);
```


### setSubTitleColor(color)

> 设置副标题颜色

- 参数 : color {string} 颜色值


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUI.xml");
//拿到控件
let appbar = ui.id("appbar");
//设置副标题颜色
appbar.setSubTitleColor("#1E1F22");
```


### setBg(color)

> 设置背景颜色

- 参数 : color {int} 颜色值


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUI.xml");
//拿到控件
let appbar = ui.id("appbar");
//设置背景颜色
appbar.setBg($color.RED);
```


### setBg(color)

> 设置背景颜色

- 参数 : color {string} 颜色值


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUI.xml");
//拿到控件
let appbar = ui.id("appbar");
//设置背景颜色
appbar.setBg("#1E1F22");
```


### back(callback)

> 监听返回事件

- 参数 : callback {(view)=>{}} 返回按钮点击事件


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUI.xml");
//拿到控件
let appbar = ui.id("appbar");
//返回按钮点击事件
appbar.back((view)=>{
    //一般标题的返回按钮就是退出界面:
    ui.finish();
});
```


### menu(callback)

> 监听菜单事件

- 参数 : callback {(title)=>{}} 菜单点击事件


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUI.xml");
//拿到控件
let appbar = ui.id("appbar");
//返回菜单点击事件
appbar.menu((title)=>{
    if(title == "菜单1"){
          //菜单1点击事件
    }
});
```


### bind(drawer)

> 绑定drawer

- 参数 : drawer {drawer}


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUI.xml");
//拿到控件
let appbar = ui.id("appbar");
let drawer = ui.id("drawer");
//让appbar与drawer联动
appbar.bind(drawer);
```


# 按钮组

- 更新时间:2025-12-02 10:12:45

> 按钮组-button-group
> 
> 是布局父类的(XLayout)的子类
> 
> 原生类型:{com.google.android.material.button.MaterialButtonToggleGroup}




## 一、常用属性


### dir - 布局方向

> 设置布局方向
> 
> 可选参数:v(纵向),h(横向)


```xml
<button-group dir="h">
    <button text="按钮1"/>
    <button text="按钮2"/>
</button-group>
```


### bg - 背景颜色

> 设置背景颜色


```xml
<button-group bg="#FF0000">
    <button text="按钮1"/>
    <button text="按钮2"/>
</button-group>
```


### bgImg - 背景图片

> 设置背景图片


```xml
<button-group bgImg="/res/t01.png">
    <button text="按钮1"/>
    <button text="按钮2"/>
</button-group>
```


### singleSelect - 是否是单选模式

> 是否是单选模式


```xml
<button-group singleSelect="false">
    <button text="按钮1"/>
    <button text="按钮2"/>
</button-group>
```


### selectRequire - 是否至少选一个

> 是否至少选一个
> 
> 只在单选模式下有效


```xml
<button-group selectRequire="false">
    <button text="按钮1"/>
    <button text="按钮2"/>
</button-group>
```


### padding - 内边距

> 设置内边距
> 
> 参数顺序:左,上,右,下(单位:dp)


```xml
<button-group padding="0,0,0,0"/>
```


### gravity - 重力

> 设置重力
> 
> 可选值参考重力参数表


```xml
<button-group gravity="center">
    <button text="按钮1"/>
    <button text="按钮2"/>
</button-group>
```


### check(index)

> 选中按钮

- 参数 : index {int} 按钮下标


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获得控件
let bg = ui.get("mButtonGroup");
//选中按钮
bg.check(0);
```


### onCheck(callback)

> 监听选中按钮的下标

- 参数 : callback ((index)=>{}) 回调


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获得控件
let bg = ui.id("mButtonGroup");
//监听选中按钮的下标
bg.onCheck((index)=>{
    $ui.toast(index);
});
```


# 按钮

- 更新时间:2025-12-02 10:12:45

> 按钮-button
> 
> 按钮控件{XButton}是属于{XView}的子控件，因此{XView}中的所有方法，按钮控件都可以调用。




按钮是界面的最简单的元素，一般用于点击操作。


![](./img/778378960274000.png)

## 一、基础使用

其实按钮本身是没有点击事件的，由于它继承了父类{XView}，因此可以调用其父类中的函数来实现点击操作。

事实上，所有的组件都是继承自{XView}的，因此都可以调用{XView}中的方法。


```xml
<ui>
    <statusbar />
    <button id="mBut" text="点击我试试" />
</ui>
```

```javascript
let ui = $ui.layout("ui.xml");
ui.show();//显示界面
//找到界面中的元素并且实现点击事件
ui.id("mBut").click(() => {
    info("我被点击了");
});
```


## 二、常用属性


### text - 文本

> 设置文本


```xml
<ui>
    <statusbar />
    <!-- 设置文本 -->
    <button text="我是文本" />
</ui>
```


![](./img/600153960859500.png)

### style - 样式

> 设置样式
> 
> 可选值有："text","outline","tonal","icon"


```xml
<ui>
    <statusbar />
    <!-- 横向排列 -->
    <linear dir="h" w="max">
        <button text="默认样式" />
        <button style="text" text="文本样式" />
        <button style="outline" text="边框样式" />
    </linear>
    <linear dir="h" w="max">
        <button style="tonal" text="色调样式" />
        <button style="icon" icon="ic_app" text="图标样式" />
    </linear>
</ui>
```


![](./img/600281077680600.png)

### color - 主题颜色

> 设置主题颜色


```xml
<ui>
    <statusbar />
    <!-- 居中显示 -->
    <linear dir="h" w="max" gravity="center">
        <button color="#57965C" text="主题颜色" />
    </linear>
</ui>
```


![](./img/600364675873000.png)

### textColor - 文本颜色

> 设置文本颜色


```xml
<ui>
    <statusbar />
    <!-- 居中显示 -->
    <linear dir="h" w="max" gravity="center">
        <button textColor="#B44A4A" text="文字颜色" />
    </linear>
</ui>
```


![](./img/600422263719900.png)

### ripper - 涟漪颜色

> 设置涟漪颜色


```xml
<ui>
    <statusbar />
    <!-- 居中显示 -->
    <linear dir="h" w="max" gravity="center">
        <button ripper="#000000" text="涟漪颜色:黑色"/>
    </linear>
</ui>
```


![](./img/601608518790900.gif)

### radius - 弧度

> 设置弧度


```xml
<ui>
    <statusbar />
    <!-- 居中显示 -->
    <linear dir="h" w="max" gravity="center">
        <button radius="8" text="圆角弧度:8dp"/>
        <button radius="15" text="圆角弧度:15dp"/>
    </linear>
</ui>
```


![](./img/601694565747000.png)

### textSize - 文本尺寸

> 设置文本尺寸


```xml
<ui>
    <statusbar />
    <!-- 居中显示 -->
    <linear dir="h" w="max" gravity="center">
        <button text="文本尺寸15" textSize="15"/>
        <button text="文本尺寸25" textSize="25"/>
    </linear>
</ui>
```


![](./img/601744822203500.png)

### icon - 图标

> 设置图标


```xml
<ui>
    <statusbar />
    <!-- 居中显示 -->
    <linear dir="h" w="max" gravity="center">
        <button text="设置图标" icon="ic_delete"/>
    </linear>
</ui>
```


![](./img/601776838398600.png)

### iconTint - 图标颜色

> 设置图标颜色


```xml
<ui>
    <statusbar />
    <!-- 居中显示 -->
    <linear dir="h" w="max" gravity="center">
        <button text="图标颜色" iconTint="#FF0000" icon="ic_delete"/>
    </linear>
</ui>
```


![](./img/601830127286500.png)

### iconSize - 图标尺寸

> 设置图标尺寸


```xml
<ui>
    <statusbar />
    <!-- 居中显示 -->
    <linear dir="h" w="max" gravity="center">
        <button text="图标尺寸:11" iconSize="11" icon="ic_delete"/>
        <button text="图标尺寸:25" iconSize="25" icon="ic_delete"/>
    </linear>
</ui>
```


![](./img/601894667150800.png)

### iconPadding - 图标内边距

> 设置图标内边距


```xml
<ui>
    <statusbar />
    <!-- 居中显示 -->
    <linear dir="h" w="max" gravity="center">
        <button text="图标内边距:5" iconPadding="5" icon="ic_delete"/>
        <button text="图标内边距:35" iconPadding="35" icon="ic_delete"/>
    </linear>
</ui>
```


![](./img/601986765134300.png)

### minW - 最小宽度

> 设置最小宽度
> 
> 单位:dp


```xml
<button minW="100" />
```


### minH - 最小高度

> 设置最小高度
> 
> 单位:dp


```xml
<button minH="100" />
```


### padding - 内边距

> 设置内边距


```xml
<ui>
    <statusbar />
    <!-- 居中显示 -->
    <linear dir="h" w="max" gravity="center">
        <!--padding顺序是:左,上,右,下-->
        <!--padding只设置一个值：则设置所有方向的内边距-->
        <!--padding只设置两个值：则设置左右和上下方向的内边距-->
        <button padding="10" text="内边距:10"/>
        <button padding="20" text="内边距:20"/>
    </linear>
</ui>
```


![](./img/602097525451800.png)

### gravity - 重力

> 设置重力


```xml
<ui>
    <statusbar />
    <!-- 为了让重力效果更直观，我将按钮增高增宽显示 -->
    <button gravity="start" text="重力:start" w="max" h="60"/>
    <button gravity="end" text="重力:end" w="max" h="60" />
</ui>
```


![](./img/602259747821900.png)

### bg - 背景颜色

> 设置背景颜色


```xml
<ui>
    <statusbar />
    <linear w="max" gravity="center">
        <button bg="#1E1F22" text="背景颜色" />
    </linear>
</ui>
```


![](./img/602360756370100.png)

### bgImg - 背景图片

> 设置背景图片


```xml
<ui>
    <statusbar />
    <linear w="max" gravity="center">
        <button bgImg="/res/button-bg.png" text="背景图片" textColor="#000000" />
    </linear>
</ui>
```


![](./img/602999329953200.png)

## 三、常用函数


### setGravity(gravity)

> 设置重力

- 参数 : gravity {String} 例如:"center|bottom"


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获得控件
let mBut = ui.id("mButton");
//设置重力
mBut.setGravity("center|bottom");
```


### setTypeface(typeface)

> 设置字体

- 参数 : typeface {int} 字体类型(使用AgUi中的常量,例如:$ui.BOLD)


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获得控件
let mBut = ui.id("mButton");
//设置字体
mBut.setTypeface($ui.BOLD);//常用值：$ui.NORMAL,$ui.ITALIC,$ui.BOLD,$ui.BOLD_ITALIC
```


### setColor(color)

> 设置主题颜色

- 参数 : color {int} 颜色


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获得控件
let mBut = ui.id("mButton");
//设置红色
mBut.setColor($color.RED);
//设置成主题的颜色(具体颜色请参考$color文档)
//mBut.setColor($color.parse("colorPrimary"));
```


### setColor(color)

> 设置主题颜色

- 参数 : color {String} 颜色


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获得控件
let mBut = ui.id("mButton");
//设置主题颜色
mBut.setColor("#1E1F22");
```


### setText(text)

> 设置文字

- 参数 : text {String} 文字


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获得控件
let mBut = ui.id("mButton");
//设置文字
mBut.setText("我是按钮");
```


### getText()

> 获得文字
> 
> 如果获取的文本为null则会返回空字符串

- 返回 : {String} 文字


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获得控件
let mBut = ui.id("mButton");
//获得文字
let text = mBut.getText("我是按钮");
```


### setTextColor(color)

> 设置文字颜色

- 参数 : color {String} 颜色


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获得控件
let mBut = ui.id("mButton");
//设置文字颜色
mBut.setTextColor("#1E1F22");
```


### setTextColor(color)

> 设置文字颜色

- 参数 : color {int} 颜色


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获得控件
let mBut = ui.id("mButton");
//设置文字颜色
mBut.setTextColor($color.RED);
```


### setRipper(color)

> 设置涟漪颜色

- 参数 : color {int} 颜色


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获得控件
let mBut = ui.id("mButton");
//设置涟漪颜色
mBut.setRipper($color.RED);
```


### setRipper(color)

> 设置涟漪颜色

- 参数 : color {string} 颜色


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获得控件
let mBut = ui.id("mButton");
//设置涟漪颜色
mBut.setRipper("#1E1F22");
```


### setRadius(radius)

> 设置弧度

- 参数 : radius {int} 弧度


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获得控件
let mBut = ui.id("mButton");
//设置弧度
mBut.setRadius(20);
```


### setTextSize(size)

> 设置字体大小

- 参数 : size {float} 字体大小


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获得控件
let mBut = ui.id("mButton");
//设置字体大小(单位:sp)
mBut.setTextSize(20);
```


### setIcon(icon)

> 设置图标

- 参数 : icon {string} 图标


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获得控件
let mBut = ui.id("mButton");
//设置图标
mBut.setIcon("logo_ag");
```


### setIconTint(color)

> 设置图标颜色

- 参数 : color {int} 图标颜色


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获得控件
let mBut = ui.id("mButton");
//设置图标
mBut.setIcon("logo_ag");
//设置图标颜色
mBut.setIconTint($color.RED);
```


### setIconTint(color)

> 设置图标颜色

- 参数 : color {string} 图标颜色


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获得控件
let mBut = ui.id("mButton");
//设置图标
mBut.setIcon("logo_ag");
//设置图标颜色
mBut.setIconTint("#1E1F22");
```


### setIconSize(size)

> 设置图标尺寸

- 参数 : size {int} 图标尺寸


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获得控件
let mBut = ui.id("mButton");
//设置图标
mBut.setIcon("logo_ag");
//设置图标尺寸(单位:dp)
mBut.setIconSize(15);
```


### setIconPadding(padding)

> 设置图标内边距

- 参数 : padding {int} 设置图标内边距


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获得控件
let mBut = ui.id("mButton");
//设置图标
mBut.setIcon("logo_ag");
//设置图标内边距
mBut.setIconPadding(8);
```


# 多选框

- 更新时间:2025-12-02 10:12:46

> 多选框-check
> 
> 原生类型:{com.google.android.material.checkbox.MaterialCheckBox}
> 
> 多选框控件{XCheck}是属于{XView}的子控件，因此{XView}中的所有方法，多选框控件都可以调用。




多选框一般用于：用户同意、配置多种选择、筛选数据等场景。


![](./img/603425381833700.png)

## 一、基础用法


```xml
<ui>
    <statusbar />
    <linear w="max" dir="h" gravity="center">
        <check id="mCheck" text="同意协议"/>
    </linear>
</ui>
```

```javascript
let ui = $ui.layout("ui.xml");
ui.show();//显示界面
//找到界面中的元素并且实现点击事件
ui.id("mCheck").onCheck((checked,comButton) => {
    if(checked){
        info("我被选中了");
    }else{
        info("没有被选中");
    }
});
```


## 二、常用属性


### text - 文本

> 设置文本


```xml
<ui>
    <statusbar />
    <linear w="max" dir="h" gravity="center">
        <check text="多选按钮" />
        <check text="多选按钮" checked="true" />
    </linear>
</ui>
```


![](./img/603260635087900.png)

### check - 选中

> 设置选中


```xml
<ui>
    <statusbar />
    <linear w="max" dir="h" gravity="center">
        <check text="多选按钮" />
        <check text="多选按钮" check="true" />
    </linear>
</ui>
```


![](./img/603260635087900.png)

### color - 主题颜色

> 设置主题颜色


```xml
<ui>
    <statusbar />
    <linear w="max" dir="h" gravity="center">
        <check text="多选按钮" color="#B44A4A" />
        <check text="多选按钮" color="#518855" />
    </linear>
</ui>
```


![](./img/603336275352200.png)

### tint - 按钮颜色

> 设置按钮颜色


```xml
<ui>
    <statusbar />
    <linear w="max" gravity="center" dir="h">
        <check tint="#518855" text="吃饭" checked="true" />
        <check tint="#C94F4F" text="睡觉" checked="true" />
        <check tint="#000000" text="游戏" checked="true" />
    </linear>
</ui>
```


![](./img/604177490718900.png)

### textColor - 文本颜色

> 设置文本颜色


```xml
<ui>
    <statusbar />
    <linear w="max" gravity="center" dir="h">
        <check textColor="#518855" text="吃饭" />
        <check textColor="#C94F4F" text="睡觉" />
        <check textColor="#000000" text="游戏" />
    </linear>
</ui>
```


![](./img/604260297998000.png)

### minW - 最小宽度

> 设置最小宽度
> 
> 单位:dp


```xml
<check minW="100dp" />
```


### minH - 最小高度

> 设置最小高度
> 
> 单位:dp


```xml
<check minH="100dp" />
```


### padding - 内边距

> 设置内边距


```xml
<ui>
    <statusbar />
    <linear w="max" gravity="center" dir="h">
        <check  padding="5" text="边距:5" />
        <check  padding="20" text="边距:20" />
        <check  padding="40" text="边距:40" />
    </linear>
</ui>
```


![](./img/604346296862000.png)

### gravity - 对齐方式

> 设置对齐方式


```xml
<ui>
    <statusbar />
    <!-- 为了让重力效果更加直观，这里都让宽度最大 -->
    <check w="max" text="重力:左" gravity="left" />
    <check w="max" text="重力:中" gravity="center" />
    <check w="max" text="重力:右" gravity="right" />
</ui>
```


![](./img/604487412932300.png)

### bg - 背景颜色

> 设置背景颜色


```xml
<ui>
    <statusbar />
    <linear w="max" gravity="center">
        <check text="背景颜色" bg="#453C39" />
    </linear>
</ui>
```


![](./img/604588586545200.png)

### bgImg - 背景图片

> 设置背景图片


```xml
<ui>
    <statusbar />
    <linear w="max" gravity="center">
        <check text="背景图片" bgImg="/res/button-bg.png" />
    </linear>
</ui>
```


![](./img/604659582346500.png)

## 三、常用函数


### onCheck(callback)

> 设置选中监听
> 
> 当选中状态改变时,会回调该函数
> 
> 注意在1.5.9版本之后,该函数回调的参数顺序为(isChecked,view)，之前的版本是(view,isChecked)

- 参数 : callback {(isChecked,view)=>{}} 选中监听


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获得控件
let mCheck = ui.id("mCheck");
//设置选中监听
mCheck.onCheck((isChecked,view)=>{
    if(isChecked){
        ui.toast("选中");
    }else{
        ui.toast("没有选中");
    }
});
```


### isChecked()

> 判断是否选中

- 返回 : {boolean} true:选中,false:没有选中


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获得控件
let mCheck = ui.id("mCheck");
//判断是否选中
let is = mCheck.isChecked();
if(is){
    toast("选中");
}else{
    toast("没有选中");
}
```


### check(checked)

> 设置选中的状态

- 参数 : checked {boolean} true:选中,false:没有选中


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获得控件
let mCheck = ui.id("mCheck");
//设置选中的状态
mCheck.check(true);
```


### setGravity(gravity)

> 设置控件的对齐方式

- 参数 : gravity {String} 例如:"center|bottom"


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获得控件
let mCheck = ui.id("mCheck");
//设置重力
mCheck.setGravity("center");
```


### setText(text)

> 设置文字

- 参数 : text {String} 文字


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获得控件
let mCheck = ui.id("mCheck");
//设置文字
mCheck.setText("记住密码");
```


### getText()

> 获得文字
> 
> 如果获取的文本为null则返回空字符串

- 返回 : {String} 文字


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获得控件
let mCheck = ui.id("mCheck");
//获得文字
let text = mCheck.getText();
```


### setColor(color)

> 设置主题颜色

- 参数 : color {String} 颜色


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获得控件
let mCheck = ui.id("mCheck");
//设置主题颜色
mCheck.setColor("#1E1F22");
```


### setColor(color)

> 设置主题颜色

- 参数 : color {int} 颜色


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获得控件
let mCheck = ui.id("mCheck");
//设置主题颜色
mCheck.setColor($color.RED);
```


### setTextColor(color)

> 设置文字颜色

- 参数 : color {String} 颜色


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获得控件
let mCheck = ui.id("mCheck");
//设置主题颜色
mCheck.setTextColor("#1E1F22");
```


### setTextColor(color)

> 设置文字颜色

- 参数 : color {int} 颜色


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获得控件
let mCheck = ui.id("mCheck");
//设置主题颜色
mCheck.setTextColor($color.RED);
```


### setBg(color)

> 设置背景颜色

- 参数 : color {String} 颜色


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获得控件
let mCheck = ui.id("mCheck");
//设置背景颜色
mCheck.setBg("#1E1F22");
```


### setBg(color)

> 设置背景颜色

- 参数 : color {int} 颜色


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获得控件
let mCheck = ui.id("mCheck");
//设置背景颜色
mCheck.setBg($color.RED);
```


# 小片组

- 更新时间:2025-12-02 10:12:46

> 小片组-chip-group
> 
> 是布局父类的(XLayout)的子类
> 
> 原生类型:{com.google.android.material.chip.ChipGroup}




## 一、常用属性


### bg - 背景颜色

> 设置背景颜色


```xml
<chip-group bg="#FF0000" />
```


### bgImg - 背景图片

> 设置背景图片


```xml
<chip-group bgImg="res/t01.png" />
```


### padding - 内边距

> 设置内边距


```xml
<chip-group padding="0,0,0,0" />
```


### check(text)

> 选中指定文本的小片
> 
> 该方法会选中所有文本相同的小片

- 参数 : text {string} 文本


```javascript
//解析布局,获取ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let mChipGroup = ui.id("mChipGroup");
//选中指定文本的小片
mChipGroup.check("选项1");
```


### inverse(text)

> 反选指定文本
> 
> 如果文本匹配则选中，否则就取消选中。

- 参数 : text {string} 文本


```javascript
//解析布局,获取ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let mChipGroup = ui.id("mChipGroup");
//选中指定文本
mChipGroup.inverse("选项1");
```


### check(index)

> 选中指定下标的小片

- 参数 : index {int} 下标


```javascript
//解析布局,获取ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let mChipGroup = ui.id("mChipGroup");
//选中指定下标的小片
mChipGroup.check(0);
```


### childCount()

> 获取子项数量

- 返回 : {int} 子项数量


```javascript
//解析布局,获取ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let mChipGroup = ui.id("mChipGroup");
//获取子项数量
let count = mChipGroup.childCount();
```


### getChild(index)

> 获取指定下标下的子项
> 
> 该函数返回的是Chip类型的子项目，而不是本应用封装的XChip类型，对Chip进行操作时需要放在ui线程中操作。

- 参数 : index {int} 下标
- 返回 : {chip} 子项


```javascript
//解析布局,获取ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let mChipGroup = ui.id("mChipGroup");
//获取指定下标下的子项
let chip = mChipGroup.getChild(0);
```


# 小片

- 更新时间:2025-12-02 10:12:46

> 小片-chip
> 
> 原生类型:{com.google.android.material.chip.Chip}
> 
> 可以当作小按钮来使用，也可以当作多选框来使用




小片：可以用来显示一些小标签什么的，还是蛮好看的。

不过，也可以用来作为按钮使用。


![](./img/612185892757200.png)

## 一、常用属性


### text - 文本

> 设置文本


```xml
<ui>
    <statusbar />
    <linear w="max" dir="h" gravity="center">
        <chip text="我是小片" />
    </linear>
</ui>
```


![](./img/611371618523400.png)

### icon - 图标

> 设置图标


```xml
<ui>
    <statusbar />
    <linear w="max" dir="h" gravity="center">
        <chip icon="logo_ag" text="我是小片" />
    </linear>
</ui>
```


![](./img/611437937349600.png)

### iconTint - 图标颜色

> 设置图标颜色


```xml
<ui>
    <statusbar />
    <linear w="max" dir="h" gravity="center">
        <chip icon="ic_delete" iconTint="#FF0000" text="我是小片" />
    </linear>
</ui>
```


![](./img/611478093404000.png)

### textColor - 文本颜色

> 设置文本颜色


```xml
<ui>
    <statusbar />
    <linear w="max" dir="h" gravity="center">
        <chip textColor="#518855" text="我是小片" />
    </linear>
</ui>
```


![](./img/611544871472300.png)

### textSize - 文本尺寸

> 设置文本尺寸
> 
> 单位:sp


```xml
<ui>
    <statusbar />
    <linear w="max" dir="h" gravity="center">
        <chip textSize="11" text="字体:11" />
        <chip textSize="16" text="字体:16" />
    </linear>
</ui>
```


![](./img/611601063213900.png)

### radius - 弧度

> 设置弧度


```xml
<ui>
    <statusbar />
    <linear w="max" dir="h" gravity="center">
        <chip radius="11" text="弧度:11" />
        <chip radius="16" text="弧度:16" />
    </linear>
</ui>
```


![](./img/611656213275200.png)

### checkable - 是否可以选中

> 设置是否可以选中


```xml
<ui>
    <statusbar />
    <linear w="max" dir="h" gravity="center">
        <chip checkable="true" text="可选中" />
        <chip text="未选中" />
    </linear>
</ui>
```


![](./img/611719142241000.png)

### showCheckIcon - 是否显示选中图标

> 是否显示选中图标


```xml
<ui>
    <statusbar />
    <linear w="max" dir="h" gravity="center">
        <chip checkable="true" showCheckIcon="true" text="可选中" />
        <chip text="未选中" />
    </linear>
</ui>
```


![](./img/611768470381600.png)

### checkIconTint - 选中图标颜色

> 设置选中图标颜色


```xml
<ui>
    <statusbar />
    <linear w="max" dir="h" gravity="center">
        <chip checkable="true" checkIconTint="#518855" showCheckIcon="true" text="可选中" />
        <chip text="未选中" />
    </linear>
</ui>
```


![](./img/611802972426800.png)

### clickable - 是否可以点击

> 设置是否可以点击


```xml
<ui>
    <statusbar />
    <linear w="max" dir="h" gravity="center">
        <chip clickable="true" text="可点击" />
        <chip clickable="false" text="不可点击" />
    </linear>
</ui>
```


![](./img/611886165669900.png)

### showCloseIcon - 是否显示关闭按钮

> 是否显示关闭按钮


```xml
<ui>
    <statusbar />
    <linear w="max" dir="h" gravity="center">
        <chip showCloseIcon="true" text="显示关闭按钮" />
    </linear>
</ui>
```


![](./img/611945468348700.png)

### closeIconTint - 关闭按钮的颜色

> 设置关闭按钮的颜色


```xml
<ui>
    <statusbar />
    <linear w="max" dir="h" gravity="center">
        <chip showCloseIcon="true" closeIconTint="#FF0000" text="显示关闭按钮" />
    </linear>
</ui>
```


![](./img/612063532482400.png)

### ripper - 涟漪颜色

> 设置涟漪颜色


```xml
<ui>
    <statusbar />
    <linear w="max" dir="h" gravity="center">
        <chip ripper="#518855" text="涟漪颜色" />
    </linear>
</ui>
```


![](./img/612120925836200.png)

### color - 主题颜色

> 设置主题颜色


```xml
<ui>
    <statusbar />
    <linear w="max" dir="h" gravity="center">
        <chip color="#518855" text="小片" />
        <chip color="#B44A4A" text="小片" />
        <chip color="#3574F0" text="小片" />
    </linear>
</ui>
```


![](./img/612185892757200.png)

### minW - 最小宽度

> 设置最小宽度
> 
> 单位:dp


```xml
<chip minW="100" />
```


### minH - 最小高度

> 设置最小高度
> 
> 单位:dp


```xml
<chip minH="100" />
```


### padding - 内边距

> 设置内边距
> 
> 单位:dp


```xml
<ui>
    <statusbar />
    <linear w="max" dir="h" gravity="center">
        <chip padding="5" text="内边距:5" />
        <chip padding="25" text="内边距:25" />
    </linear>
</ui>
```


![](./img/612340787909600.png)

## 二、常用函数


### check(checked)

> 设置选中状态

- 参数 : checked {boolean} 选中状态


```javascript
//解析布局,获取ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let mChip = ui.id("mChip");
//设置选中状态
mChip.check(true);
```


### isChecked()

> 判断是否选中

- 返回 : {boolean} 是否选中


```javascript
//解析布局,获取ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let mChip = ui.id("mChip");
//获取选中状态
let is = mChip.isChecked();
if (is) {
    toast("选中");
}else{
    toast("未选中");
}
```


### onClose(callback)

> 监听关闭事件

- 参数 : callback {(view)=>{}} 关闭回调


```javascript
//解析布局,获取ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let mChip = ui.id("mChip");
//监听关闭事件
mChip.onClose((v)=>{
    //我被关闭了
});
```


### onCheck(callback)

> 监听选中事件

- 参数 : callback {(isChecked)=>{}} 选中回调


```javascript
//解析布局,获取ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let mChip = ui.id("mChip");
//监听选中事件
mChip.onCheck((is)=>{
    if (is) {
         toast("选中");
    }
});
```


### setText(text)

> 设置文本

- 参数 : text {string} 文字


```javascript
//解析布局,获取ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let mChip = ui.id("mChip");
//设置文本
mChip.setText("我是小片");
```


### getText()

> 获得文本

- 返回 : {string} 文字


```javascript
//解析布局,获取ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let mChip = ui.id("mChip");
//获取文本
let text = mChip.getText();
```


# 下拉框

- 更新时间:2025-12-02 10:12:46

> 下拉框-drop
> 
> 布局原生类型:{com.google.android.material.textfield.TextInputLayout}
> 组件原生类型:{com.google.android.material.textfield.MaterialAutoCompleteTextView}




下拉框类似于一个小菜单，点一下才会展开让你选，核心用途就是帮你方便、规范地挑东西。


![](./img/775261983393400.png)

## 一、基础用法


```xml
<ui>
    <statusbar />
    <linear w="max" padding="15" gravity="center" h="max">
        <drop id="mDrop" w="max">
            <!-- 添加选项 -->
            <item text="吃饭" />
            <item text="睡觉" />
            <item text="电影" />
        </drop>
    </linear>
</ui>
```

```javascript
//解析布局
let ui = $ui.layout("ui.xml");
ui.show();//显示界面
//为下拉框添加选中事件
ui.id("mDrop").onCheck((value, index) => {
    info("选中下标为:" + index + "的元素:" + value);
});
```


## 二、常用属性


### style - 样式

> 设置样式
> 
> 可选:fill,outline


```xml
<ui>
    <statusbar />
    <linear w="max" padding="100" gravity="center">
        <drop style="outline" w="max">
            <item text="吃饭" />
            <item text="睡觉" />
        </drop>
        <drop style="fill" w="max">
            <item text="吃饭" />
            <item text="睡觉" />
        </drop>
    </linear>
</ui>
```


![](./img/775987544222400.png)

### hint - 提示文字

> 设置提示文字


```xml
<ui>
    <statusbar />
    <linear w="max" padding="100" gravity="center">
        <drop hint="你的爱好" style="outline" w="max">
            <item text="吃饭" />
            <item text="睡觉" />
        </drop>
    </linear>
</ui>
```


![](./img/776048049257900.png)

### def - 默认文字

> 设置默认文字


```xml
<ui>
    <statusbar />
    <linear w="max" padding="100" gravity="center">
        <drop hint="你的爱好" def="吃饭" style="outline" w="max">
            <item text="吃饭" />
            <item text="睡觉" />
        </drop>
    </linear>
</ui>
```


![](./img/776048049257900.png)

### item - 子选项

> 设置子选项
> 
> 子选项使用item标签，只有text一个属性


```xml
<ui>
    <statusbar />
    <linear w="max" gravity="center">
        <drop id="mDrop" w="max">
            <!-- 添加选项 -->
            <item text="吃饭" />
            <item text="睡觉" />
            <item text="电影" />
        </drop>
    </linear>
</ui>
```


![](./img/775261983393400.png)

### color - 主题颜色

> 设置主题颜色


```xml
<ui>
    <statusbar />
    <linear w="max" padding="100" gravity="center">
        <drop color="#B44A4A" style="outline" w="max">
            <item text="吃饭" />
            <item text="睡觉" />
        </drop>
    </linear>
</ui>
```


![](./img/776155047288900.png)

### textColor - 文字的颜色

> 设置文字的颜色


```xml
<ui>
    <statusbar />
    <linear w="max" padding="100" gravity="center">
        <drop color="#B44A4A" textColor="#57965C" style="outline" w="max">
            <item text="吃饭" />
            <item text="睡觉" />
        </drop>
    </linear>
</ui>
```


![](./img/776208807917600.png)

### hideIcon - 是否隐藏后面的倒三角图标

> 是否隐藏后面的倒三角图标


```xml
<ui>
    <statusbar />
    <linear w="max" padding="100" gravity="center">
        <drop hideIcon="true" style="outline" w="max">
            <item text="吃饭" />
            <item text="睡觉" />
        </drop>
    </linear>
</ui>
```


![](./img/776250206768600.png)

### gravity - 布局重力

> 设置布局重力


```xml
<ui>
    <statusbar />
    <linear w="max" padding="100" gravity="center">
        <drop hideIcon="true" gravity="center" style="outline" w="max">
            <item text="吃饭" />
            <item text="睡觉" />
        </drop>
    </linear>
</ui>
```


![](./img/776511197330000.png)

### padding - 布局内边距

> 设置布局内边距
> 
> 单位:dp


```xml
<ui>
    <statusbar />
    <linear w="max" padding="100" gravity="center">
        <drop hideIcon="true" padding="20" style="outline" w="max">
            <item text="吃饭" />
            <item text="睡觉" />
        </drop>
    </linear>
</ui>
```


![](./img/776457374823400.png)

### bg - 背景颜色

> 设置背景颜色


```xml
<ui>
    <statusbar />
    <linear w="max" padding="100" gravity="center">
        <drop bg="#518855" style="outline" w="max">
            <item text="吃饭" />
            <item text="睡觉" />
        </drop>
    </linear>
</ui>
```


![](./img/776583835610600.png)

### bgImg - 背景图片

> 设置背景图片


```xml
<ui>
    <statusbar />
    <linear w="max" padding="100" gravity="center">
        <drop bgImg="/res/bg-drop.png" style="outline" w="max">
            <item text="吃饭" />
            <item text="睡觉" />
        </drop>
    </linear>
</ui>
```


![](./img/776800912434000.png)

## 三、常用函数


### onCheck(callback)

> 事件监听

- 参数 : callback {(title,index)=>{}} 回调


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let drop = ui.id("mDrop");
//监听选中事件
drop.onCheck((title,index)=>{
    toast(title);
});
```


### setText(text)

> 设置文字

- 参数 : text {string} 文字


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let drop = ui.id("mDrop");
//设置文字
drop.setText("选项1");
```


### getText()

> 获得文字

- 返回 : {string} 文字


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let drop = ui.id("mDrop");
//获取文本
let text = drop.getText();
```


### flush(items)

> 设置数据

- 参数 : items {string[]} 数据


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let drop = ui.id("mDrop");
//设置数据
drop.flush(["张三","李四","王五"]);
```


# 编辑框

- 更新时间:2025-12-02 10:12:46

> 编辑框-edit
> 
> 原生类型:{androidx.appcompat.widget.AppCompatEditText}




这是一种小巧的输入框

edit比input输入框更加小巧一些，是安卓原生拓展库的组件，而input输入框是M3风格的组件。


![](./img/791094562061700.png)

## 一、常用属性


### hint - 提示文本

> 设置提示文本


```xml
<ui>
    <statusbar />
    <linear padding="50" w="max" gravity="center">
        <edit hint="请输入:" />
    </linear>
</ui>
```


![](./img/789754995220700.png)

### text - 文本

> 设置文本


```xml
<ui>
    <statusbar />
    <linear padding="50" w="max" gravity="center">
        <edit text="文字内容" />
    </linear>
</ui>
```


![](./img/789794472910300.png)

### textColor - 文本颜色

> 设置文本颜色


```xml
<ui>
    <statusbar />
    <linear padding="50" w="max" gravity="center">
        <edit text="文字内容" textColor="#57965C" />
    </linear>
</ui>
```


![](./img/789852347187200.png)

### def - 默认文本

> 设置默认文本


```xml
<ui>
    <statusbar />
    <linear padding="50" w="max" gravity="center">
        <edit def="默认文本" />
    </linear>
</ui>
```


![](./img/789904227177000.png)

### type - 输入内容的类型

> 输入内容的类型
> 
> 可选值:
> pass:密码,
> num:数字,
> phone:手机号


```xml
<ui>
    <statusbar />
    <linear padding="50" w="max" gravity="center">
        <edit text="abcdef" type="pass" />
    </linear>
</ui>
```


![](./img/789950243159000.png)

### size - 文本尺寸

> 设置文本尺寸
> 
> 单位:sp


```xml
<ui>
    <statusbar />
    <linear padding="50" w="max" gravity="center">
        <edit size="16" text="文本大小:16" />
        <edit size="20" text="文本大小:20" />
    </linear>
</ui>
```


![](./img/790008794448600.png)

### minW - 最小宽度

> 设置最小宽度
> 
> 单位:dp


```xml
<ui>
    <statusbar />
    <linear padding="50" w="max" gravity="center">
        <edit minW="300" text="最小宽度:300" />
        <edit text="正常宽度" />
    </linear>
</ui>
```


![](./img/790077178825600.png)

### minH - 最小高度

> 设置最小高度
> 
> 单位:dp


```xml
<edit minH="100" />
```


### gravity - 布局重力

> 设置布局重力


```xml
<ui>
    <statusbar />
    <linear padding="50" w="max" gravity="center">
        <edit w="max" gravity="center" text="我的文本" />
    </linear>
</ui>
```


![](./img/790128473724600.png)

### padding - 布局内边距

> 设置布局内边距


```xml
<ui>
    <statusbar />
    <linear padding="50" w="max" gravity="center">
        <edit padding="20" text="我的文本" />
    </linear>
</ui>
```


![](./img/790180053900700.png)

### bg - 背景颜色

> 设置背景颜色


```xml
<ui>
    <statusbar />
    <linear padding="50" w="max" gravity="center">
        <edit bg="#518855" text="我的文本" />
    </linear>
</ui>
```


![](./img/790211858032800.png)

### bgImg - 背景图片

> 设置背景图片


```xml
<ui>
    <statusbar />
    <linear padding="50" w="max" gravity="center">
        <edit bgImg="/res/bg-edit.png" text="我的文本" textColor="#FFFFFF" gravity="center" />
    </linear>
</ui>
```


![](./img/790487260539500.png)

## 二、常用函数


### getText()

> 获取输入框内容

- 返回 : {string} 内容


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let edit = ui.id("mEdit");
//获取输入框内容
let text = edit.getText();
```


### setError(msg)

> 设置异常信息提示

- 参数 : msg {string} 异常提示


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let edit = ui.id("mEdit");
//设置异常信息提示
edit.setError("输入内容不能为空");
```


### setText(text)

> 设置文字

- 参数 : text {string} 文字内容


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let edit = ui.id("mEdit");
//设置文字
edit.setText("新的内容");
```


### onChanged(callback)

> 监听文本改变

- 参数 : callback {(text,start,before,count)=>{}} 监听回调
- 版本 : 1.8.0


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let mInput = ui.id("mInput");
//监听文本改变
mInput.onChanged((text,start,before,count)=>{
    log("文本改变了:"+text);
});
```


### onChangedAfter(callback)

> 监听文本改变后

- 参数 : callback {(text)=>{}} 监听回调
- 版本 : 1.8.0


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let mInput = ui.id("mInput");
//监听文本改变
mInput.onChangedAfter((text)=>{
    log("文本改变了:"+text);
});
```


### onChangedBefore(callback)

> 监听文本改变前

- 参数 : callback {(text,start,count,after)=>{}} 监听回调
- 版本 : 1.8.0


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let mInput = ui.id("mInput");
//监听文本改变
mInput.onChangedBefore((text,start,count,after)=>{
    log("文本改变了:"+text);
});
```


# 悬浮按钮

- 更新时间:2025-12-02 10:12:46

> 悬浮按钮-fab
> 
> 原生类型:{com.google.android.material.floatingactionbutton.FloatingActionButton}




一般配合帧布局：将按钮放在帧布局的上层来实现悬浮效果。


![](./img/818776736622200.png)

## 一、常用属性


### color - 主题颜色

> 设置主题颜色


```xml
<ui>
    <statusbar />
    <linear w="max" gravity="center" h="max" padding="20">
        <fab color="#518855" />
    </linear>
</ui>
```


![](./img/817959591075700.png)

### icon - 图标

> 设置图标


```xml
<ui>
    <statusbar />
    <linear w="max" gravity="center" h="max" padding="20">
        <fab icon="ic_menu" />
    </linear>
</ui>
```


![](./img/818014187410700.png)

### path - 路径图标

> 设置路径图标


```xml
<ui>
    <statusbar />
    <linear w="max" gravity="center" h="max" padding="20">
        <fab path="/res/girl-1.png" />
    </linear>
</ui>
```


![](./img/818346252598700.png)

### iconTint - 图标颜色

> 设置图标颜色


```xml
<ui>
    <statusbar />
    <linear w="max" gravity="center" h="max" padding="20">
        <fab icon="ic_home" iconTint="#0000FF" />
    </linear>
</ui>
```


![](./img/818432990911800.png)

### tip - 提示

> 设置提示
> 
> 安卓8+才支持这个配置


```xml
<ui>
    <statusbar />
    <linear w="max" gravity="center" h="max" padding="20">
        <fab tip="我是按钮" />
    </linear>
</ui>
```


![](./img/818574196509000.png)

### radius - 弧度

> 设置弧度


```xml
<ui>
    <statusbar />
    <linear w="max" dir="h" gravity="center" h="max" padding="20">
        <fab radius="10" margin="5" />
        <fab radius="20" margin="5" />
        <fab radius="45" margin="5" />
    </linear>
</ui>
```


![](./img/818698319302600.png)

### size - 尺寸

> 设置尺寸


```xml
<ui>
    <statusbar />
    <linear w="max" dir="h" gravity="center" h="max" padding="20">
        <fab size="35" margin="5" />
        <fab size="40" margin="5" />
        <fab size="45" margin="5" />
    </linear>
</ui>
```


![](./img/818776736622200.png)

## 二、常用函数


### show()

> 显示悬浮按钮


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let fab = ui.id("mFab");
//显示控件
fab.show();
```


### hide()

> 隐藏悬浮按钮


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let fab = ui.id("mFab");
//隐藏控件
fab.hide();
```


### setColor(color)

> 设置主题颜色

- 参数 : color {String} 颜色


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let fab = ui.id("mFab");
//设置主题颜色
fab.setColor("#1E1F22");
```


### setIcon(icon)

> 设置图标

- 参数 : icon {String} 图片名称


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let fab = ui.id("mFab");
//设置图标
fab.setIcon("logo_ag");
```


### setTip(tip)

> 设置提示信息

- 参数 : tip {String} 提示信息


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let fab = ui.id("mFab");
//设置提示信息
fab.setTip("开始执行");
```


# 分割线

- 更新时间:2025-12-02 10:12:46

> 分割线-hr
> 
> 原生类型:{com.google.android.material.divider.MaterialDivider}




## 一、常用属性


### color - 颜色

> 设置颜色


```xml
<hr color="#F1F0FA" w="max" />
```


![](./img/777137928282500.png)

### size - 尺寸(px)

> 设置尺寸(px)


```xml
<ui>
    <statusbar />
    <linear w="max" h="max" gravity="center">
        <hr size="5" w="max" margin="20" />
        <hr size="10" w="max" margin="20" />
        <hr size="15" w="max" margin="20" />
    </linear>
</ui>
```


![](./img/777215933092900.png)

### start - 开始边距(dp)

> 设置开始边距(dp)


```xml
<ui>
    <statusbar />
    <linear w="max" h="max" gravity="center">
        <hr w="max" start="20" margin="20"  />
        <hr w="max" end="20" margin="20" />
        <hr w="max" start="20" end="20" margin="20"  />
    </linear>
</ui>
```


![](./img/777340110166300.png)

### end - 结束边距(dp)

> 设置结束边距(dp)


```xml
<ui>
    <statusbar />
    <linear w="max" h="max" gravity="center">
        <hr w="max" start="20" margin="20"  />
        <hr w="max" end="20" margin="20" />
        <hr w="max" start="20" end="20" margin="20"  />
    </linear>
</ui>
```


![](./img/777340110166300.png)

## 二、常用函数


### size(size)

> 设置粗细

- 参数 : size {int} 粗细(px)


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let hr = ui.id("mHr");
//设置粗细
hr.size(20);
```


### insertStart(start)

> 设置开始边距

- 参数 : start {int} 开始边距


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let hr = ui.id("mHr");
//设置开始边距
hr.insertStart(20);
```


### insertEnd(end)

> 设置结束边距

- 参数 : end {int} 结束边距


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let hr = ui.id("mHr");
//设置结束边距
hr.insertEnd(20);
```


### setColor(color)

> 设置主题颜色

- 参数 : color {String} 颜色


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let hr = ui.id("mHr");
//设置主题颜色
hr.setColor("#1E1F22");
```


# 图片与图标

- 更新时间:2025-12-02 10:12:46

> 图片-img
> 
> 常用于显示图片或者图标
> 
> 原生类型:{com.google.android.material.imageview.ShapeableImageView}




图片(图标)：用于显示图片或者图标


![](./img/819952284073000.png)

## 一、常用属性


### radius - 圆弧半径

> 设置圆弧半径
> 
> 单位:dp


```xml
<img radius="16"/>
```


### url - 图片链接

> 设置图片链接


```xml
<img url="http://..."/>
```


### strokeWidth - 边框宽度

> 设置边框宽度
> 
> 单位:dp


```xml
<img strokeWidth="5"/>
```


### strokeColor - 边框颜色

> 设置边框颜色


```xml
<img strokeColor="#FF0000"/>
```


### scaleType - 拉伸类型

> 设置拉伸类型
> 
> 可选(忽略大小写,可忽略下划线):FIT_CENTER, FIT_START, FIT_END, FIT_XY, CENTER, CENTER_CROP, CENTER_INSIDE, MATRIX


```xml
<img scaleType="fitxy"/>
```


### tint - 图片填充颜色

> 设置图片填充颜色


```xml
<img tint="#FF0000"/>
```


### path - 图片本地路径

> 设置图片本地路径


```xml
<img path="/res/t01.png"/>
```


### src - 图片或图标路径

> 设置图片或图标路径


```xml
<img src="/res/t01.png"/>
```


### rotation - 旋转角度

> 设置旋转角度


```xml
<img rotation="45"/>
```


### rotateSpeed - 自动旋转的倍速

> 设置自动旋转的倍速


```xml
<img rotateSpeed="3"/>
```


### rotate - 是否自动旋转

> 是否自动旋转


```xml
<img rotate="true"/>
```


### padding - 内边距

> 设置内边距


```xml
<!--padding顺序是:左,上,右,下-->
<!--padding只设置一个值：则设置所有方向的内边距-->
<!--padding只设置两个值：则设置左右和上下方向的内边距-->
<img padding="20" />
```


### gravity - 重力

> 设置重力


```xml
<img gravity="start" />
```


### bg - 背景颜色

> 设置背景颜色


```xml
<img bg="#1E1F22" />
```


### bgImg - 背景图片

> 设置背景图片


```xml
<img bgImg="./img.png" />
```


## 二、常用函数


### rotate(rotated)

> 图片自动旋转

- 参数 : rotated {boolean} 是否旋转


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let mImg = ui.id("mImg");
//设置图片自动旋转
mImg.rotate(true);
```


### rotate(rotated, speed)

> 图片自动旋转

- 参数 : rotated {boolean} 是否旋转
- 参数 : speed {float} 旋转速度


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let mImg = ui.id("mImg");
//设置图片自动旋转
mImg.rotate(true,10);
```


### setRotation(rotation)

> 设置角度

- 参数 : rotation {float} 角度


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let mImg = ui.id("mImg");
//设置角度
mImg.setRotation(45);
```


### setSrc(src)

> 设置图标

- 参数 : src {string} 设置图片名称,并且加载名称上的图片


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let mImg = ui.id("mImg");
//设置图标
mImg.setSrc("logo_ag");
```


### setUrl(url)

> 设置图片Url

- 参数 : url {string} 设置图片Url,并且加载Url上的图片


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let mImg = ui.id("mImg");
//设置图片链接(这里我随便弄了个链接)
mImg.setUrl("https://www.baidu.com/icon.png  ");
```


### setPath(path)

> 设置图片路径

- 参数 : path {string} 设置图片路径,并且加载路径上的图片


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let mImg = ui.id("mImg");
//设置图片
mImg.setPath("./res/mImg.png");
```


### setImg(bitmap)

> 设置图片

- 参数 : bitmap {bitmap} 设置的图片


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let mImg = ui.id("mImg");
//设置图片
let img = $img.read("./res/mImg.png");
mImg.setImg(img.getBitmap());
```


### getImg()

> 获取图片

- 返回 : {bitmap} 获取到的图片


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let mImg = ui.id("mImg");
//获取图片
let bitmap = mImg.getImg();
//构建$img对象
let img = $img.open(bitmap);
```


# UI框架

- 更新时间:2025-12-02 10:12:44



UI框架是基于谷歌[Material 3](https://m3.material.io/)进行拓展，封装了全部控件以及布局。 甚至封装了组件式的控件，可以帮助开发者快速完成界面开发。

与此同时，提供了大量界面模板，你可以在软件示例中找到，也可以在本文档中找到。


![](./img/ui-demo.png)

#### UI框架设计图

UI框架中最大的类是XView类，其余的所有视图都是XView的子类，因此XView类中的所有方法都可以被其子类调用。
其中XLayout是XView的子类，也是所有布局类型的父类，所以XLayout类的所有方法都可以被其子类调用。

例如1：XView类中有'click(点击监听)'方法，这个方法可以监听点击事件，因此所有的子组件都可以调用这个方法监听点击事件。

例如2：XLayout类中有'addView(添加视图)'方法，这个方法可以使得布局动态添加一个子视图，'linear(线性布局)'是XLayout的子类，因此可以调用'addView'方法添加子视图。


![](./img/ui-fragment.png)

# 输入框

- 更新时间:2025-12-02 10:12:46

> 输入框-input
> 
> 组件原生类型:{com.google.android.material.textfield.TextInputEditText}
> 
> 布局原生类型:{com.google.android.material.textfield.TextInputLayout}




输入框：一个可以输入文字的地方。


![](./img/820325920861600.png)

## 一、基础用法


简单写一个登录的小案例，当点击登录按钮的时候就获取用户输入的信息，当点击取消按钮的时候就清空用户输入的内容：


```xml
<ui>
    <statusbar />
    <linear w="max" dir="v" gravity="center" h="max" padding="20">
        <input id="count" prefix="账号:" w="max" />
        <input id="pass" prefix="密码:" type="pass" w="max"  />
        <button-group dir="h" w="max">
            <button id="login" text="登录" style="outline" weight="1"/>
            <button id="cancel" text="取消" style="outline" weight="1" textColor="#B44A4A" />
        </button-group>
    </linear>
</ui>
```

```javascript
let ui = $ui.layout("ui.xml");
ui.show();
//[登录]获取用户输入的信息
ui.id("login").click(() => {
    let count = ui.id("count").getText();
    let pass = ui.id("pass").getText();
    alert("账号信息", "账号：" + count + "\n" + "密码：" + pass);
});
//[取消]清空用户输入的内容
ui.id("cancel").click(() => {
    ui.id("count").setText("");
    ui.id("pass").setText("");
    toast("已清空");
});
```


![](./img/820824673352400.png)

## 二、常用属性


### style - 样式

> 设置样式
> 
> 可选:fill,outline


```xml
<ui>
    <statusbar />
    <linear w="max" dir="v" gravity="center" h="max" padding="20">
        <input style="outline" text="outline样式" w="max" />
        <input style="fill" text="fill样式" w="max" />
    </linear>
</ui>
```


![](./img/820949440675300.png)

### hint - 提示文本

> 提示文本


```xml
<ui>
    <statusbar />
    <linear w="max" dir="v" gravity="center" h="max" padding="20">
        <input hint="请输入" w="max" />
    </linear>
</ui>
```


![](./img/820994282465600.png)

### text - 文本

> 设置文本


```xml
<ui>
    <statusbar />
    <linear w="max" dir="v" gravity="center" h="max" padding="20">
        <input hint="请输入" text="默认文字" w="max" />
    </linear>
</ui>
```


![](./img/821030258658900.png)

### def - 文本

> 设置文本


```xml
<ui>
    <statusbar />
    <linear w="max" dir="v" gravity="center" h="max" padding="20">
        <input hint="请输入" def="默认文字" w="max" />
    </linear>
</ui>
```


![](./img/821030258658900.png)

### len - 字数限制

> 设置字数限制


```xml
<ui>
    <statusbar />
    <linear w="max" dir="v" gravity="center" h="max" padding="20">
        <input len="50" w="max" />
    </linear>
</ui>
```


![](./img/821083337465700.png)

### maxLines - 最大行数

> 最大行数


```xml
<ui>
    <statusbar />
    <linear w="max" dir="v" gravity="center" h="max" padding="20">
        <input maxLines="3" w="max" />
    </linear>
</ui>
```


![](./img/821119836418400.png)

### minLines - 最少行数

> 最少行数


```xml
<ui>
    <statusbar />
    <linear w="max" dir="v" gravity="center" h="max" padding="20">
        <input minLines="3" w="max" />
    </linear>
</ui>
```


![](./img/821175683477700.png)

### help - 帮助文字

> 帮助文字


```xml
<ui>
    <statusbar />
    <linear w="max" dir="v" gravity="center" h="max" padding="20">
        <input help="可以输入中文" w="max" />
    </linear>
</ui>
```


![](./img/821206691453200.png)

### prefix - 前缀

> 设置前缀


```xml
<ui>
    <statusbar />
    <linear w="max" dir="v" gravity="center" h="max" padding="20">
        <input prefix="账号:" w="max" />
    </linear>
</ui>
```


![](./img/821271802433400.png)

### suffix - 后缀

> 设置后缀


```xml
<ui>
    <statusbar />
    <linear w="max" dir="v" gravity="center" h="max" padding="20">
        <input suffix="@qq.com" text="2450099002" w="max" />
    </linear>
</ui>
```


![](./img/821352843824200.png)

### type - 输入类型

> 设置输入类型
> 
> 可选:pass,number,phone


```xml
<ui>
    <statusbar />
    <linear w="max" dir="v" gravity="center" h="max" padding="20">
        <input type="pass" text="2450099002" w="max" />
    </linear>
</ui>
```


![](./img/821385266215300.png)

### bg - 背景颜色

> 设置背景颜色


```xml
<ui>
    <statusbar />
    <linear w="max" dir="v" gravity="center" h="max" padding="20">
        <input bg="#518855" w="max" />
    </linear>
</ui>
```


![](./img/821580281488000.png)

### bgImg - 背景图片

> 设置背景图片


```xml
<ui>
    <statusbar />
    <linear w="max" dir="v" gravity="center" h="max" padding="20">
        <input bgImg="/res/bg-input.png" w="max" />
    </linear>
</ui>
```


![](./img/821546252782500.png)

### color - 主题颜色

> 设置主题颜色


```xml
<ui>
    <statusbar />
    <linear w="max" dir="v" gravity="center" h="max" padding="20">
        <input color="#518855" text="主题颜色" w="max" />
        <input color="#B44A4A" text="主题颜色" w="max" />
    </linear>
</ui>
```


![](./img/821636371377900.png)

### textColor - 文本颜色

> 设置文本颜色


```xml
<ui>
    <statusbar />
    <linear w="max" dir="v" gravity="center" h="max" padding="20">
        <input textColor="#518855" text="文字颜色" w="max" />
        <input textColor="#B44A4A" text="文字颜色" w="max" />
    </linear>
</ui>
```


![](./img/821676700688800.png)

### strokeColor - 边框颜色

> 设置边框颜色


```xml
<ui>
    <statusbar />
    <linear w="max" dir="v" gravity="center" h="max" padding="20">
        <input strokeColor="#518855" text="边框颜色" w="max" />
    </linear>
</ui>
```


![](./img/821724818089500.png)

### strokeWidth - 边框宽度

> 设置边框宽度


```xml
<ui>
    <statusbar />
    <linear w="max" dir="v" gravity="center" h="max" padding="20">
        <input strokeWidth="3" text="边框宽度" w="max" />
        <input strokeWidth="6" text="边框宽度" w="max" />
    </linear>
</ui>
```


![](./img/821782108879300.png)

### radius - 弧度

> 设置弧度


```xml
<ui>
    <statusbar />
    <linear w="max" dir="v" gravity="center" h="max" padding="20">
        <input text="设置弧度" radius="16" w="max" />
        <input text="设置弧度" radius="0,16" w="max" />
        <input text="设置弧度" radius="20,5,5,20" w="max" />
    </linear>
</ui>
```


![](./img/821891654121600.png)

### padding - 布局内边距

> 设置布局内边距


```xml
<ui>
    <statusbar />
    <linear w="max" dir="v" gravity="center" h="max" padding="20">
        <!-- 左、上、右、下 -->
        <input text="设置弧度" padding="30,30,30,30" w="max" />
    </linear>
</ui>
```


![](./img/822117009830400.png)

### gravity - 布局重力

> 布局重力


```xml
<ui>
    <statusbar />
    <linear w="max" dir="v" gravity="center" h="max" padding="20">
        <input text="设置重力" gravity="center" w="max" />
    </linear>
</ui>
```


![](./img/822196996553700.png)

## 三、常用函数


### setHint(hint)

> 设置预提示

- 参数 : hint {string} 预提示


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let mInput = ui.id("mInput");
//设置预提示
mInput.setHint("请输入名字");
```


### setBgColor(color)

> 设置背景颜色

- 参数 : color {string} 颜色


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let mInput = ui.id("mInput");
//设置背景颜色
mInput.setBgColor("#ff0000");//也可以是M3主题动态色，例如:colorPrimary
```


### setStrokeColor(color)

> 设置边框颜色

- 参数 : color {string} 颜色
- 版本 : 1.5.3


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let mInput = ui.id("mInput");
//设置边框颜色
mInput.setStrokeColor("#ff0000");//也可以是M3主题动态色，例如:colorPrimary
```


### setStrokeWidth(strokeWidth)

> 设置边框宽度

- 参数 : strokeWidth {int} 宽度
- 版本 : 1.5.3


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let mInput = ui.id("mInput");
//设置边框宽度
mInput.setStrokeWidth(5);//单位:dp
```


### setRadius(topLeft, topRight, bottomLeft, bottomRight)

> 设置弧度

- 参数 : topLeft {float} 左上
- 参数 : topRight {float} 上右
- 参数 : bottomLeft {float} 左下
- 参数 : bottomRight {float} 右下
- 版本 : 1.5.3


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let mInput = ui.id("mInput");
//设置边框弧度
mInput.setRadius(20,20,5,5);//单位:dp
```


### setText(text)

> 设置文字

- 参数 : text {string} 文字内容


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let mInput = ui.id("mInput");
//设置文本
mInput.setText("我是文字");
```


### getText()

> 获取输入框内容

- 返回 : {string} 内容


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let mInput = ui.id("mInput");
//获得文本
let text = mInput.getText();
```


### setError(msg)

> 设置异常信息提示

- 参数 : msg {string} 异常提示


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let mInput = ui.id("mInput");
//设置异常提示
mInput.setError("错啦");
```


### getEditText()

> 获得TextInputEditText对象

- 返回 : {TextInputEditText} 编辑框对象


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let mInput = ui.id("mInput");
//获得TextInputEditText对象
let editText = mInput.getEditText();
```


### onChanged(callback)

> 监听文本改变

- 参数 : callback {(text,start,before,count)=>{}} 监听回调
- 版本 : 1.8.0


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let mInput = ui.id("mInput");
//监听文本改变
mInput.onChanged((text,start,before,count)=>{
    log("文本改变了:"+text);
});
```


### onChangedAfter(callback)

> 监听文本改变后

- 参数 : callback {(text)=>{}} 监听回调
- 版本 : 1.8.0


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let mInput = ui.id("mInput");
//监听文本改变
mInput.onChangedAfter((text)=>{
    log("文本改变了:"+text);
});
```


### onChangedBefore(callback)

> 监听文本改变前

- 参数 : callback {(text,start,count,after)=>{}} 监听回调
- 版本 : 1.8.0


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let mInput = ui.id("mInput");
//监听文本改变
mInput.onChangedBefore((text,start,count,after)=>{
    log("文本改变了:"+text);
});
```


### onFocusChange(callback)

> 监听焦点改变

- 参数 : callback {(hasFocus)=>{}} 监听回调
- 版本 : 1.8.2


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let mInput = ui.id("mInput");
//监听焦点改变
mInput.onFocusChange((hasFocus)=>{
    log("焦点改变了:"+hasFocus);
});
```


# 绝对布局

- 更新时间:2025-12-02 10:12:44

> 绝对布局-absolute
> 
> 是布局父类的(XLayout)的子类,因此可以使用XLayout的所有方法
> 
> 原生类型:{android.widget.AbsoluteLayout}




### bg - 背景颜色

> 设置背景颜色


```xml
<absolute bg="#57965C" />
```


### bgImg - 背景图片

> 设置背景图片


```xml
<absolute bgImg="res/t01.png" />
```


### padding - 内边距

> 设置内边距
> 
> 参数顺序:左,上,右,下(单位:dp)


```xml
<absolute padding="0,0,0,0" />
```


### gravity - 重力

> 设置重力
> 
> 绝对布局只能设置前景重力，并且要求安卓6.0+。


```xml
<absolute gravity="center" />
```


## 子控件属性表

被绝对布局包裹的子控件可以使用如下属性：

| 中文名   | 英文名    | 描述                                                         |
|----------|-----------|--------------------------------------------------------------|
| 横轴     | x         | 设置视图在AbsoluteLayout中的横轴（X轴）位置                   |
| 纵轴     | y         | 设置视图在AbsoluteLayout中的纵轴（Y轴）位置                   |
| 解决方向 | resolveDir | 确定视图应遵循的实际布局方向，可选值为“rtl”（右到左）或“ltr”（左到右） |
| 宽       | w         | 设置视图的宽度，可选值为“auto”（自动，即WRAP_CONTENT）、“max”（最大，即MATCH_PARENT）或具体整数（单位为dp） |
| 高       | h         | 设置视图的高度，可选值为“auto”（自动，即WRAP_CONTENT）、“max”（最大，即MATCH_PARENT）或具体整数（单位为dp） |


# 卡片布局

- 更新时间:2025-12-02 10:12:44

> 卡片布局-card
> 
> 是布局父类的(XLayout)的子类,因此可以使用XLayout的所有方法,但需要注意卡片布局本身是帧布局的子类，因此建议在卡片布局中加入线性布局来使用。
> 
> 原生类型:{com.google.android.material.card.MaterialCardView}




## 一、常用属性


### style - 风格

> 设置风格
> 
> 可选值:fill,outline,elevate


```xml
<card style="outline" />
```


### clickable - 是否可以点击

> 设置是否可以点击


```xml
<card clickable="true" />
```


### ripper - 涟漪颜色

> 设置涟漪颜色


```xml
<card ripper="red" />
```


### radius - 弧度

> 设置弧度
> 
> 单位:dp


```xml
<card radius="10" />
```


### minW - 最小宽度

> 设置最小宽度
> 
> 单位:dp


```xml
<card minW="20" />
```


### minH - 最小高度

> 设置最小高度
> 
> 单位:dp


```xml
<card minH="20" />
```


### bg - 背景颜色

> 设置背景颜色


```xml
<card bg="#57965C" />
```


### tint - 填充颜色

> 设置填充颜色
> 
> 背景颜色会无视卡片的圆弧角度，填充颜色会填充整个卡片，并且保证卡片的角度和样式


```xml
<card tint="#57965C" />
```


### bgImg - 背景图片

> 设置背景图片


```xml
<card bgImg="res/t01.png" />
```


### padding - 内边距

> 设置内边距
> 
> 参数顺序:左,上,右,下(单位:dp)


```xml
<card padding="0,0,0,0" />
```


### gravity - 重力

> 设置重力
> 
> 卡片只能设置前景重力，不要求安卓版本。


```xml
<card gravity="center" />
```


## 二、子控件属性表

被卡片布局包裹的子控件可以使用如下属性：

| 中文名   | 英文名        | 描述                                                         |
|----------|---------------|--------------------------------------------------------------|
| 布局方向 | dir           | 设置子视图的排列方向，可选值为“rtl”（右到左）或“ltr”（左到右） |
| 解决方向 | resolveDir    | 确定视图应遵循的实际布局方向，可选值为“rtl”（右到左）或“ltr”（左到右） |
| 宽       | w             | 设置视图的宽度，可选值为“auto”（自动，即WRAP_CONTENT）、“max”（最大，即MATCH_PARENT）或具体整数（单位为dp） |
| 高       | h             | 设置视图的高度，可选值为“auto”（自动，即WRAP_CONTENT）、“max”（最大，即MATCH_PARENT）或具体整数（单位为dp） |
| 布局重力 | layout_gravity | 设置视图的布局重力，通过GravityAdd获取对应的重力值             |
| 外边距   | margin        | 设置视图的外边距，可传入单个整数（四边外边距相同）或四个整数（分别对应左、上、右、下外边距），单位为dp |
| 左外边距 | margin_left   | 单独设置视图的左外边距，单位为dp                             |
| 上外边距 | margin_top    | 单独设置视图的上外边距，单位为dp                             |
| 右外边距 | margin_right  | 单独设置视图的右外边距，单位为dp                             |
| 下外边距 | margin_bottom | 单独设置视图的下外边距，单位为dp                             |


## 三、常用函数


### setClickable(clickable)

> 设置可点击

- 参数 : clickable {boolean} 是否可点击
- 版本 : 1.8.2


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let card = ui.id("mCard");
//设置可点击
card.setClickable(true);
```


### setRipper(colorStr)

> 设置涟漪色

- 参数 : colorStr {string} 颜色字符串
- 版本 : 1.8.2


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let card = ui.id("mCard");
//设置涟漪色
card.setRipper("#FF0000");
```


### setRipper(colorVal)

> 设置涟漪色

- 参数 : colorVal {int} 颜色值
- 版本 : 1.8.2


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let card = ui.id("mCard");
//设置涟漪色
card.setRipper($color.RED);
```


### setBg(color)

> 设置背景颜色

- 参数 : color {int} 颜色值
- 版本 : 1.8.2


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let card = ui.id("mCard");
//设置背景颜色
card.setBg($color.RED);
```


### setBg(color)

> 设置背景颜色

- 参数 : color {string} 颜色字符串
- 版本 : 1.8.2


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let card = ui.id("mCard");
//设置背景颜色
card.setBg("#1E1F22");
```


### setTint(colorVal)

> 设置填充色

- 参数 : colorVal {int} 颜色值
- 版本 : 1.8.2


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let card = ui.id("mCard");
//设置填充色
card.setTint($color.RED);
```


### setTint(colorStr)

> 设置填充色

- 参数 : colorStr {string} 颜色字符串
- 版本 : 1.8.2


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let card = ui.id("mCard");
//设置填充色
card.setTint("#FF0000");
```


### setRadius(number)

> 设置弧度

- 参数 : number {float} 弧度(单位:dp)
- 版本 : 1.8.2


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let card = ui.id("mCard");
//设置弧度
card.setRadius(15);
```


# 约束布局

- 更新时间:2025-12-02 10:12:45

> 约束布局-const
> 
> 是布局父类的(XLayout)的子类,因此可以使用XLayout的所有方法
> 
> 原生类型:{androidx.constraintlayout.widget.ConstraintLayout}




### minW - 最小宽度

> 设置最小宽度
> 
> 单位:dp


```xml
<const minW="20" />
```


### minH - 最小高度

> 设置最小高度
> 
> 单位:dp


```xml
<const minH="20" />
```


### bg - 背景颜色

> 设置背景颜色


```xml
<const bg="#57965C" />
```


### bgImg - 背景图片

> 设置背景图片


```xml
<const bgImg="res/t01.png" />
```


### padding - 内边距

> 设置内边距
> 
> 参数顺序:左,上,右,下(单位:dp)


```xml
<const padding="0,0,0,0" />
```


### gravity - 重力

> 设置重力
> 
> 约束布局只能设置前景重力，并且要求安卓6.0+。


```xml
<const gravity="center" />
```


## 子控件属性表

被约束布局包裹的子控件可以使用如下属性：

| 中文名     | 英文名          | 描述                                                         |
|------------|-----------------|--------------------------------------------------------------|
| 垂直偏移   | verticalBias    | 设置视图在垂直方向的偏移值，若与水平偏移均设为0.5，可实现居中对齐 |
| 水平偏移   | horizontalBias  | 设置视图在水平方向的偏移值，若与垂直偏移均设为0.5，可实现居中对齐 |
| 布局方向   | dir             | 设置子视图的排列方向，可选值为“rtl”（右到左）或“ltr”（左到右） |
| 解决方向   | resolveDir      | 确定视图应遵循的实际布局方向，可选值为“rtl”（右到左）或“ltr”（左到右） |
| 宽         | w               | 设置视图的宽度，可选值为“auto”（自动，即WRAP_CONTENT）、“max”（最大，即MATCH_PARENT）或具体整数（单位为dp） |
| 高         | h               | 设置视图的高度，可选值为“auto”（自动，即WRAP_CONTENT）、“max”（最大，即MATCH_PARENT）或具体整数（单位为dp） |
| 外边距     | margin          | 设置视图的外边距，可传入单个整数（四边外边距相同）或四个整数（分别对应左、上、右、下外边距），单位为dp |
| 左外边距   | margin_left     | 单独设置视图的左外边距，单位为dp                             |
| 上外边距   | margin_top      | 单独设置视图的上外边距，单位为dp                             |
| 右外边距   | margin_right    | 单独设置视图的右外边距，单位为dp                             |
| 下外边距   | margin_bottom   | 单独设置视图的下外边距，单位为dp                             |


# 锚点布局

- 更新时间:2025-12-02 10:12:45

> 锚点布局-coord
> 
> 是布局父类(XLayout)的子类,因此可以使用XLayout的所有方法
> 
> 原生类型:{androidx.coordinatorlayout.widget.CoordinatorLayout}




锚点布局，能够实现的效果让人意想不到，你可以理解为：船舶停靠在某个驿站上，一般用anchor属性指定驿站的名字，用anchorLayout指定要前往的驿站。


![](../img/coord_toolbar_fab.png)


```xml
<ui>
    <statusbar />
    <!--
    anchor属性是所有控件都有的属性，但是使用anchorLayout属性必须要被coord锚点布局包才可以
    -->
    <coord h="max" w="max">
        <!--
        anchor="linear" 指的是:给线性布局(linear)取一个驿站名称为'linear'
        -->
        <linear anchor="linear" gravity="center" h="max" margin_bottom="75" w="max">
            <text text="Hello World!" />
        </linear>
        <!--
        anchorLayout="linear" 指的是:锚定到名称为'linear'的布局上
        -->
        <toolbar anchor="toolbar" anchorGravity="center|bottom" anchorLayout="linear"
            fabAnim="slide" fabGravity="center" fabMode="out" fabRadius="25" h="75"
            layout_gravity="bottom" w="max">
            <menu icon="ic_search" text="搜搜" />
            <menu icon="ic_set" text="设置" />
            <menu icon="ic_menu" text="菜单" />
        </toolbar>
        <!--
        这里我让(fab)悬浮按钮锚定到(toolbar)工作条的布局上，同时在(toolbar)工作条的布局上设置悬浮按钮的样式，
        然而(toolbar)工作条能够专门和(fab)悬浮按一起联动，实现凹陷的效果。
        -->
        <fab anchorLayout="toolbar" icon="ic_add" iconTint="txt" radius="27" />
    </coord>
</ui>
```


## 一、常用属性


### minW - 最小宽度

> 设置最小宽度
> 
> 单位:dp


```xml
<coord minW="20" />
```


### minH - 最小高度

> 设置最小高度
> 
> 单位:dp


```xml
<coord minH="20" />
```


### bg - 背景颜色

> 设置背景颜色


```xml
<coord bg="#57965C" />
```


### bgImg - 背景图片

> 设置背景图片


```xml
<coord bgImg="res/t01.png" />
```


### padding - 内边距

> 设置内边距
> 
> 参数顺序:左,上,右,下(单位:dp)


```xml
<coord padding="0,0,0,0" />
```


### gravity - 重力

> 设置重力
> 
> 锚点布局只能设置前景重力，并且要求安卓6.0+。


```xml
<coord gravity="center" />
```


## 二、子控件属性表

被锚点布局约束的子控件可以使用如下属性：

| 中文名       | 英文名          | 描述                                                         |
|--------------|-----------------|--------------------------------------------------------------|
| 布局方向     | dir             | 设置子视图的排列方向，可选值为“rtl”（右到左）或“ltr”（左到右） |
| 解决方向     | resolveDir      | 确定视图应遵循的实际布局方向，可选值为“rtl”（右到左）或“ltr”（左到右） |
| 行为         | behavior        | 指定视图与其他视图或父布局的交互方式，可选值为“appbar”（应用条，对应AppBarLayout.ScrollingViewBehavior）或“fab”（悬浮按钮，对应ScrollAwareFabBehavior） |
| 参考线       | keyline         | 在CoordinatorLayout中定义参考线，帮助子视图根据参考线定位，单位为dp |
| 锚点视图       | anchorLayout        | 设置锚定的视图，用于让当前视图相对锚定视图进行布局（需为每个视图设置anchor以引用） |
| 锚点重力     | anchorGravity   | 设置当前视图相对于锚点视图的重力方向，通过GravityAdd获取对应的重力值 |
| 避让插入边   | dodgeInsetEdges | 指定视图在遇到系统窗口插入边（如状态栏、导航栏等）时的避让行为，通过GravityAdd获取对应值 |
| 插入边       | insetEdge       | 指定视图哪一侧视为系统窗口插入边的边界，当系统窗口覆盖布局时，视图会调整位置或大小为系统窗口留出空间，通过GravityAdd获取对应值 |
| 宽           | w               | 设置视图的宽度，可选值为“auto”（自动，即WRAP_CONTENT）、“max”（最大，即MATCH_PARENT）或具体整数（单位为dp） |
| 高           | h               | 设置视图的高度，可选值为“auto”（自动，即WRAP_CONTENT）、“max”（最大，即MATCH_PARENT）或具体整数（单位为dp） |
| 布局重力     | layout_gravity  | 设置视图的布局重力，通过GravityAdd获取对应的重力值             |
| 外边距       | margin          | 设置视图的外边距，可传入单个整数（四边外边距相同）或四个整数（分别对应左、上、右、下外边距），单位为dp |
| 左外边距     | margin_left     | 单独设置视图的左外边距，单位为dp                             |
| 上外边距     | margin_top      | 单独设置视图的上外边距，单位为dp                             |
| 右外边距     | margin_right    | 单独设置视图的右外边距，单位为dp                             |
| 下外边距     | margin_bottom   | 单独设置视图的下外边距，单位为dp                             |


# 抽屉布局

- 更新时间:2025-12-02 10:12:45

> 抽屉布局-drawer
> 
> 是布局父类{XLayout}的子类,因此可以使用XLayout的所有方法
> 
> 原生类型:{androidx.drawerlayout.widget.DrawerLayout}




### bg - 背景颜色

> 设置背景颜色


```xml
<drawer bg="#57965C" />
```


### bgImg - 背景图片

> 设置背景图片


```xml
<drawer bgImg="res/t01.png" />
```


### padding - 内边距

> 设置内边距
> 
> 参数顺序:左,上,右,下(单位:dp)


```xml
<drawer padding="0,0,0,0" />
```


### gravity - 重力

> 设置重力
> 
> 抽屉布局只能设置前景重力，并且要求安卓6.0+。


```xml
<drawer gravity="center" />
```


## 子控件属性表

被抽屉布局包裹的子控件可以使用如下属性：

| 中文名     | 英文名          | 描述                                                         |
|------------|-----------------|--------------------------------------------------------------|
| 布局方向   | dir             | 设置子视图的排列方向，可选值为“rtl”（右到左）或“ltr”（左到右） |
| 解决方向   | resolveDir      | 确定视图应遵循的实际布局方向，可选值为“rtl”（右到左）或“ltr”（左到右） |
| 宽         | w               | 设置视图的宽度，可选值为“auto”（自动，即WRAP_CONTENT）、“max”（最大，即MATCH_PARENT）或具体整数（单位为dp） |
| 高         | h               | 设置视图的高度，可选值为“auto”（自动，即WRAP_CONTENT）、“max”（最大，即MATCH_PARENT）或具体整数（单位为dp） |
| 布局重力   | layout_gravity  | 设置视图的布局重力，通过GravityAdd获取对应的重力值             |
| 外边距     | margin          | 设置视图的外边距，可传入单个整数（四边外边距相同）或四个整数（分别对应左、上、右、下外边距），单位为dp |
| 左外边距   | margin_left     | 单独设置视图的左外边距，单位为dp                             |
| 上外边距   | margin_top      | 单独设置视图的上外边距，单位为dp                             |
| 右外边距   | margin_right    | 单独设置视图的右外边距，单位为dp                             |
| 下外边距   | margin_bottom   | 单独设置视图的下外边距，单位为dp                             |


# 流式布局

- 更新时间:2025-12-02 10:12:45

> 流式布局-flow
> 
> 是布局父类的(XLayout)的子类,因此可以使用XLayout的所有方法
> 
> 原生类型:{com.google.android.material.internal.FlowLayout}




### minW - 最小宽度

> 设置最小宽度
> 
> 单位:dp


```xml
<flow minW="20" />
```


### minH - 最小高度

> 设置最小高度
> 
> 单位:dp


```xml
<flow minH="20" />
```


### bg - 背景颜色

> 设置背景颜色


```xml
<flow bg="#57965C" />
```


### bgImg - 背景图片

> 设置背景图片


```xml
<flow bgImg="res/t01.png" />
```


### padding - 内边距

> 设置内边距
> 
> 参数顺序:左,上,右,下(单位:dp)


```xml
<flow padding="0,0,0,0" />
```


### gravity - 重力

> 设置重力


```xml
<flow gravity="center" />
```


## 子控件属性表

被流式布局包含的子控件可以使用如下属性：

| 中文名   | 英文名    | 描述                                                         |
|----------|-----------|--------------------------------------------------------------|
| 解决方向 | resolveDir | 确定视图应遵循的实际布局方向，可选值为“rtl”（右到左）或“ltr”（左到右） |
| 宽       | w         | 设置视图的宽度，可选值为“auto”（自动，即WRAP_CONTENT）、“max”（最大，即MATCH_PARENT）或具体整数（单位为dp） |
| 高       | h         | 设置视图的高度，可选值为“auto”（自动，即WRAP_CONTENT）、“max”（最大，即MATCH_PARENT）或具体整数（单位为dp） |


# 刷新布局

- 更新时间:2025-12-02 10:12:45

> 刷新布局-flush
> 
> 是布局父类的(XLayout)的子类,因此可以使用XLayout的所有方法
> 
> 原生类型:{androidx.swiperefreshlayout.widget.SwipeRefreshLayout}




### minW - 最小宽度

> 设置最小宽度
> 
> 单位:dp


```xml
<flush minW="20" />
```


### minH - 最小高度

> 设置最小高度
> 
> 单位:dp


```xml
<flush minH="20" />
```


### bg - 背景颜色

> 设置背景颜色


```xml
<flush bg="#57965C" />
```


### bgImg - 背景图片

> 设置背景图片


```xml
<flush bgImg="res/t01.png" />
```


### padding - 内边距

> 设置内边距
> 
> 参数顺序:左,上,右,下(单位:dp)


```xml
<flush padding="0,0,0,0" />
```


### gravity - 重力

> 设置重力
> 
> 刷新布局只能设置前景重力，并且要求安卓6.0+。


```xml
<flush gravity="center" />
```


## 子控件属性表

被下拉刷新布局包含的子控件可以使用如下属性：

| 中文名   | 英文名    | 描述                                                         |
|----------|-----------|--------------------------------------------------------------|
| 解决方向 | resolveDir | 确定视图应遵循的实际布局方向，可选值为“rtl”（右到左）或“ltr”（左到右） |
| 宽       | w         | 设置视图的宽度，可选值为“auto”（自动，即WRAP_CONTENT）、“max”（最大，即MATCH_PARENT）或具体整数（单位为dp） |
| 高       | h         | 设置视图的高度，可选值为“auto”（自动，即WRAP_CONTENT）、“max”（最大，即MATCH_PARENT）或具体整数（单位为dp） |


### flush(runnable)

> 设置下拉刷新监听

- 参数 : runnable {()=>{}} 刷新时执行的任务


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUii.xml");
//获取控件
let fl = ui.id("mFlushLayout");
//监听下拉刷新
fl.flush(()=>{
    //处理一些事情...
});
```


# 帧布局

- 更新时间:2025-12-02 10:12:45

> 帧布局-frame
> 
> 是布局父类的(XLayout)的子类,因此可以使用XLayout的所有方法
> 
> 原生类型:{android.widget.FrameLayout}




### minW - 最小宽度

> 设置最小宽度
> 
> 单位:dp


```xml
<frame minW="20" />
```


### minH - 最小高度

> 设置最小高度
> 
> 单位:dp


```xml
<frame minH="20" />
```


### bg - 背景颜色

> 设置背景颜色


```xml
<frame bg="#57965C" />
```


### bgImg - 背景图片

> 设置背景图片


```xml
<frame bgImg="res/t01.png" />
```


### padding - 内边距

> 设置内边距
> 
> 参数顺序:左,上,右,下(单位:dp)


```xml
<frame padding="0,0,0,0" />
```


### gravity - 重力

> 设置重力
> 
> 帧布局只能设置前景重力，并且要求安卓6.0+。


```xml
<frame gravity="center" />
```


## 子控件属性表

被帧布局包裹的子控件可以使用如下属性：

| 中文名     | 英文名          | 描述                                                         |
|------------|-----------------|--------------------------------------------------------------|
| 布局方向   | dir             | 设置子视图的排列方向，可选值为“rtl”（右到左）或“ltr”（左到右） |
| 解决方向   | resolveDir      | 确定视图应遵循的实际布局方向，可选值为“rtl”（右到左）或“ltr”（左到右） |
| 宽         | w               | 设置视图的宽度，可选值为“auto”（自动，即WRAP_CONTENT）、“max”（最大，即MATCH_PARENT）或具体整数（单位为dp） |
| 高         | h               | 设置视图的高度，可选值为“auto”（自动，即WRAP_CONTENT）、“max”（最大，即MATCH_PARENT）或具体整数（单位为dp） |
| 布局重力   | layout_gravity  | 设置视图的布局重力，通过GravityAdd获取对应的重力值             |
| 外边距     | margin          | 设置视图的外边距，可传入单个整数（四边外边距相同）或四个整数（分别对应左、上、右、下外边距），单位为dp |
| 左外边距   | margin_left     | 单独设置视图的左外边距，单位为dp                             |
| 上外边距   | margin_top      | 单独设置视图的上外边距，单位为dp                             |
| 右外边距   | margin_right    | 单独设置视图的右外边距，单位为dp                             |
| 下外边距   | margin_bottom   | 单独设置视图的下外边距，单位为dp                             |


# 网格布局

- 更新时间:2025-12-02 10:12:45

> 网格布局-grid
> 
> 是布局父类的(XLayout)的子类,因此可以使用XLayout的所有方法
> 
> 原生类型:{android.widget.GridLayout}




### minW - 最小宽度

> 设置最小宽度
> 
> 单位:dp


```xml
<grid minW="20" />
```


### minH - 最小高度

> 设置最小高度
> 
> 单位:dp


```xml
<grid minH="20" />
```


### dir - 布局方向

> 设置布局方向


```xml
<grid dir="h" />
```


### bg - 背景颜色

> 设置背景颜色


```xml
<grid bg="#57965C" />
```


### bgImg - 背景图片

> 设置背景图片


```xml
<grid bgImg="res/t01.png" />
```


### padding - 内边距

> 设置内边距
> 
> 参数顺序:左,上,右,下(单位:dp)


```xml
<grid padding="0,0,0,0" />
```


### gravity - 重力

> 设置重力
> 
> 网格布局只能设置前景重力，并且要求安卓6.0+。


```xml
<grid gravity="center" />
```


## 子控件属性表

被网格布局包裹的子控件可以使用如下属性：

| 中文名     | 英文名          | 描述                                                         |
|------------|-----------------|--------------------------------------------------------------|
| 布局方向   | dir             | 设置子视图的排列方向，可选值为“rtl”（右到左）或“ltr”（左到右） |
| 解决方向   | resolveDir      | 确定视图应遵循的实际布局方向，可选值为“rtl”（右到左）或“ltr”（左到右） |
| 宽         | w               | 设置视图的宽度，可选值为“auto”（自动，即WRAP_CONTENT）、“max”（最大，即MATCH_PARENT）或具体整数（单位为dp） |
| 高         | h               | 设置视图的高度，可选值为“auto”（自动，即WRAP_CONTENT）、“max”（最大，即MATCH_PARENT）或具体整数（单位为dp） |
| 外边距     | margin          | 设置视图的外边距，可传入单个整数（四边外边距相同）或四个整数（分别对应左、上、右、下外边距），单位为dp |
| 左外边距   | margin_left     | 单独设置视图的左外边距，单位为dp                             |
| 上外边距   | margin_top      | 单独设置视图的上外边距，单位为dp                             |
| 右外边距   | margin_right    | 单独设置视图的右外边距，单位为dp                             |
| 下外边距   | margin_bottom   | 单独设置视图的下外边距，单位为dp                             |


# 包含布局

- 更新时间:2025-12-02 10:12:45

> 包含布局-include
> 
> 包含布局主要用于引入其他布局文件，避免单个布局文件过大导致代码臃肿。
> 包含布局的本质就是一个线性布局，所以在使用的时候遵循线性布局的规则即可。
> 是布局父类的(XLayout)的子类,因此可以使用XLayout的所有方法
> 
> 原生类型:{android.widget.LinearLayout}




### path - 子界面路径

> 子界面路径


```xml
<include path="xml/child.xml" />
```


### minW - 最小宽度

> 设置最小宽度
> 
> 单位:dp


```xml
<include minW="20" />
```


### minH - 最小高度

> 设置最小高度
> 
> 单位:dp


```xml
<include minH="20" />
```


### dir - 布局方向

> 设置布局方向


```xml
<include dir="h" />
```


### bg - 背景颜色

> 设置背景颜色


```xml
<include bg="#57965C" />
```


### bgImg - 背景图片

> 设置背景图片


```xml
<include bgImg="res/t01.png" />
```


### padding - 内边距

> 设置内边距
> 
> 参数顺序:左,上,右,下(单位:dp)


```xml
<include padding="0,0,0,0" />
```


### gravity - 重力

> 设置重力


```xml
<include gravity="center" />
```


# 线性布局

- 更新时间:2025-12-02 10:12:45

> 线性布局-linear
> 
> 是布局父类的(XLayout)的子类,因此可以使用XLayout的所有方法
> 
> 原生类型:{android.widget.LinearLayout}




### minW - 最小宽度

> 设置最小宽度
> 
> 单位:dp


```xml
<linear minW="20" />
```


### minH - 最小高度

> 设置最小高度
> 
> 单位:dp


```xml
<linear minH="20" />
```


### dir - 布局方向

> 设置布局方向


```xml
<linear dir="h" />
```


### bg - 背景颜色

> 设置背景颜色


```xml
<linear bg="#57965C" />
```


### bgImg - 背景图片

> 设置背景图片


```xml
<linear bgImg="res/t01.png" />
```


### padding - 内边距

> 设置内边距
> 
> 参数顺序:左,上,右,下(单位:dp)


```xml
<linear padding="0,0,0,0" />
```


### gravity - 重力

> 设置重力


```xml
<linear gravity="center" />
```


## 子控件属性表

被线性布局包裹的子控件可以使用如下属性：

| 中文名     | 英文名          | 描述                                                         |
|------------|-----------------|--------------------------------------------------------------|
| 布局方向   | dir             | 设置子视图的排列方向，可选值为“rtl”（右到左）或“ltr”（左到右） |
| 解决方向   | resolveDir      | 确定视图应遵循的实际布局方向，可选值为“rtl”（右到左）或“ltr”（左到右） |
| 宽         | w               | 设置视图的宽度，可选值为“auto”（自动，即WRAP_CONTENT）、“max”（最大，即MATCH_PARENT）或具体整数（单位为dp） |
| 高         | h               | 设置视图的高度，可选值为“auto”（自动，即WRAP_CONTENT）、“max”（最大，即MATCH_PARENT）或具体整数（单位为dp） |
| 权重       | weight          | 设置视图的权重，通过浮点值指定，用于在LinearLayout中分配剩余空间 |
| 布局重力   | layout_gravity  | 设置视图的布局重力，通过GravityAdd获取对应的重力值             |
| 外边距     | margin          | 设置视图的外边距，可传入单个整数（四边外边距相同）或四个整数（分别对应左、上、右、下外边距），单位为dp |
| 左外边距   | margin_left     | 单独设置视图的左外边距，单位为dp                             |
| 上外边距   | margin_top      | 单独设置视图的上外边距，单位为dp                             |
| 右外边距   | margin_right    | 单独设置视图的右外边距，单位为dp                             |
| 下外边距   | margin_bottom   | 单独设置视图的下外边距，单位为dp                             |


# 滑动布局

- 更新时间:2025-12-02 10:12:45

> 滑动布局-nested
> 
> 是布局父类的(XLayout)的子类,因此可以使用XLayout的所有方法
> 
> 原生类型:{androidx.core.widget.NestedScrollView}




### minW - 最小宽度

> 设置最小宽度
> 
> 单位:dp


```xml
<nested minW="20" />
```


### minH - 最小高度

> 设置最小高度
> 
> 单位:dp


```xml
<nested minH="20" />
```


### bg - 背景颜色

> 设置背景颜色


```xml
<nested bg="#57965C" />
```


### bgImg - 背景图片

> 设置背景图片


```xml
<nested bgImg="res/t01.png" />
```


### padding - 内边距

> 设置内边距
> 
> 参数顺序:左,上,右,下(单位:dp)


```xml
<nested padding="0,0,0,0" />
```


### gravity - 重力

> 设置重力
> 
> 滑动布局只能设置前景重力，无安卓版本要求。


```xml
<nested gravity="center" />
```


## 子控件属性表

被滑动布局包裹的子控件可以使用如下属性：

| 中文名     | 英文名          | 描述                                                         |
|------------|-----------------|--------------------------------------------------------------|
| 布局方向   | dir             | 设置子视图的排列方向，可选值为“rtl”（右到左）或“ltr”（左到右） |
| 解决方向   | resolveDir      | 确定视图应遵循的实际布局方向，可选值为“rtl”（右到左）或“ltr”（左到右） |
| 宽         | w               | 设置视图的宽度，可选值为“auto”（自动，即WRAP_CONTENT）、“max”（最大，即MATCH_PARENT）或具体整数（单位为dp） |
| 高         | h               | 设置视图的高度，可选值为“auto”（自动，即WRAP_CONTENT）、“max”（最大，即MATCH_PARENT）或具体整数（单位为dp） |
| 布局重力   | layout_gravity  | 设置视图的布局重力，通过GravityAdd获取对应的重力值             |
| 外边距     | margin          | 设置视图的外边距，可传入单个整数（四边外边距相同）或四个整数（分别对应左、上、右、下外边距），单位为dp |
| 左外边距   | margin_left     | 单独设置视图的左外边距，单位为dp                             |
| 上外边距   | margin_top      | 单独设置视图的上外边距，单位为dp                             |
| 右外边距   | margin_right    | 单独设置视图的右外边距，单位为dp                             |
| 下外边距   | margin_bottom   | 单独设置视图的下外边距，单位为dp                             |


### onScroll(callback)

> 监听滚动

- 参数 : callback 滚动回调 


```javascript
let ui = $ui.layout("./res/main.xml");//解析界面
ui.show();//显示界面
//找到滑动控件
let mNested = ui.id("mNested");
//监听混动事件
mNested.onScroll((x,y,view)=>{
    //处理事情
});
```


# 相对布局

- 更新时间:2025-12-02 10:12:45

> 相对布局-relative
> 
> 是布局父类的(XLayout)的子类,因此可以使用XLayout的所有方法
> 
> 原生类型:{android.widget.RelativeLayout}




### minW - 最小宽度

> 设置最小宽度
> 
> 单位:dp


```xml
<relative minW="20" />
```


### minH - 最小高度

> 设置最小高度
> 
> 单位:dp


```xml
<relative minH="20" />
```


### bg - 背景颜色

> 设置背景颜色


```xml
<relative bg="#57965C" />
```


### bgImg - 背景图片

> 设置背景图片


```xml
<relative bgImg="res/t01.png" />
```


### padding - 内边距

> 设置内边距
> 
> 参数顺序:左,上,右,下(单位:dp)


```xml
<relative padding="0,0,0,0" />
```


### gravity - 重力

> 设置重力


```xml
<relative gravity="center" />
```


## 子控件属性表

被相对布局包裹的子控件可以使用如下属性：

| 中文名         | 英文名          | 描述                                                         |
|----------------|-----------------|--------------------------------------------------------------|
| 与父布局对齐   | alignWithParent | 布尔值属性，用于指定当对应的参考视图不存在时，当前视图是否与父布局对齐 |
| 布局方向       | dir             | 设置子视图的排列方向，可选值为“rtl”（右到左）或“ltr”（左到右） |
| 解决方向       | resolveDir      | 确定视图应遵循的实际布局方向，可选值为“rtl”（右到左）或“ltr”（左到右） |
| 宽             | w               | 设置视图的宽度，可选值为“auto”（自动，即WRAP_CONTENT）、“max”（最大，即MATCH_PARENT）或具体整数（单位为dp） |
| 高             | h               | 设置视图的高度，可选值为“auto”（自动，即WRAP_CONTENT）、“max”（最大，即MATCH_PARENT）或具体整数（单位为dp） |
| 外边距         | margin          | 设置视图的外边距，可传入单个整数（四边外边距相同）或四个整数（分别对应左、上、右、下外边距），单位为dp |
| 左外边距       | margin_left     | 单独设置视图的左外边距，单位为dp                             |
| 上外边距       | margin_top      | 单独设置视图的上外边距，单位为dp                             |
| 右外边距       | margin_right    | 单独设置视图的右外边距，单位为dp                             |
| 下外边距       | margin_bottom   | 单独设置视图的下外边距，单位为dp                             |


# 滚动布局

- 更新时间:2025-12-02 10:12:45

> 滚动布局-scroll
> 
> 是布局父类的(XLayout)的子类,因此可以使用XLayout的所有方法
> 
> 原生类型:{android.widget.ScrollView}




### dir - 布局方向

> 设置布局方向


```xml
<scroll dir="h" />
```


### showBar - 显示滚动条

> 设置显示滚动条


```xml
<scroll showBar="true" />
```


### minW - 最小宽度

> 设置最小宽度
> 
> 单位:dp


```xml
<scroll minW="20" />
```


### minH - 最小高度

> 设置最小高度
> 
> 单位:dp


```xml
<scroll minH="20" />
```


### bg - 背景颜色

> 设置背景颜色


```xml
<scroll bg="#57965C" />
```


### bgImg - 背景图片

> 设置背景图片


```xml
<scroll bgImg="res/t01.png" />
```


### padding - 内边距

> 设置内边距
> 
> 参数顺序:左,上,右,下(单位:dp)


```xml
<scroll padding="0,0,0,0" />
```


### gravity - 重力

> 设置重力
> 
> 滚动布局只能设置前景重力，无安卓版本要求。


```xml
<scroll gravity="center" />
```


## 子控件属性表

被滚动布局包裹的子控件可以使用如下属性：

| 中文名     | 英文名          | 描述                                                         |
|------------|-----------------|--------------------------------------------------------------|
| 布局方向   | dir             | 设置子视图的排列方向，可选值为“rtl”（右到左）或“ltr”（左到右） |
| 解决方向   | resolveDir      | 确定视图应遵循的实际布局方向，可选值为“rtl”（右到左）或“ltr”（左到右） |
| 宽         | w               | 设置视图的宽度，可选值为“auto”（自动，即WRAP_CONTENT）、“max”（最大，即MATCH_PARENT）或具体整数（单位为dp） |
| 高         | h               | 设置视图的高度，可选值为“auto”（自动，即WRAP_CONTENT）、“max”（最大，即MATCH_PARENT）或具体整数（单位为dp） |
| 布局重力   | layout_gravity  | 设置视图的布局重力，通过GravityAdd获取对应的重力值             |
| 外边距     | margin          | 设置视图的外边距，可传入单个整数（四边外边距相同）或四个整数（分别对应左、上、右、下外边距），单位为dp |
| 左外边距   | margin_left     | 单独设置视图的左外边距，单位为dp                             |
| 上外边距   | margin_top      | 单独设置视图的上外边距，单位为dp                             |
| 右外边距   | margin_right    | 单独设置视图的右外边距，单位为dp                             |
| 下外边距   | margin_bottom   | 单独设置视图的下外边距，单位为dp                             |


### onScroll(callback)

> 监听滚动

- 参数 : callback 滚动回调 


```javascript
let ui = $ui.layout("./res/main.xml");//解析界面
ui.show();//显示界面
//找到滑动控件
let mScroll = ui.id("mScroll");
//监听混动事件
mScroll.onScroll((x,y,view)=>{
    //处理事情
});
```


# 布局父类

- 更新时间:2025-12-02 10:12:47

> 布局父类-XLayout
> 
> 布局父类{XLayout}是属于{XView}的子控件，因此{XView}中的所有方法，布局父类都可以调用。
> 
> 所有布局控件都继承{XLayout}类，一因此可以调用{XLayout}中的方法。
> 
> 为了清晰的了解本软件的UI界面框架结构，我给你画个图:XView->XLayout->XScroll、XLinear、XCard等等
> 
> 这是什么意思呢？例如:XScroll是<scroll>标签、XLinear是<linear>标签、XCard是<card>标签等等我就不一一例举了，这些标签都是XLayout布局类的子类，也就是说这些对象都可以调用XLayout中的方法，而XLayout又是XView的子类，因此也可以调用XView中的所有方法。




### addView(xView)

> 添加子视图

- 参数 : xView {XView} 控件


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取布局控件
let layout = ui.id("myLayout");
//创建一个新的文本控件
let textView = $ui.create("text").setText("新添加的文本");
//添加到布局中
layout.addView(textView);
```


### addView(view)

> 添加子视图

- 参数 : view {View} 控件


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取布局控件
let layout = ui.id("myLayout");
//创建一个新的原生文本控件
let textView = new TextView(activity);
textView.setText("原生文本");
//添加到布局中
layout.addView(textView);
```


### removeView(xView)

> 移除子视图

- 参数 : xView {XView} 要移除的控件


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取布局控件
let layout = ui.id("myLayout");
//获取要移除的控件
let childView = ui.id("childView");
//从布局中移除
layout.removeView(childView);
```


### removeView(view)

> 移除子视图

- 参数 : view {View} 要移除的原生控件


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取布局控件
let layout = ui.id("myLayout");
//获取要移除的原生控件
let nativeView = findViewById(R.id.native_view);
//从布局中移除
layout.removeView(nativeView);
```


### removeView(index)

> 根据索引移除子视图

- 参数 : index {Integer} 子视图索引


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取布局控件
let layout = ui.id("myLayout");
//移除第一个子视图
layout.removeView(0);
```


### removeView(from, to)

> 批量移除子视图

- 参数 : from {Integer} 起始索引
- 参数 : to {Integer} 结束索引


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取布局控件
let layout = ui.id("myLayout");
//移除从索引1开始的3个子视图
layout.removeView(1, 3);
```


### removeAll()

> 移除所有子视图


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取布局控件
let layout = ui.id("myLayout");
//清空所有子视图
layout.removeAll();
```


# 日志

- 更新时间:2025-12-02 10:12:46

> 日志-log




日志组件：显示日志信息


![](./img/1033925169795800.png)

## 一、常用属性


### padding - 内边距

> 设置内边距


```xml
<ui>
    <statusbar />
    <log w="max" h="max" padding="50" />
</ui>
```


![](./img/1034016914246900.png)

### bg - 背景颜色

> 设置背景颜色


```xml
<log bg="#FF0000" />
```


### bgImg - 背景图片

> 设置背景图片


```xml
<log bgImg="res/t01.png" />
```


## 二、常用函数


### setTextSize(size)

> 设置字体大小

- 参数 : size {float} 字体大小
- 版本 : 1.7.3


### setBgColor(color)

> 设置背景颜色

- 参数 : color {int} 背景颜色
- 版本 : 1.7.3


### setBgColor(color)

> 设置背景颜色

- 参数 : color {String} 背景颜色
- 版本 : 1.7.3


### getContent()

> 获取所有日志内容

- 返回 : {String} 所有日志内容
- 版本 : 1.7.3


### scrollBottom()

> 滚动到底部

- 版本 : 1.7.3


### clear()

> 清空日志

- 版本 : 1.7.3


```javascript
//其实有更加简单的方法来清空日志
$log.delete();//通知所有的日志组件(包括悬浮窗日志)清空日志信息
```


# 列表

- 更新时间:2025-12-02 10:12:46

> 列表-ls
> 
> 原生类型:{androidx.recyclerview.widget.RecyclerView}




列表控件，算的算是一个比较复杂的控件，但是该组件确是最常用的组件之一，
因为它可以用来展示一个列表，比如一个商品列表、一个用户列表、一个消息列表等等。


![](./img/1036371318861000.png)

### layout - 子项布局

> 设置子项布局


```xml
<ui>
    <statusbar />
    <ls id="mLs" w="max" h="max" margin="15" >
        <!-- 列表布局中:用来指定每个子项目的布局 -->
        <layout w="max">
            <!-- 卡片布局:需要配合线性布局来写更好看的界面 -->
            <card w="max" margin="2">
                <linear w="max" dir="h" gravity="center|left" padding="15">
                    <!-- 这里才是真正显示数据的地方 -->
                    <text id="name" minW="120" />
                    <text id="age" />
                    <linear w="max" gravity="center|end" weight="1">
                        <button id="delBut" style="text" text="删除" textColor="red" />
                    </linear>
                </linear>
            </card>
        </layout>
    </ls>
</ui>
```


![](./img/1036371318861000.png)


```javascript
let ui = $ui.layout("/ui.xml");
ui.show();
//找到列表控件
let ls = ui.id("mLs");
//绑定解析视图的方法(必须优先调用)
ls.bindHolder((itemUi, itemData, position) => {
    itemUi.id("name").setText("姓名:" + itemData.name);
    itemUi.id("age").setText("年龄:" + itemData.age);
    itemUi.id("delBut").click(() => {
        $tip.show("删除", "确定删除:" + itemData.name + "吗？", () => {
            //列表删除指定下标的元素
            ls.del(position);
        });
    });
});
//设置数据
ls.flush([
    {
        name: "张三",
        age: 16
    }, {
        name: "李四",
        age: 18
    }
]);
```


### spanCount - 列数

> 设置列数
> 
> 当该属性被设置的时候，布局将采用网格布局来添加子项。


```xml
<ui>
    <statusbar />
    <ls id="mLs" spanCount="2" w="max" h="max" margin="15" >
        <!-- 列表布局中:用来指定每个子项目的布局 -->
        <layout w="max">
            <!-- 卡片布局:需要配合线性布局来写更好看的界面 -->
            <card w="max" margin="2">
                <linear w="max" dir="h" gravity="center|left" padding="15">
                    <!-- 这里才是真正显示数据的地方 -->
                    <text id="name" minW="120" />
                    <text id="age" />
                    <linear w="max" gravity="center|end" weight="1">
                        <button id="delBut" style="text" text="删除" textColor="red" />
                    </linear>
                </linear>
            </card>
        </layout>
    </ls>
</ui>
```


![](./img/1036885281225000.png)

### padding - 内边距

> 设置内边距


```xml
<ui>
    <statusbar />
    <ls id="mLs" w="max" h="max" padding="50" >
        <!-- 列表布局中:用来指定每个子项目的布局 -->
        <layout w="max">
            <!-- 卡片布局:需要配合线性布局来写更好看的界面 -->
            <card w="max" margin="2">
                <linear w="max" dir="h" gravity="center|left" padding="15">
                    <!-- 这里才是真正显示数据的地方 -->
                    <text id="name" minW="120" />
                    <text id="age" />
                    <linear w="max" gravity="center|end" weight="1">
                        <button id="delBut" style="text" text="删除" textColor="red" />
                    </linear>
                </linear>
            </card>
        </layout>
    </ls>
</ui>
```


![](./img/1036952604432100.png)

### bg - 背景颜色

> 设置背景颜色


```xml
<ui>
    <statusbar />
    <ls id="mLs" bg="#1E1F22" w="max" h="max" margin="15" >
        <!-- 列表布局中:用来指定每个子项目的布局 -->
        <layout w="max">
            <!-- 卡片布局:需要配合线性布局来写更好看的界面 -->
            <card w="max" margin="2">
                <linear w="max" dir="h" gravity="center|left" padding="15">
                    <!-- 这里才是真正显示数据的地方 -->
                    <text id="name" minW="120" />
                    <text id="age" />
                    <linear w="max" gravity="center|end" weight="1">
                        <button id="delBut" style="text" text="删除" textColor="red" />
                    </linear>
                </linear>
            </card>
        </layout>
    </ls>
</ui>
```


![](./img/1037040261908500.png)

### bgImg - 背景图片

> 设置背景图片


```xml
<ui>
    <statusbar />
    <ls id="mLs" bgImg="/res/bg-ls.png" w="max" h="max" margin="30" >
        <!-- 列表布局中:用来指定每个子项目的布局 -->
        <layout w="max">
            <!-- 卡片布局:需要配合线性布局来写更好看的界面 -->
            <card w="max" margin="2">
                <linear w="max" dir="h" gravity="center|left" padding="15">
                    <!-- 这里才是真正显示数据的地方 -->
                    <text id="name" minW="120" />
                    <text id="age" />
                    <linear w="max" gravity="center|end" weight="1">
                        <button id="delBut" style="text" text="删除" textColor="red" />
                    </linear>
                </linear>
            </card>
        </layout>
    </ls>
</ui>
```


![](./img/1037283848936000.png)

### scrollTop()

> 滚动到顶部


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let mLs = ui.id("mLs");
//滚动到顶部
mLs.scrollTop();
```


### scrollBottom()

> 滚动到底部


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let mLs = ui.id("mLs");
//滚动到底部
mLs.scrollBottom();
```


### scroll(position)

> 滚动到指定位置

- 参数 : position {int} 下标


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let mLs = ui.id("mLs");
//滚动到指定位置
mLs.scroll(10);
```


### bindHolder(holder)

> 数据绑定
> 
> 在ls标签中，我没需要设置layout标签设计每个列表子项的布局，而该函数就是用来解析每个子项的布局的。

- 参数 : holder {(itemHolder, itemData, position)=>{}} 绑定


```javascript
let ui = $ui.layout("main.xml");
let mLs = ui.id("mLs");//获取列表组件
//开始解析每个数据对应的布局
mLs.bindHolder((itemUi,itemData,position)=>{
    //itemUi相当于解析layout节点后返回的ui对象，可以通过这个对象拿到子组件，例如:
    let text = itemUi.id("mText");
    //接下来绑定数据，如果数组每个元素是字符串，则可以直接设置数据
    text.setText(itemData);
});
```


### flush(data)

> 设置并且刷新数据

- 参数 : data {obj[]} 数据


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let mLs = ui.id("mLs");
//设置并且刷新数据
mLs.flush(["数据1","数据2","数据3"]);
```


### flush(data, position)

> 刷新指定位置数据

- 参数 : data {obj} 数据
- 参数 : position {int} 下标


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let mLs = ui.id("mLs");
//刷新指定位置数据
mLs.flush("新数据", 0);
```


### del(position)

> 删除指定位置数据

- 参数 : position {int} 下标


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let mLs = ui.id("mLs");
//删除指定位置数据
mLs.del(0);
```


### add(data)

> 添加一个数据

- 参数 : data {obj} 数据


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let mLs = ui.id("mLs");
//添加一个数据
mLs.add("新数据");
```


### add(data, position)

> 添加一个数据到指定位置

- 参数 : data {obj} 数据
- 参数 : position {int} 下标


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let mLs = ui.id("mLs");
//添加一个数据到指定位置
mLs.add("新数据", 0);
```


### clear()

> 清空列表


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let mLs = ui.id("mLs");
//清空列表
mLs.clear();
```


### getData()

> 获取数据

- 返回 : {obj[]} 数据列表
- 版本 : 1.7.3


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let mLs = ui.id("mLs");
//获取数据
let data = mLs.getData();
//打印出来
log(data);
```


# 导航栏

- 更新时间:2025-12-02 10:12:46

> 导航栏-nav
> 
> 原生类型:{com.google.android.material.bottomnavigation.BottomNavigationView}




导航栏：一般用于与多页布局(pager)联动，实现界面的跳转


![](./img/nav_demo.png)


```xml
<ui>
    <statusbar />
    <!-- 我习惯性把导航栏放在底部因此设置重力 gravity="bottom" -->
    <linear w="max" h="max" dir="v" gravity="bottom">
        <nav w="max">
            <menu text="主页" icon="ic_home" />
            <menu text="设置" icon="ic_set" />
            <menu text="菜单" icon="ic_menu" />
        </nav>
    </linear>
</ui>
```


## 一、基础用法


```xml
<ui>
    <statusbar />
    <!-- 我习惯性把导航栏放在底部因此设置重力 gravity="bottom" -->
    <linear w="max" h="max" dir="v" gravity="bottom">
        <!-- 给导航栏设置id id="mNav" -->
        <nav id="mNav" w="max">
            <menu text="菜单1" icon="ic_home" />
            <menu text="菜单2" icon="ic_search" />
            <menu text="菜单3" icon="ic_set" />
        </nav>
    </linear>
</ui>
```

```javascript
//解析布局
let ui = $ui.layout("ui.xml");
ui.show();//显示界面
//获取控件
let nav = ui.id("mNav");
//监听菜单事件
nav.menu((title)=>{
    toast(title);
});
```


## 二、常用属性


### menu - 菜单

> 设置菜单


```xml
<ui>
    <statusbar />
    <!-- 我习惯性把导航栏放在底部因此设置重力 gravity="bottom" -->
    <linear w="max" h="max" dir="v" gravity="bottom">
        <!--
        menu中的showAction属性:
        ifroom:如果有空间,则显示
        always:总是显示
        never:从不显示
        withtext:与文本一起显示
        -->
        <nav w="max">
            <menu text="菜单1" icon="ic_home" showAction="ifroom" />
            <menu text="菜单2" icon="ic_search" showAction="ifroom" />
            <menu text="菜单3" icon="ic_set" showAction="always" />
            <!-- 虽然设置了 showAction="never" 但是对于导航栏来说依旧会显示 对于应用条(toolbar)就不一定显示了-->
            <menu text="菜单4" icon="ic_logger" showAction="never" />
            <menu text="菜单5" icon="ic_menu" showAction="withtext" />
        </nav>
    </linear>
</ui>
```


![](./img/nav_menu.png)

### iconTint - 图标颜色

> 设置图标颜色


```xml
<ui>
    <statusbar />
    <!-- 我习惯性把导航栏放在底部因此设置重力 gravity="bottom" -->
    <linear w="max" h="max" dir="v" gravity="bottom">
        <!-- 设置图标的填充颜色 iconTint="#FF0000"
        当图标被选中时会自动设置这个颜色，没有被选中的会被设置成这个颜色较浅的色彩(通过这个颜色计算得到的)
         -->
        <nav w="max" iconTint="#FF0000">
            <menu text="菜单1" icon="ic_home" showAction="ifroom" />
            <menu text="菜单2" icon="ic_search" showAction="ifroom" />
            <menu text="菜单3" icon="ic_set" showAction="always" />
            <!-- 虽然设置了 showAction="never" 但是对于导航栏来说依旧会显示 对于应用条(toolbar)就不一定显示了-->
            <menu text="菜单4" icon="ic_logger" showAction="never" />
            <menu text="菜单5" icon="ic_menu" showAction="withtext" />
        </nav>
    </linear>
</ui>
```


![](./img/nav_iconTint.png)

### textColor - 文本颜色

> 设置文本颜色


```xml
<ui>
    <statusbar />
    <!-- 我习惯性把导航栏放在底部因此设置重力 gravity="bottom" -->
    <linear w="max" h="max" dir="v" gravity="bottom">
        <!-- 设置文本颜色 textColor="#FF0000" -->
        <nav w="max" textColor="#FF0000">
            <menu text="菜单1" icon="ic_home" />
            <menu text="菜单2" icon="ic_search" />
            <menu text="菜单3" icon="ic_set" />
        </nav>
    </linear>
</ui>
```


![](./img/nav_textColor.png)

### checkColor - 选中后图标颜色

> 设置选中后图标颜色


```xml
<ui>
    <statusbar />
    <!-- 我习惯性把导航栏放在底部因此设置重力 gravity="bottom" -->
    <linear w="max" h="max" dir="v" gravity="bottom">
        <!-- 设置选中颜色 checkColor="#FF0000" -->
        <nav w="max" checkColor="#FF0000">
            <menu text="菜单1" icon="ic_home" />
            <menu text="菜单2" icon="ic_search" />
            <menu text="菜单3" icon="ic_set" />
        </nav>
    </linear>
</ui>
```


![](./img/nav_checkColor.png)

### bg - 背景颜色

> 设置背景颜色


```xml
<ui>
    <statusbar />
    <!-- 我习惯性把导航栏放在底部因此设置重力 gravity="bottom" -->
    <linear w="max" h="max" dir="v" gravity="bottom">
        <!-- 设置背景颜色 bg="#518855" -->
        <nav w="max" bg="#518855">
            <menu text="菜单1" icon="ic_home" />
            <menu text="菜单2" icon="ic_search" />
            <menu text="菜单3" icon="ic_set" />
        </nav>
    </linear>
</ui>
```


![](./img/nav_bg.png)

### bgImg - 背景图片

> 设置背景图片


```xml
<ui>
    <statusbar />
    <!-- 我习惯性把导航栏放在底部因此设置重力 gravity="bottom" -->
    <linear w="max" h="max" dir="v" gravity="bottom" padding="5">
        <!-- 设置背景图片 bgImg="/res/bg_nav.png" -->
        <nav w="max" bgImg="/res/bg_nav.png" h="90">
            <menu text="菜单1" icon="ic_home" />
            <menu text="菜单2" icon="ic_search" />
            <menu text="菜单3" icon="ic_set" />
        </nav>
    </linear>
</ui>
```


![](./img/nav_bgImg.png)

## 三、常用函数


### setBg(color)

> 设置背景颜色

- 参数 : color {int} 颜色值
- 版本 : 1.8.2


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let nav = ui.id("mNav");
//设置背景颜色
nav.setBg($color.RED);
```


### setBg(color)

> 设置背景颜色

- 参数 : color {string} 颜色字符串
- 版本 : 1.8.2


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let nav = ui.id("mNav");
//设置背景颜色
nav.setBg("#1E1F22");
```


### setIconTint(color)

> 设置图标颜色

- 参数 : color {int} 颜色值
- 版本 : 1.8.2


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let nav = ui.id("mNav");
//设置图标颜色
nav.setIconTint($color.RED);
```


### setIconTint(color)

> 设置图标颜色

- 参数 : color {string} 颜色字符串
- 版本 : 1.8.2


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let nav = ui.id("mNav");
//设置图标颜色
nav.setIconTint("#1E1F22");
```


### setTextColor(color)

> 设置文本颜色

- 参数 : color {int} 颜色值
- 版本 : 1.8.2


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let nav = ui.id("mNav");
//设置文本颜色
nav.setTextColor($color.RED);
```


### setTextColor(color)

> 设置文本颜色

- 参数 : color {string} 颜色字符串
- 版本 : 1.8.2


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let nav = ui.id("mNav");
//设置文本颜色
nav.setTextColor("#1E1F22");
```


### setCheckColor(color)

> 设置选中颜色

- 参数 : color {int} 颜色值
- 版本 : 1.8.2


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let nav = ui.id("mNav");
//设置选中颜色
nav.setCheckColor($color.RED);
```


### setCheckColor(color)

> 设置选中颜色

- 参数 : color {string} 颜色字符串
- 版本 : 1.8.2


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let nav = ui.id("mNav");
//设置选中颜色
nav.setCheckColor("#1E1F22");
```


### check(index)

> 选中指定菜单

- 参数 : index {int} 菜单索引


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let nav = ui.id("mNav");
//选中指定菜单
nav.check(0);
```


### menu(callback)

> 监听菜单事件

- 参数 : callback {(title)=>{}} 菜单点击事件


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let nav = ui.id("mNav");
//监听菜单事件
nav.menu((title)=>{
    toast(title);
});
```


# color-颜色属性对照表

- 更新时间:2025-12-02 10:12:44




### 1. 属性颜色

| 属性值                               | 颜色                                                           |
|-----------------------------------|--------------------------------------------------------------|
| colorPrimary、主题                   | com.google.android.material.R.attr.colorPrimary              |
| colorSurface、背景                   | com.google.android.material.R.attr.colorSurface              |
| colorOnSurface、文本                 | com.google.android.material.R.attr.colorOnSurface            |
| colorOnPrimary、主题主反色              | com.google.android.material.R.attr.colorOnPrimary            |
| colorPrimaryContainer、主题主容器颜色     | com.google.android.material.R.attr.colorPrimaryContainer     |
| colorOnPrimaryContainer、主题主容器反色   | com.google.android.material.R.attr.colorOnPrimaryContainer   |
| colorSecondary、主题次颜色              | com.google.android.material.R.attr.colorSecondary            |
| colorOnSecondary、主题次反色            | com.google.android.material.R.attr.colorOnSecondary          |
| colorSecondaryContainer、主题次容器颜色   | com.google.android.material.R.attr.colorSecondaryContainer   |
| colorOnSecondaryContainer、主题次容器反色 | com.google.android.material.R.attr.colorOnSecondaryContainer |
| colorTertiary                     | com.google.android.material.R.attr.colorTertiary             |
| colorOnTertiary                   | com.google.android.material.R.attr.colorOnTertiary           |
| colorTertiaryContainer            | com.google.android.material.R.attr.colorTertiaryContainer    |
| colorOnTertiaryContainer          | com.google.android.material.R.attr.colorOnTertiaryContainer  |
| colorError、主题错误颜色                 | com.google.android.material.R.attr.colorError                |
| colorOnError、主题错误反色               | com.google.android.material.R.attr.colorOnError              |
| colorErrorContainer、主题错误容器颜色      | com.google.android.material.R.attr.colorErrorContainer       |
| colorOnErrorContainer、主题错误容器反色    | com.google.android.material.R.attr.colorOnErrorContainer     |
| colorOnBackground、主题背景反色          | com.google.android.material.R.attr.colorOnBackground         |
| colorSurfaceVariant、主题中性容器颜色      | com.google.android.material.R.attr.colorSurfaceVariant       |
| colorOnSurfaceVariant、主题中性容器反色    | com.google.android.material.R.attr.colorOnSurfaceVariant     |
| colorOutline、主题中性轮廓颜色             | com.google.android.material.R.attr.colorOutline              |
| colorOutlineVariant、主题中性轮廓反色      | com.google.android.material.R.attr.colorOutlineVariant       |
| colorPrimaryInverse、主题主状态反色       | com.google.android.material.R.attr.colorPrimaryInverse       |

### 2. 名称颜色

| 属性值              | 颜色        |
|------------------|-----------|
| white、白色         | #FFFFFF   |
| black、黑色         | #000000   |
| null、透明、none、空、无 | #00000000 |
| green、绿色         | #57965C   |
| red、红色           | #C94F4F   |
| blue、蓝色          | #3574F0   |
| yellow、黄色        | #C29E4A   |

:::tip 注意
由于脚本支持中文和英文编程，所以颜色属性值可以采用中文，也可以采用英文。

例如：color="red"

等同：颜色="红色"
:::


# gravity-重力属性对照表

- 更新时间:2025-12-02 10:12:44



#### 使用方法


```xml
<ui>
    <statusbar/>
    <!-- 这里的 gravity 重力值，可以决定子组件(按钮)在布局中的位置 center 表示让按钮居中 -->
    <linear w="max" h="max" gravity="center">
        <button text="按钮"/>
    </linear>
</ui>
```


#### Gravity属性值对照表

| 属性值                                        | 对应的Gravity值                     |
|--------------------------------------------|---------------------------------|
| fill、填充                                    | Gravity.FILL                    |
| fill_h、fill_horizontal、水平填充、横向填充           | Gravity.FILL_HORIZONTAL         |
| fill_v、fill_vertical、垂直填充、竖向填充             | Gravity.FILL_VERTICAL           |
| start、开头、开始、头部                             | Gravity.START                   |
| end、末尾、结束、尾部                               | Gravity.END                     |
| left、左、左边                                  | Gravity.LEFT                    |
| right、右、右边                                 | Gravity.RIGHT                   |
| top、上、上边                                   | Gravity.TOP                     |
| bottom、下、下边、下面                             | Gravity.BOTTOM                  |
| center、中、中心、中间、居中                          | Gravity.CENTER                  |
| center_h、center_horizontal、水平居中、横向居中       | Gravity.CENTER_HORIZONTAL       |
| center_v、center_vertical、垂直居中、竖向居中         | Gravity.CENTER_VERTICAL         |
| display_h、display_horizontal、水平显示裁剪、横向显示裁剪 | Gravity.DISPLAY_CLIP_HORIZONTAL |
| display_v、display_vertical、垂直显示裁剪、竖向显示裁剪   | Gravity.DISPLAY_CLIP_VERTICAL   |
| clip_h、clip_horizontal、水平裁剪、横向裁剪           | Gravity.CLIP_HORIZONTAL         |
| clip_v、clip_vertical、垂直裁剪、竖向裁剪             | Gravity.CLIP_VERTICAL           |

:::tip 注意
由于脚本支持中文和英文编程，所以重力属性值可以采用中文，也可以采用英文。

例如：gravity="center"

等同：重力="中"
:::


# 补充文档

- 更新时间:2025-12-02 10:12:44



## [1.gravity-重力 属性对照表](./other/gravity)

## [2.color-颜色 属性对照表](./other/color)


# 多页布局

- 更新时间:2025-12-02 10:12:46

> 多页布局-pager
> 
> 多页布局允许用户在里面写多个界面并实现界面左右滑动，并且支持绑定标签页布局(tab)以及导航栏(nav)
> 
> 原生类型:{androidx.viewpager2.widget.ViewPager2}




## 一、常用属性


### fragment - 多页布局

> 设置多页布局
> 
> 其中每个fragment最后都会被解析成一个布局，把这个节点理解为ui节点就好了，本质上就是个LinearLayout。


```xml
<pager w="max" h="max">
    <fragment />
    <fragment />
    <fragment />
</pager>
```


### def - 默认下标页面

> 设置默认下标页面


```xml
<pager def="0" />
```


### padding - 内边距

> 设置内边距


```xml
<!--padding顺序是:左,上,右,下-->
<!--padding只设置一个值：则设置所有方向的内边距-->
<!--padding只设置两个值：则设置左右和上下方向的内边距-->
<pager padding="20" />
```


### gravity - 重力

> 设置重力


```xml
<pager gravity="start" />
```


### bg - 背景颜色

> 设置背景颜色


```xml
<radio bg="#1E1F22" />
```


### bgImg - 背景图片

> 设置背景图片


```xml
<pager bgImg="./img.png" />
```


## 二、常用函数


### setCurIndex(index)

> 设置当前页面索引

- 参数 : index {int} 当前页面索引


```javascript
//解析界面,获得ui布局
let ui = $ui.layout("./mUi.xml");
//获得控件
let pager = ui.id("mPager");
//设置当前页面索引
pager.setCurIndex(0);
```


### curIndex()

> 获得当前页面索引

- 返回 : {int} 当前页面索引


```javascript
//解析界面,获得ui布局
let ui = $ui.layout("./mUi.xml");
//获得控件
let pager = ui.id("mPager");
//获得当前页面索引
let index = pager.curIndex();
```


### bind(xTab)

> 绑定与tab联动

- 参数 : xTab {tab} 标签布局


```javascript
//解析界面,获得ui布局
let ui = $ui.layout("./mUi.xml");
//获得控件
let pager = ui.id("mPager");
let tab = ui.id("mTab");
//与标签布局联动
pager.bind(tab);
```


### bind(xNav)

> 绑定与nav联动

- 参数 : xNav {nav} 底部导航布局


```javascript
//解析界面,获得ui布局
let ui = $ui.layout("./mUi.xml");
//获得控件
let pager = ui.id("mPager");
let nav = ui.id("mNav");
//与导航栏联动
pager.bind(nav);
```


### onCheck(callback)

> 监听页面切换事件

- 参数 : callback {(index)=>{}} 页面切换事件


```javascript
//解析界面,获得ui布局
let ui = $ui.layout("./mUi.xml");
//获得控件
let pager = ui.id("mPager");
//监听页面切换事件
pager.onCheck((index)=>{
    //..
});
```


### onState(callback)

> 监听页面状态事件

- 参数 : callback {(state)=>{}} 页面状态事件


```javascript
//解析界面,获得ui布局
let ui = $ui.layout("./mUi.xml");
//获得控件
let pager = ui.id("mPager");
//监听页面状态事件
pager.onState((state)=>{
    //...
});
```


# 进度条

- 更新时间:2025-12-02 10:12:47

> 进度条-progress
> 
> 圆形原生类型:{com.google.android.material.progressindicator.CircularProgressIndicator}
> 线性原生类型:{com.google.android.material.progressindicator.LinearProgressIndicator}




进度条：比如下载进度，游戏进度，进度条就是用来显示进度的控件


![](./img/progress_demo.gif)


```xml
<ui>
    <statusbar />
    <linear w="max" padding="10">
        <linear w="max" dir="h">
            <progress w="max" padding="10" run="true" />
            <progress w="max" color="#518855" padding="10" run="true" />
            <progress w="max" color="#B44A4A" padding="10" run="true" />
        </linear>
        <progress w="max" style="line" run="true" padding="10" />
        <progress w="max" style="line" color="#518855" padding="10" run="true" />
        <progress w="max" style="line" color="#B44A4A" padding="10" run="true" />
    </linear>
</ui>
```


## 一、基础用法


```xml
<ui>
    <statusbar />
    <linear w="max" padding="10">
        <!-- 指定进度条的id -->
        <progress id="circularProgress" w="max"/>
        <progress id="lineProgress" w="max" style="line"/>
    </linear>
</ui>
```

```javascript
//解析布局
let ui = $ui.layout("ui.xml");
ui.show();//显示界面
//获取圆形/线性进度条
let cp = ui.id("circularProgress");
let lp = ui.id("lineProgress");
//动态模拟进度条的走动
for (let i = 1; i <= 10; i++) {
    sleep(150);
    //[核心]:设置进度
    cp.setProgress(i * 10);
    lp.setProgress(i * 10);
}
```


## 二、常用属性


### visible - 可见性

> 设置可见性


```xml
<progress visible="false" />
```


### style - 样式

> 设置样式


```xml
<ui>
    <statusbar />
    <linear w="max" padding="10">
        <!-- 默认样式 -->
        <progress w="max" />
        <!-- 直线样式 -->
        <progress w="max" style="line" />
    </linear>
</ui>
```


![](./img/progress_style.png)

### thickness - 厚度

> 设置厚度


```xml
<ui>
    <statusbar />
    <linear w="max" padding="10">
        <!-- 设置厚度 thickness="10" -->
        <progress w="max" thickness="10" />
        <progress w="max" style="line" thickness="10" />
    </linear>
</ui>
```


![](./img/progress_thickness.png)

### run - 动画

> 设置动画


```xml
<ui>
    <statusbar />
    <linear w="max" padding="10">
        <!-- 默认样式 -->
        <progress w="max" run="true"/>
        <!-- 直线样式 -->
        <progress w="max" style="line" run="true"/>
    </linear>
</ui>
```


![](./img/progress_run.gif)

### color - 颜色

> 设置颜色


```xml
<ui>
    <statusbar />
    <linear w="max" padding="10">
        <!-- 设置颜色 color="#518855" -->
        <progress w="max" color="#518855" />
        <progress w="max" style="line" color="#B44A4A" />
    </linear>
</ui>
```


![](./img/progress_color.png)

### minW - 最小宽度

> 设置最小宽度


```xml
<progress minW="100" />
```


### minH - 最小高度

> 设置最小高度


```xml
<progress minH="100" />
```


### padding - 内边距

> 设置内边距


```xml
<ui>
    <statusbar />
    <linear w="max" padding="10">
        <!-- 设置内边距 padding="20" -->
        <progress padding="20" />
        <progress style="line" padding="35" />
    </linear>
</ui>
```


![](./img/progress_padding.png)

### bg - 背景颜色

> 设置背景颜色


```xml
<ui>
    <statusbar />
    <linear w="max" padding="10">
        <!-- 设置背景颜色 -->
        <progress w="max" padding="10" bg="#518855"/>
        <progress w="max" style="line" bg="#B44A4A" padding="10" />
    </linear>
</ui>
```


![](./img/progress_bg.png)

### bgImg - 背景图片

> 设置背景图片


```xml
<ui>
    <statusbar />
    <linear w="max" padding="10">
        <!-- 设置背景图片 bgImg="/res/bg_pg.png" -->
        <progress w="max" padding="10" bgImg="/res/bg_pg.png" />
        <!-- 设置背景图片 bgImg="/res/bg_pgLine.png" -->
        <progress w="max" style="line" padding="10" bgImg="/res/bg_pgLine.png" />
    </linear>
</ui>
```


![](./img/progress_bgImg.png)

## 三、常用函数


### setProgress(progress)

> 设置进度
> 
> 此方法需要安卓7.0以上生效

- 参数 : progress {int} 进度值


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let progress = ui.id("mProgress");
//设置进度
progress.setProgress(50);
```


### setMax(progress)

> 设置最大进度

- 参数 : progress {int} 最大值


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let progress = ui.id("mProgress");
//设置最大进度
progress.setMax(100);
```


### getProgress()

> 获得进度

- 返回 : {int} 进度


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let progress = ui.id("mProgress");
//获得进度
let p = progress.getProgress();
```


### show()

> 显示进度条


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let progress = ui.id("mProgress");
//显示进度条
progress.show();
```


### hide()

> 隐藏进度条


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let progress = ui.id("mProgress");
//隐藏进度条
progress.hide();
```


# 单选按钮组

- 更新时间:2025-12-02 10:12:47

> 单选按钮组-radio-group
> 
> 在此布局中，单选按钮会自动取消和选中，保证一组按钮只被选中一个
> 
> 是布局父类的(XLayout)的子类
> 
> 原生类型:{android.widget.RadioGroup}




## 一、常用属性


### dir - 排列方向

> 设置排列方向
> 
> 可选:v:竖向排列,h:横向排列


```xml
<radio-group dir="h" />
```


### color - 主题颜色

> 设置主题颜色


```xml
<radio-group color="#57965C" text="主题色为绿色" />
```


### padding - 内边距

> 设置内边距


```xml
<!--padding顺序是:左,上,右,下-->
<!--padding只设置一个值：则设置所有方向的内边距-->
<!--padding只设置两个值：则设置左右和上下方向的内边距-->
<radio-group padding="20" text="内边距" />
```


### gravity - 重力

> 设置重力


```xml
<radio-group gravity="start" h="100" margin="20" text="重力:start" w="max" />
```


### bg - 背景颜色

> 设置背景颜色


```xml
<radio-group bg="#1E1F22" text="背景颜色" />
```


### bgImg - 背景图片

> 设置背景图片


```xml
<radio-group bgImg="./img.png" text="背景图片" />
```


### check(index)

> 设置选中的下标

- 参数 : index {int} 下标


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let rg = ui.id("mRadioGroup");
//设置选中的下标
rg.check(0);
```


### onCheck(callback)

> 设置选中下标的事件回调

- 参数 : callback {(index)=>{}} 回调


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let rg = ui.id("mRadioGroup");
//设置选中下标的事件回调
rg.onCheck((index)=>{
    //..
});
```


### getCheckedIndex()

> 获取选择下标

- 返回 : {int} 下标 (-1表示没有选择)


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let rg = ui.id("mRadioGroup");
//获得选择下标
let index = rg.getCheckedIndex();
```


### getCheckedText()

> 获取选择的文本

- 返回 : {string} 名称 (null表示没有选择)


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let rg = ui.id("mRadioGroup");
//获得选择的文本
let text = rg.getCheckedText();
```


# 单选按钮

- 更新时间:2025-12-02 10:12:47

> 单选按钮-radio
> 
> 原生类型:{com.google.android.material.radiobutton.MaterialRadioButton}




单选按钮：一般需要配合单选按钮组(radio-group)的配合才能实现互相排斥的效果，这个控件常用在只需要在多个选择中选择一个的情况。


![](./img/radio_color.png)

## 一、常用属性


### color - 主题颜色

> 设置主题颜色


```xml
<ui>
    <statusbar />
    <linear w="max" padding="10" dir="h">
        <radio text="吃饭" />
        <!-- 设置主题颜色 color="#518855" -->
        <radio color="#518855" text="睡觉" />
        <radio color="#B44A4A" text="游戏" />
    </linear>
</ui>
```


![](./img/radio_color.png)

### check - 选中状态

> 设置选中状态


```xml
<ui>
    <statusbar />
    <linear w="max" padding="10" dir="h">
        <!-- 设置选中状态 check="true" -->
        <radio text="吃饭" check="false" />
        <radio text="睡觉" check="true" />
        <radio text="游戏" check="false" />
    </linear>
</ui>
```


![](./img/radio_check.png)

### text - 文本

> 设置文本


```xml
<ui>
    <statusbar />
    <linear w="max" padding="10" dir="h">
        <!-- 设置文本 text="吃饭" -->
        <radio text="吃饭" />
        <radio text="睡觉" />
        <radio text="游戏" />
    </linear>
</ui>
```


![](./img/radio_text.png)

### textColor - 文本颜色

> 设置文本颜色


```xml
<ui>
    <statusbar />
    <linear w="max" padding="10" dir="h">
        <!-- 设置文本颜色 textColor="theme" 指的是使用app主题主要颜色 -->
        <radio text="吃饭" textColor="theme" />
        <!-- 设置文本颜色 textColor="#518855" -->
        <radio text="睡觉" textColor="#518855"/>
        <radio text="游戏" textColor="#C94F4F" />
    </linear>
</ui>
```


![](./img/radio_textColor.png)

### minW - 最小宽度

> 设置最小宽度


```xml
<radio minW="100" />
```


### minH - 最小高度

> 设置最小高度


```xml
<radio minH="100" />
```


### padding - 内边距

> 设置内边距


```xml
<ui>
    <statusbar />
    <linear w="max" padding="10" dir="h">
        <!--padding顺序是:左,上,右,下-->
        <!--padding只设置一个值：则设置所有方向的内边距-->
        <!--padding只设置两个值：则设置左右和上下方向的内边距-->
        <radio text="吃饭" textColor="theme" padding="5" />
        <!-- 设置内边距 padding="10" -->
        <radio text="睡觉" textColor="#518855" padding="10" />
        <radio text="游戏" textColor="#C94F4F" padding="15" />
    </linear>
</ui>
```


![](./img/radio_padding.png)

### gravity - 重力

> 设置重力


```xml
<radio gravity="start" h="100" margin="20" text="重力:start" w="max" />
```


![](./img/radio_gravity.png)

### bg - 背景颜色

> 设置背景颜色


```xml
<ui>
    <statusbar />
    <linear w="max" padding="10" dir="h">
        <!-- 设置背景颜色 bg="#518855" -->
        <radio text="绿色" bg="#518855" />
        <radio text="红色" bg="#B44A4A" />
    </linear>
</ui>
```


![](./img/radio_bg.png)

### bgImg - 背景图片

> 设置背景图片


```xml
<ui>
    <statusbar />
    <linear w="max" padding="10" dir="h">
        <!--
        通过 bgImg="/res/eat.png" 设置控件的背景图片
        为了让图片显示的大小一样所以设置了 w="100" h="55"
        为了让文字显示的明显所以设置了文本颜色 textColor="#B34A4A"
        为了让每个单选按钮能够间隔开来所以设置了外边距 margin="5"
         -->
        <radio text="吃饭" margin="5" textColor="#B34A4A" bgImg="/res/eat.png" w="100" h="55" />
        <radio text="睡觉" margin="5" textColor="#FFFFFF" bgImg="/res/sleep.png" w="100" h="55" />
        <radio text="游戏" margin="5" textColor="#2e58e2" bgImg="/res/game.png" w="100" h="55" />
    </linear>
</ui>
```


![](./img/radio_bgImg.png)

## 二、常用函数


### isChecked()

> 判断选中状态

- 返回 : {boolean} 是否选中了
- 版本 : 1.8.2


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let radio = ui.id("mRadio");
//判断选中状态
if(radio.isChecked()){
    log("选中了");
}
```


### check(checked)

> 设置选中状态

- 参数 : checked {boolean} 是否选中


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let radio = ui.id("mRadio");
//设置选中状态
radio.check(true);
```


### onCheck(callback)

> 设置选中状态回调事件

- 参数 : callback {(isChecked)=>{}} 回调事件


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let radio = ui.id("mRadio");
//设置选中状态回调事件
radio.onCheck((isChecked)=>{
    //..
});
```


### setGravity(gravity)

> 设置控件的对齐方式

- 参数 : gravity {String} 例如:"center|bottom"


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let radio = ui.id("mRadio");
//设置控件的对齐方式
radio.setGravity("center|bottom");
```


### setText(text)

> 设置文字

- 参数 : text {String} 文字


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let radio = ui.id("mRadio");
//设置文字
radio.setText("吃饭");
```


### getText()

> 获得文字

- 返回 : {String} 文字


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let radio = ui.id("mRadio");
//获得文字
let text = radio.getText();
```


### setColor(color)

> 设置主题颜色

- 参数 : color {String} 颜色


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let radio = ui.id("mRadio");
//设置主题颜色
radio.setColor("#26282E");
```


### setTextColor(color)

> 设置文字颜色

- 参数 : color {String} 颜色


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let radio = ui.id("mRadio");
//设置文字颜色
radio.setTextColor("#26282E");
```


# 轨道

- 更新时间:2025-12-02 10:12:47

> 轨道-rail
> 
> 这个控件和nav导航栏控件很像，只不过是竖向排列的
> 
> 原生类型:{com.google.android.material.navigationrail.NavigationRailView}




## 一、常用属性


### iconTint - 图标颜色

> 设置图标颜色


```xml
<rail iconTint="#FF0000" />
```


### textColor - 文本颜色

> 设置文本颜色


```xml
<rail textColor="#FF0000" />
```


### checkColor - 选中后图标颜色

> 设置选中后图标颜色


```xml
<rail checkColor="#FF0000" />
```


### padding - 内边距

> 设置内边距


```xml
<!--padding顺序是:左,上,右,下-->
<!--padding只设置一个值：则设置所有方向的内边距-->
<!--padding只设置两个值：则设置左右和上下方向的内边距-->
<rail padding="20" text="内边距" />
```


### gravity - 重力

> 设置重力


```xml
<rail gravity="start" h="100" margin="20" text="重力:start" w="max" />
```


### bg - 背景颜色

> 设置背景颜色


```xml
<rail bg="#1E1F22" text="背景颜色" />
```


### bgImg - 背景图片

> 设置背景图片


```xml
<rail bgImg="./img.png" text="背景图片" />
```


## 二、常用函数


### setBg(color)

> 设置背景颜色

- 参数 : color {int} 颜色值
- 版本 : 1.8.2


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let rail = ui.id("mRail");
//设置背景颜色
rail.setBg($color.RED);
```


### setBg(color)

> 设置背景颜色

- 参数 : color {string} 颜色字符串
- 版本 : 1.8.2


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let rail = ui.id("mRail");
//设置背景颜色
rail.setBg("#1E1F22");
```


### setIconTint(color)

> 设置图标颜色

- 参数 : color {int} 颜色值
- 版本 : 1.8.2


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let rail = ui.id("mRail");
//设置图标颜色
rail.setIconTint($color.RED);
```


### setIconTint(color)

> 设置图标颜色

- 参数 : color {string} 颜色字符串
- 版本 : 1.8.2


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let rail = ui.id("mRail");
//设置图标颜色
rail.setIconTint("#1E1F22");
```


### setTextColor(color)

> 设置文本颜色

- 参数 : color {int} 颜色值
- 版本 : 1.8.2


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let rail = ui.id("mRail");
//设置文本颜色
rail.setTextColor($color.RED);
```


### setTextColor(color)

> 设置文本颜色

- 参数 : color {string} 颜色字符串
- 版本 : 1.8.2


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let rail = ui.id("mRail");
//设置文本颜色
rail.setTextColor("#1E1F22");
```


### setCheckColor(color)

> 设置选中颜色

- 参数 : color {int} 颜色值
- 版本 : 1.8.2


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let rail = ui.id("mRail");
//设置选中颜色
rail.setCheckColor($color.RED);
```


### setCheckColor(color)

> 设置选中颜色

- 参数 : color {string} 颜色字符串
- 版本 : 1.8.2


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let rail = ui.id("mRail");
//设置选中颜色
rail.setCheckColor("#1E1F22");
```


### check(index)

> 选中指定菜单

- 参数 : index {int} 菜单索引


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let rail = ui.id("mRail");
//选中指定菜单
rail.check(0);
```


### menu(callback)

> 监听菜单事件

- 参数 : callback {(title)=>{}} 菜单点击事件


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let rail = ui.id("mRail");
//监听菜单事件
rail.menu((title)=>{
    toast(title);
});
```


# 范围

- 更新时间:2025-12-02 10:12:47

> 范围-range
> 
> 原生类型:{com.google.android.material.slider.RangeSlider}




## 一、常用属性


### from - 开始值

> 设置开始值


```xml
<range from="0" />
```


### to - 结束值

> 设置结束值


```xml
<range to="100" />
```


### fromValue - 左初始值

> 设置左初始值


```xml
<range fromValue="10" />
```


### toValue - 右初始值

> 设置右初始值


```xml
<range toValue="60" />
```


### step - 进步值

> 设置进步值


```xml
<range step="1" />
```


### color - 主题颜色

> 设置主题颜色


```xml
<range color="#FF0000" />
```


### label - 标签文字

> 设置标签文字


```xml
<range label="进度:" />
```


### labelEnd - 标签文字尾部

> 设置标签文字尾部


```xml
<range labelEnd="个" />
```


### padding - 内边距

> 设置内边距


```xml
<!--padding顺序是:左,上,右,下-->
<!--padding只设置一个值：则设置所有方向的内边距-->
<!--padding只设置两个值：则设置左右和上下方向的内边距-->
<range padding="20" />
```


### gravity - 重力

> 设置重力


```xml
<range gravity="start" />
```


### bg - 背景颜色

> 设置背景颜色


```xml
<range bg="#1E1F22" />
```


### bgImg - 背景图片

> 设置背景图片


```xml
<range bgImg="./img.png" />
```


## 二、常用函数


### onLabel(callback)

> 设置标签格式化

- 参数 : callback {(floatValue)=>{ return "标签"; }} 格式化回调


### onChange(callback)

> 设置变化监听

- 参数 : callback {(from,to)=>{}} 回调


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let range = ui.id("mRange");
//设置数据变化监听
range.onChange((from,to)=>{
    //..
});
```


### getRange()

> 获取范围

- 返回 : {number[]}


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let range = ui.id("mRange");
//获取数据(开始,结束)
range.getRange();
```


### setData(from, to)

> 设置数据

- 参数 : from {float} 开始值(当前值一致)
- 参数 : to {float} 结束值


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let range = ui.id("mRange");
//设置数据(开始,结束)
range.setData(0,100);
```


# 拖动条

- 更新时间:2025-12-02 10:12:47

> 拖动条-seek
> 
> 该组件比slider更加小巧，属于安卓原生组件。
> 
> 原生类型:{android.widget.SeekBar}




## 一、常用属性


### from - 开始值

> 设置开始值


```xml
<seek from="0" />
```


### to - 结束值

> 设置结束值


```xml
<tab to="100" />
```


### value - 当前值

> 设置当前值


```xml
<tab value="30" />
```


### padding - 内边距

> 设置内边距


```xml
<!--padding顺序是:左,上,右,下-->
<!--padding只设置一个值：则设置所有方向的内边距-->
<!--padding只设置两个值：则设置左右和上下方向的内边距-->
<tab seek="20" />
```


### bg - 背景颜色

> 设置背景颜色


```xml
<tab seek="#1E1F22" />
```


### bgImg - 背景图片

> 设置背景图片


```xml
<tab seek="./img.png" />
```


## 二、常用函数


### onChange(callback)

> 设置数值变化监听
> 
> 注意:只监听由用户手动触发的数值变化,若为编程时设置的数值,则忽略

- 参数 : callback {(value)=>{}}


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let seek = ui.id("mSeek");
//设置选中的下标
seek.onChange((value)=>{
    //..
});
```


### getValue()

> 获取当前数值

- 返回 : {int} 当前数值


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let seek = ui.id("mSeek");
//获取进度数值
let value = seek.getValue();
```


### getMin()

> 获取最小值

- 返回 : {int} 当前数值


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let seek = ui.id("mSeek");
//获取最小值
let minVal = seek.getMin();
```


### getMax()

> 获取最大值

- 返回 : {int} 当前数值


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let seek = ui.id("mSeek");
//获取最大值
let maxVal = seek.getMax();
```


### setValue(value)

> 设置数值

- 参数 : value {int} 数值


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let seek = ui.id("mSeek");
//设置数值
seek.setValue(50);
```


### setMax(value)

> 设置最大值

- 参数 : value {int} 数值


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let seek = ui.id("mSeek");
//设置最大值
seek.setMax(50);
```


### setMin(value)

> 设置最小值

- 参数 : value {int} 数值


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let seek = ui.id("mSeek");
//设置最小值
seek.setMin(0);
```


# 滑动条

- 更新时间:2025-12-02 10:12:47

> 滑动条-slider
> 
> 原生类型:{com.google.android.material.slider.Slider}




滚动条：常用于动态设置数字参数，通过滑动就可以变换数值。


![](./img/slider_demo.png)

## 一、常用属性


### from - 开始值

> 设置开始值


```xml
<ui>
    <statusbar />
    <linear w="max" h="max" dir="v" gravity="center">
        <!-- 滑动条 默认开始值是0 结束值是100 -->
        <slider  />
        <!-- 滑动条 设置开始值 from="20" -->
        <slider from="20" />
    </linear>
</ui>
```


![](./img/slider_from.png)

### to - 结束值

> 设置结束值


```xml
<ui>
    <statusbar />
    <linear w="max" h="max" dir="v" gravity="center">
        <!-- 滑动条 默认开始值是0 结束值是100 -->
        <slider  />
        <!-- 滑动条
        设置开始值 from="20"
        设置结束值 to="30"
        -->
        <slider from="20" to="30" />
    </linear>
</ui>
```


![](./img/slider_to.png)

### value - 初始值

> 设置初始值


```xml
<ui>
    <statusbar />
    <linear w="max" h="max" dir="v" gravity="center">
        <!-- 滑动条 默认开始值是0 结束值是100
        设置当前值为 50
        -->
        <slider value="50" />
    </linear>
</ui>
```


![](./img/slider_value.png)

### step - 进步值

> 设置进步值


```xml
<ui>
    <statusbar />
    <linear w="max" h="max" dir="v" gravity="center">
        <!-- 滑动条 默认开始值是0 结束值是100
        设置进步值为 1
        -->
        <slider step="1" />
    </linear>
</ui>
```


![](./img/slider_step.png)

### color - 主题颜色

> 设置主题颜色


```xml
<ui>
    <statusbar />
    <linear w="max" h="max" dir="v" gravity="center">
        <!-- 滑动条 设置主题颜色 color="#518855" -->
        <slider />
        <slider color="#518855" />
        <slider color="#B44A4A" />
    </linear>
</ui>
```


![](./img/slider_demo.png)

### label - 标签文字

> 设置标签文字


```xml
<ui>
    <statusbar />
    <linear w="max" h="max" dir="v" gravity="center">
        <!-- 滑动条 默认开始值是0 结束值是100
        设置标签 label="进度:"
        -->
        <slider label="进度:" />
    </linear>
</ui>
```


![](./img/slider_label.png)

### labelEnd - 标签文字尾部

> 设置标签文字尾部


```xml
<ui>
    <statusbar />
    <linear w="max" h="max" dir="v" gravity="center">
        <!-- 滑动条 默认开始值是0 结束值是100
        设置尾部标签 labelEnd="个"
        注意：label和labelEnd只能有一个生效，避免重复设置
        -->
        <slider labelEnd="个" />
    </linear>
</ui>
```


![](./img/slider_labelEnd.png)

### padding - 内边距

> 设置内边距


```xml
<ui>
    <statusbar />
    <linear w="max" h="max" dir="v" gravity="center">
        <!-- 滑动条 默认开始值是0 结束值是100 -->
        <!--padding顺序是:左,上,右,下-->
        <!--padding只设置一个值：则设置所有方向的内边距-->
        <!--padding只设置两个值：则设置左右和上下方向的内边距-->
        <slider padding="5" />
        <slider padding="10" />
        <slider padding="15" />
    </linear>
</ui>
```


![](./img/slider_padding.png)

### bg - 背景颜色

> 设置背景颜色


```xml
<ui>
    <statusbar />
    <linear w="max" h="max" dir="v" gravity="center">
        <!-- 滑动条 默认开始值是0 结束值是100
        设置背景颜色 bg="#518855"
        -->
        <slider bg="#518855" />
        <slider bg="#B44A4A" />
    </linear>
</ui>
```


![](./img/slider_bg.png)

### bgImg - 背景图片

> 设置背景图片


```xml
<ui>
    <statusbar />
    <linear w="max" h="max" dir="v" gravity="center">
        <!-- 滑动条 默认开始值是0 结束值是100
        设置背景图片 bgImg="/res/bg_slider.png"
        -->
        <slider bgImg="/res/bg_slider.png" />
    </linear>
</ui>
```


![](./img/slider_bgImg.png)

## 二、常用函数


### setBg(color)

> 设置背景颜色

- 参数 : color {int} 颜色值
- 版本 : 1.8.2


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let slider = ui.id("mSlider");
//设置背景颜色
slider.setBg($color.RED);
```


### setBg(color)

> 设置背景颜色

- 参数 : color {string} 颜色字符串
- 版本 : 1.8.2


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let slider = ui.id("mSlider");
//设置背景颜色
slider.setBg("#1E1F22");
```


### setColor(color)

> 设置主题颜色

- 参数 : color {int} 颜色值
- 版本 : 1.8.2


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let slider = ui.id("mSlider");
//设置主题颜色
slider.setColor($color.RED);
```


### setColor(color)

> 设置主题颜色

- 参数 : color {string} 颜色字符串
- 版本 : 1.8.2


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let slider = ui.id("mSlider");
//设置主题颜色
slider.setColor("#1E1F22");
```


### onLabel(callback)

> 设置标签格式化

- 参数 : callback {(floatValue)=>{ return "标签"; }} 格式化回调


### onChange(callback)

> 设置数值变化监听
> 
> 注意:只监听由用户手动触发的数值变化,若为编程时设置的数值,则忽略

- 参数 : callback {(value)=>{}}


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let slider = ui.id("mSlider");
//设置选中的下标
slider.onChange((value)=>{
    //..
});
```


### getValue()

> 获取当前进度值

- 返回 : {float} 当前数值


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let slider = ui.id("mSlider");
//获取当前进度值
let val = slider.getValue();
```


### setValue(value)

> 设置数据

- 参数 : value {float} 当前值 


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let slider = ui.id("mSlider");
//设置当前值
slider.setValue(10);
```


### setFrom(from)

> 设置数据

- 参数 : from {float} 开始值 


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let slider = ui.id("mSlider");
//设置开始大小
slider.setFrom(0);
```


### setStep(step)

> 设置数据

- 参数 : step {float} 进步值 


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let slider = ui.id("mSlider");
//设置进步值
slider.setStep(1);
```


### setTo(to)

> 设置数据

- 参数 : to {float} 结束值 


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let slider = ui.id("mSlider");
//设置结束大小
slider.setTo(100);
```


### setData(from, to)

> 设置数据

- 参数 : from {float} 开始值(当前值一致)
- 参数 : to {float} 结束值


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let slider = ui.id("mSlider");
//设置数据(开始,结束)
slider.setData(0,100);
```


### setData(from, to, value)

> 设置数据

- 参数 : from {float} 开始值
- 参数 : to {float} 结束值
- 参数 : value {float} 当前值


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let slider = ui.id("mSlider");
//设置数据(开始,结束,当前值)
slider.setData(0,100,20);
```


# 状态栏

- 更新时间:2025-12-02 10:12:47

> 状态栏-statusbar
> 
> 本质上就是一个{MaterialTextView},只不过高度为状态条的高度,此控主要用来占位置,避免手机状态条挡住主要的布局
> 
> 原生类型:{com.google.android.material.textview.MaterialTextView}




状态栏：一般手机界面的最上方的部分就是状态栏。


![](./img/statusbar_example.png)

## 一、常用属性


### color - 背景颜色

> 设置背景颜色


```xml
<ui>
    <statusbar />
    <linear w="max" dir="v" gravity="center" h="max">
        <statusbar color="#518855" />
        <statusbar color="#B44A4A" />
        <statusbar color="#3574F0" />
    </linear>
</ui>
```


![](./img/822704913786800.png)

### bg - 背景颜色

> 设置背景颜色


```xml
<ui>
    <statusbar bg="#518855" />
</ui>
```


![](./img/823019796005800.png)

### bgImg - 背景图片

> 设置背景图片


```xml
<statusbar bgImg="./img.png"/>
```


![](./img/822979123418600.png)

## 二、常用函数


### setColor(color)

> 设置颜色

- 参数 : color {string} 文本颜色


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let bar = ui.id("mBar");
//设置颜色
bar.setColor("#1E1F22");
```


# 开关

- 更新时间:2025-12-02 10:12:47

> 开关-switch
> 
> 原生类型:{com.google.android.material.materialswitch.MaterialSwitch}




开关：顾名思义，就是开关的意思，只有打开或者关闭两种状态。


![](./img/823241319415800.png)

## 一、常用属性


### color - 主题颜色

> 设置主题颜色


```xml
<ui>
    <statusbar />
    <linear w="max" h="max" dir="h" gravity="center" padding="20">
        <switch color="#57965C" text="主题色为绿色" />
    </linear>
</ui>
```


![](./img/823661390164300.png)

### text - 文本

> 设置文本


```xml
<ui>
    <statusbar />
    <linear w="max" h="max" dir="h" gravity="center" padding="20">
        <switch text="我是文本" />
    </linear>
</ui>
```


![](./img/823704126486300.png)

### textColor - 文本颜色

> 设置文本颜色


```xml
<ui>
    <statusbar />
    <linear w="max" h="max" dir="h" gravity="center" padding="20">
        <switch text="文本颜色"  textColor="#B44A4A" />
    </linear>
</ui>
```


![](./img/823742446042900.png)

### check - 是否选中

> 设置是否选中


```xml
<ui>
    <statusbar />
    <linear w="max" h="max" dir="h" gravity="center" padding="20">
        <switch text="默认选中"  check="true" />
    </linear>
</ui>
```


![](./img/823778688193600.png)

### minW - 最小宽度

> 设置最小宽度


```xml
<ui>
    <statusbar />
    <linear w="max" h="max" dir="v" gravity="center" padding="20">
        <switch text="开关" />
        <switch text="开关" minW="200" />
    </linear>
</ui>
```


![](./img/823844386523100.png)

### minH - 最小高度

> 设置最小高度


```xml
<ui>
    <statusbar />
    <linear w="max" h="max" dir="v" gravity="center" padding="20">
        <switch text="开关" />
        <switch text="开关" minH="40" />
        <switch text="开关" minH="70" />
    </linear>
</ui>
```


![](./img/823887649088400.png)

### padding - 内边距

> 设置内边距


```xml
<ui>
    <statusbar />
    <linear w="max" h="max" dir="v" gravity="center" padding="20">
        <!--padding 顺序是:左,上,右,下-->
        <!--padding 只设置一个值：则设置所有方向的内边距-->
        <!--padding 只设置两个值：则设置左右和上下方向的内边距-->
        <switch padding="8" text="内边距" />
        <switch padding="12" text="内边距" />
        <switch padding="16" text="内边距" />
    </linear>
</ui>
```


![](./img/824262862930600.png)

### gravity - 重力

> 设置重力


```xml
<ui>
    <statusbar />
    <linear w="max" h="max" dir="v" gravity="center" padding="20">
        <switch text="开关" w="max" />
        <switch text="开关" gravity="center" w="max" />
        <switch text="开关" gravity="end" w="max" />
    </linear>
</ui>
```


![](./img/824016785709400.png)

### bg - 背景颜色

> 设置背景颜色


```xml
<ui>
    <statusbar />
    <linear w="max" h="max" dir="v" gravity="center" padding="20">
        <switch text="开关" bg="#518855" />
        <switch text="开关" bg="#B44A4A" />
    </linear>
</ui>
```


![](./img/824071990244600.png)

### bgImg - 背景图片

> 设置背景图片


```xml
<ui>
    <statusbar />
    <linear w="max" h="max" dir="v" gravity="center" padding="20">
        <switch text="开关" bgImg="/res/bg-switch.png" padding="15" />
    </linear>
</ui>
```


![](./img/824213477601000.png)

## 二、常用函数


### check(checked)

> 设置选中状态

- 参数 : checked {boolean} 是否选中


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let switzh = ui.id("mSwitch");
//设置选中状态
switzh.check(true);
```


### isChecked()

> 判断选中状态

- 返回 : {boolean} 是否选中了
- 版本 : 1.8.2


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let switzh = ui.id("mSwitch");
//判断选中状态
if(switzh.isChecked()){
    log("选中了");
}
```


### onCheck(callback)

> 设置状态改变监听

- 参数 : callback ((checked)=>{}) 回调


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let switzh = ui.id("mSwitch");
//设置状态改变监听
switzh.onCheck((checked)=>{
    //..
});
```


### setGravity(gravity)

> 设置控件的对齐方式

- 参数 : gravity {String} 例如:"center|bottom"


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let switzh = ui.id("mSwitch");
//设置控件的对齐方式
switzh.setGravity("center|bottom");
```


### setText(text)

> 设置文字

- 参数 : text {String} 文字


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let switzh = ui.id("mSwitch");
//设置文字
switzh.setText("是否开启");
```


### getText()

> 获取文字

- 返回 : {String} 文字


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let switzh = ui.id("mSwitch");
//获得文字
let text = switzh.getText();
```


### setColor(color)

> 设置主题颜色

- 参数 : color {String} 颜色


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let switzh = ui.id("mSwitch");
//设置主题颜色
switzh.setColor("#26282E");
```


### setTextColor(color)

> 设置文字颜色

- 参数 : color {String} 颜色


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let switzh = ui.id("mSwitch");
//设置文字颜色
switzh.setTextColor("#26282E");
```


# 标签布局

- 更新时间:2025-12-02 10:12:47

> 标签布局-tab
> 
> 原生类型:{com.google.android.material.tabs.TabLayout}




## 一、常用属性


### item - 选项标签

> 选项标签


```xml
<tab w="max">
    <item text="选项1" icon="ag_logo" iconTint="#FF0000" />
    <item text="选项2" icon="ag_logo" iconTint="#00FF00" />
</tab>
```


### padding - 内边距

> 设置内边距


```xml
<!--padding顺序是:左,上,右,下-->
<!--padding只设置一个值：则设置所有方向的内边距-->
<!--padding只设置两个值：则设置左右和上下方向的内边距-->
<tab padding="20" />
```


### bg - 背景颜色

> 设置背景颜色


```xml
<tab bg="#1E1F22" />
```


### bgImg - 背景图片

> 设置背景图片


```xml
<tab bgImg="./img.png" />
```


# 文本

- 更新时间:2025-12-02 10:12:47

> 文本-text
> 
> 原生类型:{com.google.android.material.textview.MaterialTextView}




## 一、常用属性


### size - 文本尺寸

> 设置文本尺寸
> 
> 单位:dp


```xml
<text size="100" />
```


### textSize - 文本尺寸

> 设置文本尺寸
> 
> 单位:dp


```xml
<text textSize="100" />
```


### typeface - 文本字体

> 设置文本字体
> 
> 可选值:sans,serif,mono,default,bold,italic,boldItalic


```xml
<text typeface="bold" />
```


### color - 文本颜色

> 设置文本颜色


```xml
<text color="#FF0000" />
```


### textColor - 文本颜色

> 设置文本颜色


```xml
<text textColor="#FF0000" />
```


### selectable - 是否可选则文本

> 设置是否可选则文本


```xml
<text selectable="true" />
```


### singleLine - 是否单行显示

> 是否单行显示


```xml
<text singleLine="true" />
```


### maxLines - 最大行数

> 设置最大行数


```xml
<text maxLines="3" />
```


### minW - 最小宽度

> 设置最小宽度


```xml
<text minW="100" />
```


### minH - 最小高度

> 设置最小高度


```xml
<text minH="100" />
```


### padding - 内边距

> 设置内边距


```xml
<!--padding顺序是:左,上,右,下-->
<!--padding只设置一个值：则设置所有方向的内边距-->
<!--padding只设置两个值：则设置左右和上下方向的内边距-->
<text padding="20" text="内边距" />
```


### gravity - 重力

> 设置重力


```xml
<text gravity="start" h="100" margin="20" text="重力:start" w="max" />
```


### bg - 背景颜色

> 设置背景颜色


```xml
<text bg="#1E1F22" text="背景颜色" />
```


### bgImg - 背景图片

> 设置背景图片


```xml
<text bgImg="./img.png" text="背景图片" />
```


## 二、常用函数


### setText(text)

> 设置文本

- 参数 : text {string} 文本内容


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let text = ui.id("mText");
//设置文本
text.setText("新的内容");
```


### setColor(color)

> 设置文本颜色

- 参数 : color {int} 文本颜色


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let text = ui.id("mText");
//设置文本颜色
text.setColor($color.RED);
```


### setColor(color)

> 设置文本颜色

- 参数 : color {string} 文本颜色


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let text = ui.id("mText");
//设置文本颜色
text.setColor("#1E1F22");
```


### setBg(color)

> 设置背景颜色

- 参数 : color {int} 颜色值
- 版本 : 1.8.2


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let text = ui.id("mText");
//设置背景颜色
text.setBg($color.RED);
```


### setBg(color)

> 设置背景颜色

- 参数 : color {string} 颜色字符串
- 版本 : 1.8.2


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let text = ui.id("mText");
//设置背景颜色
text.setBg("#1E1F22");
```


### setSize(size)

> 设置文本尺寸

- 参数 : size {float} 尺寸


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let text = ui.id("mText");
//设置文本尺寸
text.setSize(18);
```


### getText()

> 获取文本内容

- 返回 : {string} 文本内容


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let text = ui.id("mText");
//获取文本内容
let t = text.getText();
```


# 工具栏

- 更新时间:2025-12-02 10:12:47

> 工具栏-toolbar
> 
> 原生类型:{com.google.android.material.bottomappbar.BottomAppBar}




### menu(callback)

> 监听菜单事件

- 参数 : callback {(title)=>{}} 菜单点击事件


```javascript
//监听菜单事件
toolbar.menu((title)=>{
    console.log(title);
});
```


# Sheet - 底部弹窗

- 更新时间:2025-12-02 10:12:44

> 底部弹窗




### layout(xmlOrPath)

> 解析布局

- 参数 : xmlOrPath {string} xml内容或者xml路径
- 返回 : {Sheet} 返回自己
- 版本 : 1.5.5


### getView()

> 获取解析后的最大布局

- 返回 : {View} 返回最大布局
- 版本 : 1.5.5


### id(id)

> 通过id获取控件

- 参数 : id {string} 控件id
- 返回 : {XView} 返回控件
- 版本 : 1.5.5


### show()

> 显示弹窗

- 版本 : 1.5.5


### close()

> 关闭弹窗

- 版本 : 1.5.5


# UI - 界面对象

- 更新时间:2025-12-02 10:12:49

> 界面对象




### getView()

> 获取解析后的最大布局

- 返回 : {View} 返回最大布局
- 版本 : 1.1.2


```javascript
//解析布局
let ui = $ui.layout("/main.xml");
//获取解析的最大视图
let view = ui.getView();
```


### id(id)

> 通过id获取控件

- 参数 : id {string} 控件id 
- 返回 : {XView} 返回控件
- 版本 : 1.1.2


```javascript
//解析布局
let ui = $ui.layout("main.xml");
//获取组件
let mButton = ui.id("mButton");
```


### run(runnable)

> ui线程

- 参数 : runnable {()=>{}} ui线程
- 版本 : 1.1.2


```javascript
let ui = $ui.layout("main.xml");
//在ui线程中执行
ui.run(()=>{
    //在ui线程中执行的代码
});
```


### toast(text)

> 悬浮土司
> 
> 悬浮土司是基于悬浮窗来实现的，因此在显示的时候会处于界面顶层。

- 参数 : text {string} 文本
- 版本 : 1.1.2


```javascript
let ui = $ui.layout("main.xml");
//悬浮土司
ui.toast("文本");
```


### toast(text, gravity)

> 悬浮土司
> 
> 悬浮土司是基于悬浮窗来实现的，因此在显示的时候会处于界面顶层。

- 参数 : text {string} 文本
- 参数 : gravity {string} 重力
- 版本 : 1.1.2


```javascript
let ui = $ui.layout("main.xml");
//悬浮土司
ui.toast("文本","center");
```


### show()

> 显示界面

- 版本 : 1.1.2


```javascript
//解析布局
let ui = $ui.layout("main.xml");
//显示界面
ui.show();
```


### finish()

> 结束界面

- 版本 : 1.1.2


```javascript
let ui = $ui.layout("main.xml");
ui.id("button").click(()=>{
    //关闭界面
    ui.finish();
});
```


### activity()

> 等待获得activity对象
> 
> 注意:如果没有解析界面,那么就直接返回null
> 如果没有显示界面,也会直接返回null
> 如果解析成功并且成功显示,那么就会进入循环中,不断的等待判断activity是否获取成功,如果获取成功,则直接返回activity

- 返回 : {AppCompatActivity} activity
- 版本 : 1.1.2


```javascript
//解析界面
let ui = $ui.layout("main.xml");
//显示界面
ui.show();
//显示完界面之后即可等待获取到activity对象
let avt = ui.activity();
```


### onStart(runnable)

> 界面初始时执行

- 参数 : runnable {(activity)=>{}} 生命周期回调
- 版本 : 1.1.2


```javascript
let ui = $ui.layout("main.xml");
ui.show();
//周期函数
ui.onStart((activity)=>{
    //界面初始时执行
});
```


### onResume(runnable)

> 重返界面时执行

- 参数 : runnable {(activity)=>{}} 生命周期回调
- 版本 : 1.1.2


```javascript
let ui = $ui.layout("main.xml");
ui.show();
//周期函数
ui.onResume((activity)=>{
    //重返界面时执行
});
```


### onPause(runnable)

> 界面暂停时执行

- 参数 : runnable {(activity)=>{}} 生命周期回调
- 版本 : 1.1.2


```javascript
let ui = $ui.layout("main.xml");
ui.show();
//周期函数
ui.onPause((activity)=>{
    //界面暂停时执行
});
```


### onStop(runnable)

> 界面停止时执行

- 参数 : runnable {(activity)=>{}} 生命周期回调
- 版本 : 1.1.2


```javascript
let ui = $ui.layout("main.xml");
ui.show();
//周期函数
ui.onStop((activity)=>{
    //界面停止时执行
});
```


### onDestroy(runnable)

> 界面销毁时执行

- 参数 : runnable {(activity)=>{}} 生命周期回调
- 版本 : 1.1.2


```javascript
let ui = $ui.layout("main.xml");
ui.show();
//周期函数
ui.onDestroy((activity)=>{
    //界面销毁时执行(一般用来释放资源)
});
```


### onRestart(runnable)

> 重新刷新界面时执行

- 参数 : runnable {(activity)=>{}} 生命周期回调
- 版本 : 1.1.2


```javascript
let ui = $ui.layout("main.xml");
ui.show();
//周期函数
ui.onRestart((activity)=>{
    //重新刷新界面时执行
});
```


### onActivityResult(runnable)

> 活动结果事件

- 参数 : runnable {(requestCode,resultCode,intent,activity)=>{}} 活动结果事件
- 版本 : 1.4.9


```javascript
let ui = $ui.layout("main.xml");
ui.show();
//周期函数
ui.onActivityResult((requestCode,resultCode,intent,activity)=>{
    //活动结果事件(一般用来申请权限时作为结果回调)
    //回调参数类型:
    //int requestCode
    //int resultCode
    //Intent intent
    //AppCompatActivity activity
});
```


### onCreateContextMenu(runnable)

> 上下文菜单创建事件

- 参数 : runnable {(menu,view,menuInfo,activity)=>{}} 上下文菜单创建事件
- 版本 : 1.4.9


```javascript
let ui = $ui.layout("main.xml");
ui.show();
//周期函数
ui.onCreateContextMenu((menu,view,menuInfo,activity)=>{
    //上下文菜单创建事件
    //回调函数参数类：
    //ContextMenu menu (其API涉及安卓API，请自行参考安卓文档)
    //View view
    //ContextMenu.ContextMenuInfo menuInfo (其API涉及安卓API，请自行参考安卓文档)
    //AppCompatActivity activity
});
```


### onCreateOptionsMenu(runnable)

> 选项菜单创建事件

- 参数 : runnable {(menu,activity)=>{}} 选项菜单创建事件
- 版本 : 1.4.9


```javascript
let ui = $ui.layout("main.xml");
ui.show();
//周期函数
ui.onCreateOptionsMenu((menu,activity)=>{
    //选项菜单创建事件
    //回调函数参数类：
    //Menu menu (其API涉及安卓API，请自行参考安卓文档)
    //AppCompatActivity activity
});
```


### onCreatePanelMenu(runnable)

> 选项菜单面板创建事件

- 参数 : runnable {(featureId,menu,activity)=>{}} 选项菜单面板创建事件
- 版本 : 1.4.9


```javascript
let ui = $ui.layout("main.xml");
ui.show();
//周期函数
ui.onCreatePanelMenu((featureId,menu,activity)=>{
    //选项菜单创建事件
    //回调函数参数类：
    //int featureId
    //Menu menu (其API涉及安卓API，请自行参考安卓文档)
    //AppCompatActivity activity
});
```


### onOptionsItemSelected(runnable)

> 选项菜单点击事件

- 参数 : runnable {(item,activity)=>{}} 选项菜单点击事件
- 版本 : 1.4.9


```javascript
let ui = $ui.layout("main.xml");
ui.show();
//周期函数
ui.onOptionsItemSelected((item,activity)=>{
    //选项菜单创建事件
    //回调函数参数类：
    //MenuItem item (其API涉及安卓API，请自行参考安卓文档)
    //AppCompatActivity activity
});
```


### onKeyDown(callback)

> 按键按下事件

- 参数 : callback {(keyCode,event,activity)=>{return false;}} 按键按下事件
- 版本 : 1.1.2


```javascript
let ui = $ui.layout("main.xml");
ui.show();
//周期函数
ui.onKeyDown((keyCode,event,activity)=>{
    //按键按下回调
    //回调参数类型:
    //int keyCode
    //KeyEvent event (其API涉及安卓API，请自行参考安卓文档)
});
```


### onKeyUp(callback)

> 按键抬起事件

- 参数 : callback {(keyCode,event,activity)=>{return false;}}  按键抬起事件
- 版本 : 1.1.2


```javascript
let ui = $ui.layout("main.xml");
ui.show();
//周期函数
ui.onKeyUp((keyCode,event,activity)=>{
    //按键抬起回调
    //回调参数类型:
    //int keyCode
    //KeyEvent event (其API涉及安卓API，请自行参考安卓文档)
});
```


### onKeyLongPress(callback)

> 长按事件

- 参数 : callback {(keyCode,event,activity)=>{return false;}}  长按事件
- 版本 : 1.1.2


```javascript
let ui = $ui.layout("main.xml");
ui.show();
//周期函数
ui.onKeyLongPress((keyCode,event,activity)=>{
    //按键长按回调
    //回调参数类型:
    //int keyCode
    //KeyEvent event (其API涉及安卓API，请自行参考安卓文档)
});
```


# $ui - 界面交互

- 更新时间:2025-12-02 10:12:49

> UI交互界面




### run(runnable)

> ui线程

- 参数 : runnable {()=>{}} ui线程 
- 版本 : 1.1.2


```javascript
//在ui线程中执行
$ui.run(()=>{
    //在ui线程中执行的代码
});
```


### layout(xmlOrPath)

> 解析全屏布局
> 
> 创建一个ui对象,并且解析布局,最终返回这个ui对象

- 参数 : xmlOrPath {string} xml内容或者路径 
- 返回 : {UI}
- 版本 : 1.1.2


```javascript
let ui = $ui.layout("./res/main.xml");
```


### sheet(activity)

> 显示底部弹窗

- 参数 : activity {activity} 需要显示底部弹窗的活动对象
- 返回 : {Sheet} 弹窗对象
- 版本 : 1.5.5


```javascript
//假如已经显示了一个ui了
let ui = $ui.layout("main.xml");
ui.show();
//当ui显示之后就可以获取对应界面的activity活动对象了
let sheet = $ui.sheet(ui.activity());//创建目标活动的底部弹窗对象
sheet.layout("sheet.xml"); //解析sheet布局
sheet.id("mButton"); //绑定sheet中的组件事件
sheet.show(); //显示底部弹窗
```


### toast(text)

> 悬浮土司
> 
> 悬浮土司是基于悬浮窗来实现的，因此在显示的时候会处于界面顶层。

- 参数 : text {string} 文本 
- 版本 : 1.1.2


```javascript
$ui.toast("文本");
```


### toast(text, gravity)

> 悬浮土司
> 
> 悬浮土司是基于悬浮窗来实现的，因此在显示的时候会处于界面顶层。

- 参数 : text {string} 文本 
- 参数 : gravity {string} 位置 
- 版本 : 1.1.2


```javascript
$ui.toast("文本","center");
```


### toPx(dp)

> dp转px

- 参数 : dp {float} dp(虚拟长度单位)
- 返回 : {float} 转换后的px(像素值)
- 版本 : 1.8.2


```javascript
//获取10dp的真实像素单位
let px = $ui.toPx(10);
```


### toDp(px)

> px转dp

- 参数 : px {float} 要转换的px(像素值)
- 返回 : {float} 转换后的(dp)虚拟像素单位
- 版本 : 1.8.2


```javascript
//获取10像素的(dp)虚拟单位值
let dp = $ui.toDp(10);
```


# 视频

- 更新时间:2025-12-02 10:12:47

> 视频-video




### onComplete(callback)

> 视频播放完成回调
> 
> 回调参数含义：mp {MediaPlayer} 视频播放对象

- 参数 : callback {(mp)=>{}} 回调


### onPrepare(callback)

> 视频播放准备好回调
> 
> 回调参数含义：mp {MediaPlayer} 视频播放对象

- 参数 : callback {(mp)=>{}} 回调


### onError(callback)

> 设置视频播放错误的监听器
> 
> 回调参数含义：mp {MediaPlayer} 视频播放对象，what {int} 事件类型，extra {int} 额外信息

- 参数 : callback {(mp, what, extra)=>{return false;}} 回调


### onInfo(callback)

> 设置视频播放信息的监听器（如缓冲开始 / 结束）
> 
> 回调参数含义：mp {MediaPlayer} 视频播放对象，what {int} 事件类型，extra {int} 额外信息

- 参数 : callback {(mp, what, extra)=>{return false;}} 回调


### path(path)

> 设置视频的路径

- 参数 : path {string} 视频的路径


### uri(uri)

> 设置视频的URI

- 参数 : uri {string} 视频的 URI 可以是本地文件或网络视频地址


### start()

> 开始播放


### pause()

> 暂停播放


### stop()

> 停止并释放资源


### resume()

> 恢复之前暂停的视频播放


### suspend()

> 暂停并释放资源


### keepScreen(keep)

> 保持屏幕常亮

- 参数 : keep {boolean} 是否保持屏幕常亮


### seekTo(ms)

> 跳转到指定的时间点

- 参数 : ms {int} 毫秒


### isPlaying()

> 是否正在播放

- 返回 : {boolean} 是否正在播放


### getDur()

> 获取视频的总时长

- 返回 : {int} 视频的总时长（毫秒），返回 -1 表示时长未知


### getCur()

> 获取当前播放位置（毫秒）

- 返回 : {int} 当前播放位置（毫秒）


### canPause()

> 判断视频是否可以暂停

- 返回 : {boolean} 是否可以暂停


### canSeekBackward()

> 判断视频是否可以向后快退

- 返回 : {boolean} 是否可以向后快退


### canSeekForward()

> 判断视频是否可以向前快进

- 返回 : {boolean} 是否可以向前快进


### getBufferPercentage()

> 获取视频缓冲的百分比

- 返回 : {int} 视频缓冲的百分比


# $ - 桥梁对象

- 更新时间:2025-12-02 10:12:47

> 作为WebView和脚本引擎之间的桥梁,在html中:$符号就是这个桥梁的对象名称,你可以直接通过$对象来调用这里提供的方法




### call(funcName)

> 调用注册函数

- 参数 : funcName {string} 函数名称
- 返回 : {string} 返回值


```javascript
//在js中:注册一个函数
let ui = $ui.layout("./mUi.xml");
let mWeb = ui.id("mWebView");
mWeb.addFunc("mFunc",()=>{
    //获得无障碍权限
    $permit.wza();
    return "";//返回值是一个字符串类型,如果在html中不需要返回值,则不用写这行代码
});
//在html中:调用这个函数
$.call("mFunc");
```


### log(log)

> 调用注册函数
> 
> 此函数只能打印一个普通的文本内容，请注意调用方式

- 参数 : log {string} 日志文本


```javascript
//在html中:
$.log("我是一个文本");
```


### toast(msg)

> 土司提示

- 参数 : msg {string} 信息


```javascript
//在html中:
$.toast("我是一个文本");
```


### alert(msg)

> 对话框提示

- 参数 : msg {string} 信息


```javascript
//在html中:
$.alert("信息");
```


### alert(title, msg)

> 对话框提示

- 参数 : title {string} 标题
- 参数 : msg {string} 信息


```javascript
//在html中:
$.alert("信息","你好啊!");
```


### getClip()

> 获得剪切板

- 返回 : {string} 文字


```javascript
//在html中:
let text = $.getClip();
```


### setClip(text)

> 设置剪切板

- 参数 : text {string} 文字


```javascript
//在html中:
$.setClip("我是来自html中的字符串");
```


# 网页

- 更新时间:2025-12-02 10:12:47

> 网页-webview
> 
> 你可以用vant,vue,layui,element-ui等框架编写html界面，在这个控件中加载这个界面，之后就是处理一些交互函数了




### onLoaded(onLoad)

> 设置加载完成回调

- 参数 : onLoad (()=>{}) 回调


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let wv = ui.id("mWebView");
//设置加载完成回调
wv.onLoaded(()=>{
    //一般在控件加载完html之后注册一些交互函数,例如：
    wv.addFunc("getWza",()=>{
        $permit.wza();//获取无障碍权限
    });
    //之后就可以在html中使用:$.call("getWza");调用这个函数了
});
```


### clear()

> 清除网页缓存


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let wv = ui.id("mWebView");
//清除网页缓存
wv.clear();
```


### loadUrl(url)

> 加载url

- 参数 : url url


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let wv = ui.id("mWebView");
//加载url
wv.loadUrl("http://...");
```


### loadHtml(html)

> 加载html字符串

- 参数 : html html字符串


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let wv = ui.id("mWebView");
//加载html字符串
wv.loadHtml(`
<html>
    //这里是html字符串
</html>
`);
```


### loadFile(path)

> 加载html文件

- 参数 : path html文件路径


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let wv = ui.id("mWebView");
//加载html文件
wv.loadFile("./html/index.html");
```


### callJs(functionName, callBack)

> 调用js无参函数


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let wv = ui.id("mWebView");
//调用js无参函数
//mFunc是html中定义的函数,如果有返回值,那么就会通过returnValue回调获取
wv.callJs("mFunc",(returnValue)=>{
    //..
});
```


### callJs(functionName)

> 调用js无参函数


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let wv = ui.id("mWebView");
//调用js无参函数
//mFunc是html中定义的函数
wv.callJs("mFunc");
```


### callJsInt(functionName, param, callBack)

> 调用js的整数参数函数

- 参数 : functionName {String} js函数名
- 参数 : param {int} 参数
- 参数 : callBack ((str)=>{}) 回调


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let wv = ui.id("mWebView");
//调用js无参函数
//mFunc是html中定义的函数,如果有返回值,那么就会通过returnValue回调获取
wv.callJsInt("setFontSize",22,(returnValue)=>{
    //..
});
```


### callJsInt(functionName, param)

> 调用js的整数参数函数

- 参数 : functionName {String} js函数名
- 参数 : param {int} 参数


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let wv = ui.id("mWebView");
//调用js无参函数
//mFunc是html中定义的函数
wv.callJsInt("setFontSize",22);
```


### callJsLong(functionName, param, callBack)

> 调用js的长整数参数函数

- 参数 : functionName {String} js函数名
- 参数 : param {long} 参数
- 参数 : callBack ((str)=>{}) 回调


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let wv = ui.id("mWebView");
//调用js无参函数
//mFunc是html中定义的函数,如果有返回值,那么就会通过returnValue回调获取
wv.callJsLong("setLength",546894564564849,(returnValue)=>{
    //..
});
```


### callJsLong(functionName, param)

> 调用js的长整数参数函数

- 参数 : functionName {String} js函数名
- 参数 : param {long} 参数


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let wv = ui.id("mWebView");
//调用js无参函数
//mFunc是html中定义的函数
wv.callJsLong("setLength",546894564564849);
```


### callJsDouble(functionName, param, callBack)

> 调用js的浮点数参数函数

- 参数 : functionName {String} js函数名
- 参数 : param {float} 参数
- 参数 : callBack ((str)=>{}) 回调


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let wv = ui.id("mWebView");
//调用js无参函数
//mFunc是html中定义的函数,如果有返回值,那么就会通过returnValue回调获取
wv.callJsDouble("setVal",3.1415926,(returnValue)=>{
    //..
});
```


### callJsDouble(functionName, param)

> 调用js的浮点数参数函数

- 参数 : functionName {String} js函数名
- 参数 : param {float} 参数


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let wv = ui.id("mWebView");
//调用js无参函数
//mFunc是html中定义的函数,如果有返回值,那么就会通过returnValue回调获取
wv.callJsDouble("setVal",3.1415926);
```


### callJsFloat(functionName, param, callBack)

> 调用js的浮点数参数函数

- 参数 : functionName {String} js函数名
- 参数 : param {float} 参数
- 参数 : callBack ((str)=>{}) 回调


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let wv = ui.id("mWebView");
//调用js无参函数
//mFunc是html中定义的函数,如果有返回值,那么就会通过returnValue回调获取
wv.callJsFloat("setVal",3.1415926,(returnValue)=>{
    //..
});
```


### callJsFloat(functionName, param)

> 调用js的浮点数参数函数

- 参数 : functionName {String} js函数名
- 参数 : param {float} 参数


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let wv = ui.id("mWebView");
//调用js无参函数
//mFunc是html中定义的函数,如果有返回值,那么就会通过returnValue回调获取
wv.callJsFloat("setVal",3.1415926);
```


### callJsChar(functionName, param, callBack)

> 调用js的字符串参数函数

- 参数 : functionName {String} js函数名
- 参数 : param {char} 参数
- 参数 : callBack ((str)=>{}) 回调


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let wv = ui.id("mWebView");
//调用js无参函数
//mFunc是html中定义的函数,如果有返回值,那么就会通过returnValue回调获取
wv.callJsChar("setChar",'A',(returnValue)=>{
    //..
});
```


### callJsChar(functionName, param)

> 调用js的字符串参数函数

- 参数 : functionName {String} js函数名
- 参数 : param {char} 参数


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let wv = ui.id("mWebView");
//调用js无参函数
//mFunc是html中定义的函数,如果有返回值,那么就会通过returnValue回调获取
wv.callJsChar("setChar",'A');
```


### callJsBool(functionName, param, callBack)

> 调用js的布尔参数函数

- 参数 : functionName {String} js函数名
- 参数 : param {boolean} 参数
- 参数 : callBack ((str)=>{}) 回调


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let wv = ui.id("mWebView");
//调用js无参函数
//mFunc是html中定义的函数,如果有返回值,那么就会通过returnValue回调获取
wv.callJsBool("setEnable",true,(returnValue)=>{
    //..
});
```


### callJsBool(functionName, param)

> 调用js的布尔参数函数

- 参数 : functionName {String} js函数名
- 参数 : param {boolean} 参数


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let wv = ui.id("mWebView");
//调用js无参函数
//mFunc是html中定义的函数
wv.callJsBool("setEnable",true);
```


### callJsStr(functionName, param, callBack)

> 调用js的长文本参数函数
> 
> 在传入长文本之前，会把文本进行URL编码，所以在html使用的时候需要使用函数``解码才能得到原本的长文本内容。

- 参数 : functionName {String} js函数名
- 参数 : param {String} 长文本参数
- 参数 : callBack ((str)=>{}) 回调


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let wv = ui.id("mWebView");
//调用js无参函数
//mFunc是html中定义的函数,如果有返回值,那么就会通过returnValue回调获取
wv.callJsStr("setCode","一大堆文字",(returnValue)=>{
    //..
});
//在html中的代码:
function setCode(str){
    //html使用的时候需要使用函数`decodeURIComponent`解码才能得到原本的长文本内容。
    let code =  decodeURIComponent(str);
    $.alert("代码",code);
}
```


### callJsStr(functionName, param)

> 调用js的长文本参数函数
> 
> 在传入长文本之前，会把文本进行URL编码，所以在html使用的时候需要使用函数``解码才能得到原本的长文本内容。

- 参数 : functionName {String} js函数名
- 参数 : param {String} 长文本参数


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let wv = ui.id("mWebView");
//调用js无参函数
//mFunc是html中定义的函数
wv.callJsStr("setCode","一大堆文字");
//在html中的代码:
function setCode(str){
    //html使用的时候需要使用函数`decodeURIComponent`解码才能得到原本的长文本内容。
    let code =  decodeURIComponent(str);
    $.alert("代码",code);
}
```


### addFunc(funcName, callback)

> 注册桥梁函数
> 
> 向桥梁对象$中注册(添加)自定义函数，之后就可以在html中通过$.call(函数名称);来调用啦

- 参数 : funcName {()=>{ return "数据"; }} 回调


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let wv = ui.id("mWebView");
//设置加载完成回调
wv.onLoaded(()=>{
    //一般在控件加载完html之后注册一些交互函数,例如：
    wv.addFunc("getWza",()=>{
        $permit.wza();//获取无障碍权限
    });
    //之后就可以在html中使用:$.call("getWza");调用这个函数了
});
```


# 菜单选项

- 更新时间:2025-12-02 10:12:47

> 菜单选项-XMenuItem
> 
> 原生类型:{android.view.MenuItem}




# 控件父类

- 更新时间:2025-12-02 10:12:48

> 控件父类-XView
> 
> 在应用中所有的控件或者布局都是这个类{XView}的子类，因此，这个类中的所有方法，所有的子类都能调用，故称为：公共方法。
> 
> 在代码示例中，多数情况下，我都是使用{XButton}按钮控件来进行演示的，其实任何控件都可以。




### getView()

> 获得安卓原生视图
> 我们可以通过控件的getView()方法获得原生控件,从而进行原生操作
> 对于[button]标签,对应的原生类就是[MaterialButton]
> 对于[text]标签,对应的原生类就是[MaterialTextView]其余的请参考原生对照表

- 返回 : {View} 安卓原生View


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./myUi.xml");
//拿到控件:{XButton}类型
let mButton = ui.id("mButton");//{XButton}属于{XView}的子类
//获得原生控件
let view = mButton.getView();//{MaterialButton}对象
//需要注意：在后续操作安卓原生对象的时候需要放在ui线程中进行
$ui.run(()=>{
    view.setText("我是新的按钮");
});
//如果不操作原生控件，我们已经封装过ui线程这一步了，可以直接在其他线程中操作
mButton.setText("我是新的按钮");
```


### getName()

> 获取组件的节点名称

- 返回 : {string} 组件节点名称
- 版本 : 1.5.5


### parseColor(color)

> 解析颜色
> 
> 可以通过这个函数获得主题颜色值或者一些常用颜色值

- 参数 : color {string} 颜色名称
- 返回 : {int} 颜色值


```javascript
let ui = $ui.layout("/ui.xml");
id myButton = ui.id("myButton");
//获取颜色值(返回int类型的颜色值)
let color = myButton.parseColor("white");
let color = myButton.parseColor("black");
let color = myButton.parseColor("null");
let color = myButton.parseColor("none");
let color = myButton.parseColor("green");
let color = myButton.parseColor("red");
let color = myButton.parseColor("blue");
let color = myButton.parseColor("yellow");
//主题颜色值(返回int类型的颜色值)
let color = myButton.parseColor("colorPrimary");//(常用)一般是主题最明显的颜色
let color = myButton.parseColor("colorSurface");//(常用)一般是背景颜色：亮色主题一般呈现白色，暗色主题一般呈现黑色
let color = myButton.parseColor("colorOnSurface");//(常用)一般是文字颜色：亮色主题一般呈现黑色，暗色主题一般呈现白色
let color = myButton.parseColor("colorOnPrimary");
let color = myButton.parseColor("colorPrimaryContainer");
let color = myButton.parseColor("colorOnPrimaryContainer");
let color = myButton.parseColor("colorSecondary");
let color = myButton.parseColor("colorOnSecondary");
let color = myButton.parseColor("colorSecondaryContainer");
let color = myButton.parseColor("colorOnSecondaryContainer");
let color = myButton.parseColor("colorTertiary");
let color = myButton.parseColor("colorOnTertiary");
let color = myButton.parseColor("colorTertiaryContainer");
let color = myButton.parseColor("colorOnTertiaryContainer");
let color = myButton.parseColor("colorError");
let color = myButton.parseColor("colorErrorContainer");
let color = myButton.parseColor("colorOnErrorContainer");
let color = myButton.parseColor("colorOnBackground");
let color = myButton.parseColor("colorSurfaceVariant");
let color = myButton.parseColor("colorOnSurfaceVariant");
let color = myButton.parseColor("colorOutline");
let color = myButton.parseColor("colorOutlineVariant");
let color = myButton.parseColor("colorPrimaryInverse");
```


### dp(dp)

> 将dp转换成对用的px

- 参数 : dp {float} dp长度
- 返回 : {float} px长度


### bgImg(path)

> 设置背景图片

- 参数 : path {string} 图片路径


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./myUi.xml");
//拿到控件
let mButton = ui.id("mButton");
//设置背景图片
mButton.bgImg("./res/bg.png");
```


### snack(msg)

> 显示 Snackbar

- 参数 : msg {string} 信息 


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./myUi.xml");
//拿到控件
let mButton = ui.id("mButton");
//显示信息条
mButton.snack("我是信息");
```


### snack(msg, title, callback)

> 显示 Snackbar

- 参数 : msg {string} 信息 
- 参数 : title {string} action标题 
- 参数 : callback {(view)=>{}} 点击事件回调 


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./myUi.xml");
//拿到控件
let mButton = ui.id("mButton");
//显示信息条
mButton.snack("我是信息","确定",(view)=>{
    //点击确定触发的事件
    toast("点击了确定");
});
```


### click(callback)

> 设置点击事件

- 参数 : callback {(view)=>{}} 点击事件 


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./myUi.xml");
//拿到控件
let mButton = ui.id("mButton");
//设置点击事件
mButton.click((view)=>{
    //点击事件
    toast("我被点击了");
});
```


### longClick(callback)

> 设置长按事件

- 参数 : callback {(view)=>{}} 点击事件 


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./myUi.xml");
//拿到控件
let mButton = ui.id("mButton");
//设置长按事件
mButton.longClick((view)=>{
    //点击事件
    toast("我被长按了");
});
```


### popup(titles, callback)

> 显示选项菜单

- 参数 : titles {string[]} 选项 
- 参数 : callback {(title)=>{}} 回调 


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./myUi.xml");
//拿到控件
let mButton = ui.id("mButton");
//显示选项菜单
mButton.popup(["选项1","选项2","选项3"],(title)=>{
    toast("点击了选项:"+title);
});
```


### popup(titles, gravity, callback)

> 显示选项菜单

- 参数 : titles {string[]} 选项 
- 参数 : gravity {string} 重力,例如:"center|start"(默认值) 
- 参数 : callback {(title)=>{}} 回调 


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./myUi.xml");
//拿到控件
let mButton = ui.id("mButton");
//显示选项菜单
mButton.popup(["选项1","选项2","选项3"],"start|center",(title)=>{
    toast("点击了选项:"+title);
});
```


### setEnabled(enabled)

> 是否启用控件

- 参数 : enabled {boolean} true:启用,false:禁用 


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./myUi.xml");
//拿到控件
let mButton = ui.id("mButton");
//禁用
mButton.setEnabled(false);
```


### isEnabled()

> 判断可用

- 返回 : {boolean} true:启用,false:禁用 


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./myUi.xml");
//拿到控件
let mButton = ui.id("mButton");
//是否可用
let is = mButton.isEnabled();
if(is){
    toast("可用");
}
```


### setVisibility(visibility)

> 设置可见性

- 参数 : visibility (使用AgUi中的常量,例如:ui.INVISIBLE) 


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./myUi.xml");
//拿到控件
let mButton = ui.id("mButton");
//设置成不可见
mButton.setVisibility($ui.GONE);
//设置成可见
//mButton.setVisibility($ui.VISIBLE);
```


### isVisibility()

> 获得可见性

- 返回 : {int} (使用AgUi中的常量,例如:ui.INVISIBLE)


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./myUi.xml");
//拿到控件
let mButton = ui.id("mButton");
//获得可见性的值
let vis = mButton.isVisibility();
if(vis==$ui.VISIBLE){
    toast("可见");
}
```


### setFocusable(focusable)

> 设置可聚焦

- 参数 : focusable {boolean} true:控件可获得焦点,false:控件不可获得焦点


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./myUi.xml");
//拿到控件
let mButton = ui.id("mButton");
//设置控件是否可聚焦
mButton.setFocusable(true);
```


### setClickable(clickable)

> 设置可点击

- 参数 : clickable {boolean} true:控件可被点击,false:控件不可被点击


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./myUi.xml");
//拿到控件
let mButton = ui.id("mButton");
//设置控件是否可点击
mButton.setClickable(true);
```


### setAlpha(alpha)

> 设置透明度

- 参数 : alpha {float} 0.5:控件半透明,1:控件不透明


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./myUi.xml");
//拿到控件
let mButton = ui.id("mButton");
//设置透明度
mButton.setAlpha(0.5);
```


### getAlpha()

> 获得透明度

- 返回 : {float} 控件透明度值


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./myUi.xml");
//拿到控件
let mButton = ui.id("mButton");
//获得透明度
let alpha = mButton.getAlpha();
```


### setElevation(elevation)

> 设置立体值
> 
> 可以让控件看起来更加立体

- 参数 : elevation {int} 立体值


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./myUi.xml");
//拿到控件
let mButton = ui.id("mButton");
//设置立体值
mButton.setElevation(10);
```


### getX()

> 获取x值
> 获取相对于父控件的x值

- 返回 : {float} x值


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./myUi.xml");
//拿到控件
let mButton = ui.id("mButton");
//获取x值
let x = mButton.getX();
```


### setX(x)

> 设置x值
> 设置在父控件中x的值

- 参数 : x {float} x值


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./myUi.xml");
//拿到控件
let mButton = ui.id("mButton");
//设置x值
mButton.setX(10);
```


### getY()

> 获取y值
> 获取相对于父控件的x值

- 返回 : {float} y值


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./myUi.xml");
//拿到控件
let mButton = ui.id("mButton");
//获取y值
let y = mButton.getY();
```


### setY(y)

> 设置y值
> 设置在父控件中y的值

- 参数 : y {float} y值


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./myUi.xml");
//拿到控件
let mButton = ui.id("mButton");
//设置y值
mButton.setY(10);
```


### getW()

> 获得控件宽度

- 返回 : {float} 宽度


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./myUi.xml");
//拿到控件
let mButton = ui.id("mButton");
//获得控件宽度
mButton.getW();
```


### getH()

> 获得控件高度

- 返回 : {float} 高度


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./myUi.xml");
//拿到控件
let mButton = ui.id("mButton");
//获得控件高度
mButton.getW();
```


### onTouch(callback)

> 获得控件高度

- 参数 : callback {(motionEvent,view)=>{return false;}} 触摸回调


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./myUi.xml");
//拿到控件
let mButton = ui.id("mButton");
//处理触摸事件
mButton.onTouch((event,view)=>{
    //处理触摸事件
    return true;
});
```


# 应用条布局

- 更新时间:2025-12-02 10:12:45

> 应用条布局-appbar-layout
> 
> 是布局父类的(XLayout)的子类
> 
> 原生类型:{com.google.android.material.appbar.AppBarLayout}




## 一、常用属性


### 背景颜色 - 背景颜色

> 设置背景颜色


```xml
<应用条布局 背景颜色="#FF0000">
</应用条布局>
```


### 背景图片 - 背景图片

> 设置背景图片


```xml
<应用条布局 背景图片="/资源/图片01.png">
</应用条布局>
```


### 滚动阴影 - 是否启用滚动阴影

> 是否启用滚动阴影


```xml
<应用条布局 滚动阴影="否">
</应用条布局>
```


### 内边距 - 内边距

> 设置内边距
> 
> 参数顺序:左,上,右,下(单位:dp)


```xml
<应用条布局 内边距="0,0,0,0">
</应用条布局>
```


### 重力 - 重力

> 设置重力


```xml
<应用条布局 重力="中">
</应用条布局>
```


### 设置背景颜色(颜色)

> 设置背景颜色

- 参数 : 颜色 {int} 颜色值


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//获得控件
定义 应用条布局 = 界面.找控件("我的应用条布局");
//设置背景颜色
应用条布局.设置背景颜色($颜色.红色);
```


### 设置背景颜色(颜色)

> 设置背景颜色

- 参数 : 颜色 {string} 颜色值


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//获得控件
定义 应用条布局 = 界面.找控件("我的应用条布局");
//设置背景颜色
应用条布局.设置背景颜色("#000000");
```


# 应用条

- 更新时间:2025-12-02 10:12:45

> 应用条-appbar
> 
> 原生类型:{com.google.android.material.appbar.MaterialToolbar}
> 
> 在使用的时候最好配合[appbar-layout]组件一起使用




应用条是一个软件的顶部条，用来显示标题、操作按钮等。


![](./img/558715009602800.png)

## 一、常用属性


### 标题 - 标题

> 设置标题


```xml
<界面>
    <!-- 状态栏 -->
    <状态栏/>
    <!-- 应用条需要配合此布局才能生效 -->
    <应用条布局 宽="最大">
        <应用条 标题="我是标题" 宽="最大" />
    </应用条布局>
</界面>
```


![](./img/556438552061700.png)

### 副标题 - 副标题

> 设置副标题


```xml
<界面>
    <!-- 状态栏 -->
    <状态栏 />
    <!-- 应用条需要配合此布局才能生效 -->
    <应用条布局 宽="最大">
        <应用条 副标题="副标题" 标题="我是标题" 宽="最大" />
    </应用条布局>
</界面>
```


![](./img/556492040793400.png)

### 标题颜色 - 标题颜色

> 设置标题颜色


```xml
<界面>
    <!-- 状态栏 -->
    <状态栏 />
    <!-- 应用条需要配合此布局才能生效 -->
    <应用条布局 宽="最大">
        <应用条 宽="最大" 标题="我是标题" 标题颜色="#B44A4A" />
    </应用条布局>
</界面>
```


![](./img/556534168069700.png)

### 副标题颜色 - 副标题颜色

> 设置副标题颜色


```xml
<界面>
    <!-- 状态栏 -->
    <状态栏 />
    <!-- 应用条需要配合此布局才能生效 -->
    <应用条布局 宽="最大">
        <应用条 副标题="副标题" 副标题颜色="#B44A4A" 宽="最大" 标题="我是标题" />
    </应用条布局>
</界面>
```


![](./img/556598502098800.png)

### 背景颜色 - 背景颜色

> 设置背景颜色


```xml
<界面>
    <!-- 状态栏 -->
    <状态栏 />
    <!-- 应用条需要配合此布局才能生效 -->
    <应用条布局 宽="最大">
        <应用条 副标题="副标题" 宽="最大" 标题="我是标题" 背景颜色="#345de6ff" />
    </应用条布局>
</界面>
```


![](./img/556657614089500.png)

### 背景图片 - 背景图片

> 设置背景图片


```xml
<界面>
    <!-- 状态栏 -->
    <状态栏 />
    <!-- 应用条需要配合此布局才能生效 -->
    <应用条布局 宽="最大">
        <应用条 宽="最大" 标题颜色="#FFFFFF" 标题="我是标题" 背景图片="/res/appbar-bg.png" />
    </应用条布局>
</界面>
```


![](./img/556860510275500.png)

### 菜单 - 菜单节点

> 菜单节点
> 
> 菜单节点中拥有如下属性：
> 
> - 文本 {string} 设置文本
> - 图标 {string} 设置图标
> - 图标颜色 {string} 设置图标颜色
> - 显示方式 {string} 菜单显示方式(总是:总是显示;有空间:如果有空间才显示;从不:从不显示;带文字:携带文本显示)
> - 项目 {xml} 子菜单节点
> 
> 项目节点拥有如下属性：
> 
> - 文本 {string} 设置文本
> - 项目 {xml} 为子菜单设置子菜单节点(因此项目节点中可以嵌套写自己的项目子菜单节点)


```xml
<!--[用法一]只用主菜单-->
<应用条 返回="是" 背景颜色="#F1F0FA" 副标题="安卓自动化平台..." 标题="主菜单"
    宽度="最大">
    <菜单 图标="ic_menu_line" 图标颜色="#000000" 文本="菜单" />
    <菜单 图标="ic_home_fill" 图标颜色="#000000" 文本="主页" />
    <菜单 图标="ic_3d" 图标颜色="#000000" 文本="转换" />
</应用条>
```

```xml
<!--[用法二]多级子菜单-->
<应用条 返回="是" 背景颜色="#F1F0FA" 副标题="可设置多级子菜单" 标题="子菜单" 宽度="最大">
    <菜单>
        <项目 文本="菜单1" />
        <项目 文本="菜单2" />
        <项目 文本="菜单3">
            <!--项目中还允许添加项目子菜单-->
            <项目 文本="菜单3-1" />
            <项目 文本="菜单3-2">
                <项目 文本="菜单3-2-1" />
                <项目 文本="菜单3-2-2" />
                <项目 文本="菜单3-2-3" />
            </项目>
            <项目 文本="菜单3-3" />
        </项目>
    </菜单>
</应用条>
```


#### 示例：主菜单


```xml
<界面>
    <!-- 状态栏 -->
    <状态栏 />
    <!-- 应用条需要配合此布局才能生效 -->
    <应用条布局 宽="最大">
        <应用条 标题="我是标题" 宽="最大">
            <菜单 图标="ic_menu_line" 图标颜色="#000000" 文本="菜单" />
            <菜单 图标="ic_home_fill" 图标颜色="#000000" 文本="主页" />
            <菜单 图标="ic_3d" 图标颜色="#000000" 文本="转换" />
        </应用条>
    </应用条布局>
</界面>
```


![](./img/557417348724400.png)

#### 示例：多级子菜单


```xml
<界面>
    <!-- 状态栏 -->
    <状态栏 />
    <!-- 应用条需要配合此布局才能生效 -->
    <应用条布局 宽="最大">
        <应用条 宽="最大" 标题="我是标题">
            <菜单 图标="ic_menu_line" 图标颜色="#000000" 文本="菜单" />
            <菜单 图标="ic_home_fill" 图标颜色="#000000" 文本="主页" />
            <菜单 图标="ic_more" 图标颜色="#000000" 文本="更多">
                <项目 文本="菜单1-1" />
                <项目 文本="菜单1-2" />
                <项目 文本="菜单1-3">
                    <!-- 项目 中还可以继续嵌套子项目 -->
                    <项目 文本="菜单2-1" />
                    <项目 文本="菜单3-2" />
                </项目>
            </菜单>
        </应用条>
    </应用条布局>
</界面>
```


![](./img/557700754691000.gif)

### 返回 - 启用返回按钮

> 设置启用返回按钮


```xml
<界面>
    <!-- 状态栏 -->
    <状态栏 />
    <!-- 应用条需要配合此布局才能生效 -->
    <应用条布局 宽="最大">
        <应用条 宽="最大" 标题="我是标题" 返回="是" />
    </应用条布局>
</界面>
```


![](./img/556937828243900.png)

### 内边距 - 内边距

> 设置内边距
> 
> 参数顺序:左,上,右,下(单位:dp)


```xml
<ui>
    <!-- 状态栏 -->
    <状态栏 />
    <!-- 应用条需要配合此布局才能生效 -->
    <应用条布局 宽="最大">
        <应用条 副标题="我没有内边距" 宽="最大" 标题="我是标题" />
    </应用条布局>
    <!-- 分割线 -->
    <分割线 />
    <应用条布局 宽="最大">
        <!--内边距 顺序是:左,上,右,下-->
        <!--内边距 只设置一个值：则设置所有方向的内边距-->
        <!--内边距 只设置两个值：则设置左右和上下方向的内边距-->
        <应用条 内边距="50" 副标题="我有内边距" 宽="最大" 标题="我是标题" />
    </应用条布局>
</ui>
```


![](./img/557150663620200.png)

## 二、常用函数


### 设置标题(标题)

> 设置标题

- 参数 : 标题 {string} 标题内容


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//拿到控件
定义 应用条 = 界面.找控件("我的应用条");
//设置标题
应用条.设置标题("新标题");
```


### 设置副标题(副标题)

> 设置副标题

- 参数 : 副标题 {string} 副标题内容


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//拿到控件
定义 应用条 = 界面.找控件("我的应用条");
//设置副标题
应用条.设置副标题("新副标题");
```


### 设置标题颜色(颜色)

> 设置标题颜色

- 参数 : 颜色 {int} 颜色值


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//拿到控件
定义 应用条 = 界面.找控件("我的应用条");
//设置标题颜色
应用条.设置标题颜色($颜色.红色);
```


### 设置标题颜色(颜色)

> 设置标题颜色

- 参数 : 颜色 {string} 颜色值


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//拿到控件
定义 应用条 = 界面.找控件("我的应用条");
//设置标题颜色
应用条.设置标题颜色("#1E1F22");
```


### 设置副标题颜色(颜色)

> 设置副标题颜色

- 参数 : 颜色 {int} 颜色值


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//拿到控件
定义 应用条 = 界面.找控件("我的应用条");
//设置副标题颜色
应用条.设置副标题颜色($颜色.红色);
```


### 设置副标题颜色(颜色)

> 设置副标题颜色

- 参数 : 颜色 {string} 颜色值


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//拿到控件
定义 应用条 = 界面.找控件("我的应用条");
//设置副标题颜色
应用条.设置副标题颜色("#1E1F22");
```


### 设置背景颜色(颜色)

> 设置背景颜色

- 参数 : 颜色 {int} 颜色值


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//拿到控件
定义 应用条 = 界面.找控件("我的应用条");
//设置背景颜色
应用条.设置背景颜色($颜色.红色);
```


### 设置背景颜色(颜色)

> 设置背景颜色

- 参数 : 颜色 {string} 颜色值


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//拿到控件
定义 应用条 = 界面.找控件("我的应用条");
//设置背景颜色
应用条.设置背景颜色("#1E1F22");
```


### 监听返回(回调)

> 监听返回事件

- 参数 : 回调 {(视图)=>{}} 返回按钮点击事件


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//拿到控件
定义 应用条 = 界面.找控件("我的应用条");
//返回按钮点击事件
应用条.监听返回((视图)=>{
    //一般标题的返回按钮就是退出界面:
    界面.结束();
});
```


### 监听菜单(回调)

> 监听菜单事件

- 参数 : 回调 {(标题)=>{}} 菜单点击事件


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//拿到控件
定义 应用条 = 界面.找控件("我的应用条");
//返回菜单点击事件
应用条.监听菜单((标题)=>{
    如果(标题 == "菜单1"){
          //菜单1点击事件
    }
});
```


### 绑定(抽屉)

> 绑定抽屉

- 参数 : 抽屉 {drawer}


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//拿到控件
定义 应用条 = 界面.找控件("我的应用条");
定义 抽屉 = 界面.找控件("我的抽屉");
//让应用条与抽屉联动
应用条.绑定(抽屉);
```


# 按钮组

- 更新时间:2025-12-02 10:12:46

> 按钮组-button-group
> 
> 是布局父类的(XLayout)的子类
> 
> 原生类型:{com.google.android.material.button.MaterialButtonToggleGroup}




## 一、常用属性


### 方向 - 布局方向

> 设置布局方向
> 
> 可选参数:v(纵向),h(横向)


```xml
<按钮组 方向="横向">
    <按钮 文本="按钮1"/>
    <按钮 文本="按钮2"/>
</按钮组>
```


### 背景颜色 - 背景颜色

> 设置背景颜色


```xml
<按钮组 背景颜色="#FF0000">
    <按钮 文本="按钮1"/>
    <按钮 文本="按钮2"/>
</按钮组>
```


### 背景图片 - 背景图片

> 设置背景图片


```xml
<按钮组 背景图片="/资源/图片01.png">
    <按钮 文本="按钮1"/>
    <按钮 文本="按钮2"/>
</按钮组>
```


### 单选模式 - 是否是单选模式

> 是否是单选模式


```xml
<按钮组 单选模式="是">
    <按钮 文本="按钮1"/>
    <按钮 文本="按钮2"/>
</按钮组>
```


### 至少选一个 - 是否至少选一个

> 是否至少选一个
> 
> 只在单选模式下有效


```xml
<按钮组 单选模式="是" 至少选一个="是">
    <按钮 文本="按钮1"/>
    <按钮 文本="按钮2"/>
</按钮组>
```


### 内边距 - 内边距

> 设置内边距
> 
> 参数顺序:左,上,右,下(单位:dp)


```xml
<按钮组 内边距="0,0,0,0"/>
```


### 重力 - 重力

> 设置重力
> 
> 可选值参考重力参数表


```xml
<按钮组 重力="中|上"/>
```


### 选中(下标)

> 选中按钮

- 参数 : 下标 {int} 按钮下标


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//获得控件
定义 按钮组 = 界面.找控件("我的按钮组");
//选中按钮
按钮组.选中(0);
```


### 监听选中(回调函数)

> 监听选中按钮的下标

- 参数 : 回调函数 ((下标)=>{}) 回调函数


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//获得控件
定义 按钮组 = 界面.找控件("我的按钮组");
//监听选中按钮的下标
按钮组.回调函数((下标)=>{
    $界面.土司("当前下标:"+下标);
});
```


# 按钮

- 更新时间:2025-12-02 10:12:45

> 按钮-button
> 
> 按钮控件{XButton}是属于{XView}的子控件，因此{XView}中的所有方法，按钮控件都可以调用。




按钮是界面的最简单的元素，一般用于点击操作。


![](./img/778378960274000.png)

#### 示例：基础使用

其实按钮本身是没有点击事件的，由于它继承了父类{XView}，因此可以调用其父类中的函数来实现点击操作。

事实上，所有的组件都是继承自{XView}的，因此都可以调用{XView}中的方法。


```xml
<界面>
    <状态栏 />
    <按钮 标识="我的按钮" 文本="点击我试试" />
</界面>
```

```javascript
定义 界面 = $界面.解析布局("ui.xml");
界面.显示();//显示界面
//找到界面中的元素并且实现点击事件
界面.找控件("我的按钮").点击事件(() => {
    信息("我被点击了");
});
```


## 二、常用属性


### 文本 - 文本

> 设置文本


```xml
<界面>
    <状态栏 />
    <!-- 设置文本 -->
    <按钮 文本="我是文本" />
</界面>
```


![](./img/600153960859500.png)

### 风格 - 样式

> 设置样式
> 
> 可选值有："文本(或文字)","轮廓(或者边框)","色调","图标"


```xml
<界面>
    <状态栏 />
    <!-- 横向排列 -->
    <线性布局 宽="最大" 方向="横向">
        <按钮 文本="默认样式" />
        <按钮 文本="文本样式" 风格="文本" />
        <按钮 文本="边框样式" 风格="轮廓" />
    </线性布局>
    <线性布局 宽="最大" 方向="横向">
        <按钮 文本="色调样式" 风格="色调" />
        <按钮 图标="ic_app" 文本="图标样式" 风格="图标" />
    </线性布局>
</界面>
```


![](./img/600281077680600.png)

### 主题颜色 - 主题颜色

> 设置主题颜色


```xml
<界面>
    <状态栏 />
    <!-- 居中显示 -->
    <线性布局 宽="最大" 方向="横向" 重力="中间">
        <按钮 文本="主题颜色" 主题颜色="#57965C" />
    </线性布局>
</界面>
```


![](./img/600364675873000.png)

### 文本颜色 - 文本颜色

> 设置文本颜色


```xml
<界面>
    <状态栏 />
    <!-- 居中显示 -->
    <线性布局 宽="最大" 方向="横向" 重力="中间">
        <按钮 文本="主题颜色" 文本颜色="#B44A4A" />
    </线性布局>
</界面>
```


![](./img/600422263719900.png)

### 涟漪颜色 - 涟漪颜色

> 设置涟漪颜色


```xml
<界面>
    <状态栏 />
    <!-- 居中显示 -->
    <线性布局 宽="最大" 方向="横向" 重力="中间">
        <按钮 文本="涟漪颜色:黑色" 涟漪颜色="#000000" />
    </线性布局>
</界面>
```


![](./img/601608518790900.gif)

### 弧度 - 弧度

> 设置弧度


```xml
<界面>
    <状态栏 />
    <!-- 居中显示 -->
    <线性布局 宽="最大" 方向="横向" 重力="中间">
        <按钮 弧度="8" 文本="圆角弧度:8dp" />
        <按钮 弧度="15" 文本="圆角弧度:15dp" />
    </线性布局>
</界面>
```


![](./img/601694565747000.png)

### 文本尺寸 - 文本尺寸

> 设置文本尺寸


```xml
<界面>
    <状态栏 />
    <!-- 居中显示 -->
    <线性布局 宽="最大" 方向="横向" 重力="中间">
        <按钮 文本尺寸="15" 文本="文本尺寸15" />
        <按钮 文本尺寸="25" 文本="文本尺寸25" />
    </线性布局>
</界面>
```


![](./img/601744822203500.png)

### 图标 - 图标

> 设置图标


```xml
<界面>
    <状态栏 />
    <!-- 居中显示 -->
    <线性布局 宽="最大" 方向="横向" 重力="中间">
        <按钮 图标="ic_delete" 文本="设置图标" />
    </线性布局>
</界面>
```


![](./img/601776838398600.png)

### 图标颜色 - 图标颜色

> 设置图标颜色


```xml
<界面>
    <状态栏 />
    <!-- 居中显示 -->
    <线性布局 宽="最大" 方向="横向" 重力="中间">
        <按钮 图标="ic_delete" 图标颜色="#FF0000" 文本="设置图标" />
    </线性布局>
</界面>
```


![](./img/601830127286500.png)

### 图标尺寸 - 图标尺寸

> 设置图标尺寸


```xml
<界面>
    <状态栏 />
    <!-- 居中显示 -->
    <线性布局 宽="最大" 方向="横向" 重力="中间">
        <按钮 图标="ic_delete" 图标尺寸="11" 文本="图标尺寸:11" />
        <按钮 图标="ic_delete" 图标尺寸="25" 文本="图标尺寸:25" />
    </线性布局>
</界面>
```


![](./img/601894667150800.png)

### 图标内边距 - 图标内边距

> 设置图标内边距


```xml
<界面>
    <状态栏 />
    <!-- 居中显示 -->
    <线性布局 宽="最大" 方向="横向" 重力="中间">
        <按钮 图标="ic_delete" 图标内边距="5" 文本="图标内边距:5" />
        <按钮 图标="ic_delete" 图标内边距="35" 文本="图标内边距:35" />
    </线性布局>
</界面>
```


![](./img/601986765134300.png)

### 最小宽度 - 最小宽度

> 设置最小宽度
> 
> 单位:dp


```xml
<按钮 最小宽度="100" />
```


### 最小高度 - 最小高度

> 设置最小高度
> 
> 单位:dp


```xml
<按钮 最小高度="100" />
```


### 内边距 - 内边距

> 设置内边距


```xml
<界面>
    <状态栏 />
    <!-- 居中显示 -->
    <线性布局 宽="最大" 方向="横向" 重力="中间">
        <!--内边距 顺序是:左,上,右,下-->
        <!--内边距 只设置一个值：则设置所有方向的内边距-->
        <!--内边距 只设置两个值：则设置左右和上下方向的内边距-->
        <按钮 内边距="10" 文本="内边距:10" />
        <按钮 内边距="20" 文本="内边距:20" />
    </线性布局>
</界面>
```


![](./img/602097525451800.png)

### 重力 - 重力

> 设置重力


```xml
<界面>
    <状态栏 />
    <!-- 为了让重力效果更直观，我将按钮增高增宽显示 -->
    <按钮 宽="最大" 文本="重力:开始" 重力="开始" 高="60" />
    <按钮 宽="最大" 文本="重力:结束" 重力="结束" 高="60" />
</界面>
```


![](./img/602259747821900.png)

### 背景颜色 - 背景颜色

> 设置背景颜色


```xml
<界面>
    <状态栏 />
    <!-- 居中显示 -->
    <线性布局 宽="最大" 方向="横向" 重力="中间">
        <按钮 背景颜色="#1E1F22" 文本="背景颜色" />
    </线性布局>
</界面>
```


![](./img/602360756370100.png)

### 背景图片 - 背景图片

> 设置背景图片


```xml
<界面>
    <状态栏 />
    <!-- 居中显示 -->
    <线性布局 宽="最大" 方向="横向" 重力="中间">
        <按钮 背景图片="/res/button-bg.png" 文本="背景图片" 文本颜色="#000000" />
    </线性布局>
</界面>
```


![](./img/602999329953200.png)

## 三、常用函数


### 设置重力(重力)

> 设置重力

- 参数 : 重力 {String} 例如:"中|下"


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//获得控件
定义 按钮 = 界面.找控件("我的按钮");
//设置重力
按钮.设置重力("中|下");
```


### 设置字体(字体)

> 设置字体

- 参数 : 字体 {int} 字体类型(使用$界面中的常量,例如:$界面.加粗)


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//获得控件
定义 按钮 = 界面.找控件("我的按钮");
//设置字体
按钮.设置字体($界面.加粗);//常用值：$界面.正常,$界面.斜体,$界面.加粗,$界面.加粗斜体
```


### 设置主题颜色(颜色值)

> 设置主题颜色
> 
> 由于打包后的apk可以选则不同的主题，那么我们就需要根据所选择的主题动态的获取颜色，详细请参考$颜色($color)的文档

- 参数 : 颜色值 {int} 颜色值


```javascript
//解析布局,获得ui对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//获得控件
定义 按钮 = 界面.找控件("我的按钮");
//设置红色
按钮.设置主题颜色($颜色.红色);
//设置成主题的颜色(具体颜色请参考$颜色文档)
//按钮.设置主题颜色($颜色.解析("主题主颜色"));
```


### 设置主题颜色(颜色值)

> 设置主题颜色

- 参数 : 颜色值 {int} 颜色值


```javascript
//解析布局,获得ui对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//获得控件
定义 按钮 = 界面.找控件("我的按钮");
//设置红色
按钮.设置主题颜色("#FF0000");
```


### 设置文本(文本)

> 设置文本

- 参数 : 文本 {string} 文本


```javascript
//解析布局,获得ui对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//获得控件
定义 按钮 = 界面.找控件("我的按钮");
//设置文字
按钮.设置文本("我是新的");
```


### 获取文本()

> 获得文本


```javascript
//解析布局,获得ui对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//获得控件
定义 按钮 = 界面.找控件("我的按钮");
//获得文字
定义 文字 = 按钮.获取文本();
```


### 设置文本颜色(颜色)

> 设置文本颜色

- 参数 : 颜色 {string} 颜色


```javascript
//解析布局,获得ui对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//获得控件
定义 按钮 = 界面.找控件("我的按钮");
//设置文本颜色
按钮.设置文本颜色("#FF0000");
```


### 设置文本颜色(颜色)

> 设置文本颜色

- 参数 : 颜色 {string} 颜色


```javascript
//解析布局,获得ui对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//获得控件
定义 按钮 = 界面.找控件("我的按钮");
//设置文本颜色
按钮.设置文本颜色($颜色.红色);
```


### 设置涟漪颜色(颜色)

> 设置涟漪颜色

- 参数 : 颜色 {int} 颜色


```javascript
//解析布局,获得ui对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//获得控件
定义 按钮 = 界面.找控件("我的按钮");
//设置涟漪颜色
按钮.设置涟漪颜色($颜色.红色);
```


### 设置涟漪颜色(颜色)

> 设置涟漪颜色

- 参数 : 颜色 {string} 颜色


```javascript
//解析布局,获得ui对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//获得控件
定义 按钮 = 界面.找控件("我的按钮");
//设置涟漪颜色
按钮.设置涟漪颜色("#FF0000");
```


### 设置弧度(弧度)

> 设置弧度

- 参数 : 弧度 {int} 弧度


```javascript
//解析布局,获得ui对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//获得控件
定义 按钮 = 界面.找控件("我的按钮");
//设置弧度
按钮.设置弧度(13);
```


### 设置文本尺寸(尺寸)

> 设置文本尺寸

- 参数 : 尺寸 {float} 尺寸


```javascript
//解析布局,获得ui对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//获得控件
定义 按钮 = 界面.找控件("我的按钮");
//设置文本尺寸
按钮.设置文本尺寸(13);
```


### 设置图标(图标)

> 设置图标

- 参数 : 图标 {string} 图标名称


```javascript
//解析布局,获得ui对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//获得控件
定义 按钮 = 界面.找控件("我的按钮");
//设置图标
按钮.设置图标("logo_ag");
```


### 设置图标颜色(颜色)

> 设置图标颜色

- 参数 : 颜色 {int} 颜色


```javascript
//解析布局,获得ui对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//获得控件
定义 按钮 = 界面.找控件("我的按钮");
//设置图标颜色
按钮.设置图标颜色($颜色.红色);
```


### 设置图标颜色(颜色)

> 设置图标颜色

- 参数 : 颜色 {string} 颜色


```javascript
//解析布局,获得ui对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//获得控件
定义 按钮 = 界面.找控件("我的按钮");
//设置图标颜色
按钮.设置图标颜色("#FF0000");
```


### 设置图标尺寸(尺寸)

> 设置图标尺寸

- 参数 : 尺寸 {int} 尺寸


```javascript
//解析布局,获得ui对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//获得控件
定义 按钮 = 界面.找控件("我的按钮");
//设置图标尺寸
按钮.设置图标尺寸(15);
```


### 设置图标内边距(内边距)

> 设置图标内边距

- 参数 : 内边距 {int} 内边距


```javascript
//解析布局,获得ui对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//获得控件
定义 按钮 = 界面.找控件("我的按钮");
//设置图标内边距
按钮.设置图标内边距(15);
```


# 多选框

- 更新时间:2025-12-02 10:12:46

> 多选框-check
> 
> 原生类型:{com.google.android.material.checkbox.MaterialCheckBox}
> 
> 多选框控件{XCheck}是属于{XView}的子控件，因此{XView}中的所有方法，多选框控件都可以调用。




多选框一般用于：用户同意、配置多种选择、筛选数据等场景。


![](./img/603425381833700.png)

#### 示例:基础用法


```xml
<界面>
    <状态栏 />
    <线性布局 宽="最大" 方向="水平" 重力="中间">
        <多选框 标识="我的多选框" 文本="同意协议"/>
    </线性布局>
</界面>
```

```javascript
定义 界面 = $界面.解析布局("ui.xml");
界面.显示();//显示界面
//找到界面中的元素并且实现点击事件
界面.找控件("我的多选框").监听选中((选中了,原生对象) => {
    如果(选中了){
        信息("我被选中了");
    }否则{
        信息("没有被选中");
    }
});
```


## 二、常用属性


### 文本 - 文本

> 设置文本


```xml
<界面>
    <状态栏 />
    <!-- 居中显示 -->
    <线性布局 宽="最大" 方向="横向" 重力="中间">
        <多选框 文本="多选按钮" />
        <多选框 文本="多选按钮" 选中="是" />
    </线性布局>
</界面>
```


![](./img/603260635087900.png)

### 选中 - 选中

> 设置选中


```xml
<界面>
    <状态栏 />
    <!-- 居中显示 -->
    <线性布局 宽="最大" 方向="横向" 重力="中间">
        <多选框 文本="多选按钮" />
        <多选框 文本="多选按钮" 选中="是" />
    </线性布局>
</界面>
```


![](./img/603260635087900.png)

### 主题颜色 - 主题颜色

> 设置主题颜色


```xml
<界面>
    <状态栏 />
    <!-- 居中显示 -->
    <线性布局 宽="最大" 方向="横向" 重力="中间">
        <多选框 主题颜色="#B44A4A" 文本="多选按钮" />
        <多选框 主题颜色="#518855" 文本="多选按钮" />
    </线性布局>
</界面>
```


![](./img/603336275352200.png)

### 按钮颜色 - 按钮颜色

> 设置按钮颜色


```xml
<界面>
    <状态栏 />
    <!-- 居中显示 -->
    <线性布局 宽="最大" 方向="横向" 重力="中间">
        <多选框 按钮颜色="#518855" 文本="吃饭" 选中="是" />
        <多选框 按钮颜色="#C94F4F" 文本="睡觉" 选中="是" />
        <多选框 按钮颜色="#000000" 文本="游戏" 选中="是" />
    </线性布局>
</界面>
```


![](./img/604177490718900.png)

### 文本颜色 - 文本颜色

> 设置文本颜色


```xml
<界面>
    <状态栏 />
    <!-- 居中显示 -->
    <线性布局 宽="最大" 方向="横向" 重力="中间">
        <多选框 文本颜色="#518855" 文本="吃饭" />
        <多选框 文本颜色="#C94F4F" 文本="睡觉" />
        <多选框 文本颜色="#000000" 文本="游戏" />
    </线性布局>
</界面>
```


![](./img/604260297998000.png)

### 最小宽度 - 最小宽度

> 设置最小宽度
> 
> 单位:dp


```xml
<多选框 最小宽度="100" />
```


### 最小高度 - 最小高度

> 设置最小高度
> 
> 单位:dp


```xml
<多选框 最小高度="100" />
```


### 内边距 - 内边距

> 设置内边距
> 
> 单位:dp 顺序:左、上、右、下


```xml
<界面>
    <状态栏 />
    <!-- 居中显示 -->
    <线性布局 宽="最大" 方向="横向" 重力="中间">
        <多选框 内边距="5" 文本="边距:5"  />
        <多选框 内边距="20" 文本="边距:20"  />
        <多选框 内边距="40" 文本="边距:40"  />
    </线性布局>
</界面>
```


![](./img/604346296862000.png)

### 重力 - 重力

> 设置重力


```xml
<界面>
    <状态栏 />
    <!-- 居中显示 -->
    <多选框 宽="最大" 文本="重力:左" 重力="左" />
    <多选框 宽="最大" 文本="重力:中" 重力="中" />
    <多选框 宽="最大" 文本="重力:右" 重力="右" />
</界面>
```


![](./img/604487412932300.png)

### 背景颜色 - 背景颜色

> 设置背景颜色


```xml
<界面>
    <状态栏 />
    <!-- 居中显示 -->
    <线性布局 宽="最大" 方向="横向" 重力="中间">
        <多选框 背景颜色="#453C39" 文本="背景颜色"  />
    </线性布局>
</界面>
```


![](./img/604588586545200.png)

### 背景图片 - 背景图片

> 设置背景图片


```xml
<界面>
    <状态栏 />
    <!-- 居中显示 -->
    <线性布局 宽="最大" 方向="横向" 重力="中间">
        <多选框 背景图片="/res/button-bg.png" 文本="背景颜色"  />
    </线性布局>
</界面>
```


![](./img/604659582346500.png)

## 三、常用函数


### 监听选中(回调)

> 设置选中监听

- 参数 : 回调 {(视图,是否选中)=>{}} 选中监听


```javascript
//解析布局,获得ui对象
定义 界面 = $界面.解析布局("./mUi.xml");
//获得控件
定义 多选框 = 界面.找控件("我的多选框");
//设置选中监听
多选框.监听选中((视图,是否选中)=>{
    如果(是否选中){
        界面.土司("选中了");
    }否则{
        界面.土司("没有选中");
    }
});
```


### 是选中的()

> 判断是否选中

- 返回 : {boolean} true:选中,false:没有选中


```javascript
//解析布局,获得ui对象
定义 界面 = $界面.解析布局("./mUi.xml");
//获得控件
定义 多选框 = 界面.找控件("我的多选框");
//判断是否选中
定义 是否选中 = 多选框.是选中的();
```


### 设置选中(状态)

> 设置选中的状态

- 参数 : 状态 {boolean} 是:选中,否:没有选中


```javascript
//解析布局,获得ui对象
定义 界面 = $界面.解析布局("./mUi.xml");
//获得控件
定义 多选框 = 界面.找控件("我的多选框");
//设置选中的状态
多选框.设置选中(否);
```


### 设置重力(重力)

> 设置重力

- 参数 : 重力 {String} 例如:"中|下"


```javascript
//解析布局,获得ui对象
定义 界面 = $界面.解析布局("./mUi.xml");
//获得控件
定义 多选框 = 界面.找控件("我的多选框");
//设置重力
多选框.设置重力("中|下");
```


### 设置文本(文本)

> 设置文本

- 参数 : 文本 {String} 例如:"我是文本"


```javascript
//解析布局,获得ui对象
定义 界面 = $界面.解析布局("./mUi.xml");
//获得控件
定义 多选框 = 界面.找控件("我的多选框");
//设置文字
多选框.设置文字("是否继续?");
//注意:'设置文本()'这个函数具有一定的容错率,你也可以写'设置文字()'
```


### 获取文本()

> 获得文本


```javascript
//解析布局,获得ui对象
定义 界面 = $界面.解析布局("./mUi.xml");
//获得控件
定义 多选框 = 界面.找控件("我的多选框");
//获得文本
定义 文本 = 多选框.获取文本();
//注意:'获得文本()'这个函数具有一定的容错率,你也可以写'获得文字()'
```


### 设置主题颜色(颜色)

> 设置主题颜色

- 参数 : 颜色 {String} 例如:"#FF0000"


```javascript
//解析布局,获得ui对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//获得控件
定义 多选框 = 界面.找控件("我的多选框");
//设置主题颜色
多选框.设置主题颜色("#FF0000");
```


### 设置主题颜色(颜色)

> 设置主题颜色

- 参数 : 颜色 {int} 颜色值


```javascript
//解析布局,获得ui对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//获得控件
定义 多选框 = 界面.找控件("我的多选框");
//设置主题颜色
多选框.设置主题颜色($颜色.红色);
```


### 设置文本颜色(颜色)

> 设置文本颜色

- 参数 : 颜色 {string} 颜色


```javascript
//解析布局,获得ui对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//获得控件
定义 多选框 = 界面.找控件("我的多选框");
//设置主题颜色
多选框.设置文本颜色("#FF0000");
```


### 设置文本颜色(颜色)

> 设置文本颜色

- 参数 : 颜色 {int} 颜色值


```javascript
//解析布局,获得ui对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//获得控件
定义 多选框 = 界面.找控件("我的多选框");
//设置主题颜色
多选框.设置文本颜色($颜色.红色);
//注意:'设置文本颜色()'这个函数具有一定的容错率,你也可以写'设置文字颜色()'
```


### 设置背景颜色(颜色)

> 设置背景颜色

- 参数 : 颜色 {int} 颜色值


```javascript
//解析布局,获得ui对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//获得控件
定义 多选框 = 界面.找控件("我的多选框");
//设置背景颜色
多选框.设置背景颜色($颜色.红色);
```


### 设置背景颜色(颜色)

> 设置背景颜色

- 参数 : 颜色 {string} 颜色


```javascript
//解析布局,获得ui对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//获得控件
定义 多选框 = 界面.找控件("我的多选框");
//设置背景颜色
多选框.设置背景颜色("#FF0000");
```


# 小片组

- 更新时间:2025-12-02 10:12:46

> 小片组-chip-group
> 
> 是布局父类的(XLayout)的子类
> 
> 原生类型:{com.google.android.material.chip.ChipGroup}




## 一、常用属性


### 背景颜色 - 背景颜色

> 设置背景颜色


```xml
<小片组 背景颜色="#FF0000" />
```


### 背景图片 - 背景图片

> 设置背景图片


```xml
<小片组 背景图片="/资源/图片01.png" />
```


### 内边距 - 内边距

> 设置内边距


```xml
<小片组 内边距="0,0,0,0" />
```


### 选中(文本)

> 选中指定文本的小片
> 
> 该方法会选中所有文本相同的小片

- 参数 : 文本 {string} 文本


```javascript
//解析布局,获取ui界面对象
定义 界面 = $界面.解析布局("./主界面.xml");
//获取控件
定义 小片组 = 界面.找控件("我的小片组");
//选中指定文本的小片
小片组.选中("选项1");
```


### 反选(文本)

> 反选指定文本
> 
> 如果文本匹配则选中，否则就取消选中。

- 参数 : 文本 {string} 文本


```javascript
//解析布局,获取ui界面对象
定义 界面 = $界面.解析布局("./主界面.xml");
//获取控件
定义 小片组 = 界面.找控件("我的小片组");
//反选指定文本
小片组.反选("选项1");
```


### 选中(下标)

> 选中指定下标的小片

- 参数 : 下标 {int} 下标


```javascript
//解析布局,获取ui界面对象
定义 界面 = $界面.解析布局("./主界面.xml");
//获取控件
定义 小片组 = 界面.找控件("我的小片组");
//选中指定下标的小片
小片组.选中(0);
```


### 子项数量()

> 获取子项数量

- 返回 : {int} 子项数量


```javascript
//解析布局,获取ui界面对象
定义 界面 = $界面.解析布局("./主界面.xml");
//获取控件
定义 小片组 = 界面.找控件("我的小片组");
//获取子项数量
定义 数量 = 小片组.子项数量();
```


### 获得子项(下标)

> 获取指定下标下的子项
> 
> 该函数返回的是Chip类型的子项目，而不是本应用封装的XChip类型，对Chip进行操作时需要放在ui线程中操作。

- 参数 : 下标 {int} 下标
- 返回 : {chip} 子项


```javascript
//解析布局,获取ui界面对象
定义 界面 = $界面.解析布局("./主界面.xml");
//获取控件
定义 小片组 = 界面.找控件("我的小片组");
//获取指定下标下的子项
定义 小片 = 小片组.获得子项(0);
```


# 小片

- 更新时间:2025-12-02 10:12:46

> 小片-chip
> 
> 原生类型:{com.google.android.material.chip.Chip}
> 
> 可以当作小按钮来使用，也可以当作多选框来使用




小片：可以用来显示一些小标签什么的，还是蛮好看的。

不过，也可以用来作为按钮使用。


![](./img/612185892757200.png)

## 一、常用属性


### 文本 - 文本

> 设置文本


```xml
<界面>
    <状态栏 />
    <线性布局 宽="最大" 方向="横向" 重力="中间">
        <小片 文本="我是小片" />
    </线性布局>
</界面>
```


![](./img/611371618523400.png)

### 图标 - 图标

> 设置图标


```xml
<界面>
    <状态栏 />
    <线性布局 宽="最大" 方向="横向" 重力="中间">
        <小片 文本="我是小片" 图标="logo_ag" />
    </线性布局>
</界面>
```


![](./img/611437937349600.png)

### 图标颜色 - 图标颜色

> 设置图标颜色


```xml
<界面>
    <状态栏 />
    <线性布局 宽="最大" 方向="横向" 重力="中间">
        <小片 图标="ic_delete" 图标颜色="#FF0000" 文本="我是小片" />
    </线性布局>
</界面>
```


![](./img/611478093404000.png)

### 文本颜色 - 文本颜色

> 设置文本颜色


```xml
<界面>
    <状态栏 />
    <线性布局 宽="最大" 方向="横向" 重力="中间">
        <小片 文本颜色="#518855" 文本="我是小片" />
    </线性布局>
</界面>
```


![](./img/611544871472300.png)

### 文本尺寸 - 文本尺寸

> 设置文本尺寸


```xml
<界面>
    <状态栏 />
    <线性布局 宽="最大" 方向="横向" 重力="中间">
        <小片 文本尺寸="11" 文本="字体:11" />
        <小片 文本尺寸="16" 文本="字体:16" />
    </线性布局>
</界面>
```


![](./img/611601063213900.png)

### 弧度 - 弧度

> 设置弧度


```xml
<界面>
    <状态栏 />
    <线性布局 宽="最大" 方向="横向" 重力="中间">
        <小片 弧度="11" 文本="弧度:11" />
        <小片 弧度="16" 文本="弧度:16" />
    </线性布局>
</界面>
```


![](./img/611656213275200.png)

### 可选中 - 可选中

> 设置可选中


```xml
<界面>
    <状态栏 />
    <线性布局 宽="最大" 方向="横向" 重力="中间">
        <小片 可选中="是" 文本="可选中" />
        <小片 文本="未选中" />
    </线性布局>
</界面>
```


![](./img/611719142241000.png)

### 显示选中图标 - 显示选中图标

> 设置显示选中图标


```xml
<界面>
    <状态栏 />
    <线性布局 宽="最大" 方向="横向" 重力="中间">
        <小片 可选中="是" 显示选中图标="true" 文本="可选中" />
        <小片 文本="未选中" />
    </线性布局>
</界面>
```


![](./img/611768470381600.png)

### 选中图标颜色 - 选中图标颜色

> 设置选中图标颜色


```xml
<界面>
    <状态栏 />
    <线性布局 宽="最大" 方向="横向" 重力="中间">
        <小片 可选中="是" 选中图标颜色="#518855" 显示选中图标="true" 文本="可选中" />
        <小片 文本="未选中" />
    </线性布局>
</界面>
```


![](./img/611802972426800.png)

### 可点击 - 是否可以点击

> 设置是否可以点击


```xml
<界面>
    <状态栏 />
    <线性布局 宽="最大" 方向="横向" 重力="中间">
        <小片 可点击="是" 文本="可点击" />
        <小片 可点击="否" 文本="不可点击" />
    </线性布局>
</界面>
```


![](./img/611886165669900.png)

### 显示关闭按钮 - 是否显示关闭按钮

> 设置是否显示关闭按钮


```xml
<界面>
    <状态栏 />
    <线性布局 宽="最大" 方向="横向" 重力="中间">
        <小片 显示关闭按钮="是" 文本="显示关闭按钮" />
    </线性布局>
</界面>
```


![](./img/611945468348700.png)

### 关闭按钮颜色 - 关闭按钮的颜色

> 设置关闭按钮的颜色


```xml
<界面>
    <状态栏 />
    <线性布局 宽="最大" 方向="横向" 重力="中间">
        <小片 显示关闭按钮="是" 关闭按钮颜色="#FF0000" 文本="显示关闭按钮" />
    </线性布局>
</界面>
```


![](./img/612063532482400.png)

### 涟漪颜色 - 涟漪颜色

> 设置涟漪颜色


```xml
<界面>
    <状态栏 />
    <线性布局 宽="最大" 方向="横向" 重力="中间">
        <小片 涟漪颜色="#518855" 文本="显示关闭按钮" />
    </线性布局>
</界面>
```


![](./img/612120925836200.png)

### 主题颜色 - 主题颜色

> 设置主题颜色


```xml
<界面>
    <状态栏 />
    <线性布局 宽="最大" 方向="横向" 重力="中间">
        <小片 主题颜色="#518855" 文本="小片" />
        <小片 主题颜色="#B44A4A" 文本="小片" />
        <小片 主题颜色="#3574F0" 文本="小片" />
    </线性布局>
</界面>
```


![](./img/612185892757200.png)

### 最小宽度 - 最小宽度

> 设置最小宽度
> 
> 单位:dp


```xml
<小片 最小宽度="100" />
```


### 最小高度 - 最小高度

> 设置最小高度
> 
> 单位:dp


```xml
<小片 最小高度="50" />
```


### 内边距 - 内边距

> 设置内边距
> 
> 单位:dp


```xml
<界面>
    <状态栏 />
    <线性布局 宽="最大" 方向="横向" 重力="中间">
        <小片 内边距="5" 文本="内边距:5" />
        <小片 内边距="25" 文本="内边距:25" />
    </线性布局>
</界面>
```


## 二、常用函数


### 设置选中(状态)

> 设置选中状态

- 参数 : 状态 {布尔值} 选中状态


```javascript
//解析布局,获取ui界面对象
定义 界面 = $界面.解析布局("./主界面.xml");
//获取控件
定义 小片 = 界面.找控件("我的小片");
//设置选中状态
小片.设置选中(真);
```


### 是选中的()

> 判断是否选中

- 返回 : {布尔值} 是否选中


```javascript
//解析布局,获取ui界面对象
定义 界面 = $界面.解析布局("./主界面.xml");
//获取控件
定义 小片 = 界面.找控件("我的小片");
//判断是否选中
如果 (小片.是选中的()) {
    信息("选中");
}否则{
    信息("未选中");
}
```


### 关闭事件(回调)

> 监听关闭事件

- 参数 : 回调 {(视图)=>{}} 关闭回调


```javascript
//解析布局,获取ui界面对象
定义 界面 = $界面.解析布局("./主界面.xml");
//获取控件
定义 小片 = 界面.找控件("我的小片");
//监听关闭事件
小片.关闭事件(函数(){
    信息("我被关闭了");
});
```


### 选中事件(回调)

> 监听选中事件

- 参数 : 回调 {(选中状态)=>{}} 选中回调


```javascript
//解析布局,获取ui界面对象
定义 界面 = $界面.解析布局("./主界面.xml");
//获取控件
定义 小片 = 界面.找控件("我的小片");
//监听选中事件
小片.选中事件((选中状态)=>{
    如果 (选中状态) {
        信息("选中");
    }否则{
        信息("未选中");
    }
});
```


### 设置文本(文本)

> 设置文本

- 参数 : 文本 {字符串} 文字


```javascript
//解析布局,获取ui界面对象
定义 界面 = $界面.解析布局("./主界面.xml");
//获取控件
定义 小片 = 界面.找控件("我的小片");
//设置文本
小片.设置文本("新的名字");
```


### 获取文本()

> 获得文本

- 返回 : {字符串} 文本


```javascript
//解析布局,获取ui界面对象
定义 界面 = $界面.解析布局("./主界面.xml");
//获取控件
定义 小片 = 界面.找控件("我的小片");
//获得文本
定义 文本 = 小片.获取文本();
信息(文本);
```


# 下拉框

- 更新时间:2025-12-02 10:12:46

> 下拉框-drop
> 
> 布局原生类型:{com.google.android.material.textfield.TextInputLayout}
> 组件原生类型:{com.google.android.material.textfield.MaterialAutoCompleteTextView}




下拉框类似于一个小菜单，点一下才会展开让你选，核心用途就是帮你方便、规范地挑东西。


![](./img/775261983393400.png)

## 一、基础用法


```xml
<ui>
    <statusbar />
    <linear w="max" padding="15" gravity="center" h="max">
        <drop id="mDrop" w="max">
            <!-- 添加选项 -->
            <item text="吃饭" />
            <item text="睡觉" />
            <item text="电影" />
        </drop>
    </linear>
</ui>
```

```javascript
//解析布局
let ui = $ui.layout("ui.xml");
ui.show();//显示界面
//为下拉框添加选中事件
ui.id("mDrop").onCheck((value, index) => {
    info("选中下标为:" + index + "的元素:" + value);
});
```


## 二、常用属性


### 风格 - 样式

> 设置样式
> 
> 可选:填充,边框(或轮廓)


```xml
<下拉框 风格="填充" />
```


![](./img/775987544222400.png)

### 提示 - 提示文字

> 设置提示文字


```xml
<下拉框 提示="请输入内容" />
```


![](./img/776048049257900.png)

### 默认 - 默认文字

> 设置默认文字


```xml
<下拉框 默认="请选择" />
```


![](./img/776048049257900.png)

### 项目 - 子选项

> 设置子选项
> 
> 子选项使用项目标签，只有文本一个属性


```xml
<下拉框 宽="最大">
    <项目 文本="选项1" />
    <项目 文本="选项2" />
    <项目 文本="选项3" />
</下拉框>
```


![](./img/775261983393400.png)

### 主题颜色 - 主题颜色

> 设置主题颜色


```xml
<下拉框 主题颜色="#FF0000" />
```


![](./img/776155047288900.png)

### 文本颜色 - 文字的颜色

> 设置文字的颜色


```xml
<下拉框 文本颜色="#FF0000" />
```


![](./img/776208807917600.png)

### 隐藏图标 - 是否隐藏后面的倒三角图标

> 是否隐藏后面的倒三角图标


```xml
<下拉框 隐藏图标="是" />
```


![](./img/776250206768600.png)

### 重力 - 布局重力

> 设置布局重力


```xml
<下拉框 重力="中" />
```


![](./img/776511197330000.png)

### 内边距 - 布局内边距

> 设置布局内边距
> 
> 单位:dp


```xml
<下拉框 内边距="0,0,0,0" />
```


![](./img/776457374823400.png)

### 背景颜色 - 背景颜色

> 设置背景颜色


```xml
<下拉框 背景颜色="#FF0000" />
```


![](./img/776583835610600.png)

### 背景图片 - 背景图片

> 设置背景图片


```xml
<下拉框 背景图片="/资源/图片01.png" />
```


![](./img/776800912434000.png)

## 三、常用函数


### 监听选中(回调)

> 事件监听

- 参数 : 回调 {(标题,下标)=>{}} 回调函数


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./主界面.xml");
//获取控件
定义 下拉框 = 界面.找控件("我的下拉框");
//监听选中事件
下拉框.监听选中((标题,下标)=>{
    土司(标题);
});
```


### 设置文字(文本)

> 设置文字

- 参数 : 文本 {string} 文字


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./主界面.xml");
//获取控件
定义 下拉框 = 界面.找控件("我的下拉框");
//设置文字
下拉框.设置文字("选项1");
//注意:'设置文字()'函数也可以写成'设置文本()'函数
```


### 获取文字()

> 获得文字

- 返回 : {string} 文字


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./主界面.xml");
//获取控件
定义 下拉框 = 界面.找控件("我的下拉框");
//获取文本
定义 文本 = 下拉框.获取文字();
//注意:'获得文字()'函数也可以写成'获得文本()'函数
```


### 刷新(数据)

> 刷新数据

- 参数 : 数据 {string[]} 数据集合


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./主界面.xml");
//获取控件
定义 下拉框 = 界面.找控件("我的下拉框");
//刷新数据
下拉框.刷新(["张三","李四","王五"]);
```


# 编辑框

- 更新时间:2025-12-02 10:12:46

> 编辑框-edit
> 
> 原生类型:{androidx.appcompat.widget.AppCompatEditText}




这是一种小巧的输入框

edit比input输入框更加小巧一些，是安卓原生拓展库的组件，而input输入框是M3风格的组件。


![](./img/791094562061700.png)

## 一、常用属性


### 提示 - 提示文本

> 设置提示文本


```xml
<编辑框 提示="请输入内容" />
```


![](./img/789754995220700.png)

### 文本 - 文本

> 设置文本


```xml
<编辑框 文本="默认内容" />
```


![](./img/789794472910300.png)

### 文本颜色 - 文本颜色

> 设置文本颜色


```xml
<编辑框 文本颜色="#FF0000" />
```


![](./img/789852347187200.png)

### 默认 - 默认文本

> 设置默认文本


```xml
<编辑框 默认="请输入内容" />
```


![](./img/789904227177000.png)

### 类型 - 输入内容的类型

> 输入内容的类型
> 
> 可选值:
> 密码:密码,
> 数字:数字,
> 手机号:手机号


```xml
<编辑框 类型="密码" />
```


![](./img/789950243159000.png)

### 尺寸 - 文本尺寸

> 设置文本尺寸


```xml
<编辑框 尺寸="16" />
```


![](./img/790008794448600.png)

### 最小宽度 - 最小宽度

> 设置最小宽度
> 
> 单位:dp


```xml
<编辑框 最小宽度="100" />
```


![](./img/790077178825600.png)

### 最小高度 - 最小高度

> 设置最小高度
> 
> 单位:dp


```xml
<编辑框 最小高度="100" />
```


### 重力 - 布局重力

> 设置布局重力


```xml
<编辑框 重力="中" />
```


![](./img/790128473724600.png)

### 内边距 - 布局内边距

> 设置布局内边距


```xml
<编辑框 内边距="0,0,0,0" />
```


![](./img/790180053900700.png)

### 背景颜色 - 背景颜色

> 设置背景颜色


```xml
<编辑框 背景颜色="#FF0000" />
```


![](./img/790211858032800.png)

### 背景图片 - 背景图片

> 设置背景图片


```xml
<编辑框 背景图片="/资源/图片01.png" />
```


![](./img/790487260539500.png)

## 二、常用函数


### 获取文字()

> 获取输入框内容

- 返回 : {string} 内容


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./主界面.xml");
//获取控件
定义 编辑框 = 界面.找控件("我的编辑框");
//获取输入框内容
定义 内容 = 编辑框.获取文字();
//注意:'获得文字()'函数也可以写成'获得文本()'函数
```


### 设置错误(提示)

> 设置错误提示

- 参数 : 提示 {string} 错误提示信息


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./主界面.xml");
//获取控件
定义 编辑框 = 界面.找控件("我的编辑框");
//设置错误提示
编辑框.设置错误("输入内容不能为空");
```


### 设置文字(文本)

> 设置文字

- 参数 : 文本 {string} 文字内容


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./主界面.xml");
//获取控件
定义 编辑框 = 界面.找控件("我的编辑框");
//设置文字
编辑框.设置文字("新的内容");
//注意:'设置文字()'函数也可以写成'设置文本()'函数
```


### 监听文本改变(回调)

> 监听文本改变

- 参数 : 回调 {(文本,开始,之前,数量)=>{}} 监听回调
- 版本 : 1.8.0


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./主界面.xml");
//获取控件
定义 输入框 = 界面.找控件("我的输入框");
//监听文本改变
输入框.监听文本改变((文本,开始,之前,数量)=>{
    日志("文本改变了:"+文本);
});
```


### 监听文本改变后(回调)

> 监听文本改变后

- 参数 : 回调 {(文本,开始,之前,数量)=>{}} 监听回调
- 版本 : 1.8.0


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./主界面.xml");
//获取控件
定义 输入框 = 界面.找控件("我的输入框");
//监听文本改变后
输入框.监听文本改变后((文本)=>{
    日志("文本改变了:"+文本);
});
```


### 监听文本改变前(回调)

> 监听文本改变前

- 参数 : 回调 {(文本,开始,数量,之前)=>{}} 监听回调
- 版本 : 1.8.0


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./主界面.xml");
//获取控件
定义 输入框 = 界面.找控件("我的输入框");
//监听文本改变前
输入框.监听文本改变前((文本,开始,数量,之前)=>{
    日志("文本改变了:"+文本);
});
```


# 悬浮按钮

- 更新时间:2025-12-02 10:12:46

> 悬浮按钮-fab
> 
> 原生类型:{com.google.android.material.floatingactionbutton.FloatingActionButton}




一般配合帧布局：将按钮放在帧布局的上层来实现悬浮效果。


![](./img/818776736622200.png)

## 一、常用属性


### 主题颜色 - 主题颜色

> 设置主题颜色


```xml
```


![](./img/817959591075700.png)

### 图标 - 图标

> 设置图标


```xml
```


![](./img/818014187410700.png)

### 路径 - 路径图标

> 设置路径图标


```xml
```


![](./img/818346252598700.png)

### 图标颜色 - 图标颜色

> 设置图标颜色


```xml
```


![](./img/818432990911800.png)

### 提示 - 提示

> 设置提示
> 
> 安卓8+才支持这个配置


```xml
```


![](./img/818574196509000.png)

### 弧度 - 弧度

> 设置弧度


```xml
```


![](./img/818698319302600.png)

### 尺寸 - 尺寸

> 设置尺寸


```xml
```


![](./img/818776736622200.png)

## 二、常用函数


### 显示()

> 显示悬浮按钮


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./主界面.xml");
//获取控件
定义 悬浮按钮 = 界面.找控件("我的悬浮按钮");
//显示控件
悬浮按钮.显示();
```


### 隐藏()

> 隐藏悬浮按钮


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./主界面.xml");
//获取控件
定义 悬浮按钮 = 界面.找控件("我的悬浮按钮");
//隐藏控件
悬浮按钮.隐藏();
```


### 设置主题颜色(颜色)

> 设置主题颜色

- 参数 : 颜色 {String} 颜色值


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./主界面.xml");
//获取控件
定义 悬浮按钮 = 界面.找控件("我的悬浮按钮");
//设置主题颜色
悬浮按钮.设置主题颜色("#FF0000");
```


### 设置图标(图标)

> 设置图标

- 参数 : 图标 {String} 图标名称


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./主界面.xml");
//获取控件
定义 悬浮按钮 = 界面.找控件("我的悬浮按钮");
//设置图标
悬浮按钮.设置图标("logo_ag");
```


### 设置提示(提示)

> 设置提示信息

- 参数 : 提示 {String} 提示信息


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./主界面.xml");
//获取控件
定义 悬浮按钮 = 界面.找控件("我的悬浮按钮");
//设置提示信息
悬浮按钮.设置提示("开始执行");
```


# 分割线

- 更新时间:2025-12-02 10:12:46

> 分割线-hr
> 
> 原生类型:{com.google.android.material.divider.MaterialDivider}




## 一、常用属性


### 颜色 - 颜色

> 设置颜色


```xml
<分割线 颜色="#F1F0FA" 宽="最大" />
```


![](./img/777137928282500.png)

### 尺寸 - 尺寸(px)

> 设置尺寸(px)


```xml
<分割线 尺寸="20" 宽="最大" />
```


![](./img/777215933092900.png)

### 开始边距 - 开始边距(dp)

> 设置开始边距(dp)


```xml
<分割线 开始边距="20" 宽="最大" />
```


![](./img/777340110166300.png)

### 结束边距 - 结束边距(dp)

> 设置结束边距(dp)


```xml
<分割线 结束边距="20" 宽="最大" />
```


![](./img/777340110166300.png)

## 二、常用函数


### 设置粗细(粗细)

> 设置粗细

- 参数 : 粗细 {int} 粗细(px)


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./主界面.xml");
//获取控件
定义 分割线 = 界面.找控件("我的分割线");
//设置粗细
分割线.设置粗细(20);
```


### 设置开始边距(开始边距)

> 设置开始边距

- 参数 : 开始边距 {int} 开始边距


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./主界面.xml");
//获取控件
定义 分割线 = 界面.找控件("我的分割线");
//设置开始边距
分割线.设置开始边距(20);
```


### 设置结束边距(结束边距)

> 设置结束边距

- 参数 : 结束边距 {int} 结束边距


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./主界面.xml");
//获取控件
定义 分割线 = 界面.找控件("我的分割线");
//设置结束边距
分割线.设置结束边距(20);
```


### 设置主题颜色(颜色)

> 设置主题颜色

- 参数 : 颜色 {String} 颜色值


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./主界面.xml");
//获取控件
定义 分割线 = 界面.找控件("我的分割线");
//设置主题颜色
分割线.设置主题颜色("#FF0000");
```


# 图片与图标

- 更新时间:2025-12-02 10:12:46

> 图片-img
> 
> 常用于显示图片或者图标
> 
> 原生类型:{com.google.android.material.imageview.ShapeableImageView}




图片(图标)：用于显示图片或者图标


![](./img/819952284073000.png)

## 一、常用属性


### 弧度 - 圆弧半径

> 设置圆弧半径
> 
> 单位:dp


```xml
<图片 弧度="16"/>
```


### 链接 - 图片链接

> 设置图片链接


```xml
<图片 链接="http://..."/>
```


### 边框宽度 - 边框宽度

> 设置边框宽度
> 
> 单位:dp


```xml
<图片 边框宽度="5"/>
```


### 边框颜色 - 边框颜色

> 设置边框颜色


```xml
<图片 边框颜色="#FF0000"/>
```


### 拉伸类型 - 拉伸类型

> 设置拉伸类型
> 
> 可选(忽略大小写,可忽略下划线):中心适配, 开始适配, 结束适配, 横竖轴适配, 居中, 中心裁剪, 内部居中, 矩阵


```xml
<图片 拉伸类型="横竖轴适配"/>
```


### 图片颜色 - 图片填充颜色

> 设置图片填充颜色


```xml
<图片 图片颜色="#FF0000"/>
```


### 路径 - 图片本地路径

> 设置图片本地路径


```xml
<图片 路径="/资源/图片01.png"/>
```


### 资源 - 图片或图标路径

> 设置图片或图标路径


```xml
<图片 资源="/资源/图片01.png"/>
```


### 旋转角度 - 旋转角度

> 设置旋转角度


```xml
<图片 旋转角度="45"/>
```


### 旋转速度 - 自动旋转的倍速

> 设置自动旋转的倍速


```xml
<图片 旋转速度="3"/>
```


### 自动旋转 - 是否自动旋转

> 是否自动旋转


```xml
<图片 自动旋转="是"/>
```


### 内边距 - 内边距

> 设置内边距


```xml
<!--内边距顺序是:左,上,右,下-->
<!--内边距只设置一个值：则设置所有方向的内边距-->
<!--内边距只设置两个值：则设置左右和上下方向的内边距-->
<图片 内边距="20" />
```


### 重力 - 重力

> 设置重力


```xml
<图片 重力="开始" />
```


### 背景颜色 - 背景颜色

> 设置背景颜色


```xml
<图片 背景颜色="#1E1F22" />
```


### 背景图片 - 背景图片

> 设置背景图片


```xml
<图片 背景图片="./资源/图片01.png" />
```


## 二、常用函数


### 自动旋转(是否旋转)

> 图片自动旋转

- 参数 : 是否旋转 {boolean} 是否旋转


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./主界面.xml");
//获取控件
定义 图片 = 界面.找控件("我的图片");
//设置图片自动旋转
图片.自动旋转(是);
```


### 自动旋转(是否旋转, 速度)

> 图片自动旋转

- 参数 : 是否旋转 {boolean} 是否旋转
- 参数 : 速度 {float} 旋转速度


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./主界面.xml");
//获取控件
定义 图片 = 界面.找控件("我的图片");
//设置图片自动旋转
图片.自动旋转(是, 10);
```


### 设置角度(角度)

> 设置角度

- 参数 : 角度 {float} 角度值


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./主界面.xml");
//获取控件
定义 图片 = 界面.找控件("我的图片");
//设置角度
图片.设置角度(45);
```


### 设置图标(图标)

> 设置图标

- 参数 : 图标 {string} 图标名称


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./主界面.xml");
//获取控件
定义 图片 = 界面.找控件("我的图片");
//设置图标
图片.设置图标("logo_ag");
```


### 设置链接(链接)

> 设置图片链接

- 参数 : 链接 {string} 图片链接地址


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./主界面.xml");
//获取控件
定义 图片 = 界面.找控件("我的图片");
//设置图片链接
图片.设置链接("https://www.baidu.com/icon.png");
```


### 设置路径(路径)

> 设置图片路径

- 参数 : 路径 {string} 图片路径


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./主界面.xml");
//获取控件
定义 图片 = 界面.找控件("我的图片");
//设置图片路径
图片.设置路径("./资源/图片01.png");
```


### 设置图片(位图)

> 设置图片

- 参数 : 位图 {bitmap} 图片位图


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./主界面.xml");
//获取控件
定义 图片 = 界面.找控件("我的图片");
//设置图片
定义 图片对象 = $图片.读取("./资源/图片01.png");
图片.设置图片(图片对象.获得位图());
```


### 获取图片()

> 获取图片

- 返回 : {bitmap} 获取到的图片位图


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./主界面.xml");
//获取控件
定义 图片 = 界面.找控件("我的图片");
//获取图片
定义 位图 = 图片.获取图片();
//构建图片对象
定义 图片对象 = $图片.打开(位图);
```


# UI框架

- 更新时间:2025-12-02 10:12:44



UI框架是基于谷歌[Material 3](https://m3.material.io/)进行拓展，封装了全部控件以及布局。 甚至封装了组件式的控件，可以帮助开发者快速完成界面开发。

与此同时，提供了大量界面模板，你可以在软件示例中找到，也可以在本文档中找到。


![](./img/ui-demo.png)

#### UI框架设计图

UI框架中最大的类是XView类，其余的所有视图都是XView的子类，因此XView类中的所有方法都可以被其子类调用。
其中XLayout是XView的子类，也是所有布局类型的父类，所以XLayout类的所有方法都可以被其子类调用。

例如1：XView类中有'click(点击监听)'方法，这个方法可以监听点击事件，因此所有的子组件都可以调用这个方法监听点击事件。

例如2：XLayout类中有'addView(添加视图)'方法，这个方法可以使得布局动态添加一个子视图，'linear(线性布局)'是XLayout的子类，因此可以调用'addView'方法添加子视图。


![](./img/ui-fragment.png)

# 输入框

- 更新时间:2025-12-02 10:12:46

> 输入框-input
> 
> 组件原生类型:{com.google.android.material.textfield.TextInputEditText}
> 
> 布局原生类型:{com.google.android.material.textfield.TextInputLayout}




输入框：一个可以输入文字的地方。


![](./img/820325920861600.png)

## 一、基础用法


## 二、常用属性


### 风格 - 样式

> 设置样式
> 
> 可选:填充,轮廓


```xml
<输入框 风格="轮廓" 文本="轮廓样式" 宽="最大" />
<输入框 风格="填充" 文本="填充样式" 宽="最大" />
```


![](./img/820949440675300.png)

### 提示 - 提示文本

> 提示文本


```xml
<输入框 提示="请输入内容" 宽="最大" />
```


![](./img/820994282465600.png)

### 文本 - 文本

> 设置文本


```xml
<输入框 文本="默认内容" 宽="最大" />
```


![](./img/821030258658900.png)

### 默认 - 文本

> 设置文本


```xml
<输入框 默认="默认内容" 宽="最大" />
```


![](./img/821030258658900.png)

### 字数 - 字数限制

> 设置字数限制


```xml
<输入框 字数="50" 宽="最大" />
```


![](./img/821083337465700.png)

### 最大行数 - 最大行数

> 最大行数


```xml
<输入框 最大行数="3" 宽="最大" />
```


![](./img/821119836418400.png)

### 最小行数 - 最少行数

> 最少行数


```xml
<输入框 最小行数="3" 宽="最大" />
```


![](./img/821175683477700.png)

### 帮助 - 帮助文字

> 帮助文字


```xml
<输入框 帮助="可以输入中文" 宽="最大" />
```


![](./img/821206691453200.png)

### 前缀 - 前缀

> 设置前缀


```xml
<输入框 前缀="电话:" 文本="110" 宽="最大" />
```


![](./img/821271802433400.png)

### 后缀 - 后缀

> 设置后缀


```xml
<输入框 后缀="@qq.com" 文本="2450099002" 宽="最大" />
```


![](./img/821352843824200.png)

### 类型 - 输入类型

> 设置输入类型
> 
> 可选:密码,数字,手机号


```xml
<输入框 文本="123456" 类型="密码" 宽="最大" />
```


![](./img/821385266215300.png)

### 背景颜色 - 背景颜色

> 设置背景颜色


```xml
<输入框 背景颜色="#55C94F4F" 宽="最大" />
```


![](./img/821580281488000.png)

### 背景图片 - 背景图片

> 设置背景图片


```xml
<输入框 背景图片="/资源/图片01.png" 宽="最大" />
```


![](./img/821546252782500.png)

### 主题颜色 - 主题颜色

> 设置主题颜色


```xml
<输入框 主题颜色="#553574F0" 文本="主题颜色" 宽="最大" />
```


![](./img/821636371377900.png)

### 文本颜色 - 文本颜色

> 设置文本颜色


```xml
<输入框 文本="文本颜色" 文本颜色="#C94F4F" 宽="最大" />
```


![](./img/821676700688800.png)

### 边框颜色 - 边框颜色

> 设置边框颜色


```xml
<输入框 边框颜色="#FF0000" 宽="最大" />
```


![](./img/821724818089500.png)

### 边框宽度 - 边框宽度

> 设置边框宽度


```xml
<输入框 边框宽度="5" 宽="最大" />
```


![](./img/821782108879300.png)

### 弧度 - 弧度

> 设置弧度


```xml
<输入框 弧度="16" 宽="最大" />
<输入框 弧度="0,16" 宽="最大" />
<!--上左,上右,下左,下右-->
<输入框 弧度="20,5,5,20" 宽="最大" />
```


![](./img/821891654121600.png)

### 内边距 - 布局内边距

> 设置布局内边距


```xml
<输入框 内边距="20,5,5,20" 宽="最大" />
```


![](./img/822117009830400.png)

### 重力 - 布局重力

> 布局重力


```xml
<输入框 重力="中" 宽="最大" />
```


![](./img/822196996553700.png)

## 三、常用函数


### 设置提示(提示)

> 设置预提示

- 参数 : 提示 {string} 提示文本


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./主界面.xml");
//获取控件
定义 输入框 = 界面.找控件("我的输入框");
//设置预提示
输入框.设置提示("请输入名字");
```


### 设置背景颜色(颜色)

> 设置背景颜色

- 参数 : 颜色 {string} 颜色值


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./主界面.xml");
//获取控件
定义 输入框 = 界面.找控件("我的输入框");
//设置背景颜色
输入框.设置背景颜色("#ff0000");//也可以是M3主题动态色，例如:主题主颜色
```


### 设置边框颜色(颜色)

> 设置边框颜色

- 参数 : 颜色 {string} 颜色值
- 版本 : 1.5.3


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./主界面.xml");
//获取控件
定义 输入框 = 界面.找控件("我的输入框");
//设置边框颜色
输入框.设置边框颜色("#ff0000");//也可以是M3主题动态色，例如:主题主颜色
```


### 设置边框宽度(宽度)

> 设置边框宽度

- 参数 : 宽度 {int} 边框宽度
- 版本 : 1.5.3


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./主界面.xml");
//获取控件
定义 输入框 = 界面.找控件("我的输入框");
//设置边框宽度
输入框.设置边框宽度(5);//单位:dp
```


### 设置弧度(左上, 上右, 左下, 右下)

> 设置弧度

- 参数 : 左上 {float} 左上角弧度
- 参数 : 上右 {float} 右上角弧度
- 参数 : 左下 {float} 左下角弧度
- 参数 : 右下 {float} 右下角弧度
- 版本 : 1.5.3


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./主界面.xml");
//获取控件
定义 输入框 = 界面.找控件("我的输入框");
//设置边框弧度
输入框.设置弧度(20,20,5,5);//单位:dp
```


### 设置文字(文本)

> 设置文字

- 参数 : 文本 {string} 文字内容


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./主界面.xml");
//获取控件
定义 输入框 = 界面.找控件("我的输入框");
//设置文本
输入框.设置文字("我是文字");
```


### 获取文字()

> 获取输入框内容

- 返回 : {string} 内容


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./主界面.xml");
//获取控件
定义 输入框 = 界面.找控件("我的输入框");
//获得文本
定义 文本 = 输入框.获取文字();
```


### 设置错误(提示)

> 设置异常信息提示

- 参数 : 提示 {string} 错误提示信息


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./主界面.xml");
//获取控件
定义 输入框 = 界面.找控件("我的输入框");
//设置异常提示
输入框.设置错误("输入内容有误");
```


### 获取编辑框()

> 获取文本输入编辑框对象

- 返回 : {TextInputEditText} 编辑框对象


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./主界面.xml");
//获取控件
定义 输入框 = 界面.找控件("我的输入框");
//获得文本输入编辑框对象
定义 编辑框 = 输入框.获取编辑框();
```


### 监听文本改变(回调)

> 监听文本改变

- 参数 : 回调 {(文本,开始,之前,数量)=>{}} 监听回调
- 版本 : 1.8.0


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./主界面.xml");
//获取控件
定义 输入框 = 界面.找控件("我的输入框");
//监听文本改变
输入框.监听文本改变((文本,开始,之前,数量)=>{
    日志("文本改变了:"+文本);
});
```


### 监听文本改变后(回调)

> 监听文本改变后

- 参数 : 回调 {(文本,开始,之前,数量)=>{}} 监听回调
- 版本 : 1.8.0


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./主界面.xml");
//获取控件
定义 输入框 = 界面.找控件("我的输入框");
//监听文本改变后
输入框.监听文本改变后((文本)=>{
    日志("文本改变了:"+文本);
});
```


### 监听文本改变前(回调)

> 监听文本改变前

- 参数 : 回调 {(文本,开始,数量,之前)=>{}} 监听回调
- 版本 : 1.8.0


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./主界面.xml");
//获取控件
定义 输入框 = 界面.找控件("我的输入框");
//监听文本改变前
输入框.监听文本改变前((文本,开始,数量,之前)=>{
    日志("文本改变了:"+文本);
});
```


### 监听焦点改变(回调)

> 监听焦点改变

- 参数 : 回调 {(有焦点)=>{}} 监听回调
- 版本 : 1.8.2


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./主界面.xml");
//获取控件
定义 输入框 = 界面.找控件("我的输入框");
//监听焦点改变
输入框.监听焦点改变((有焦点)=>{
    日志("焦点改变了:"+文本);
});
```


# 绝对布局

- 更新时间:2025-12-02 10:12:44

> 绝对布局-absolute
> 
> 是布局父类的(XLayout)的子类,因此可以使用XLayout的所有方法
> 
> 原生类型:{android.widget.AbsoluteLayout}




### 背景颜色 - 背景颜色

> 设置背景颜色


```xml
<绝对布局 背景颜色="#57965C" />
```


### 背景图片 - 背景图片

> 设置背景图片


```xml
<绝对布局 背景图片="资源/图片01.png" />
```


### 内边距 - 内边距

> 设置内边距
> 
> 参数顺序:左,上,右,下(单位:dp)


```xml
<绝对布局 内边距="0,0,0,0" />
```


### 重力 - 重力

> 设置重力
> 
> 绝对布局只能设置前景重力，并且要求安卓6.0+。


```xml
<绝对布局 重力="中" />
```


## 子控件属性表

被绝对布局包裹的子控件可以使用如下属性：

| 中文名   | 英文名    | 描述                                                         |
|----------|-----------|--------------------------------------------------------------|
| 横轴     | x         | 设置视图在AbsoluteLayout中的横轴（X轴）位置                   |
| 纵轴     | y         | 设置视图在AbsoluteLayout中的纵轴（Y轴）位置                   |
| 解决方向 | resolveDir | 确定视图应遵循的实际布局方向，可选值为“rtl”（右到左）或“ltr”（左到右） |
| 宽       | w         | 设置视图的宽度，可选值为“auto”（自动，即WRAP_CONTENT）、“max”（最大，即MATCH_PARENT）或具体整数（单位为dp） |
| 高       | h         | 设置视图的高度，可选值为“auto”（自动，即WRAP_CONTENT）、“max”（最大，即MATCH_PARENT）或具体整数（单位为dp） |


# 卡片布局

- 更新时间:2025-12-02 10:12:45

> 卡片布局-card
> 
> 是布局父类的(XLayout)的子类,因此可以使用XLayout的所有方法,但需要注意卡片布局本身是帧布局的子类，因此建议在卡片布局中加入线性布局来使用。
> 
> 原生类型:{com.google.android.material.card.MaterialCardView}




## 一、常用属性


### 风格 - 风格

> 设置风格
> 
> 可选值:填充,轮廓,阴影


```xml
<卡片 风格="轮廓" />
```


### 可点击 - 是否可以点击

> 设置是否可以点击


```xml
<卡片 可点击="是" />
```


### 涟漪颜色 - 涟漪颜色

> 设置涟漪颜色


```xml
<卡片 涟漪颜色="#FF0000" />
```


### 弧度 - 弧度

> 设置弧度
> 
> 单位:dp


```xml
<卡片 弧度="10" />
```


### 最小宽度 - 最小宽度

> 设置最小宽度
> 
> 单位:dp


```xml
<卡片 最小宽度="20" />
```


### 最小高度 - 最小高度

> 设置最小高度
> 
> 单位:dp


```xml
<卡片 最小高度="20" />
```


### 背景颜色 - 背景颜色

> 设置背景颜色


```xml
<卡片 背景颜色="#57965C" />
```


### 填充颜色 - 填充颜色

> 设置填充颜色
> 
> 背景颜色会无视卡片的圆弧角度，填充颜色会填充整个卡片，并且保证卡片的角度和样式


```xml
<卡片 填充颜色="#57965C" />
```


### 背景图片 - 背景图片

> 设置背景图片


```xml
<卡片 背景图片="资源/图片01.png" />
```


### 内边距 - 内边距

> 设置内边距
> 
> 参数顺序:左,上,右,下(单位:dp)


```xml
<卡片 内边距="0,0,0,0" />
```


### 重力 - 重力

> 设置重力
> 
> 
> 卡片只能设置前景重力，不要求安卓版本。


```xml
<卡片 重力="中" />
```


## 二、子控件属性表

被卡片布局包裹的子控件可以使用如下属性：

| 中文名   | 英文名        | 描述                                                         |
|----------|---------------|--------------------------------------------------------------|
| 布局方向 | dir           | 设置子视图的排列方向，可选值为“rtl”（右到左）或“ltr”（左到右） |
| 解决方向 | resolveDir    | 确定视图应遵循的实际布局方向，可选值为“rtl”（右到左）或“ltr”（左到右） |
| 宽       | w             | 设置视图的宽度，可选值为“auto”（自动，即WRAP_CONTENT）、“max”（最大，即MATCH_PARENT）或具体整数（单位为dp） |
| 高       | h             | 设置视图的高度，可选值为“auto”（自动，即WRAP_CONTENT）、“max”（最大，即MATCH_PARENT）或具体整数（单位为dp） |
| 布局重力 | layout_gravity | 设置视图的布局重力，通过GravityAdd获取对应的重力值             |
| 外边距   | margin        | 设置视图的外边距，可传入单个整数（四边外边距相同）或四个整数（分别对应左、上、右、下外边距），单位为dp |
| 左外边距 | margin_left   | 单独设置视图的左外边距，单位为dp                             |
| 上外边距 | margin_top    | 单独设置视图的上外边距，单位为dp                             |
| 右外边距 | margin_right  | 单独设置视图的右外边距，单位为dp                             |
| 下外边距 | margin_bottom | 单独设置视图的下外边距，单位为dp                             |


## 三、常用函数


### 设置可点击(可点击)

> 设置可点击

- 参数 : 可点击 {布尔值} 是否可点击
- 版本 : 1.8.2


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//获取控件
定义 卡片 = 界面.找控件("我的卡片");
//设置可点击
卡片.设置可点击(是);
```


### 设置涟漪色(颜色)

> 设置涟漪色

- 参数 : 颜色 {字符串} 颜色字符串
- 版本 : 1.8.2


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//获取控件
定义 卡片 = 界面.找控件("我的卡片");
//设置涟漪色
卡片.设置涟漪色("#FF0000");
```


### 设置涟漪色(颜色)

> 设置涟漪色

- 参数 : 颜色 {数字} 颜色值
- 版本 : 1.8.2


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//获取控件
定义 卡片 = 界面.找控件("我的卡片");
//设置涟漪色
卡片.设置涟漪色($颜色.红色);
```


### 设置背景颜色(颜色)

> 设置背景颜色

- 参数 : 颜色 {数字} 文本颜色值
- 版本 : 1.8.2


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//获取控件
定义 卡片 = 界面.找控件("我的卡片");
//设置背景颜色
卡片.设置背景颜色($颜色.红色);
```


### 设置背景颜色(颜色)

> 设置背景颜色

- 参数 : 颜色 {字符串} 颜色字符串
- 版本 : 1.8.2


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//获取控件
定义 卡片 = 界面.找控件("我的卡片");
//设置背景颜色
卡片.设置背景颜色("#1E1F22");
```


### 设置填充色(颜色)

> 设置填充色

- 参数 : 颜色 {数字} 颜色值
- 版本 : 1.8.2


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//获取控件
定义 卡片 = 界面.找控件("我的卡片");
//设置填充色
卡片.设置填充色($颜色.红色);
```


### 设置填充色(颜色)

> 设置填充色

- 参数 : 颜色 {字符串} 颜色字符串
- 版本 : 1.8.2


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//获取控件
定义 卡片 = 界面.找控件("我的卡片");
//设置填充色
卡片.设置填充色("#FF0000");
```


### 设置弧度(弧度)

> 设置弧度

- 参数 : 弧度 {数字} 弧度(单位:dp)
- 版本 : 1.8.2


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//获取控件
定义 卡片 = 界面.找控件("我的卡片");
//设置弧度
卡片.设置弧度(15);
```


# 约束布局

- 更新时间:2025-12-02 10:12:45

> 约束布局-const
> 
> 是布局父类的(XLayout)的子类,因此可以使用XLayout的所有方法
> 
> 原生类型:{androidx.constraintlayout.widget.ConstraintLayout}




### 最小宽度 - 最小宽度

> 设置最小宽度
> 
> 单位:dp


```xml
<约束布局 最小宽度="20" />
```


### 最小高度 - 最小高度

> 设置最小高度
> 
> 单位:dp


```xml
<约束布局 最小高度="20" />
```


### 背景颜色 - 背景颜色

> 设置背景颜色


```xml
<约束布局 背景颜色="#57965C" />
```


### 背景图片 - 背景图片

> 设置背景图片


```xml
<约束布局 背景图片="资源/图片01.png" />
```


### 内边距 - 内边距

> 设置内边距
> 
> 参数顺序:左,上,右,下(单位:dp)


```xml
<约束布局 内边距="0,0,0,0" />
```


### 重力 - 重力

> 设置重力
> 
> 约束布局只能设置前景重力，并且要求安卓6.0+。


```xml
<约束布局 重力="中" />
```


## 子控件属性表

被约束布局包裹的子控件可以使用如下属性：

| 中文名     | 英文名          | 描述                                                         |
|------------|-----------------|--------------------------------------------------------------|
| 垂直偏移   | verticalBias    | 设置视图在垂直方向的偏移值，若与水平偏移均设为0.5，可实现居中对齐 |
| 水平偏移   | horizontalBias  | 设置视图在水平方向的偏移值，若与垂直偏移均设为0.5，可实现居中对齐 |
| 布局方向   | dir             | 设置子视图的排列方向，可选值为“rtl”（右到左）或“ltr”（左到右） |
| 解决方向   | resolveDir      | 确定视图应遵循的实际布局方向，可选值为“rtl”（右到左）或“ltr”（左到右） |
| 宽         | w               | 设置视图的宽度，可选值为“auto”（自动，即WRAP_CONTENT）、“max”（最大，即MATCH_PARENT）或具体整数（单位为dp） |
| 高         | h               | 设置视图的高度，可选值为“auto”（自动，即WRAP_CONTENT）、“max”（最大，即MATCH_PARENT）或具体整数（单位为dp） |
| 外边距     | margin          | 设置视图的外边距，可传入单个整数（四边外边距相同）或四个整数（分别对应左、上、右、下外边距），单位为dp |
| 左外边距   | margin_left     | 单独设置视图的左外边距，单位为dp                             |
| 上外边距   | margin_top      | 单独设置视图的上外边距，单位为dp                             |
| 右外边距   | margin_right    | 单独设置视图的右外边距，单位为dp                             |
| 下外边距   | margin_bottom   | 单独设置视图的下外边距，单位为dp                             |


# 锚点布局

- 更新时间:2025-12-02 10:12:45

> 锚点布局-coord
> 
> 是布局父类(XLayout)的子类,因此可以使用XLayout的所有方法
> 
> 原生类型:{androidx.coordinatorlayout.widget.CoordinatorLayout}




锚点布局，能够实现的效果让人意想不到，你可以理解为：船舶停靠在某个驿站上，一般用anchor属性指定驿站的名字，用anchorLayout指定要前往的驿站。


![](../img/coord_toolbar_fab.png)


```xml
<ui>
    <statusbar />
    <!--
    anchor属性是所有控件都有的属性，但是使用anchorLayout属性必须要被coord锚点布局包才可以
    -->
    <coord h="max" w="max">
        <!--
        anchor="linear" 指的是:给线性布局(linear)取一个驿站名称为'linear'
        -->
        <linear anchor="linear" gravity="center" h="max" margin_bottom="75" w="max">
            <text text="Hello World!" />
        </linear>
        <!--
        anchorLayout="linear" 指的是:锚定到名称为'linear'的布局上
        -->
        <toolbar anchor="toolbar" anchorGravity="center|bottom" anchorLayout="linear"
            fabAnim="slide" fabGravity="center" fabMode="out" fabRadius="25" h="75"
            layout_gravity="bottom" w="max">
            <menu icon="ic_search" text="搜搜" />
            <menu icon="ic_set" text="设置" />
            <menu icon="ic_menu" text="菜单" />
        </toolbar>
        <!--
        这里我让(fab)悬浮按钮锚定到(toolbar)工作条的布局上，同时在(toolbar)工作条的布局上设置悬浮按钮的样式，
        然而(toolbar)工作条能够专门和(fab)悬浮按一起联动，实现凹陷的效果。
        -->
        <fab anchorLayout="toolbar" icon="ic_add" iconTint="txt" radius="27" />
    </coord>
</ui>
```


## 一、常用属性


### 最小宽度 - 最小宽度

> 设置最小宽度
> 
> 单位:dp


```xml
<锚点布局 最小宽度="20" />
```


### 最小高度 - 最小高度

> 设置最小高度
> 
> 单位:dp


```xml
<锚点布局 最小高度="20" />
```


### 背景颜色 - 背景颜色

> 设置背景颜色


```xml
<锚点布局 背景颜色="#57965C" />
```


### 背景图片 - 背景图片

> 设置背景图片


```xml
<锚点布局 背景图片="资源/图片01.png" />
```


### 内边距 - 内边距

> 设置内边距
> 
> 参数顺序:左,上,右,下(单位:dp)


```xml
<锚点布局 内边距="0,0,0,0" />
```


### 重力 - 重力

> 设置重力
> 
> 锚点布局只能设置前景重力，并且要求安卓6.0+。


```xml
<锚点布局 重力="中" />
```


## 二、子控件属性表

被锚点布局约束的子控件可以使用如下属性：

| 中文名       | 英文名          | 描述                                                         |
|--------------|-----------------|--------------------------------------------------------------|
| 布局方向     | dir             | 设置子视图的排列方向，可选值为“rtl”（右到左）或“ltr”（左到右） |
| 解决方向     | resolveDir      | 确定视图应遵循的实际布局方向，可选值为“rtl”（右到左）或“ltr”（左到右） |
| 行为         | behavior        | 指定视图与其他视图或父布局的交互方式，可选值为“appbar”（应用条，对应AppBarLayout.ScrollingViewBehavior）或“fab”（悬浮按钮，对应ScrollAwareFabBehavior） |
| 参考线       | keyline         | 在CoordinatorLayout中定义参考线，帮助子视图根据参考线定位，单位为dp |
| 锚点视图       | anchorLayout        | 设置锚定的视图，用于让当前视图相对锚定视图进行布局（需为每个视图设置anchor以引用） |
| 锚点重力     | anchorGravity   | 设置当前视图相对于锚点视图的重力方向，通过GravityAdd获取对应的重力值 |
| 避让插入边   | dodgeInsetEdges | 指定视图在遇到系统窗口插入边（如状态栏、导航栏等）时的避让行为，通过GravityAdd获取对应值 |
| 插入边       | insetEdge       | 指定视图哪一侧视为系统窗口插入边的边界，当系统窗口覆盖布局时，视图会调整位置或大小为系统窗口留出空间，通过GravityAdd获取对应值 |
| 宽           | w               | 设置视图的宽度，可选值为“auto”（自动，即WRAP_CONTENT）、“max”（最大，即MATCH_PARENT）或具体整数（单位为dp） |
| 高           | h               | 设置视图的高度，可选值为“auto”（自动，即WRAP_CONTENT）、“max”（最大，即MATCH_PARENT）或具体整数（单位为dp） |
| 布局重力     | layout_gravity  | 设置视图的布局重力，通过GravityAdd获取对应的重力值             |
| 外边距       | margin          | 设置视图的外边距，可传入单个整数（四边外边距相同）或四个整数（分别对应左、上、右、下外边距），单位为dp |
| 左外边距     | margin_left     | 单独设置视图的左外边距，单位为dp                             |
| 上外边距     | margin_top      | 单独设置视图的上外边距，单位为dp                             |
| 右外边距     | margin_right    | 单独设置视图的右外边距，单位为dp                             |
| 下外边距     | margin_bottom   | 单独设置视图的下外边距，单位为dp                             |


# 抽屉布局

- 更新时间:2025-12-02 10:12:45

> 抽屉布局-drawer
> 
> 是布局父类{XLayout}的子类,因此可以使用XLayout的所有方法
> 
> 原生类型:{androidx.drawerlayout.widget.DrawerLayout}




### 背景颜色 - 背景颜色

> 设置背景颜色


```xml
<抽屉布局 背景颜色="#57965C" />
```


### 背景图片 - 背景图片

> 设置背景图片


```xml
<抽屉布局 背景图片="资源/图片01.png" />
```


### 内边距 - 内边距

> 设置内边距
> 
> 参数顺序:左,上,右,下(单位:dp)


```xml
<抽屉布局 内边距="0,0,0,0" />
```


### 重力 - 重力

> 设置重力
> 
> 抽屉布局只能设置前景重力，并且要求安卓6.0+。


```xml
<抽屉布局 重力="中" />
```


## 子控件属性表

被抽屉布局包裹的子控件可以使用如下属性：

| 中文名     | 英文名          | 描述                                                         |
|------------|-----------------|--------------------------------------------------------------|
| 布局方向   | dir             | 设置子视图的排列方向，可选值为“rtl”（右到左）或“ltr”（左到右） |
| 解决方向   | resolveDir      | 确定视图应遵循的实际布局方向，可选值为“rtl”（右到左）或“ltr”（左到右） |
| 宽         | w               | 设置视图的宽度，可选值为“auto”（自动，即WRAP_CONTENT）、“max”（最大，即MATCH_PARENT）或具体整数（单位为dp） |
| 高         | h               | 设置视图的高度，可选值为“auto”（自动，即WRAP_CONTENT）、“max”（最大，即MATCH_PARENT）或具体整数（单位为dp） |
| 布局重力   | layout_gravity  | 设置视图的布局重力，通过GravityAdd获取对应的重力值             |
| 外边距     | margin          | 设置视图的外边距，可传入单个整数（四边外边距相同）或四个整数（分别对应左、上、右、下外边距），单位为dp |
| 左外边距   | margin_left     | 单独设置视图的左外边距，单位为dp                             |
| 上外边距   | margin_top      | 单独设置视图的上外边距，单位为dp                             |
| 右外边距   | margin_right    | 单独设置视图的右外边距，单位为dp                             |
| 下外边距   | margin_bottom   | 单独设置视图的下外边距，单位为dp                             |


# 流式布局

- 更新时间:2025-12-02 10:12:45

> 流式布局-flow
> 
> 是布局父类的(XLayout)的子类,因此可以使用XLayout的所有方法
> 
> 原生类型:{com.google.android.material.internal.FlowLayout}




### 最小宽度 - 最小宽度

> 设置最小宽度
> 
> 单位:dp


```xml
<流式布局 最小宽度="20" />
```


### 最小高度 - 最小高度

> 设置最小高度
> 
> 单位:dp


```xml
<流式布局 最小高度="20" />
```


### 背景颜色 - 背景颜色

> 设置背景颜色


```xml
<流式布局 背景颜色="#57965C" />
```


### 背景图片 - 背景图片

> 设置背景图片


```xml
<流式布局 背景图片="资源/图片01.png" />
```


### 内边距 - 内边距

> 设置内边距
> 
> 参数顺序:左,上,右,下(单位:dp)


```xml
<流式布局 内边距="0,0,0,0" />
```


### 重力 - 重力

> 设置重力
> 
> 流式布局只能设置前景重力，并且要求安卓6.0+。


```xml
<流式布局 重力="中" />
```


## 子控件属性表

被流式布局包含的子控件可以使用如下属性：

| 中文名   | 英文名    | 描述                                                         |
|----------|-----------|--------------------------------------------------------------|
| 解决方向 | resolveDir | 确定视图应遵循的实际布局方向，可选值为“rtl”（右到左）或“ltr”（左到右） |
| 宽       | w         | 设置视图的宽度，可选值为“auto”（自动，即WRAP_CONTENT）、“max”（最大，即MATCH_PARENT）或具体整数（单位为dp） |
| 高       | h         | 设置视图的高度，可选值为“auto”（自动，即WRAP_CONTENT）、“max”（最大，即MATCH_PARENT）或具体整数（单位为dp） |


# 刷新布局

- 更新时间:2025-12-02 10:12:45

> 刷新布局-flush
> 
> 是布局父类的(XLayout)的子类,因此可以使用XLayout的所有方法
> 
> 原生类型:{androidx.swiperefreshlayout.widget.SwipeRefreshLayout}




### 最小宽度 - 最小宽度

> 设置最小宽度
> 
> 单位:dp


```xml
<刷新布局 最小宽度="20" />
```


### 最小高度 - 最小高度

> 设置最小高度
> 
> 单位:dp


```xml
<刷新布局 最小高度="20" />
```


### 背景颜色 - 背景颜色

> 设置背景颜色


```xml
<刷新布局 背景颜色="#57965C" />
```


### 背景图片 - 背景图片

> 设置背景图片


```xml
<刷新布局 背景图片="资源/图片01.png" />
```


### 内边距 - 内边距

> 设置内边距
> 
> 参数顺序:左,上,右,下(单位:dp)


```xml
<刷新布局 内边距="0,0,0,0" />
```


### 重力 - 重力

> 设置重力
> 
> 刷新布局只能设置前景重力，并且要求安卓6.0+。


```xml
<刷新布局 重力="中" />
```


## 子控件属性表

被下拉刷新布局包含的子控件可以使用如下属性：

| 中文名   | 英文名    | 描述                                                         |
|----------|-----------|--------------------------------------------------------------|
| 解决方向 | resolveDir | 确定视图应遵循的实际布局方向，可选值为“rtl”（右到左）或“ltr”（左到右） |
| 宽       | w         | 设置视图的宽度，可选值为“auto”（自动，即WRAP_CONTENT）、“max”（最大，即MATCH_PARENT）或具体整数（单位为dp） |
| 高       | h         | 设置视图的高度，可选值为“auto”（自动，即WRAP_CONTENT）、“max”（最大，即MATCH_PARENT）或具体整数（单位为dp） |


### 监听刷新(runnable)

> 设置下拉刷新监听

- 参数 : runnable {()=>{}} 刷新时执行的任务


```javascript
//解析布局,获得ui对象
定义 我的界面 = $界面.解析界面("./资源/主界面.xml");
//获取控件
定义 下拉刷新控件 = 我的界面.找控件("我的下拉刷新控件");
//监听下拉刷新
下拉刷新控件.监听刷新(()=>{
    //处理一些事情...
});
```


# 帧布局

- 更新时间:2025-12-02 10:12:45

> 帧布局-frame
> 
> 是布局父类的(XLayout)的子类,因此可以使用XLayout的所有方法
> 
> 原生类型:{android.widget.FrameLayout}




### 最小宽度 - 最小宽度

> 设置最小宽度
> 
> 单位:dp


```xml
<帧布局 最小宽度="20" />
```


### 最小高度 - 最小高度

> 设置最小高度
> 
> 单位:dp


```xml
<帧布局 最小高度="20" />
```


### 背景颜色 - 背景颜色

> 设置背景颜色


```xml
<帧布局 背景颜色="#57965C" />
```


### 背景图片 - 背景图片

> 设置背景图片


```xml
<帧布局 背景图片="资源/图片01.png" />
```


### 内边距 - 内边距

> 设置内边距
> 
> 参数顺序:左,上,右,下(单位:dp)


```xml
<帧布局 内边距="0,0,0,0" />
```


### 重力 - 重力

> 设置重力
> 
> 帧布局只能设置前景重力，并且要求安卓6.0+。


```xml
<帧布局 重力="中" />
```


## 子控件属性表

被帧布局包裹的子控件可以使用如下属性：

| 中文名     | 英文名          | 描述                                                         |
|------------|-----------------|--------------------------------------------------------------|
| 布局方向   | dir             | 设置子视图的排列方向，可选值为“rtl”（右到左）或“ltr”（左到右） |
| 解决方向   | resolveDir      | 确定视图应遵循的实际布局方向，可选值为“rtl”（右到左）或“ltr”（左到右） |
| 宽         | w               | 设置视图的宽度，可选值为“auto”（自动，即WRAP_CONTENT）、“max”（最大，即MATCH_PARENT）或具体整数（单位为dp） |
| 高         | h               | 设置视图的高度，可选值为“auto”（自动，即WRAP_CONTENT）、“max”（最大，即MATCH_PARENT）或具体整数（单位为dp） |
| 布局重力   | layout_gravity  | 设置视图的布局重力，通过GravityAdd获取对应的重力值             |
| 外边距     | margin          | 设置视图的外边距，可传入单个整数（四边外边距相同）或四个整数（分别对应左、上、右、下外边距），单位为dp |
| 左外边距   | margin_left     | 单独设置视图的左外边距，单位为dp                             |
| 上外边距   | margin_top      | 单独设置视图的上外边距，单位为dp                             |
| 右外边距   | margin_right    | 单独设置视图的右外边距，单位为dp                             |
| 下外边距   | margin_bottom   | 单独设置视图的下外边距，单位为dp                             |


# 网格布局

- 更新时间:2025-12-02 10:12:45

> 网格布局-grid
> 
> 是布局父类的(XLayout)的子类,因此可以使用XLayout的所有方法
> 
> 原生类型:{android.widget.GridLayout}




### 最小宽度 - 最小宽度

> 设置最小宽度
> 
> 单位:dp


```xml
<网格布局 最小宽度="20" />
```


### 最小高度 - 最小高度

> 设置最小高度
> 
> 单位:dp


```xml
<网格布局 最小高度="20" />
```


### 方向 - 布局方向

> 设置布局方向


```xml
<网格布局 方向="横向" />
```


### 背景颜色 - 背景颜色

> 设置背景颜色


```xml
<网格布局 背景颜色="#57965C" />
```


### 背景图片 - 背景图片

> 设置背景图片


```xml
<网格布局 背景图片="资源/图片01.png" />
```


### 内边距 - 内边距

> 设置内边距
> 
> 参数顺序:左,上,右,下(单位:dp)


```xml
<网格布局 内边距="0,0,0,0" />
```


### 重力 - 重力

> 设置重力
> 
> 网格布局只能设置前景重力，并且要求安卓6.0+。


```xml
<网格布局 重力="中" />
```


## 子控件属性表

被网格布局包裹的子控件可以使用如下属性：

| 中文名     | 英文名          | 描述                                                         |
|------------|-----------------|--------------------------------------------------------------|
| 布局方向   | dir             | 设置子视图的排列方向，可选值为“rtl”（右到左）或“ltr”（左到右） |
| 解决方向   | resolveDir      | 确定视图应遵循的实际布局方向，可选值为“rtl”（右到左）或“ltr”（左到右） |
| 宽         | w               | 设置视图的宽度，可选值为“auto”（自动，即WRAP_CONTENT）、“max”（最大，即MATCH_PARENT）或具体整数（单位为dp） |
| 高         | h               | 设置视图的高度，可选值为“auto”（自动，即WRAP_CONTENT）、“max”（最大，即MATCH_PARENT）或具体整数（单位为dp） |
| 外边距     | margin          | 设置视图的外边距，可传入单个整数（四边外边距相同）或四个整数（分别对应左、上、右、下外边距），单位为dp |
| 左外边距   | margin_left     | 单独设置视图的左外边距，单位为dp                             |
| 上外边距   | margin_top      | 单独设置视图的上外边距，单位为dp                             |
| 右外边距   | margin_right    | 单独设置视图的右外边距，单位为dp                             |
| 下外边距   | margin_bottom   | 单独设置视图的下外边距，单位为dp                             |


# 包含布局

- 更新时间:2025-12-02 10:12:45

> 包含布局-include
> 
> 包含布局主要用于引入其他布局文件，避免单个布局文件过大导致代码臃肿。
> 包含布局的本质就是一个线性布局，所以在使用的时候遵循线性布局的规则即可。
> 是布局父类的(XLayout)的子类,因此可以使用XLayout的所有方法
> 
> 原生类型:{android.widget.LinearLayout}




### 路径 - 子界面路径

> 子界面路径


```xml
<包含布局 路径="界面/子界面.xml" />
```


### 最小宽度 - 最小宽度

> 设置最小宽度
> 
> 单位:dp


```xml
<包含布局 最小宽度="20" />
```


### 最小高度 - 最小高度

> 设置最小高度
> 
> 单位:dp


```xml
<包含布局 最小高度="20" />
```


### 方向 - 布局方向

> 设置布局方向


```xml
<包含布局 方向="横向" />
```


### 背景颜色 - 背景颜色

> 设置背景颜色


```xml
<包含布局 背景颜色="#57965C" />
```


### 背景图片 - 背景图片

> 设置背景图片


```xml
<包含布局 背景图片="资源/图片01.png" />
```


### 内边距 - 内边距

> 设置内边距
> 
> 参数顺序:左,上,右,下(单位:dp)


```xml
<包含布局 内边距="0,0,0,0" />
```


### 重力 - 重力

> 设置重力


```xml
<包含布局 重力="中" />
```


# 线性布局

- 更新时间:2025-12-02 10:12:45

> 线性布局-linear
> 
> 是布局父类的(XLayout)的子类,因此可以使用XLayout的所有方法
> 
> 原生类型:{android.widget.LinearLayout}




### 最小宽度 - 最小宽度

> 设置最小宽度
> 
> 单位:dp


```xml
<线性布局 最小宽度="20" />
```


### 最小高度 - 最小高度

> 设置最小高度
> 
> 单位:dp


```xml
<线性布局 最小高度="20" />
```


### 方向 - 布局方向

> 设置布局方向


```xml
<线性布局 方向="横向" />
```


### 背景颜色 - 背景颜色

> 设置背景颜色


```xml
<线性布局 背景颜色="#57965C" />
```


### 背景图片 - 背景图片

> 设置背景图片


```xml
<线性布局 背景图片="资源/图片01.png" />
```


### 内边距 - 内边距

> 设置内边距
> 
> 参数顺序:左,上,右,下(单位:dp)


```xml
<线性布局 内边距="0,0,0,0" />
```


### 重力 - 重力

> 设置重力


```xml
<线性布局 重力="中" />
```


## 子控件属性表

被线性布局包裹的子控件可以使用如下属性：

| 中文名     | 英文名          | 描述                                                         |
|------------|-----------------|--------------------------------------------------------------|
| 布局方向   | dir             | 设置子视图的排列方向，可选值为“rtl”（右到左）或“ltr”（左到右） |
| 解决方向   | resolveDir      | 确定视图应遵循的实际布局方向，可选值为“rtl”（右到左）或“ltr”（左到右） |
| 宽         | w               | 设置视图的宽度，可选值为“auto”（自动，即WRAP_CONTENT）、“max”（最大，即MATCH_PARENT）或具体整数（单位为dp） |
| 高         | h               | 设置视图的高度，可选值为“auto”（自动，即WRAP_CONTENT）、“max”（最大，即MATCH_PARENT）或具体整数（单位为dp） |
| 权重       | weight          | 设置视图的权重，通过浮点值指定，用于在LinearLayout中分配剩余空间 |
| 布局重力   | layout_gravity  | 设置视图的布局重力，通过GravityAdd获取对应的重力值             |
| 外边距     | margin          | 设置视图的外边距，可传入单个整数（四边外边距相同）或四个整数（分别对应左、上、右、下外边距），单位为dp |
| 左外边距   | margin_left     | 单独设置视图的左外边距，单位为dp                             |
| 上外边距   | margin_top      | 单独设置视图的上外边距，单位为dp                             |
| 右外边距   | margin_right    | 单独设置视图的右外边距，单位为dp                             |
| 下外边距   | margin_bottom   | 单独设置视图的下外边距，单位为dp                             |


# 滑动布局

- 更新时间:2025-12-02 10:12:45

> 滑动布局-nested
> 
> 是布局父类的(XLayout)的子类,因此可以使用XLayout的所有方法
> 
> 原生类型:{androidx.core.widget.NestedScrollView}




### 最小宽度 - 最小宽度

> 设置最小宽度
> 
> 单位:dp


```xml
<滑动布局 最小宽度="20" />
```


### 最小高度 - 最小高度

> 设置最小高度
> 
> 单位:dp


```xml
<滑动布局 最小高度="20" />
```


### 背景颜色 - 背景颜色

> 设置背景颜色


```xml
<滑动布局 背景颜色="#57965C" />
```


### 背景图片 - 背景图片

> 设置背景图片


```xml
<滑动布局 背景图片="资源/图片01.png" />
```


### 内边距 - 内边距

> 设置内边距
> 
> 参数顺序:左,上,右,下(单位:dp)


```xml
<滑动布局 内边距="0,0,0,0" />
```


### 重力 - 重力

> 设置重力
> 
> 滑动布局只能设置前景重力，无安卓版本要求。


```xml
<滑动布局 重力="中" />
```


## 子控件属性表

被滑动布局包裹的子控件可以使用如下属性：

| 中文名     | 英文名          | 描述                                                         |
|------------|-----------------|--------------------------------------------------------------|
| 布局方向   | dir             | 设置子视图的排列方向，可选值为“rtl”（右到左）或“ltr”（左到右） |
| 解决方向   | resolveDir      | 确定视图应遵循的实际布局方向，可选值为“rtl”（右到左）或“ltr”（左到右） |
| 宽         | w               | 设置视图的宽度，可选值为“auto”（自动，即WRAP_CONTENT）、“max”（最大，即MATCH_PARENT）或具体整数（单位为dp） |
| 高         | h               | 设置视图的高度，可选值为“auto”（自动，即WRAP_CONTENT）、“max”（最大，即MATCH_PARENT）或具体整数（单位为dp） |
| 布局重力   | layout_gravity  | 设置视图的布局重力，通过GravityAdd获取对应的重力值             |
| 外边距     | margin          | 设置视图的外边距，可传入单个整数（四边外边距相同）或四个整数（分别对应左、上、右、下外边距），单位为dp |
| 左外边距   | margin_left     | 单独设置视图的左外边距，单位为dp                             |
| 上外边距   | margin_top      | 单独设置视图的上外边距，单位为dp                             |
| 右外边距   | margin_right    | 单独设置视图的右外边距，单位为dp                             |
| 下外边距   | margin_bottom   | 单独设置视图的下外边距，单位为dp                             |


### 监听滚动(callback)

> 监听滚动

- 参数 : callback 滚动回调 


```javascript
定义 界面 = $界面.解析布局("./资源/主界面.xml");//解析界面
界面.显示();//显示界面
//找到滑动控件
定义 滑动控件 = 界面.找控件("我的滑动布局");
//监听混动事件
滑动控件.监听滚动((x,y,视图)=>{
    //处理事情
});
```


# 相对布局

- 更新时间:2025-12-02 10:12:45

> 相对布局-relative
> 
> 是布局父类的(XLayout)的子类,因此可以使用XLayout的所有方法
> 
> 原生类型:{android.widget.RelativeLayout}




### 最小宽度 - 最小宽度

> 设置最小宽度
> 
> 单位:dp


```xml
<相对布局 最小宽度="20" />
```


### 最小高度 - 最小高度

> 设置最小高度
> 
> 单位:dp


```xml
<相对布局 最小高度="20" />
```


### 背景颜色 - 背景颜色

> 设置背景颜色


```xml
<相对布局 背景颜色="#57965C" />
```


### 背景图片 - 背景图片

> 设置背景图片


```xml
<相对布局 背景图片="资源/图片01.png" />
```


### 内边距 - 内边距

> 设置内边距
> 
> 参数顺序:左,上,右,下(单位:dp)


```xml
<相对布局 内边距="0,0,0,0" />
```


### 重力 - 重力

> 设置重力


```xml
<相对布局 重力="中" />
```


## 子控件属性表

被相对布局包裹的子控件可以使用如下属性：

| 中文名         | 英文名          | 描述                                                         |
|----------------|-----------------|--------------------------------------------------------------|
| 与父布局对齐   | alignWithParent | 布尔值属性，用于指定当对应的参考视图不存在时，当前视图是否与父布局对齐 |
| 布局方向       | dir             | 设置子视图的排列方向，可选值为“rtl”（右到左）或“ltr”（左到右） |
| 解决方向       | resolveDir      | 确定视图应遵循的实际布局方向，可选值为“rtl”（右到左）或“ltr”（左到右） |
| 宽             | w               | 设置视图的宽度，可选值为“auto”（自动，即WRAP_CONTENT）、“max”（最大，即MATCH_PARENT）或具体整数（单位为dp） |
| 高             | h               | 设置视图的高度，可选值为“auto”（自动，即WRAP_CONTENT）、“max”（最大，即MATCH_PARENT）或具体整数（单位为dp） |
| 外边距         | margin          | 设置视图的外边距，可传入单个整数（四边外边距相同）或四个整数（分别对应左、上、右、下外边距），单位为dp |
| 左外边距       | margin_left     | 单独设置视图的左外边距，单位为dp                             |
| 上外边距       | margin_top      | 单独设置视图的上外边距，单位为dp                             |
| 右外边距       | margin_right    | 单独设置视图的右外边距，单位为dp                             |
| 下外边距       | margin_bottom   | 单独设置视图的下外边距，单位为dp                             |


# 滚动布局

- 更新时间:2025-12-02 10:12:45

> 滚动布局-scroll
> 
> 是布局父类的(XLayout)的子类,因此可以使用XLayout的所有方法
> 
> 原生类型:{android.widget.ScrollView}




### 方向 - 布局方向

> 设置布局方向


```xml
<滚动布局 方向="横向" />
```


### 显示滚动条 - 布局方向

> 设置布局方向


```xml
<滚动布局 显示滚动条="是" />
```


### 最小宽度 - 最小宽度

> 设置最小宽度
> 
> 单位:dp


```xml
<滚动布局 最小宽度="20" />
```


### 最小高度 - 最小高度

> 设置最小高度
> 
> 单位:dp


```xml
<滚动布局 最小高度="20" />
```


### 背景颜色 - 背景颜色

> 设置背景颜色


```xml
<滚动布局 背景颜色="#57965C" />
```


### 背景图片 - 背景图片

> 设置背景图片


```xml
<滚动布局 背景图片="资源/图片01.png" />
```


### 内边距 - 内边距

> 设置内边距
> 
> 参数顺序:左,上,右,下(单位:dp)


```xml
<滚动布局 内边距="0,0,0,0" />
```


### 重力 - 重力

> 设置重力
> 
> 滚动布局只能设置前景重力，无安卓版本要求。


```xml
<滚动布局 重力="中" />
```


## 子控件属性表

被滚动布局包裹的子控件可以使用如下属性：

| 中文名     | 英文名          | 描述                                                         |
|------------|-----------------|--------------------------------------------------------------|
| 布局方向   | dir             | 设置子视图的排列方向，可选值为“rtl”（右到左）或“ltr”（左到右） |
| 解决方向   | resolveDir      | 确定视图应遵循的实际布局方向，可选值为“rtl”（右到左）或“ltr”（左到右） |
| 宽         | w               | 设置视图的宽度，可选值为“auto”（自动，即WRAP_CONTENT）、“max”（最大，即MATCH_PARENT）或具体整数（单位为dp） |
| 高         | h               | 设置视图的高度，可选值为“auto”（自动，即WRAP_CONTENT）、“max”（最大，即MATCH_PARENT）或具体整数（单位为dp） |
| 布局重力   | layout_gravity  | 设置视图的布局重力，通过GravityAdd获取对应的重力值             |
| 外边距     | margin          | 设置视图的外边距，可传入单个整数（四边外边距相同）或四个整数（分别对应左、上、右、下外边距），单位为dp |
| 左外边距   | margin_left     | 单独设置视图的左外边距，单位为dp                             |
| 上外边距   | margin_top      | 单独设置视图的上外边距，单位为dp                             |
| 右外边距   | margin_right    | 单独设置视图的右外边距，单位为dp                             |
| 下外边距   | margin_bottom   | 单独设置视图的下外边距，单位为dp                             |


### 监听滚动(callback)

> 监听滚动

- 参数 : callback 滚动回调 


```javascript
定义 界面 = $界面.解析布局("./资源/主界面.xml");//解析界面
界面.显示();//显示界面
//找到滑动控件
定义 滑动控件 = 界面.找控件("我的滑动布局");
//监听混动事件
滑动控件.监听滚动((x,y,视图)=>{
    //处理事情
});
```


# 布局父类

- 更新时间:2025-12-02 10:12:47

> 布局父类-XLayout
> 
> 布局父类{XLayout}是属于{XView}的子控件，因此{XView}中的所有方法，布局父类都可以调用。
> 
> 所有布局控件都继承{XLayout}类，一因此可以调用{XLayout}中的方法。
> 
> 为了清晰的了解本软件的UI界面框架结构，我给你画个图:XView->XLayout->XScroll、XLinear、XCard等等
> 
> 这是什么意思呢？例如:XScroll是<scroll>标签、XLinear是<linear>标签、XCard是<card>标签等等我就不一一例举了，这些标签都是XLayout布局类的子类，也就是说这些对象都可以调用XLayout中的方法，而XLayout又是XView的子类，因此也可以调用XView中的所有方法。




### 添加视图(xView)

> 添加子视图

- 参数 : xView {XView} 控件


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//获取布局控件
定义 布局 = 界面.找控件("我的布局");
//创建一个新的文本控件
定义 文本控件 = $界面.创建("文本").设置文本("新添加的文本");
//添加到布局中
布局.添加视图(文本控件);
```


### 添加视图(view)

> 添加子视图

- 参数 : view {View} 控件


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//获取布局控件
定义 布局 = 界面.找控件("我的布局");
//创建一个新的原生文本控件
定义 原生文本 = new TextView(活动);
原生文本. setText("原生文本");
//添加到布局中
布局.添加视图(原生文本);
```


### 移除视图(xView)

> 移除子视图

- 参数 : xView {XView} 要移除的控件


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//获取布局控件
定义 布局 = 界面.找控件("我的布局");
//获取要移除的控件
定义 子控件 = 界面.找控件("子控件");
//从布局中移除
布局.移除视图(子控件);
```


### 移除视图(view)

> 移除子视图

- 参数 : view {View} 要移除的原生控件


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//获取布局控件
定义 布局 = 界面.找控件("我的布局");
//获取要移除的原生控件
定义 原生控件 = 找到视图(R.id.原生控件);
//从布局中移除
布局.移除视图(原生控件);
```


### 移除视图(index)

> 根据索引移除子视图

- 参数 : index {Integer} 子视图索引


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//获取布局控件
定义 布局 = 界面.找控件("我的布局");
//移除第一个子视图
布局.移除视图(0);
```


### 移除视图(from, to)

> 批量移除子视图

- 参数 : from {Integer} 起始索引
- 参数 : to {Integer} 结束索引


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//获取布局控件
定义 布局 = 界面.找控件("我的布局");
//移除从索引1开始的3个子视图
布局.移除视图(1, 3);
```


### 移除所有视图()

> 移除所有子视图


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//获取布局控件
定义 布局 = 界面.找控件("我的布局");
//清空所有子视图
布局.移除所有视图();
```


# 日志

- 更新时间:2025-12-02 10:12:46

> 日志-log




日志组件：显示日志信息


![](./img/1033925169795800.png)

## 一、常用属性


### 内边距 - 内边距

> 设置内边距


```xml
<日志 内边距="0,0,0,0" />
```


![](./img/1034016914246900.png)

### 背景颜色 - 背景颜色

> 设置背景颜色


```xml
<日志 背景颜色="#FF0000" />
```


### 背景图片 - 背景图片

> 设置背景图片


```xml
<日志 背景图片="/资源/图片01.png" />
```


## 二、常用函数


# 列表

- 更新时间:2025-12-02 10:12:46

> 列表-ls
> 
> 原生类型:{androidx.recyclerview.widget.RecyclerView}




列表控件，算的算是一个比较复杂的控件，但是该组件确是最常用的组件之一，
因为它可以用来展示一个列表，比如一个商品列表、一个用户列表、一个消息列表等等。


![](./img/1036371318861000.png)

### 布局 - 子项布局

> 设置子项布局


```xml
<界面>
    <状态栏 />
    <列表 高="最大" 标识="mLs" 外边距="15" 宽="最大">
        <!-- 列表布局中:用来指定每个子项目的布局 -->
        <布局 宽="最大">
            <!-- 卡片布局:需要配合线性布局来写更好看的界面 -->
            <卡片 外边距="2" 宽="最大">
                <线性布局 方向="横向" 重力="中|left" 内边距="15" 宽="最大">
                    <!-- 这里才是真正显示数据的地方 -->
                    <文字 标识="name" 最小宽度="120" />
                    <文字 标识="age" />
                    <线性布局 重力="中|右" 宽="最大" 权重="1">
                        <按钮 风格="文本" 标识="delBut" 文本="删除" 文本颜色="红色" />
                    </线性布局>
                </线性布局>
            </卡片>
        </布局>
    </列表>
</界面>
```


![](./img/1036371318861000.png)


```javascript
定义 界面 = $界面.解析布局("/ui.xml");
界面.显示();
//找到列表控件
定义 列表 = 界面.找控件("mLs");
//绑定解析视图的方法
列表.绑定持有者((子布局, 数据, 位置) => {
    子布局.找控件("name").设置文本("姓名:" + 数据.姓名);
    子布局.找控件("age").设置文本("年龄:" + 数据.年龄);
    子布局.找控件("delBut").点击事件(() => {
        $提示.显示("删除", "确定删除:" + 数据.姓名 + "吗？", () => {
            //列表删除指定下标的元素
            列表.移除(位置);
        });
    });
});
//设置数据
列表.刷新([
    {
        姓名: "张三",
        年龄: 16
    }, {
        姓名: "李四",
        年龄: 18
    }
]);
```


### 列数 - 列数

> 设置列数
> 
> 当该属性被设置的时候，布局将采用网格布局来添加子项。


```xml
<界面>
    <状态栏 />
    <列表 高="最大" 标识="mLs" 外边距="15" 列数="2" 宽="最大">
        <!-- 列表布局中:用来指定每个子项目的布局 -->
        <布局 宽="最大">
            <!-- 卡片布局:需要配合线性布局来写更好看的界面 -->
            <卡片 外边距="2" 宽="最大">
                <线性布局 方向="横向" 重力="中|left" 内边距="15" 宽="最大">
                    <!-- 这里才是真正显示数据的地方 -->
                    <文字 标识="name" 最小宽度="120" />
                    <文字 标识="age" />
                    <线性布局 重力="中|右" 宽="最大" 权重="1">
                        <按钮 风格="文本" 标识="delBut" 文本="删除" 文本颜色="红色" />
                    </线性布局>
                </线性布局>
            </卡片>
        </布局>
    </列表>
</界面>
```


![](./img/1036885281225000.png)

### 内边距 - 内边距

> 设置内边距


```xml
<界面>
    <状态栏 />
    <列表 高="最大" 标识="mLs" 内边距="50" 宽="最大">
        <!-- 列表布局中:用来指定每个子项目的布局 -->
        <布局 宽="最大">
            <!-- 卡片布局:需要配合线性布局来写更好看的界面 -->
            <卡片 外边距="2" 宽="最大">
                <线性布局 方向="横向" 重力="中|left" 内边距="15" 宽="最大">
                    <!-- 这里才是真正显示数据的地方 -->
                    <文字 标识="name" 最小宽度="120" />
                    <文字 标识="age" />
                    <线性布局 重力="中|右" 宽="最大" 权重="1">
                        <按钮 风格="文本" 标识="delBut" 文本="删除" 文本颜色="红色" />
                    </线性布局>
                </线性布局>
            </卡片>
        </布局>
    </列表>
</界面>
```


![](./img/1036952604432100.png)

### 背景颜色 - 背景颜色

> 设置背景颜色


```xml
<界面>
    <状态栏 />
    <列表 背景颜色="#1E1F22" 高="最大" 标识="mLs" 外边距="15" 宽="最大">
        <!-- 列表布局中:用来指定每个子项目的布局 -->
        <布局 宽="最大">
            <!-- 卡片布局:需要配合线性布局来写更好看的界面 -->
            <卡片 外边距="2" 宽="最大">
                <线性布局 方向="横向" 重力="中|left" 内边距="15" 宽="最大">
                    <!-- 这里才是真正显示数据的地方 -->
                    <文字 标识="name" 最小宽度="120" />
                    <文字 标识="age" />
                    <线性布局 重力="中|右" 宽="最大" 权重="1">
                        <按钮 风格="文本" 标识="delBut" 文本="删除" 文本颜色="红色" />
                    </线性布局>
                </线性布局>
            </卡片>
        </布局>
    </列表>
</界面>
```


![](./img/1037040261908500.png)

### 背景图片 - 背景图片

> 设置背景图片


```xml
<界面>
    <状态栏 />
    <列表 外边距="30" 宽="最大" 标识="mLs" 背景图片="/res/bg-ls.png" 高="最大">
        <!-- 列表布局中:用来指定每个子项目的布局 -->
        <布局 宽="最大">
            <!-- 卡片布局:需要配合线性布局来写更好看的界面 -->
            <卡片 外边距="2" 宽="最大">
                <线性布局 内边距="15" 宽="最大" 方向="横向" 重力="中|left">
                    <!-- 这里才是真正显示数据的地方 -->
                    <文字 最小宽度="120" 标识="name" />
                    <文字 标识="age" />
                    <线性布局 宽="最大" 权重="1" 重力="中|右">
                        <按钮 文本="删除" 文本颜色="红色" 标识="delBut" 风格="文本" />
                    </线性布局>
                </线性布局>
            </卡片>
        </布局>
    </列表>
</界面>
```


![](./img/1037283848936000.png)

### 滚动到顶部()

> 滚动到顶部


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./主界面.xml");
//获取控件
定义 列表 = 界面.找控件("我的列表");
//滚动到顶部
列表.滚动到顶部();
```


### 滚动到底部()

> 滚动到底部


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./主界面.xml");
//获取控件
定义 列表 = 界面.找控件("我的列表");
//滚动到底部
列表.滚动到底部();
```


### 滚动(位置)

> 滚动到指定位置

- 参数 : 位置 {int} 滚动位置


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./主界面.xml");
//获取控件
定义 列表 = 界面.找控件("我的列表");
//滚动到指定位置
列表.滚动(10);
```


### 绑定持有者(持有者)

> 数据绑定
> 
> 在列表标签中，我没需要设置布局标签设计每个列表子项的布局，而该函数就是用来解析每个子项的布局的。

- 参数 : 持有者 {(子项持有者, 子项数据, 位置)=>{}} 数据绑定回调


```javascript
定义 界面 = $界面.解析布局("主界面.xml");
定义 列表 = 界面.找控件("我的列表");//获取列表组件
//开始解析每个数据对应的布局
列表.绑定持有者((子项界面,子项数据,位置)=>{
    //子项界面相当于解析布局节点后返回的界面对象，可以通过这个对象拿到子组件，例如:
    定义 文本 = 子项界面.找控件("我的文本");
    //接下来绑定数据，如果数组每个元素是字符串，则可以直接设置数据
    文本.设置文字(子项数据);
});
//注意:'绑定持有者()'函数也可以写成'解析数据()'函数
```


### 刷新(数据)

> 设置并且刷新数据

- 参数 : 数据 {obj[]} 数据集合


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./主界面.xml");
//获取控件
定义 列表 = 界面.找控件("我的列表");
//设置并且刷新数据
列表.刷新(["数据1","数据2","数据3"]);
```


### 刷新(数据, 位置)

> 刷新指定位置数据

- 参数 : 数据 {obj} 数据内容
- 参数 : 位置 {int} 数据位置


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./主界面.xml");
//获取控件
定义 列表 = 界面.找控件("我的列表");
//刷新指定位置数据
列表.刷新("新数据", 0);
```


### 移除(位置)

> 移除指定位置数据

- 参数 : 位置 {int} 数据位置


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./主界面.xml");
//获取控件
定义 列表 = 界面.找控件("我的列表");
//移除指定位置数据
列表.移除(0);
```


### 添加(数据)

> 添加一个数据

- 参数 : 数据 {obj} 数据内容


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./主界面.xml");
//获取控件
定义 列表 = 界面.找控件("我的列表");
//添加一个数据
列表.添加("新数据");
```


### 添加(数据, 位置)

> 添加一个数据到指定位置

- 参数 : 数据 {obj} 数据内容
- 参数 : 位置 {int} 插入位置


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./主界面.xml");
//获取控件
定义 列表 = 界面.找控件("我的列表");
//添加一个数据到指定位置
列表.添加("新数据", 0);
```


### 清空()

> 清空列表


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./主界面.xml");
//获取控件
定义 列表 = 界面.找控件("我的列表");
//清空列表
列表.清空();
```


### 获取数据()

> 获取数据

- 返回 : {obj[]} 数据列表
- 版本 : 1.7.3


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./主界面.xml");
//获取控件
定义 列表 = 界面.找控件("我的列表");
//获取数据
定义 数据 = 列表.获取数据();
//打印出来
日志(数据);
```


# 导航栏

- 更新时间:2025-12-02 10:12:46

> 导航栏-nav
> 
> 原生类型:{com.google.android.material.bottomnavigation.BottomNavigationView}




导航栏：一般用于与多页布局(pager)联动，实现界面的跳转


![](./img/nav_demo.png)


```xml
<ui>
    <statusbar />
    <!-- 我习惯性把导航栏放在底部因此设置重力 gravity="bottom" -->
    <linear w="max" h="max" dir="v" gravity="bottom">
        <nav w="max">
            <menu text="主页" icon="ic_home" />
            <menu text="设置" icon="ic_set" />
            <menu text="菜单" icon="ic_menu" />
        </nav>
    </linear>
</ui>
```


## 一、基础用法


```xml
<ui>
    <statusbar />
    <!-- 我习惯性把导航栏放在底部因此设置重力 gravity="bottom" -->
    <linear w="max" h="max" dir="v" gravity="bottom">
        <!-- 给导航栏设置id id="mNav" -->
        <nav id="mNav" w="max">
            <menu text="菜单1" icon="ic_home" />
            <menu text="菜单2" icon="ic_search" />
            <menu text="菜单3" icon="ic_set" />
        </nav>
    </linear>
</ui>
```

```javascript
//解析布局
let ui = $ui.layout("ui.xml");
ui.show();//显示界面
//获取控件
let nav = ui.id("mNav");
//监听菜单事件
nav.menu((title)=>{
    toast(title);
});
```


## 二、常用属性


### 菜单 - 菜单

> 设置菜单


```xml
    <!--显示方式:
    有空间:如果有空间,则显示
    总是:总是显示
    从不:从不显示
    带文本:与文本一起显示
    -->
<导航栏 宽="最大">
    <菜单 文本="菜单1" 图标="ag_logo" 图标颜色="#FF0000" 显示方式="有空间" />
    <菜单 文本="菜单2" 显示方式="有空间" />
    <菜单 文本="菜单3" 显示方式="总是" />
    <菜单 文本="菜单3" 显示方式="从不" />
    <菜单 文本="菜单3" 显示方式="带文本" />
</导航栏>
```


![](./img/nav_menu.png)

### 图标颜色 - 图标颜色

> 设置图标颜色


```xml
<导航栏 图标颜色="#FF0000" />
```


![](./img/nav_iconTint.png)

### 文本颜色 - 文本颜色

> 设置文本颜色


```xml
<导航栏 文本颜色="#FF0000" />
```


![](./img/nav_textColor.png)

### 选中颜色 - 选中后图标颜色

> 设置选中后图标颜色


```xml
<导航栏 选中颜色="#FF0000" />
```


![](./img/nav_checkColor.png)

### 背景颜色 - 背景颜色

> 设置背景颜色


```xml
<导航栏 背景颜色="#1E1F22" 文本="背景颜色" />
```


![](./img/nav_bg.png)

### 背景图片 - 背景图片

> 设置背景图片


```xml
<导航栏 背景图片="./资源/图片01.png" 文本="背景图片" />
```


![](./img/nav_bgImg.png)

## 三、常用函数


### 设置背景颜色(颜色)

> 设置背景颜色

- 参数 : 颜色 {数字} 文本颜色值
- 版本 : 1.8.2


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//获取控件
定义 导航栏 = 界面.找控件("我的导航栏");
//设置背景颜色
导航栏.设置背景颜色($颜色.红色);
```


### 设置背景颜色(颜色)

> 设置背景颜色

- 参数 : 颜色 {字符串} 颜色字符串
- 版本 : 1.8.2


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//获取控件
定义 导航栏 = 界面.找控件("我的导航栏");
//设置背景颜色
导航栏.设置背景颜色("#1E1F22");
```


### 设置图标颜色(颜色)

> 设置图标颜色

- 参数 : 颜色 {数字} 文本颜色值
- 版本 : 1.8.2


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//获取控件
定义 导航栏 = 界面.找控件("我的导航栏");
//设置图标颜色
导航栏.设置图标颜色($颜色.红色);
```


### 设置图标颜色(颜色)

> 设置图标颜色

- 参数 : 颜色 {字符串} 颜色字符串
- 版本 : 1.8.2


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//获取控件
定义 导航栏 = 界面.找控件("我的导航栏");
//设置图标颜色
导航栏.设置图标颜色("#1E1F22");
```


### 设置文本颜色(颜色)

> 设置文本颜色

- 参数 : 颜色 {数字} 文本颜色值
- 版本 : 1.8.2


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//获取控件
定义 导航栏 = 界面.找控件("我的导航栏");
//设置文本颜色
导航栏.设置文本颜色($颜色.红色);
```


### 设置文本颜色(颜色)

> 设置文本颜色

- 参数 : 颜色 {字符串} 颜色字符串
- 版本 : 1.8.2


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//获取控件
定义 导航栏 = 界面.找控件("我的导航栏");
//设置文本颜色
导航栏.设置文本颜色("#1E1F22");
```


### 设置选中颜色(颜色)

> 设置选中颜色

- 参数 : 颜色 {数字} 文本颜色值
- 版本 : 1.8.2


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//获取控件
定义 导航栏 = 界面.找控件("我的导航栏");
//设置选中颜色
导航栏.设置选中颜色($颜色.红色);
```


### 设置选中颜色(颜色)

> 设置选中颜色

- 参数 : 颜色 {字符串} 颜色字符串
- 版本 : 1.8.2


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//获取控件
定义 导航栏 = 界面.找控件("我的导航栏");
//设置选中颜色
导航栏.设置选中颜色("#1E1F22");
```


### 选中(索引)

> 选中指定菜单

- 参数 : 索引 {int} 菜单索引


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./主界面.xml");
//获取控件
定义 导航栏 = 界面.找控件("我的导航栏");
//选中指定菜单
导航栏.选中(0);
```


### 菜单(回调)

> 监听菜单事件

- 参数 : 回调 {(标题)=>{}} 菜单点击事件回调


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./主界面.xml");
//获取控件
定义 导航栏 = 界面.找控件("我的导航栏");
//监听菜单事件
导航栏.菜单((标题)=>{
    土司(标题);
});
```


# color-颜色属性对照表

- 更新时间:2025-12-02 10:12:44




### 1. 属性颜色

| 属性值                               | 颜色                                                           |
|-----------------------------------|--------------------------------------------------------------|
| colorPrimary、主题                   | com.google.android.material.R.attr.colorPrimary              |
| colorSurface、背景                   | com.google.android.material.R.attr.colorSurface              |
| colorOnSurface、文本                 | com.google.android.material.R.attr.colorOnSurface            |
| colorOnPrimary、主题主反色              | com.google.android.material.R.attr.colorOnPrimary            |
| colorPrimaryContainer、主题主容器颜色     | com.google.android.material.R.attr.colorPrimaryContainer     |
| colorOnPrimaryContainer、主题主容器反色   | com.google.android.material.R.attr.colorOnPrimaryContainer   |
| colorSecondary、主题次颜色              | com.google.android.material.R.attr.colorSecondary            |
| colorOnSecondary、主题次反色            | com.google.android.material.R.attr.colorOnSecondary          |
| colorSecondaryContainer、主题次容器颜色   | com.google.android.material.R.attr.colorSecondaryContainer   |
| colorOnSecondaryContainer、主题次容器反色 | com.google.android.material.R.attr.colorOnSecondaryContainer |
| colorTertiary                     | com.google.android.material.R.attr.colorTertiary             |
| colorOnTertiary                   | com.google.android.material.R.attr.colorOnTertiary           |
| colorTertiaryContainer            | com.google.android.material.R.attr.colorTertiaryContainer    |
| colorOnTertiaryContainer          | com.google.android.material.R.attr.colorOnTertiaryContainer  |
| colorError、主题错误颜色                 | com.google.android.material.R.attr.colorError                |
| colorOnError、主题错误反色               | com.google.android.material.R.attr.colorOnError              |
| colorErrorContainer、主题错误容器颜色      | com.google.android.material.R.attr.colorErrorContainer       |
| colorOnErrorContainer、主题错误容器反色    | com.google.android.material.R.attr.colorOnErrorContainer     |
| colorOnBackground、主题背景反色          | com.google.android.material.R.attr.colorOnBackground         |
| colorSurfaceVariant、主题中性容器颜色      | com.google.android.material.R.attr.colorSurfaceVariant       |
| colorOnSurfaceVariant、主题中性容器反色    | com.google.android.material.R.attr.colorOnSurfaceVariant     |
| colorOutline、主题中性轮廓颜色             | com.google.android.material.R.attr.colorOutline              |
| colorOutlineVariant、主题中性轮廓反色      | com.google.android.material.R.attr.colorOutlineVariant       |
| colorPrimaryInverse、主题主状态反色       | com.google.android.material.R.attr.colorPrimaryInverse       |

### 2. 名称颜色

| 属性值              | 颜色        |
|------------------|-----------|
| white、白色         | #FFFFFF   |
| black、黑色         | #000000   |
| null、透明、none、空、无 | #00000000 |
| green、绿色         | #57965C   |
| red、红色           | #C94F4F   |
| blue、蓝色          | #3574F0   |
| yellow、黄色        | #C29E4A   |

:::tip 注意
由于脚本支持中文和英文编程，所以颜色属性值可以采用中文，也可以采用英文。

例如：color="red"

等同：颜色="红色"
:::


# gravity-重力属性对照表

- 更新时间:2025-12-02 10:12:44



#### 使用方法


```xml
<ui>
    <statusbar/>
    <!-- 这里的 gravity 重力值，可以决定子组件(按钮)在布局中的位置 center 表示让按钮居中 -->
    <linear w="max" h="max" gravity="center">
        <button text="按钮"/>
    </linear>
</ui>
```


#### Gravity属性值对照表

| 属性值                                        | 对应的Gravity值                     |
|--------------------------------------------|---------------------------------|
| fill、填充                                    | Gravity.FILL                    |
| fill_h、fill_horizontal、水平填充、横向填充           | Gravity.FILL_HORIZONTAL         |
| fill_v、fill_vertical、垂直填充、竖向填充             | Gravity.FILL_VERTICAL           |
| start、开头、开始、头部                             | Gravity.START                   |
| end、末尾、结束、尾部                               | Gravity.END                     |
| left、左、左边                                  | Gravity.LEFT                    |
| right、右、右边                                 | Gravity.RIGHT                   |
| top、上、上边                                   | Gravity.TOP                     |
| bottom、下、下边、下面                             | Gravity.BOTTOM                  |
| center、中、中心、中间、居中                          | Gravity.CENTER                  |
| center_h、center_horizontal、水平居中、横向居中       | Gravity.CENTER_HORIZONTAL       |
| center_v、center_vertical、垂直居中、竖向居中         | Gravity.CENTER_VERTICAL         |
| display_h、display_horizontal、水平显示裁剪、横向显示裁剪 | Gravity.DISPLAY_CLIP_HORIZONTAL |
| display_v、display_vertical、垂直显示裁剪、竖向显示裁剪   | Gravity.DISPLAY_CLIP_VERTICAL   |
| clip_h、clip_horizontal、水平裁剪、横向裁剪           | Gravity.CLIP_HORIZONTAL         |
| clip_v、clip_vertical、垂直裁剪、竖向裁剪             | Gravity.CLIP_VERTICAL           |

:::tip 注意
由于脚本支持中文和英文编程，所以重力属性值可以采用中文，也可以采用英文。

例如：gravity="center"

等同：重力="中"
:::


# 补充文档

- 更新时间:2025-12-02 10:12:44



## [1.gravity-重力 属性对照表](./other/gravity)

## [2.color-颜色 属性对照表](./other/color)


# 多页布局

- 更新时间:2025-12-02 10:12:47

> 多页布局-pager
> 
> 多页布局允许用户在里面写多个界面并实现界面左右滑动，并且支持绑定标签页布局(tab)以及导航栏(nav)
> 
> 原生类型:{androidx.viewpager2.widget.ViewPager2}




## 一、常用属性


### 布局 - 多页布局

> 设置多页布局
> 
> 其中每个'界面'最后都会被解析成一个布局，本质上就是个'线性布局'。


```xml
<多页布局 宽="最大" 高="最大">
    <布局 />
    <布局 />
    <布局 />
</多页布局>
```


### 默认下标 - 默认下标页面

> 设置默认下标页面


```xml
<多页布局 默认下标="0" />
```


### 内边距 - 内边距

> 设置内边距


```xml
<!--内边距顺序是:左,上,右,下-->
<!--只设置一个值：则设置所有方向的内边距-->
<!--只设置两个值：则设置左右和上下方向的内边距-->
<多页布局 内边距="0,0,0,0" />
```


### 重力 - 重力

> 设置重力


```xml
<多页布局 重力="开始" />
```


### 背景颜色 - 背景颜色

> 设置背景颜色


```xml
<多页布局 背景颜色="#1E1F22" />
```


### 背景图片 - 背景图片

> 设置背景图片


```xml
<多页布局 背景图片="./资源/图片01.png" />
```


## 二、常用函数


### 设置下标(index)

> 设置当前页面索引

- 参数 : index {int} 当前页面索引


```javascript
//解析界面,获得ui布局
定义 我的界面 = $界面.解析布局("./界面/主界面.xml");
//获得控件(传入"标识")
定义 多页布局 = 我的界面.找控件("我的多页布局");
//设置当前页面索引为0
多页布局.设置下标(0);
```


### 获取下标()

> 获得当前页面索引

- 返回 : {int} 当前页面索引


```javascript
//解析界面,获得界面布局
定义 我的界面 = $界面.解析布局("./界面/主界面.xml");
//获得控件
定义 多页布局 = 我的界面.找控件("我的多页布局");
//获得当前页面索引
定义 下标 = 多页布局.获取下标();
```


### 绑定(xTab)

> 绑定与标签页联动

- 参数 : xTab {tab} 标签页布局


```javascript
//解析界面,获得界面布局
定义 我的界面 = $界面.解析布局("./界面/主界面.xml");
//获得控件
定义 多页布局 = 我的界面.找控件("我的多页布局");
定义 标签页 = 我的界面.找控件("我的标签页");
//与标签页布局联动
多页布局.绑定(标签页);
```


### 绑定(xNav)

> 绑定与导航栏联动

- 参数 : xNav {nav} 底部导航布局


```javascript
//解析界面,获得界面布局
定义 我的界面 = $界面.解析布局("./界面/主界面.xml");
//获得控件
定义 多页布局 = 我的界面.找控件("我的多页布局");
定义 导航栏 = 我的界面.找控件("我的导航栏");
//与导航栏联动
多页布局.绑定(导航栏);
```


### 监听界面切换(回调)

> 监听界面切换事件

- 参数 : 回调 {(下标)=>{}} 界面切换事件回调


```javascript
//解析界面,获得界面布局
定义 我的界面 = $界面.解析布局("./界面/主界面.xml");
//获得控件
定义 多页布局 = 我的界面.找控件("我的多页布局");
//监听界面切换事件
多页布局.监听界面切换((下标)=>{
    //..
});
```


### 监听状态改变(回调)

> 监听状态改变事件

- 参数 : 回调 {(状态)=>{}} 状态改变事件回调


```javascript
//解析界面,获得界面布局
定义 我的界面 = $界面.解析布局("./界面/主界面.xml");
//获得控件
定义 多页布局 = 我的界面.找控件("我的多页布局");
//监听状态改变事件
多页布局.监听状态改变((状态)=>{
    //...
});
```


# 进度条

- 更新时间:2025-12-02 10:12:47

> 进度条-progress
> 
> 圆形原生类型:{com.google.android.material.progressindicator.CircularProgressIndicator}
> 线性原生类型:{com.google.android.material.progressindicator.LinearProgressIndicator}




进度条：比如下载进度，游戏进度，进度条就是用来显示进度的控件


![](./img/progress_demo.gif)


```xml
<ui>
    <statusbar />
    <linear w="max" padding="10">
        <linear w="max" dir="h">
            <progress w="max" padding="10" run="true" />
            <progress w="max" color="#518855" padding="10" run="true" />
            <progress w="max" color="#B44A4A" padding="10" run="true" />
        </linear>
        <progress w="max" style="line" run="true" padding="10" />
        <progress w="max" style="line" color="#518855" padding="10" run="true" />
        <progress w="max" style="line" color="#B44A4A" padding="10" run="true" />
    </linear>
</ui>
```


## 一、基础用法


```xml
<ui>
    <statusbar />
    <linear w="max" padding="10">
        <!-- 指定进度条的id -->
        <progress id="circularProgress" w="max"/>
        <progress id="lineProgress" w="max" style="line"/>
    </linear>
</ui>
```

```javascript
//解析布局
let ui = $ui.layout("ui.xml");
ui.show();//显示界面
//获取圆形/线性进度条
let cp = ui.id("circularProgress");
let lp = ui.id("lineProgress");
//动态模拟进度条的走动
for (let i = 1; i <= 10; i++) {
    sleep(150);
    //[核心]:设置进度
    cp.setProgress(i * 10);
    lp.setProgress(i * 10);
}
```


## 二、常用属性


### 可见 - 可见性

> 设置可见性


```xml
<进度条 可见="否" />
```


### 风格 - 样式

> 设置样式


```xml
<进度条 风格="直线" />
```


![](./img/progress_style.png)

### 厚度 - 厚度

> 设置厚度


```xml
<进度条 厚度="10" />
```


![](./img/progress_thickness.png)

### 动画 - 动画

> 设置动画


```xml
<进度条 动画="是" />
```


### 颜色 - 颜色

> 设置颜色


```xml
<进度条 颜色="#FF0000" />
```


![](./img/progress_color.png)

### 最小宽度 - 最小宽度

> 设置最小宽度


```xml
<进度条 最小宽度="100" />
```


### 最小高度 - 最小高度

> 设置最小高度


```xml
<进度条 最小高度="100" />
```


### 内边距 - 内边距

> 设置内边距


```xml
<进度条 内边距="0,0,0,0" />
```


![](./img/progress_padding.png)

### 背景颜色 - 背景颜色

> 设置背景颜色


```xml
<进度条 背景颜色="#1E1F22" />
```


![](./img/progress_bg.png)

### 背景图片 - 背景图片

> 设置背景图片


```xml
<进度条 背景图片="./资源/图片01.png" />
```


![](./img/progress_bgImg.png)

## 三、常用函数


### 设置进度(进度值)

> 设置进度
> 
> 此方法需要安卓7.0以上生效

- 参数 : 进度值 {int} 进度值(0-100)


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./主界面.xml");
//获取控件
定义 进度条 = 界面.找控件("我的进度条");
//设置进度
进度条.设置进度(50);
```


### 设置最大值(最大值)

> 设置最大进度

- 参数 : 最大值 {int} 最大进度值


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./主界面.xml");
//获取控件
定义 进度条 = 界面.找控件("我的进度条");
//设置最大进度
进度条.设置最大值(100);
```


### 获取进度()

> 获取进度

- 返回 : {int} 当前进度值


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./主界面.xml");
//获取控件
定义 进度条 = 界面.找控件("我的进度条");
//获得进度
定义 进度 = 进度条.获取进度();
```


### 显示()

> 显示进度条


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./主界面.xml");
//获取控件
定义 进度条 = 界面.找控件("我的进度条");
//显示进度条
进度条.显示();
```


### 隐藏()

> 隐藏进度条


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./主界面.xml");
//获取控件
定义 进度条 = 界面.找控件("我的进度条");
//隐藏进度条
进度条.隐藏();
```


# 单选按钮组

- 更新时间:2025-12-02 10:12:47

> 单选按钮组-radio-group
> 
> 在此布局中，单选按钮会自动取消和选中，保证一组按钮只被选中一个
> 
> 是布局父类的(XLayout)的子类
> 
> 原生类型:{android.widget.RadioGroup}




## 一、常用属性


### 方向 - 排列方向

> 设置排列方向
> 
> 可选参数:v(纵向),h(横向)


```xml
<单选按钮组 方向="横向">
    <单选按钮 文本="选项1"/>
    <单选按钮 文本="选项2"/>
</单选按钮组>
```


### 主题颜色 - 主题颜色

> 设置主题颜色


```xml
<单选按钮组 主题颜色="#57965C" 文本="主题色为绿色" />
```


### 内边距 - 内边距

> 设置内边距
> 
> 参数顺序:左,上,右,下(单位:dp)


```xml
<单选按钮组 内边距="20,20,20,20" 文本="内边距" />
```


### 重力 - 重力

> 设置重力
> 
> 可选值参考重力参数表


```xml
<单选按钮组 重力="中|上" />
```


### 背景颜色 - 背景颜色

> 设置背景颜色


```xml
<单选按钮组 背景颜色="#1E1F22" 文本="背景颜色" />
```


### 背景图片 - 背景图片

> 设置背景图片


```xml
<单选按钮组 背景图片="./资源/图片.png" 文本="背景图片" />
```


### 选中(下标)

> 设置选中的下标

- 参数 : 下标 {int} 按钮下标


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//获得控件
定义 单选组 = 界面.找控件("我的单选组");
//设置选中的下标
单选组.选中(0);
```


### 监听选中(回调函数)

> 监听选中按钮的下标

- 参数 : 回调函数 ((下标)=>{}) 回调函数


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//获得控件
定义 单选组 = 界面.找控件("我的单选组");
//监听选中按钮的下标
单选组.监听选中((下标)=>{
    $界面.土司("当前下标:"+下标);
});
```


### 获取选中下标()

> 获取选中的下标

- 返回 : {int} 下标 (-1表示没有选择)


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//获得控件
定义 单选组 = 界面.找控件("我的单选组");
//获得选中的下标
定义 下标 = 单选组.获取选中下标();
```


### 获取选中文本()

> 获取选中的文本

- 返回 : {string} 文本 (null表示没有选择)


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//获得控件
定义 单选组 = 界面.找控件("我的单选组");
//获得选中的文本
定义 文本 = 单选组.获取选中文本();
```


# 单选按钮

- 更新时间:2025-12-02 10:12:47

> 单选按钮-radio
> 
> 原生类型:{com.google.android.material.radiobutton.MaterialRadioButton}




单选按钮：一般需要配合单选按钮组(radio-group)的配合才能实现互相排斥的效果，这个控件常用在只需要在多个选择中选择一个的情况。


![](./img/radio_color.png)

## 一、常用属性


### 主题颜色 - 主题颜色

> 设置主题颜色


```xml
<单选按钮 主题颜色="#57965C" 文本="主题色为绿色" />
```


![](./img/radio_color.png)

### 选中 - 选中状态

> 设置选中状态


```xml
<单选按钮 选中="是" 文本="主题色为绿色" />
```


![](./img/radio_check.png)

### 文本 - 文本

> 设置文本


```xml
<单选按钮 文本="默认文本" />
```


![](./img/radio_text.png)

### 文本颜色 - 文本颜色

> 设置文本颜色


```xml
<单选按钮 主题颜色="#57965C" 文本="文本为白色" 文本颜色="#FFFFFF" />
```


![](./img/radio_textColor.png)

### 最小宽度 - 最小宽度

> 设置最小宽度


```xml
<单选按钮 最小宽度="100" />
```


### 最小高度 - 最小高度

> 设置最小高度


```xml
<单选按钮 最小高度="100" />
```


### 内边距 - 内边距

> 设置内边距


```xml
<!--内边距顺序是:左,上,右,下-->
<!--内边距只设置一个值：则设置所有方向的内边距-->
<!--内边距只设置两个值：则设置左右和上下方向的内边距-->
<单选按钮 内边距="20" 文本="内边距" />
```


![](./img/radio_padding.png)

### 重力 - 重力

> 设置重力


```xml
<单选按钮 重力="开始" 高="100" 外边距="20" 文本="重力:开始" 宽="最大" />
```


![](./img/radio_gravity.png)

### 背景颜色 - 背景颜色

> 设置背景颜色


```xml
<单选按钮 背景颜色="#1E1F22" 文本="背景颜色" />
```


![](./img/radio_bg.png)

### 背景图片 - 背景图片

> 设置背景图片


```xml
<单选按钮 背景图片="./资源/图片01.png" 文本="背景图片" />
```


![](./img/radio_bgImg.png)

## 二、常用函数


### 是选中的()

> 判断选中状态

- 返回 : {布尔值} 是否选中
- 版本 : 1.8.2


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//获取控件
定义 单选按钮 = 界面.找控件("我的单选按钮");
//判断选中状态
如果(单选按钮.是选中的()){
    日志("选中了");
}
```


### 设置选中(状态)

> 设置选中状态

- 参数 : 状态 {boolean} 是否选中


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./主界面.xml");
//获取控件
定义 单选按钮 = 界面.找控件("我的单选按钮");
//设置选中状态
单选按钮.设置选中(是);
```


### 监听选中(回调)

> 监听选中事件

- 参数 : 回调 {(是否选中)=>{}} 选中事件回调


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./主界面.xml");
//获取控件
定义 单选按钮 = 界面.找控件("我的单选按钮");
//监听选中事件
单选按钮.监听选中((是否选中)=>{
    //..
});
```


### 设置重力(重力)

> 设置重力

- 参数 : 重力 {String} 重力值，例如:"中|下"


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./主界面.xml");
//获取控件
定义 单选按钮 = 界面.找控件("我的单选按钮");
//设置重力
单选按钮.设置重力("中|下");
```


### 设置文字(文本)

> 设置文字

- 参数 : 文本 {String} 文字内容


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./主界面.xml");
//获取控件
定义 单选按钮 = 界面.找控件("我的单选按钮");
//设置文字
单选按钮.设置文字("吃饭");
```


### 获取文字()

> 获取文字

- 返回 : {String} 文字内容


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./主界面.xml");
//获取控件
定义 单选按钮 = 界面.找控件("我的单选按钮");
//获得文字
定义 文本 = 单选按钮.获取文字();
```


### 设置主题颜色(颜色)

> 设置主题颜色

- 参数 : 颜色 {String} 颜色值


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./主界面.xml");
//获取控件
定义 单选按钮 = 界面.找控件("我的单选按钮");
//设置主题颜色
单选按钮.设置主题颜色("#26282E");
```


### 设置文本颜色(颜色)

> 设置文本颜色

- 参数 : 颜色 {String} 颜色值


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./主界面.xml");
//获取控件
定义 单选按钮 = 界面.找控件("我的单选按钮");
//设置文本颜色
单选按钮.设置文本颜色("#26282E");
```


# 轨道

- 更新时间:2025-12-02 10:12:47

> 轨道-rail
> 
> 这个控件和nav导航栏控件很像，只不过是竖向排列的
> 
> 原生类型:{com.google.android.material.navigationrail.NavigationRailView}




## 一、常用属性


### 图标颜色 - 图标颜色

> 设置图标颜色


```xml
<轨道 图标颜色="#FF0000" />
```


### 文本颜色 - 文本颜色

> 设置文本颜色


```xml
<轨道 文本颜色="#FF0000" />
```


### 选中颜色 - 选中后图标颜色

> 设置选中后图标颜色


```xml
<轨道 选中颜色="#FF0000" />
```


### 内边距 - 内边距

> 设置内边距
> 
> 参数顺序:左,上,右,下(单位:dp)


```xml
<轨道 内边距="20,20,20,20" 文本="内边距" />
```


### 重力 - 重力

> 设置重力
> 
> 可选值参考重力参数表


```xml
<轨道 重力="中|上" />
```


### 背景颜色 - 背景颜色

> 设置背景颜色


```xml
<轨道 背景颜色="#1E1F22" 文本="背景颜色" />
```


### 背景图片 - 背景图片

> 设置背景图片


```xml
<轨道 背景图片="./资源/图片.png" 文本="背景图片" />
```


## 二、常用函数


### 设置背景颜色(颜色)

> 设置背景颜色

- 参数 : 颜色 {数字} 文本颜色值
- 版本 : 1.8.2


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//获取控件
定义 轨道栏 = 界面.找控件("我的轨道栏");
//设置背景颜色
轨道栏.设置背景颜色($颜色.红色);
```


### 设置背景颜色(颜色)

> 设置背景颜色

- 参数 : 颜色 {字符串} 颜色字符串
- 版本 : 1.8.2


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//获取控件
定义 轨道栏 = 界面.找控件("我的轨道栏");
//设置背景颜色
轨道栏.设置背景颜色("#1E1F22");
```


### 设置图标颜色(颜色)

> 设置图标颜色

- 参数 : 颜色 {数字} 文本颜色值
- 版本 : 1.8.2


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//获取控件
定义 轨道栏 = 界面.找控件("我的轨道栏");
//设置图标颜色
轨道栏.设置图标颜色($颜色.红色);
```


### 设置图标颜色(颜色)

> 设置图标颜色

- 参数 : 颜色 {字符串} 颜色字符串
- 版本 : 1.8.2


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//获取控件
定义 轨道栏 = 界面.找控件("我的轨道栏");
//设置图标颜色
轨道栏.设置图标颜色("#1E1F22");
```


### 设置文本颜色(颜色)

> 设置文本颜色

- 参数 : 颜色 {数字} 文本颜色值
- 版本 : 1.8.2


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//获取控件
定义 轨道栏 = 界面.找控件("我的轨道栏");
//设置文本颜色
轨道栏.设置文本颜色($颜色.红色);
```


### 设置文本颜色(颜色)

> 设置文本颜色

- 参数 : 颜色 {字符串} 颜色字符串
- 版本 : 1.8.2


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//获取控件
定义 轨道栏 = 界面.找控件("我的轨道栏");
//设置文本颜色
轨道栏.设置文本颜色("#1E1F22");
```


### 设置选中颜色(颜色)

> 设置选中颜色

- 参数 : 颜色 {数字} 文本颜色值
- 版本 : 1.8.2


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//获取控件
定义 轨道栏 = 界面.找控件("我的轨道栏");
//设置选中颜色
轨道栏.设置选中颜色($颜色.红色);
```


### 设置选中颜色(颜色)

> 设置选中颜色

- 参数 : 颜色 {字符串} 颜色字符串
- 版本 : 1.8.2


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//获取控件
定义 轨道栏 = 界面.找控件("我的轨道栏");
//设置选中颜色
轨道栏.设置选中颜色("#1E1F22");
```


### 选中(索引)

> 选中指定菜单

- 参数 : 索引 {int} 菜单索引


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./主界面.xml");
//获取控件
定义 轨道栏 = 界面.找控件("我的轨道栏");
//选中指定菜单
轨道栏.选中(0);
```


### 菜单(回调)

> 监听菜单事件

- 参数 : 回调 {(标题)=>{}} 菜单点击事件


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./主界面.xml");
//获取控件
定义 轨道栏 = 界面.找控件("我的轨道栏");
//监听菜单事件
轨道栏.菜单((标题)=>{
    土司(标题);
});
```


# 范围

- 更新时间:2025-12-02 10:12:47

> 范围-range
> 
> 原生类型:{com.google.android.material.slider.RangeSlider}




## 一、常用属性


### 开始值 - 开始值

> 设置开始值


```xml
<范围 开始值="0" />
```


### 结束值 - 结束值

> 设置结束值


```xml
<范围 结束值="100" />
```


### 左初始值 - 左初始值

> 设置左初始值


```xml
<范围 左初始值="10" />
```


### 右初始值 - 右初始值

> 设置右初始值


```xml
<范围 右初始值="60" />
```


### 进步值 - 进步值

> 设置进步值


```xml
<范围 进步值="1" />
```


### 主题颜色 - 主题颜色

> 设置主题颜色


```xml
<范围 主题颜色="#FF0000" />
```


### 标签 - 标签文字

> 设置标签文字


```xml
<范围 标签="进度:" />
```


### 标签尾部 - 标签文字尾部

> 设置标签文字尾部


```xml
<范围 标签尾部="个" />
```


### 内边距 - 内边距

> 设置内边距
> 
> 参数顺序:左,上,右,下(单位:dp)


```xml
<范围 内边距="20,20,20,20" />
```


### 重力 - 重力

> 设置重力
> 
> 可选值参考重力参数表


```xml
<范围 重力="中|上" />
```


### 背景颜色 - 背景颜色

> 设置背景颜色


```xml
<范围 背景颜色="#1E1F22" />
```


### 背景图片 - 背景图片

> 设置背景图片


```xml
<范围 背景图片="./资源/图片.png" />
```


## 二、常用函数


### 标签格式化(回调)

> 设置标签格式化

- 参数 : 回调 {(浮点值)=>{ return "标签"; }} 格式化回调


### 监听变化(回调)

> 监听数据变化

- 参数 : 回调 {(开始,结束)=>{}} 回调函数


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//获取控件
定义 范围 = 界面.找控件("我的范围");
//监听数据变化
范围.监听变化((开始,结束)=>{
    //..
});
```


### 获取范围()

> 获取范围

- 返回 : {number[]}


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//获取控件
定义 范围 = 界面.找控件("我的范围");
//获得范围数据
定义 范围数据 = 范围.获取范围();
```


### 设置数据(开始, 结束)

> 设置数据

- 参数 : 开始 {float} 开始值
- 参数 : 结束 {float} 结束值


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//获取控件
定义 范围 = 界面.找控件("我的范围");
//设置数据(开始,结束)
范围.设置数据(0,100);
```


# 拖动条

- 更新时间:2025-12-02 10:12:47

> 拖动条-seek
> 
> 该组件比slider更加小巧，属于安卓原生组件。
> 
> 原生类型:{android.widget.SeekBar}




## 一、常用属性


### from - 开始值

> 设置开始值


```xml
<seek from="0" />
```


### to - 结束值

> 设置结束值


```xml
<tab to="100" />
```


### value - 当前值

> 设置当前值


```xml
<tab value="30" />
```


### padding - 内边距

> 设置内边距


```xml
<!--padding顺序是:左,上,右,下-->
<!--padding只设置一个值：则设置所有方向的内边距-->
<!--padding只设置两个值：则设置左右和上下方向的内边距-->
<tab seek="20" />
```


### bg - 背景颜色

> 设置背景颜色


```xml
<tab seek="#1E1F22" />
```


### bgImg - 背景图片

> 设置背景图片


```xml
<tab seek="./img.png" />
```


## 二、常用函数


### onChange(callback)

> 设置数值变化监听
> 
> 注意:只监听由用户手动触发的数值变化,若为编程时设置的数值,则忽略

- 参数 : callback {(value)=>{}}


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let seek = ui.id("mSeek");
//设置选中的下标
seek.onChange((value)=>{
    //..
});
```


### getValue()

> 获取当前数值

- 返回 : {int} 当前数值


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let seek = ui.id("mSeek");
//获取进度数值
let value = seek.getValue();
```


### getMin()

> 获取最小值

- 返回 : {int} 当前数值


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let seek = ui.id("mSeek");
//获取最小值
let minVal = seek.getMin();
```


### getMax()

> 获取最大值

- 返回 : {int} 当前数值


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let seek = ui.id("mSeek");
//获取最大值
let maxVal = seek.getMax();
```


### setValue(value)

> 设置数值

- 参数 : value {int} 数值


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let seek = ui.id("mSeek");
//设置数值
seek.setValue(50);
```


### setMax(value)

> 设置最大值

- 参数 : value {int} 数值


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let seek = ui.id("mSeek");
//设置最大值
seek.setMax(50);
```


### setMin(value)

> 设置最小值

- 参数 : value {int} 数值


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let seek = ui.id("mSeek");
//设置最小值
seek.setMin(0);
```


# 滑动条

- 更新时间:2025-12-02 10:12:47

> 滑动条-slider
> 
> 原生类型:{com.google.android.material.slider.Slider}




滚动条：常用于动态设置数字参数，通过滑动就可以变换数值。


![](./img/slider_demo.png)

## 一、常用属性


### 开始值 - 开始值

> 设置开始值


```xml
<滑动条 开始值="0" />
```


![](./img/slider_from.png)

### 结束值 - 结束值

> 设置结束值


```xml
<滑动条 结束值="100" />
```


![](./img/slider_to.png)

### 当前值 - 初始值

> 设置初始值


```xml
<滑动条 当前值="30" />
```


![](./img/slider_value.png)

### 进步值 - 进步值

> 设置进步值


```xml
<滑动条 进步值="1" />
```


![](./img/slider_step.png)

### 主题颜色 - 主题颜色

> 设置主题颜色


```xml
<滑动条 主题颜色="#FF0000" />
```


![](./img/slider_demo.png)

### 标签 - 标签文字

> 设置标签文字


```xml
<滑动条 标签="进度:" />
```


![](./img/slider_label.png)

### 标签尾部 - 标签文字尾部

> 设置标签文字尾部


```xml
<滑动条 标签尾部="个" />
```


![](./img/slider_labelEnd.png)

### 内边距 - 内边距

> 设置内边距
> 
> 参数顺序:左,上,右,下(单位:dp)


```xml
<滑动条 内边距="20,20,20,20" />
```


![](./img/slider_padding.png)

### 背景颜色 - 背景颜色

> 设置背景颜色


```xml
<滑动条 背景颜色="#1E1F22" />
```


![](./img/slider_bg.png)

### 背景图片 - 背景图片

> 设置背景图片


```xml
<滑动条 背景图片="./资源/图片.png" />
```


![](./img/slider_bgImg.png)

## 二、常用函数


### 设置背景颜色(颜色)

> 设置背景颜色

- 参数 : 颜色 {数字} 文本颜色值
- 版本 : 1.8.2


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//获取控件
定义 滚动条 = 界面.找控件("我的滚动条");
//设置背景颜色
滚动条.设置背景颜色($颜色.红色);
```


### 设置背景颜色(颜色)

> 设置背景颜色

- 参数 : 颜色 {字符串} 颜色字符串
- 版本 : 1.8.2


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//获取控件
定义 滚动条 = 界面.找控件("我的滚动条");
//设置背景颜色
滚动条.设置背景颜色("#1E1F22");
```


### 设置主题颜色(颜色)

> 设置主题颜色

- 参数 : 颜色 {数字} 文本颜色值
- 版本 : 1.8.2


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//获取控件
定义 滚动条 = 界面.找控件("我的滚动条");
//设置主题颜色
滚动条.设置主题颜色($颜色.红色);
```


### 设置主题颜色(颜色)

> 设置主题颜色

- 参数 : 颜色 {字符串} 颜色字符串
- 版本 : 1.8.2


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//获取控件
定义 滚动条 = 界面.找控件("我的滚动条");
//设置主题颜色
滚动条.设置主题颜色("#1E1F22");
```


### 标签格式化(回调)

> 设置标签格式化

- 参数 : 回调 {(浮点值)=>{ return "标签"; }} 格式化回调


### 监听变化(回调)

> 监听数值变化
> 
> 注意:只监听由用户手动触发的数值变化,若为编程时设置的数值,则忽略

- 参数 : 回调 {(数值)=>{}}


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//获取控件
定义 滑动条 = 界面.找控件("我的滑动条");
//监听数值变化
滑动条.监听变化((数值)=>{
    //..
});
```


### 获取值()

> 获取当前值

- 返回 : {float} 当前数值


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//获取控件
定义 滑动条 = 界面.找控件("我的滑动条");
//获得当前值
定义 当前值 = 滑动条.获取值();
```


### 设置值(数值)

> 设置当前值

- 参数 : 数值 {float} 当前值


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//获取控件
定义 滑动条 = 界面.找控件("我的滑动条");
//设置当前值
滑动条.设置值(10);
```


### 设置开始值(开始值)

> 设置开始值

- 参数 : 开始值 {float} 开始值


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//获取控件
定义 滑动条 = 界面.找控件("我的滑动条");
//设置开始值
滑动条.设置开始值(0);
```


### 设置进步值(进步值)

> 设置进步值

- 参数 : 进步值 {float} 进步值


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//获取控件
定义 滑动条 = 界面.找控件("我的滑动条");
//设置进步值
滑动条.设置进步值(1);
```


### 设置结束值(结束值)

> 设置结束值

- 参数 : 结束值 {float} 结束值


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//获取控件
定义 滑动条 = 界面.找控件("我的滑动条");
//设置结束值
滑动条.设置结束值(100);
```


### 设置数据(开始, 结束)

> 设置数据

- 参数 : 开始 {float} 开始值
- 参数 : 结束 {float} 结束值


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//获取控件
定义 滑动条 = 界面.找控件("我的滑动条");
//设置数据(开始,结束)
滑动条.设置数据(0,100);
```


### 设置数据(开始, 结束, 当前值)

> 设置数据

- 参数 : 开始 {float} 开始值
- 参数 : 结束 {float} 结束值
- 参数 : 当前值 {float} 当前值


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//获取控件
定义 滑动条 = 界面.找控件("我的滑动条");
//设置数据(开始,结束,当前值)
滑动条.设置数据(0,100,20);
```


# 状态栏

- 更新时间:2025-12-02 10:12:47

> 状态栏-statusbar
> 
> 本质上就是一个{MaterialTextView},只不过高度为状态条的高度,此控主要用来占位置,避免手机状态条挡住主要的布局
> 
> 原生类型:{com.google.android.material.textview.MaterialTextView}




状态栏：一般手机界面的最上方的部分就是状态栏。


![](./img/statusbar_example.png)

## 一、常用属性


### 颜色 - 背景颜色

> 设置背景颜色


```xml
<状态栏 颜色="#1E1F22" />
```


![](./img/822704913786800.png)

### 背景颜色 - 背景颜色

> 设置背景颜色


```xml
<状态栏 背景颜色="#1E1F22"/>
```


![](./img/823019796005800.png)

### 背景图片 - 背景图片

> 设置背景图片


```xml
<状态栏 背景图片="./资源/图片.png"/>
```


![](./img/822979123418600.png)

## 二、常用函数


### 设置颜色(颜色)

> 设置颜色

- 参数 : 颜色 {string} 颜色值


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//获取控件
定义 状态栏 = 界面.找控件("我的状态栏");
//设置颜色
状态栏.设置颜色("#1E1F22");
```


# 开关

- 更新时间:2025-12-02 10:12:47

> 开关-switch
> 
> 原生类型:{com.google.android.material.materialswitch.MaterialSwitch}




开关：顾名思义，就是开关的意思，只有打开或者关闭两种状态。


![](./img/823241319415800.png)

## 一、常用属性


### 主题颜色 - 主题颜色

> 设置主题颜色


```xml
<开关 主题颜色="#57965C" 文本="主题色为绿色" />
```


![](./img/823661390164300.png)

### 文本 - 文本

> 设置文本


```xml
<开关 文本="默认文本" />
```


![](./img/823704126486300.png)

### 文本颜色 - 文本颜色

> 设置文本颜色


```xml
<开关 主题颜色="#57965C" 文本="文本为白色" 文本颜色="#FFFFFF" />
```


![](./img/823742446042900.png)

### 选中 - 是否选中

> 设置是否选中


```xml
<开关 选中="是" />
```


![](./img/823778688193600.png)

### 最小宽度 - 最小宽度

> 设置最小宽度


```xml
<开关 最小宽度="100" />
```


![](./img/823844386523100.png)

### 最小高度 - 最小高度

> 设置最小高度


```xml
<开关 最小高度="100" />
```


![](./img/823887649088400.png)

### 内边距 - 内边距

> 设置内边距
> 
> 参数顺序:左,上,右,下(单位:dp)


```xml
<开关 内边距="20,20,20,20" 文本="内边距" />
```


![](./img/824262862930600.png)

### 重力 - 重力

> 设置重力
> 
> 可选值参考重力参数表


```xml
<开关 重力="中|上" />
```


![](./img/824016785709400.png)

### 背景颜色 - 背景颜色

> 设置背景颜色


```xml
<开关 背景颜色="#1E1F22" 文本="背景颜色" />
```


![](./img/824071990244600.png)

### 背景图片 - 背景图片

> 设置背景图片


```xml
<开关 背景图片="./资源/图片.png" 文本="背景图片" />
```


![](./img/824213477601000.png)

## 二、常用函数


### 设置选中(状态)

> 设置选中状态

- 参数 : 状态 {boolean} 是否选中


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//获取控件
定义 开关 = 界面.找控件("我的开关");
//设置选中状态
开关.设置选中(是);
```


### 是选中的()

> 判断选中状态

- 返回 : {布尔值} 是否选中
- 版本 : 1.8.2


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//获取控件
定义 开关 = 界面.找控件("我的开关");
//判断选中状态
如果(开关.是选中的()){
    日志("选中了");
}
```


### 监听选中(回调)

> 监听状态改变

- 参数 : 回调 ((是否选中)=>{}) 回调函数


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//获取控件
定义 开关 = 界面.找控件("我的开关");
//监听状态改变
开关.监听选中((是否选中)=>{
    //..
});
```


### 设置重力(重力)

> 设置重力

- 参数 : 重力 {String} 例如:"中|下"


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//获取控件
定义 开关 = 界面.找控件("我的开关");
//设置重力
开关.设置重力("中|下");
```


### 设置文本(文本)

> 设置文本

- 参数 : 文本 {String} 文本内容


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//获取控件
定义 开关 = 界面.找控件("我的开关");
//设置文本
开关.设置文本("是否开启");
```


### 获取文本()

> 获取文本

- 返回 : {String} 文本内容


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//获取控件
定义 开关 = 界面.找控件("我的开关");
//获得文本
定义 文本 = 开关.获取文本();
```


### 设置主题颜色(颜色)

> 设置主题颜色

- 参数 : 颜色 {String} 颜色值


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//获取控件
定义 开关 = 界面.找控件("我的开关");
//设置主题颜色
开关.设置主题颜色("#26282E");
```


### 设置文本颜色(颜色)

> 设置文本颜色

- 参数 : 颜色 {String} 颜色值


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//获取控件
定义 开关 = 界面.找控件("我的开关");
//设置文本颜色
开关.设置文本颜色("#26282E");
```


# 标签布局

- 更新时间:2025-12-02 10:12:47

> 标签布局-tab
> 
> 原生类型:{com.google.android.material.tabs.TabLayout}




## 一、常用属性


### 项目 - 选项标签

> 选项标签


```xml
<标签布局>
    <项目 文本="选项1" 图标="ag_logo" 图标颜色="#FF0000" />
    <项目 文本="选项2" 图标="ag_logo" 图标颜色="#00FF00" />
</标签布局>
```


### 内边距 - 内边距

> 设置内边距
> 
> 参数顺序:左,上,右,下(单位:dp)


```xml
<标签布局 内边距="20,20,20,20" />
```


### 背景颜色 - 背景颜色

> 设置背景颜色


```xml
<标签布局 背景颜色="#1E1F22" />
```


### 背景图片 - 背景图片

> 设置背景图片


```xml
<标签布局 背景图片="./资源/图片.png" />
```


# 文本

- 更新时间:2025-12-02 10:12:47

> 文本-text
> 
> 原生类型:{com.google.android.material.textview.MaterialTextView}




## 一、常用属性


### 尺寸 - 文本尺寸

> 设置文本尺寸
> 
> 单位:dp


```xml
<文本 尺寸="100" />
```


### 文本尺寸 - 文本尺寸

> 设置文本尺寸
> 
> 单位:dp


```xml
<文本 文本尺寸="100" />
```


### 字体 - 文本字体

> 设置文本字体
> 
> 可选值:无衬线,衬线,等宽,默认,加粗,斜体,加粗斜体


```xml
<文本 字体="加粗" />
```


### 颜色 - 文本颜色

> 设置文本颜色


```xml
<文本 颜色="#FF0000" />
```


### 文本颜色 - 文本颜色

> 设置文本颜色


```xml
<文本 文本颜色="#FF0000" />
```


### 可选择 - 是否可选则文本

> 设置是否可选则文本


```xml
<文本 可选择="是" />
```


### 单行显示 - 是否单行显示

> 是否单行显示


```xml
<文本 单行显示="是" />
```


### 最大行数 - 最大行数

> 设置最大行数


```xml
<文本 最大行数="3" />
```


### 最小宽度 - 最小宽度

> 设置最小宽度


```xml
<文本 最小宽度="100" />
```


### 最小高度 - 最小高度

> 设置最小高度


```xml
<文本 最小高度="100" />
```


### 内边距 - 内边距

> 设置内边距
> 
> 参数顺序:左,上,右,下(单位:dp)


```xml
<文本 内边距="20,20,20,20" 文本="内边距" />
```


### 重力 - 重力

> 设置重力
> 
> 可选值参考重力参数表


```xml
<文本 重力="中|上" />
```


### 背景颜色 - 背景颜色

> 设置背景颜色


```xml
<文本 背景颜色="#1E1F22" 文本="背景颜色" />
```


### 背景图片 - 背景图片

> 设置背景图片


```xml
<文本 背景图片="./资源/图片.png" 文本="背景图片" />
```


## 二、常用函数


### 设置文本(文本内容)

> 设置文本

- 参数 : 文本内容 {string} 文本内容


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//获取控件
定义 文本 = 界面.找控件("我的文本");
//设置文本
文本.设置文本("新的内容");
```


### 设置颜色(颜色)

> 设置文本颜色

- 参数 : 颜色 {int} 文本颜色值


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//获取控件
定义 文本 = 界面.找控件("我的文本");
//设置文本颜色
文本.设置颜色($颜色.红色);
```


### 设置颜色(颜色)

> 设置文本颜色

- 参数 : 颜色 {string} 文本颜色值


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//获取控件
定义 文本 = 界面.找控件("我的文本");
//设置文本颜色
文本.设置颜色("#1E1F22");
```


### 设置背景颜色(颜色)

> 设置背景颜色

- 参数 : 颜色 {数字} 文本颜色值
- 版本 : 1.8.2


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//获取控件
定义 文本 = 界面.找控件("我的文本");
//设置背景颜色
文本.设置背景颜色($颜色.红色);
```


### 设置背景颜色(颜色)

> 设置背景颜色

- 参数 : 颜色 {字符串} 颜色字符串
- 版本 : 1.8.2


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//获取控件
定义 文本 = 界面.找控件("我的文本");
//设置背景颜色
文本.设置背景颜色("#1E1F22");
```


### 设置尺寸(尺寸)

> 设置文本尺寸

- 参数 : 尺寸 {float} 文本尺寸


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//获取控件
定义 文本 = 界面.找控件("我的文本");
//设置文本尺寸
文本.设置尺寸(18);
```


### 获取文本()

> 获取文本内容

- 返回 : {string} 文本内容


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//获取控件
定义 文本 = 界面.找控件("我的文本");
//获得文本内容
定义 文本内容 = 文本.获取文本();
```


# 工具栏

- 更新时间:2025-12-02 10:12:47

> 工具栏-toolbar
> 
> 原生类型:{com.google.android.material.bottomappbar.BottomAppBar}




### 菜单(回调)

> 监听菜单事件

- 参数 : 回调 {(标题)=>{}} 菜单点击事件


```javascript
//监听菜单事件
工具栏.菜单((标题)=>{
    控制台.日志(标题);
});
```


# Sheet - 底部弹窗

- 更新时间:2025-12-02 10:12:44

> 底部弹窗




### 解析布局(xml内容或路径)

> 解析布局

- 参数 : xml内容或路径 {string} xml内容或者xml路径
- 返回 : {底部弹窗} 返回自己
- 版本 : 1.5.5


### 获得视图()

> 获取解析后的最大布局

- 返回 : {View} 返回最大布局
- 版本 : 1.5.8


### 找控件(标识)

> 通过标识获取控件

- 参数 : 标识 {string} 控件标识
- 返回 : {XView} 返回控件
- 版本 : 1.5.8


### 显示()

> 显示弹窗

- 版本 : 1.5.8


### 关闭()

> 关闭弹窗

- 版本 : 1.5.8


# UI - 界面对象

- 更新时间:2025-12-02 10:12:49

> 界面对象




### 获得视图()

> 获取解析后的最大布局

- 返回 : {View} 返回最大布局
- 版本 : 1.5.8


```javascript
//解析布局
定义 界面 = $界面.解析布局("主界面.xml");
//获取最大视图
定义 最大视图 = 界面.获得视图();
```


### 找控件(标识)

> 通过标识找到组件

- 参数 : 标识 {字符串} 组件标识 
- 返回 : {XView} 控件


```javascript
定义 界面 = $界面.解析布局("主界面.xml");
//获取组件
定义 按钮 = 界面.找控件("按钮");
```


### 界面线程(回调函数)

> 在ui线程中执行

- 参数 : 回调函数 {()=>{}} ui线程回调函数


```javascript
定义 界面 = $界面.解析布局("主界面.xml");
//在ui线程中执行
界面.界面线程(()=>{
    //在ui线程中执行的代码
});
```


### 土司(文本)

> 悬浮土司
> 
> 悬浮土司是基于悬浮窗来实现的，因此在显示的时候会处于界面顶层。

- 参数 : 文本 {字符串} 文本
- 版本 : 1.1.2


```javascript
定义 界面 = $界面.解析布局("主界面.xml");
//悬浮土司
界面.土司("文本");
```


### 土司(文本, 重力)

> 悬浮土司
> 
> 悬浮土司是基于悬浮窗来实现的，因此在显示的时候会处于界面顶层。

- 参数 : 文本 {字符串} 文本
- 参数 : 重力 {字符串} 重力
- 版本 : 1.1.2


```javascript
定义 界面 = $界面.解析布局("主界面.xml");
//悬浮土司
界面.土司("文本","中间");
```


### 显示()

> 显示界面

- 返回 : {UI} 界面
- 版本 : 1.12


```javascript
定义 界面 = $界面.解析布局("主界面.xml");
//显示界面
界面.显示();
```


### 结束()

> 结束界面


```javascript
定义 界面 = $界面.解析布局("主界面.xml");
//显示界面
界面.显示();
//找一个按钮控件来关闭界面
界面.找控件("关闭按钮").点击事件(函数(){
    //关闭界面
    界面.结束();
});
```


### 获得活动对象()

> 等待获得activity对象
> 
> 注意:如果没有解析界面,那么就直接返回null
> 如果没有显示界面,也会直接返回null
> 如果解析成功并且成功显示,那么就会进入循环中,不断的等待判断activity是否获取成功,如果获取成功,则直接返回activity

- 返回 : {AppCompatActivity} activity
- 版本 : 1.1.2


```javascript
//解析界面
定义 界面 = $界面.解析布局("主界面.xml");
//显示界面
界面.显示();
//显示完界面之后即可等待获取到activity对象
定义 活动对象 = 界面.获得活动对象();
```


### 当活动开始(回调)

> 界面初始时执行

- 参数 : 回调 {(activity)=>{}} 生命周期回调
- 版本 : 1.1.2


```javascript
定义 界面 = $界面.解析布局("主界面.xml");
界面.显示();
//周期函数
界面.当活动开始((activity)=>{
    //界面初始时执行
});
```


### 当活动恢复(回调)

> 重返界面时执行

- 参数 : 回调 {(activity)=>{}} 生命周期回调
- 版本 : 1.1.2


```javascript
定义 界面 = $界面.解析布局("主界面.xml");
界面.显示();
//周期函数
界面.当活动恢复((activity)=>{
    //重返界面时执行
});
```


### 当活动暂停(回调)

> 界面暂停时执行

- 参数 : 回调 {(activity)=>{}} 生命周期回调
- 版本 : 1.1.2


```javascript
定义 界面 = $界面.解析布局("主界面.xml");
界面.显示();
//周期函数
界面.当活动暂停((activity)=>{
    //界面暂停时执行
});
```


### 当活动停止(回调)

> 界面停止时执行

- 参数 : 回调 {(activity)=>{}} 生命周期回调
- 版本 : 1.1.2


```javascript
定义 界面 = $界面.解析布局("主界面.xml");
界面.显示();
//周期函数
界面.当活动停止((activity)=>{
    //界面停止时执行
});
```


### 当活动销毁(回调)

> 界面销毁时执行

- 参数 : 回调 {(activity)=>{}} 生命周期回调
- 版本 : 1.1.2


```javascript
定义 界面 = $界面.解析布局("主界面.xml");
界面.显示();
//周期函数
界面.当活动销毁((activity)=>{
    //界面销毁时执行(一般用来释放资源)
});
```


### 当活动重启(回调)

> 重新刷新界面时执行

- 参数 : 回调 {(activity)=>{}} 生命周期回调
- 版本 : 1.1.2


```javascript
定义 界面 = $界面.解析布局("主界面.xml");
界面.显示();
//周期函数
界面.当活动重启((activity)=>{
    //重新刷新界面时执行
});
```


### 当活动结果(回调)

> 活动结果事件

- 参数 : 回调 {(requestCode,resultCode,intent,activity)=>{}} 活动结果事件
- 版本 : 1.4.9


```javascript
定义 界面 = $界面.解析布局("主界面.xml");
界面.显示();
//周期函数
界面.当活动结果((requestCode,resultCode,intent,activity)=>{
    //活动结果事件(一般用来申请权限时作为结果回调)
    //回调参数类型:
    //int requestCode
    //int resultCode
    //Intent intent
    //AppCompatActivity activity
});
```


### 当上下文菜单创建(回调)

> 上下文菜单创建事件

- 参数 : 回调 {(menu,view,menuInfo,activity)=>{}} 上下文菜单创建事件
- 版本 : 1.4.9


```javascript
定义 界面 = $界面.解析布局("主界面.xml");
界面.显示();
//周期函数
界面.当上下文菜单创建((menu,view,menuInfo,activity)=>{
    //上下文菜单创建事件
    //回调函数参数类：
    //ContextMenu menu (其API涉及安卓API，请自行参考安卓文档)
    //View view
    //ContextMenu.ContextMenuInfo menuInfo (其API涉及安卓API，请自行参考安卓文档)
    //AppCompatActivity activity
});
```


### 当选项菜单创建(回调)

> 选项菜单创建事件

- 参数 : 回调 {(menu,activity)=>{}} 选项菜单创建事件
- 版本 : 1.4.9


```javascript
定义 界面 = $界面.解析布局("主界面.xml");
界面.显示();
//周期函数
界面.当选项菜单创建((menu,activity)=>{
    //选项菜单创建事件
    //回调函数参数类：
    //Menu menu (其API涉及安卓API，请自行参考安卓文档)
    //AppCompatActivity activity
});
```


### 当选项菜单面板创建(回调)

> 选项菜单面板创建事件

- 参数 : 回调 {(featureId,menu,activity)=>{}} 选项菜单面板创建事件
- 版本 : 1.4.9


```javascript
定义 界面 = $界面.解析布局("主界面.xml");
界面.显示();
//周期函数
界面.当选项菜单面板创建((featureId,menu,activity)=>{
    //选项菜单创建事件
    //回调函数参数类：
    //int featureId
    //Menu menu (其API涉及安卓API，请自行参考安卓文档)
    //AppCompatActivity activity
});
```


### 当选项菜单选中(回调)

> 选项菜单点击事件

- 参数 : 回调 {(item,activity)=>{}} 选项菜单点击事件
- 版本 : 1.4.9


```javascript
定义 界面 = $界面.解析布局("主界面.xml");
界面.显示();
//周期函数
界面.当选项菜单选中((item,activity)=>{
    //选项菜单创建事件
    //回调函数参数类：
    //MenuItem item (其API涉及安卓API，请自行参考安卓文档)
    //AppCompatActivity activity
});
```


### 当按键按下(回调)

> 按键按下事件

- 参数 : 回调 {(keyCode,event,activity)=>{return false;}}  按键抬起事件
- 版本 : 1.1.2


```javascript
定义 界面 = $界面.解析布局("主界面.xml");
界面.显示();
//周期函数
界面.当按键按下((keyCode,event,activity)=>{
    //当按键按下回调
    //回调参数类型:
    //int keyCode
    //KeyEvent event (其API涉及安卓API，请自行参考安卓文档)
});
```


### 当按键抬起(回调)

> 按键抬起事件

- 参数 : 回调 {(keyCode,event,activity)=>{return false;}}  按键抬起事件
- 版本 : 1.1.2


```javascript
定义 界面 = $界面.解析布局("主界面.xml");
界面.显示();
//周期函数
界面.当按键抬起((keyCode,event,activity)=>{
    //按键抬起回调
    //回调参数类型:
    //int keyCode
    //KeyEvent event (其API涉及安卓API，请自行参考安卓文档)
});
```


### 当按键长按(回调)

> 长按事件

- 参数 : 回调 {(keyCode,event,activity)=>{return false;}}  长按事件
- 版本 : 1.1.2


```javascript
定义 界面 = $界面.解析布局("主界面.xml");
界面.显示();
//周期函数
界面.当按键长按((keyCode,event,activity)=>{
    //按键长按回调
    //回调参数类型:
    //int keyCode
    //KeyEvent event (其API涉及安卓API，请自行参考安卓文档)
});
```


# $ui - 界面交互

- 更新时间:2025-12-02 10:12:49

> UI交互界面




### 界面线程(回调函数)

> 界面线程
> 
> 一般修改界面元素的时候需要用到界面线程，由于本应用已经自动把所有控件操作都放到了界面线程中，所以不需要额外调用。

- 参数 : 回调函数 {()=>{}} 回调函数 
- 版本 : 1.5.8


```javascript
//在界面线程中执行
$界面.界面线程(()=>{
    //在界面线程中执行的代码
});
//或者下面的方式更加直观:先定义要执行的函数
定义 要执行的函数 = 函数(){
    //要执行的内容
}
//然后把这个函数传进去,那么这个函数就会在界面线程中执行
$界面.界面线程(要执行的函数);
```


### 解析布局(xml内容或者路径)

> 解析全屏布局
> 
> 创建一个界面(ui)对象,并且解析布局,最终返回这个界面(ui)对象

- 参数 : xml内容或者路径 {string} xml内容或者xml路径 
- 返回 : {UI} ui对象
- 版本 : 1.5.8


```javascript
定义 我的界面 = $界面.解析布局("./资源/主界面.xml");
```


### 创建底部弹窗(活动对象)

> 显示底部弹窗

- 参数 : 活动对象 {activity} 需要显示底部弹窗的活动对象 
- 返回 : {Sheet} 弹窗对象
- 版本 : 1.5.8


```javascript
//假如已经显示了一个ui了
定义 界面 = $界面.解析界面("主界面.xml");
界面.显示();//显示界面(ui)
//当界面(ui)显示之后就可以获取对应界面的活动对象(activity)了
定义 底部弹窗 = $界面.创建底部弹窗(界面.获得活动对象());//创建目标活动的底部弹窗对象
底部弹窗.解析布局("底部对话框.xml"); //解析底部弹窗(sheet)布局
底部弹窗.找控件("我的按钮"); //绑定底部弹窗(sheet)中的组件事件
底部弹窗.显示(); //显示底部弹窗
```


### 土司(文本)

> 悬浮土司
> 
> 悬浮土司是基于悬浮窗来实现的，因此在显示的时候会处于界面顶层。

- 参数 : 文本 {string} 文本 
- 版本 : 1.5.8


```javascript
$界面.土司("文本");
```


### 土司(文本, 重力)

> 悬浮土司
> 
> 悬浮土司是基于悬浮窗来实现的，因此在显示的时候会处于界面顶层。

- 参数 : 文本 {string} 文本 
- 参数 : 重力 {string} 位置 
- 版本 : 1.5.8


```javascript
$界面.土司("文本","中");
```


### 转px(dp)

> dp转px

- 参数 : dp {数字} dp(虚拟长度单位)
- 返回 : {数字} 转换后的px(像素值)
- 版本 : 1.8.2


```javascript
//获取10dp的真实像素单位
定义 像素 = $界面.转px(10);
```


### 转dp(像素)

> px转dp

- 参数 : 像素 {数字} 要转换的px(像素值)
- 返回 : {数字} 转换后的(dp)虚拟像素单位
- 版本 : 1.8.2


```javascript
//获取10像素的(dp)虚拟单位值
定义 dp = $界面.转dp(10);
```


# 视频

- 更新时间:2025-12-02 10:12:47

> 视频-video




### onComplete(callback)

> 视频播放完成回调
> 
> 回调参数含义：mp {MediaPlayer} 视频播放对象

- 参数 : callback {(mp)=>{}} 回调


### onPrepare(callback)

> 视频播放准备好回调
> 
> 回调参数含义：mp {MediaPlayer} 视频播放对象

- 参数 : callback {(mp)=>{}} 回调


### onError(callback)

> 设置视频播放错误的监听器
> 
> 回调参数含义：mp {MediaPlayer} 视频播放对象，what {int} 事件类型，extra {int} 额外信息

- 参数 : callback {(mp, what, extra)=>{return false;}} 回调


### onInfo(callback)

> 设置视频播放信息的监听器（如缓冲开始 / 结束）
> 
> 回调参数含义：mp {MediaPlayer} 视频播放对象，what {int} 事件类型，extra {int} 额外信息

- 参数 : callback {(mp, what, extra)=>{return false;}} 回调


### path(path)

> 设置视频的路径

- 参数 : path {string} 视频的路径


### uri(uri)

> 设置视频的URI

- 参数 : uri {string} 视频的 URI 可以是本地文件或网络视频地址


### start()

> 开始播放


### pause()

> 暂停播放


### stop()

> 停止并释放资源


### resume()

> 恢复之前暂停的视频播放


### suspend()

> 暂停并释放资源


### keepScreen(keep)

> 保持屏幕常亮

- 参数 : keep {boolean} 是否保持屏幕常亮


### seekTo(ms)

> 跳转到指定的时间点

- 参数 : ms {int} 毫秒


### isPlaying()

> 是否正在播放

- 返回 : {boolean} 是否正在播放


### getDur()

> 获取视频的总时长

- 返回 : {int} 视频的总时长（毫秒），返回 -1 表示时长未知


### getCur()

> 获取当前播放位置（毫秒）

- 返回 : {int} 当前播放位置（毫秒）


### canPause()

> 判断视频是否可以暂停

- 返回 : {boolean} 是否可以暂停


### canSeekBackward()

> 判断视频是否可以向后快退

- 返回 : {boolean} 是否可以向后快退


### canSeekForward()

> 判断视频是否可以向前快进

- 返回 : {boolean} 是否可以向前快进


### getBufferPercentage()

> 获取视频缓冲的百分比

- 返回 : {int} 视频缓冲的百分比


# $ - 桥梁对象

- 更新时间:2025-12-02 10:12:47

> 作为WebView和脚本引擎之间的桥梁,在html中:$符号就是这个桥梁的对象名称,你可以直接通过$对象来调用这里提供的方法




### call(funcName)

> 调用注册函数

- 参数 : funcName {string} 函数名称
- 返回 : {string} 返回值


```javascript
//在js中:注册一个函数
let ui = $ui.layout("./mUi.xml");
let mWeb = ui.id("mWebView");
mWeb.addFunc("mFunc",()=>{
    //获得无障碍权限
    $permit.wza();
    return "";//返回值是一个字符串类型,如果在html中不需要返回值,则不用写这行代码
});
//在html中:调用这个函数
$.call("mFunc");
```


### log(log)

> 调用注册函数
> 
> 此函数只能打印一个普通的文本内容，请注意调用方式

- 参数 : log {string} 日志文本


```javascript
//在html中:
$.log("我是一个文本");
```


### toast(msg)

> 土司提示

- 参数 : msg {string} 信息


```javascript
//在html中:
$.toast("我是一个文本");
```


### alert(msg)

> 对话框提示

- 参数 : msg {string} 信息


```javascript
//在html中:
$.alert("信息");
```


### alert(title, msg)

> 对话框提示

- 参数 : title {string} 标题
- 参数 : msg {string} 信息


```javascript
//在html中:
$.alert("信息","你好啊!");
```


### getClip()

> 获得剪切板

- 返回 : {string} 文字


```javascript
//在html中:
let text = $.getClip();
```


### setClip(text)

> 设置剪切板

- 参数 : text {string} 文字


```javascript
//在html中:
$.setClip("我是来自html中的字符串");
```


# 网页

- 更新时间:2025-12-02 10:12:47

> 网页-webview
> 
> 你可以用vant,vue,layui,element-ui等框架编写html界面，在这个控件中加载这个界面，之后就是处理一些交互函数了




### onLoaded(onLoad)

> 设置加载完成回调

- 参数 : onLoad (()=>{}) 回调


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let wv = ui.id("mWebView");
//设置加载完成回调
wv.onLoaded(()=>{
    //一般在控件加载完html之后注册一些交互函数,例如：
    wv.addFunc("getWza",()=>{
        $permit.wza();//获取无障碍权限
    });
    //之后就可以在html中使用:$.call("getWza");调用这个函数了
});
```


### clear()

> 清除网页缓存


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let wv = ui.id("mWebView");
//清除网页缓存
wv.clear();
```


### loadUrl(url)

> 加载url

- 参数 : url url


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let wv = ui.id("mWebView");
//加载url
wv.loadUrl("http://...");
```


### loadHtml(html)

> 加载html字符串

- 参数 : html html字符串


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let wv = ui.id("mWebView");
//加载html字符串
wv.loadHtml(`
<html>
    //这里是html字符串
</html>
`);
```


### loadFile(path)

> 加载html文件

- 参数 : path html文件路径


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let wv = ui.id("mWebView");
//加载html文件
wv.loadFile("./html/index.html");
```


### callJs(functionName, callBack)

> 调用js无参函数


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let wv = ui.id("mWebView");
//调用js无参函数
//mFunc是html中定义的函数,如果有返回值,那么就会通过returnValue回调获取
wv.callJs("mFunc",(returnValue)=>{
    //..
});
```


### callJs(functionName)

> 调用js无参函数


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let wv = ui.id("mWebView");
//调用js无参函数
//mFunc是html中定义的函数
wv.callJs("mFunc");
```


### callJsInt(functionName, param, callBack)

> 调用js的整数参数函数

- 参数 : functionName {String} js函数名
- 参数 : param {int} 参数
- 参数 : callBack ((str)=>{}) 回调


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let wv = ui.id("mWebView");
//调用js无参函数
//mFunc是html中定义的函数,如果有返回值,那么就会通过returnValue回调获取
wv.callJsInt("setFontSize",22,(returnValue)=>{
    //..
});
```


### callJsInt(functionName, param)

> 调用js的整数参数函数

- 参数 : functionName {String} js函数名
- 参数 : param {int} 参数


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let wv = ui.id("mWebView");
//调用js无参函数
//mFunc是html中定义的函数
wv.callJsInt("setFontSize",22);
```


### callJsLong(functionName, param, callBack)

> 调用js的长整数参数函数

- 参数 : functionName {String} js函数名
- 参数 : param {long} 参数
- 参数 : callBack ((str)=>{}) 回调


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let wv = ui.id("mWebView");
//调用js无参函数
//mFunc是html中定义的函数,如果有返回值,那么就会通过returnValue回调获取
wv.callJsLong("setLength",546894564564849,(returnValue)=>{
    //..
});
```


### callJsLong(functionName, param)

> 调用js的长整数参数函数

- 参数 : functionName {String} js函数名
- 参数 : param {long} 参数


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let wv = ui.id("mWebView");
//调用js无参函数
//mFunc是html中定义的函数
wv.callJsLong("setLength",546894564564849);
```


### callJsDouble(functionName, param, callBack)

> 调用js的浮点数参数函数

- 参数 : functionName {String} js函数名
- 参数 : param {float} 参数
- 参数 : callBack ((str)=>{}) 回调


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let wv = ui.id("mWebView");
//调用js无参函数
//mFunc是html中定义的函数,如果有返回值,那么就会通过returnValue回调获取
wv.callJsDouble("setVal",3.1415926,(returnValue)=>{
    //..
});
```


### callJsDouble(functionName, param)

> 调用js的浮点数参数函数

- 参数 : functionName {String} js函数名
- 参数 : param {float} 参数


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let wv = ui.id("mWebView");
//调用js无参函数
//mFunc是html中定义的函数,如果有返回值,那么就会通过returnValue回调获取
wv.callJsDouble("setVal",3.1415926);
```


### callJsFloat(functionName, param, callBack)

> 调用js的浮点数参数函数

- 参数 : functionName {String} js函数名
- 参数 : param {float} 参数
- 参数 : callBack ((str)=>{}) 回调


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let wv = ui.id("mWebView");
//调用js无参函数
//mFunc是html中定义的函数,如果有返回值,那么就会通过returnValue回调获取
wv.callJsFloat("setVal",3.1415926,(returnValue)=>{
    //..
});
```


### callJsFloat(functionName, param)

> 调用js的浮点数参数函数

- 参数 : functionName {String} js函数名
- 参数 : param {float} 参数


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let wv = ui.id("mWebView");
//调用js无参函数
//mFunc是html中定义的函数,如果有返回值,那么就会通过returnValue回调获取
wv.callJsFloat("setVal",3.1415926);
```


### callJsChar(functionName, param, callBack)

> 调用js的字符串参数函数

- 参数 : functionName {String} js函数名
- 参数 : param {char} 参数
- 参数 : callBack ((str)=>{}) 回调


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let wv = ui.id("mWebView");
//调用js无参函数
//mFunc是html中定义的函数,如果有返回值,那么就会通过returnValue回调获取
wv.callJsChar("setChar",'A',(returnValue)=>{
    //..
});
```


### callJsChar(functionName, param)

> 调用js的字符串参数函数

- 参数 : functionName {String} js函数名
- 参数 : param {char} 参数


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let wv = ui.id("mWebView");
//调用js无参函数
//mFunc是html中定义的函数,如果有返回值,那么就会通过returnValue回调获取
wv.callJsChar("setChar",'A');
```


### callJsBool(functionName, param, callBack)

> 调用js的布尔参数函数

- 参数 : functionName {String} js函数名
- 参数 : param {boolean} 参数
- 参数 : callBack ((str)=>{}) 回调


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let wv = ui.id("mWebView");
//调用js无参函数
//mFunc是html中定义的函数,如果有返回值,那么就会通过returnValue回调获取
wv.callJsBool("setEnable",true,(returnValue)=>{
    //..
});
```


### callJsBool(functionName, param)

> 调用js的布尔参数函数

- 参数 : functionName {String} js函数名
- 参数 : param {boolean} 参数


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let wv = ui.id("mWebView");
//调用js无参函数
//mFunc是html中定义的函数
wv.callJsBool("setEnable",true);
```


### callJsStr(functionName, param, callBack)

> 调用js的长文本参数函数
> 
> 在传入长文本之前，会把文本进行URL编码，所以在html使用的时候需要使用函数``解码才能得到原本的长文本内容。

- 参数 : functionName {String} js函数名
- 参数 : param {String} 长文本参数
- 参数 : callBack ((str)=>{}) 回调


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let wv = ui.id("mWebView");
//调用js无参函数
//mFunc是html中定义的函数,如果有返回值,那么就会通过returnValue回调获取
wv.callJsStr("setCode","一大堆文字",(returnValue)=>{
    //..
});
//在html中的代码:
function setCode(str){
    //html使用的时候需要使用函数`decodeURIComponent`解码才能得到原本的长文本内容。
    let code =  decodeURIComponent(str);
    $.alert("代码",code);
}
```


### callJsStr(functionName, param)

> 调用js的长文本参数函数
> 
> 在传入长文本之前，会把文本进行URL编码，所以在html使用的时候需要使用函数``解码才能得到原本的长文本内容。

- 参数 : functionName {String} js函数名
- 参数 : param {String} 长文本参数


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let wv = ui.id("mWebView");
//调用js无参函数
//mFunc是html中定义的函数
wv.callJsStr("setCode","一大堆文字");
//在html中的代码:
function setCode(str){
    //html使用的时候需要使用函数`decodeURIComponent`解码才能得到原本的长文本内容。
    let code =  decodeURIComponent(str);
    $.alert("代码",code);
}
```


### addFunc(funcName, callback)

> 注册桥梁函数
> 
> 向桥梁对象$中注册(添加)自定义函数，之后就可以在html中通过$.call(函数名称);来调用啦

- 参数 : funcName {()=>{ return "数据"; }} 回调


```javascript
//解析布局,获得ui对象
let ui = $ui.layout("./mUi.xml");
//获取控件
let wv = ui.id("mWebView");
//设置加载完成回调
wv.onLoaded(()=>{
    //一般在控件加载完html之后注册一些交互函数,例如：
    wv.addFunc("getWza",()=>{
        $permit.wza();//获取无障碍权限
    });
    //之后就可以在html中使用:$.call("getWza");调用这个函数了
});
```


# 菜单选项

- 更新时间:2025-12-02 10:12:47

> 菜单选项-XMenuItem
> 
> 原生类型:{android.view.MenuItem}




# 控件父类

- 更新时间:2025-12-02 10:12:48

> 控件父类-XView
> 
> 在应用中所有的控件或者布局都是这个类{XView}的子类，因此，这个类中的所有方法，所有的子类都能调用，故称为：公共方法。
> 
> 在代码示例中，多数情况下，我都是使用{XButton}按钮控件来进行演示的，其实任何控件都可以。




### 获取视图()


### 获取名称()


### 解析颜色(color)


### dp(dp)

> 将dp转换成对用的px

- 参数 : dp {float} dp长度
- 返回 : {float} px长度


### dp转px(dp)


### 设置背景图片(路径)

> 设置背景图片

- 参数 : 路径 {string} 图片路径


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//拿到控件
定义 按钮 = 界面.找控件("我的按钮");
//设置背景图片
按钮.设置背景图片("./资源/背景.png");
```


### 显示提示条(信息)

> 显示提示条

- 参数 : 信息 {string} 信息内容


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//拿到控件
定义 按钮 = 界面.找控件("我的按钮");
//显示信息条
按钮.显示提示条("我是信息");
```


### 显示提示条(信息, 标题, 回调函数)

> 显示提示条

- 参数 : 信息 {string} 信息内容
- 参数 : 标题 {string} 按钮标题
- 参数 : 回调函数 {(视图)=>{}} 点击事件回调


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//拿到控件
定义 按钮 = 界面.找控件("我的按钮");
//显示信息条
按钮.显示提示条("我是信息","确定",(视图)=>{
    //点击确定触发的事件
    $界面.土司("点击了确定");
});
```


### 点击事件(回调函数)

> 设置点击事件

- 参数 : 回调函数 {(视图)=>{}} 点击事件


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//拿到控件
定义 按钮 = 界面.找控件("我的按钮");
//设置点击事件
按钮.点击事件((视图)=>{
    //点击事件
    $界面.土司("我被点击了");
});
```


### 长按事件(回调函数)

> 设置长按事件

- 参数 : 回调函数 {(视图)=>{}} 长按事件


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//拿到控件
定义 按钮 = 界面.找控件("我的按钮");
//设置长按事件
按钮.长按事件((视图)=>{
    //长按事件
    $界面.土司("我被长按了");
});
```


### 显示菜单(选项, 回调函数)

> 显示选项菜单

- 参数 : 选项 {string[]} 选项列表
- 参数 : 回调函数 {(标题)=>{}} 回调函数


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//拿到控件
定义 按钮 = 界面.找控件("我的按钮");
//显示选项菜单
按钮.显示菜单(["选项1","选项2","选项3"],(标题)=>{
    $界面.土司("点击了选项:"+标题);
});
```


### 显示菜单(选项, 重力, 回调函数)

> 显示选项菜单

- 参数 : 选项 {string[]} 选项列表
- 参数 : 重力 {string} 重力参数
- 参数 : 回调函数 {(标题)=>{}} 回调函数


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//拿到控件
定义 按钮 = 界面.找控件("我的按钮");
//显示选项菜单
按钮.显示菜单(["选项1","选项2","选项3"],"start|center",(标题)=>{
    $界面.土司("点击了选项:"+标题);
});
```


### 启用控件(启用)

> 是否启用控件

- 参数 : 启用 {boolean} true:启用,false:禁用


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//拿到控件
定义 按钮 = 界面.找控件("我的按钮");
//禁用控件
按钮.启用控件(false);
```


### 是否可用()

> 判断可用

- 返回 : {boolean} true:启用,false:禁用


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//拿到控件
定义 按钮 = 界面.找控件("我的按钮");
//是否可用
定义 是否可用 = 按钮.是否可用();
如果(是否可用){
    $界面.土司("可用");
}
```


### 设置可见性(可见性)

> 设置可见性

- 参数 : 可见性 (使用界面常量,例如:界面.隐藏)


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//拿到控件
定义 按钮 = 界面.找控件("我的按钮");
//设置成不可见
按钮.设置可见性($界面.隐藏);
//设置成可见
//按钮.设置可见性($界面.显示);
```


### 获得可见性()

> 获得可见性

- 返回 : {int} (使用界面常量,例如:界面.隐藏)


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//拿到控件
定义 按钮 = 界面.找控件("我的按钮");
//获得可见性的值
定义 可见性 = 按钮.获得可见性();
如果(可见性==$界面.显示){
    $界面.土司("可见");
}
```


### 设置可聚焦(可聚焦)

> 设置可聚焦

- 参数 : 可聚焦 {boolean} true:控件可获得焦点,false:控件不可获得焦点


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//拿到控件
定义 按钮 = 界面.找控件("我的按钮");
//设置控件是否可聚焦
按钮.设置可聚焦(true);
```


### 设置可点击(可点击)

> 设置可点击

- 参数 : 可点击 {boolean} true:控件可被点击,false:控件不可被点击


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//拿到控件
定义 按钮 = 界面.找控件("我的按钮");
//设置控件是否可点击
按钮.设置可点击(true);
```


### 设置透明度(透明度)

> 设置透明度

- 参数 : 透明度 {float} 0.5:控件半透明,1:控件不透明


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//拿到控件
定义 按钮 = 界面.找控件("我的按钮");
//设置透明度
按钮.设置透明度(0.5);
```


### 获得透明度()

> 获得透明度

- 返回 : {float} 控件透明度值


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//拿到控件
定义 按钮 = 界面.找控件("我的按钮");
//获得透明度
定义 透明度 = 按钮.获得透明度();
```


### 设置立体值(立体值)

> 设置立体值
> 
> 可以让控件看起来更加立体

- 参数 : 立体值 {int} 立体值


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//拿到控件
定义 按钮 = 界面.找控件("我的按钮");
//设置立体值
按钮.设置立体值(10);
```


### 获得x()

> 获取x值
> 获取相对于父控件的x值

- 返回 : {float} x值


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//拿到控件
定义 按钮 = 界面.找控件("我的按钮");
//获取x值
定义 x = 按钮.获得x();
```


### 设置x(x)

> 设置x值
> 设置在父控件中x的值

- 参数 : x {float} x值


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//拿到控件
定义 按钮 = 界面.找控件("我的按钮");
//设置x值
按钮.设置x(10);
```


### 获得y()

> 获取y值
> 获取相对于父控件的y值

- 返回 : {float} y值


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//拿到控件
定义 按钮 = 界面.找控件("我的按钮");
//获取y值
定义 y = 按钮.获得y();
```


### 设置y(y)

> 设置y值
> 设置在父控件中y的值

- 参数 : y {float} y值


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//拿到控件
定义 按钮 = 界面.找控件("我的按钮");
//设置y值
按钮.设置y(10);
```


### 获得宽度()

> 获得控件宽度

- 返回 : {int} 宽度


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//拿到控件
定义 按钮 = 界面.找控件("我的按钮");
//获得控件宽度
定义 宽度 = 按钮.获得宽度();
```


### 获得高度()

> 获得控件高度

- 返回 : {int} 高度


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//拿到控件
定义 按钮 = 界面.找控件("我的按钮");
//获得控件高度
定义 高度 = 按钮.获得高度();
```


### 触摸事件(回调函数)

> 处理触摸事件

- 参数 : 回调函数 {(触摸事件,视图)=>{return false;}} 触摸回调


```javascript
//解析布局,获得界面对象
定义 界面 = $界面.解析布局("./资源/主界面.xml");
//拿到控件
定义 按钮 = 界面.找控件("我的按钮");
//处理触摸事件
按钮.触摸事件((事件,视图)=>{
    //处理触摸事件
    返回 true;
});
```


